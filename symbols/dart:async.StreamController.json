{
    "name": "dart:async.StreamController",
    "extends": [],
    "memberOf": "dart:async",
    "events": [
        {
            "name": "onCancel",
            "type": "dart:async.ControllerCancelCallback",
            "desc": "<p>The callback which is called when the stream is canceled.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n        ",
            "static": false,
            "memberOf": "",
            "sig": "",
            "params": [
                {
                    "name": "onCancelHandler",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/onCancel.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCancelCallback get onCancel;<\/code><\/pre>\n        ",
            "isDeprecated": false,
            "isConstant": false
        },
        {
            "name": "onListen",
            "type": "dart:async.ControllerCallback",
            "desc": "<p>The callback which is called when the stream is listened to.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n        ",
            "static": false,
            "memberOf": "",
            "sig": "",
            "params": [
                {
                    "name": "onListenHandler",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/onListen.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCallback get onListen;<\/code><\/pre>\n        ",
            "isDeprecated": false,
            "isConstant": false
        },
        {
            "name": "onPause",
            "type": "dart:async.ControllerCallback",
            "desc": "<p>The callback which is called when the stream is paused.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n<p>Pause related callbacks are not supported on broadcast stream controllers.<\/p>\n        ",
            "static": false,
            "memberOf": "",
            "sig": "",
            "params": [
                {
                    "name": "onPauseHandler",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/onPause.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCallback get onPause;<\/code><\/pre>\n        ",
            "isDeprecated": false,
            "isConstant": false
        },
        {
            "name": "onResume",
            "type": "dart:async.ControllerCallback",
            "desc": "<p>The callback which is called when the stream is resumed.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n<p>Pause related callbacks are not supported on broadcast stream controllers.<\/p>\n        ",
            "static": false,
            "memberOf": "",
            "sig": "",
            "params": [
                {
                    "name": "onResumeHandler",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/onResume.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCallback get onResume;<\/code><\/pre>\n        ",
            "isDeprecated": false,
            "isConstant": false
        }
    ],
    "methods": [
        {
            "name": "StreamController",
            "type": "",
            "desc": "<p>A controller with a <a href=\"dart-async\/StreamController\/stream.html\">stream<\/a> that supports only one single subscriber.<\/p>\n<p>If <code>sync<\/code> is true, the returned stream controller is a\n<a href=\"dart-async\/SynchronousStreamController-class.html\">SynchronousStreamController<\/a>, and must be used with the care\nand attention necessary to not break the <a href=\"dart-async\/Stream-class.html\">Stream<\/a> contract. If in doubt,\nuse the non-sync version.<\/p>\n<p>Using an asynchronous controller will never give the wrong\nbehavior, but using a synchronous controller incorrectly can cause\notherwise correct programs to break.<\/p>\n<p>A synchronous controller is only intended for optimizing event\npropagation when one asynchronous event immediately triggers another.\nIt should not be used unless the calls to <a href=\"dart-async\/StreamController\/add.html\">add<\/a> or <a href=\"dart-async\/StreamController\/addError.html\">addError<\/a>\nare guaranteed to occur in places where it won't break <code>Stream<\/code> invariants.<\/p>\n<p>Use synchronous controllers only to forward (potentially transformed)\nevents from another stream or a future.<\/p>\n<p>A Stream should be inert until a subscriber starts listening on it (using\nthe <code>onListen<\/code> callback to start producing events). Streams should not\nleak resources (like websockets) when no user ever listens on the stream.<\/p>\n<p>The controller buffers all incoming events until a subscriber is\nregistered, but this feature should only be used in rare circumstances.<\/p>\n<p>The <code>onPause<\/code> function is called when the stream becomes\npaused. <code>onResume<\/code> is called when the stream resumed.<\/p>\n<p>The <code>onListen<\/code> callback is called when the stream\nreceives its listener and <code>onCancel<\/code> when the listener ends\nits subscription. If <code>onCancel<\/code> needs to perform an asynchronous operation,\n<code>onCancel<\/code> should return a future that completes when the cancel operation\nis done.<\/p>\n<p>If the stream is canceled before the controller needs new data the\n<code>onResume<\/code> call might not be executed.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.StreamController",
            "sig": "",
            "params": [
                {
                    "name": "onListen",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "onPause",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "onResume",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "onCancel",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "sync",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-async\/StreamController\/StreamController.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamController(\n    {void onListen(),\n    void onPause(),\n    void onResume(),\n    onCancel(),\n    bool sync: false}) {\n  return sync\n      ? new _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)\n      : new _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "add",
            "type": "",
            "desc": "<p>Sends a data <code>event<\/code>.<\/p>\n<p>Listeners receive this event in a later microtask.<\/p>\n<p>Note that a synchronous controller (created by passing true to the <code>sync<\/code>\nparameter of the <code>StreamController<\/code> constructor) delivers events\nimmediately. Since this behavior violates the contract mentioned here,\nsynchronous controllers should only be used as described in the\ndocumentation to ensure that the delivered events always <em>appear<\/em> as if\nthey were delivered in a separate microtask.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.StreamController",
            "sig": "",
            "params": [
                {
                    "name": "event",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/add.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T event);<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "addError",
            "type": "",
            "desc": "<p>Sends or enqueues an error event.<\/p>\n<p>If <code>error<\/code> is <code>null<\/code>, it is replaced by a <a href=\"dart-core\/NullThrownError-class.html\">NullThrownError<\/a>.<\/p>\n<p>Listeners receive this event at a later microtask. This behavior can be\noverridden by using <code>sync<\/code> controllers. Note, however, that sync\ncontrollers have to satisfy the preconditions mentioned in the\ndocumentation of the constructors.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.StreamController",
            "sig": "",
            "params": [
                {
                    "name": "error",
                    "type": "dart:core.Object",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "stackTrace",
                    "type": "dart:core.StackTrace",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/addError.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(Object error, [StackTrace stackTrace]);<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "addStream",
            "type": "dart:async.Future",
            "desc": "<p>Receives events from <code>source<\/code> and puts them into this controller's stream.<\/p>\n<p>Returns a future which completes when the source stream is done.<\/p>\n<p>Events must not be added directly to this controller using <a href=\"dart-async\/StreamController\/add.html\">add<\/a>,\n<a href=\"dart-async\/StreamController\/addError.html\">addError<\/a>, <a href=\"dart-async\/StreamController\/close.html\">close<\/a> or <a href=\"dart-async\/StreamController\/addStream.html\">addStream<\/a>, until the returned future\nis complete.<\/p>\n<p>Data and error events are forwarded to this controller's stream. A done\nevent on the source will end the <code>addStream<\/code> operation and complete the\nreturned future.<\/p>\n<p>If <code>cancelOnError<\/code> is true, only the first error on <code>source<\/code> is\nforwarded to the controller's stream, and the <code>addStream<\/code> ends\nafter this. If <code>cancelOnError<\/code> is false, all errors are forwarded\nand only a done event will end the <code>addStream<\/code>.\nIf <code>cancelOnError<\/code> is omitted, it defaults to false.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.StreamController",
            "sig": "",
            "params": [
                {
                    "name": "source",
                    "type": "dart:async.Stream",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "cancelOnError",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/addStream.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future addStream(Stream&lt;T&gt; source, {bool cancelOnError});<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "StreamController.broadcast",
            "type": "",
            "desc": "<p>A controller where <a href=\"dart-async\/StreamController\/stream.html\">stream<\/a> can be listened to more than once.<\/p>\n<p>The <a href=\"dart-async\/Stream-class.html\">Stream<\/a> returned by <a href=\"dart-async\/StreamController\/stream.html\">stream<\/a> is a broadcast stream.\nIt can be listened to more than once.<\/p>\n<p>A Stream should be inert until a subscriber starts listening on it (using\nthe <code>onListen<\/code> callback to start producing events). Streams should not\nleak resources (like websockets) when no user ever listens on the stream.<\/p>\n<p>Broadcast streams do not buffer events when there is no listener.<\/p>\n<p>The controller distributes any events to all currently subscribed\nlisteners at the time when <a href=\"dart-async\/StreamController\/add.html\">add<\/a>, <a href=\"dart-async\/StreamController\/addError.html\">addError<\/a> or <a href=\"dart-async\/StreamController\/close.html\">close<\/a> is called.\nIt is not allowed to call <code>add<\/code>, <code>addError<\/code>, or <code>close<\/code> before a previous\ncall has returned. The controller does not have any internal queue of\nevents, and if there are no listeners at the time the event is added,\nit will just be dropped, or, if it is an error, be reported as uncaught.<\/p>\n<p>Each listener subscription is handled independently,\nand if one pauses, only the pausing listener is affected.\nA paused listener will buffer events internally until unpaused or canceled.<\/p>\n<p>If <code>sync<\/code> is true, events may be fired directly by the stream's\nsubscriptions during an <a href=\"dart-async\/StreamController\/add.html\">add<\/a>, <a href=\"dart-async\/StreamController\/addError.html\">addError<\/a> or <a href=\"dart-async\/StreamController\/close.html\">close<\/a> call.\nThe returned stream controller is a <a href=\"dart-async\/SynchronousStreamController-class.html\">SynchronousStreamController<\/a>,\nand must be used with the care and attention necessary to not break\nthe <a href=\"dart-async\/Stream-class.html\">Stream<\/a> contract.\nSee <a href=\"dart-async\/Completer\/Completer.sync.html\">Completer.sync<\/a> for some explanations on when a synchronous\ndispatching can be used.\nIf in doubt, keep the controller non-sync.<\/p>\n<p>If <code>sync<\/code> is false, the event will always be fired at a later time,\nafter the code adding the event has completed.\nIn that case, no guarantees are given with regard to when\nmultiple listeners get the events, except that each listener will get\nall events in the correct order. Each subscription handles the events\nindividually.\nIf two events are sent on an async controller with two listeners,\none of the listeners may get both events\nbefore the other listener gets any.\nA listener must be subscribed both when the event is initiated\n(that is, when <a href=\"dart-async\/StreamController\/add.html\">add<\/a> is called)\nand when the event is later delivered,\nin order to receive the event.<\/p>\n<p>The <code>onListen<\/code> callback is called when the first listener is subscribed,\nand the <code>onCancel<\/code> is called when there are no longer any active listeners.\nIf a listener is added again later, after the <code>onCancel<\/code> was called,\nthe <code>onListen<\/code> will be called again.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.StreamController",
            "sig": "",
            "params": [
                {
                    "name": "onListen",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "onCancel",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "sync",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-async\/StreamController\/StreamController.broadcast.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamController.broadcast(\n    {void onListen(), void onCancel(), bool sync: false}) {\n  return sync\n      ? new _SyncBroadcastStreamController&lt;T&gt;(onListen, onCancel)\n      : new _AsyncBroadcastStreamController&lt;T&gt;(onListen, onCancel);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "close",
            "type": "dart:async.Future",
            "desc": "<p>Closes the stream.<\/p>\n<p>Listeners receive the done event at a later microtask. This behavior can be\noverridden by using <code>sync<\/code> controllers. Note, however, that sync\ncontrollers have to satisfy the preconditions mentioned in the\ndocumentation of the constructors.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.StreamController",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "dart-async\/StreamController\/close.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close();<\/code><\/pre>\n    ",
            "isDeprecated": false
        }
    ],
    "props": [
        {
            "name": "hasListener",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether there is a subscriber on the <a href=\"dart-async\/Stream-class.html\">Stream<\/a>.<\/p>\n        ",
            "memberOf": "dart:async.StreamController",
            "isConstant": false,
            "href": "dart-async\/StreamController\/hasListener.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasListener;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "isClosed",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether the stream controller is closed for adding more events.<\/p>\n<p>The controller becomes closed by calling the <a href=\"dart-async\/StreamController\/close.html\">close<\/a> method.\nNew events cannot be added, by calling <a href=\"dart-async\/StreamController\/add.html\">add<\/a> or <a href=\"dart-async\/StreamController\/addError.html\">addError<\/a>,\nto a closed controller.<\/p>\n<p>If the controller is closed,\nthe \"done\" event might not have been delivered yet,\nbut it has been scheduled, and it is too late to add more events.<\/p>\n        ",
            "memberOf": "dart:async.StreamController",
            "isConstant": false,
            "href": "dart-async\/StreamController\/isClosed.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isClosed;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "isPaused",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether the subscription would need to buffer events.<\/p>\n<p>This is the case if the controller's stream has a listener and it is\npaused, or if it has not received a listener yet. In that case, the\ncontroller is considered paused as well.<\/p>\n<p>A broadcast stream controller is never considered paused. It always\nforwards its events to all uncanceled subscriptions, if any,\nand let the subscriptions handle their own pausing and buffering.<\/p>\n        ",
            "memberOf": "dart:async.StreamController",
            "isConstant": false,
            "href": "dart-async\/StreamController\/isPaused.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isPaused;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "sink",
            "type": "dart:async.StreamSink",
            "types": [],
            "desc": "<p>Returns a view of this object that only exposes the <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> interface.<\/p>\n        ",
            "memberOf": "dart:async.StreamController",
            "isConstant": false,
            "href": "dart-async\/StreamController\/sink.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;T&gt; get sink;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "stream",
            "type": "dart:async.Stream",
            "types": [],
            "desc": "<p>The stream that this controller is controlling.<\/p>\n        ",
            "memberOf": "dart:async.StreamController",
            "isConstant": false,
            "href": "dart-async\/StreamController\/stream.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream;<\/code><\/pre>\n        ",
            "isDeprecated": false
        }
    ],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": true,
    "implementors": [],
    "realImplementors": [],
    "cn": [],
    "href": "dart-async\/StreamController-class.html",
    "desc": "<p>A controller with the stream it controls.<\/p>\n<p>This controller allows sending data, error and done events on\nits <a href=\"dart-async\/StreamController\/stream.html\">stream<\/a>.\nThis class can be used to create a simple stream that others\ncan listen on, and to push events to that stream.<\/p>\n<p>It's possible to check whether the stream is paused or not, and whether\nit has subscribers or not, as well as getting a callback when either of\nthese change.<\/p>\n    ",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "StreamController"
}