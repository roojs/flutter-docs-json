{
    "desc": "<p>Utility class for all the async APIs in the <code>flutter_test<\/code> library.<\/p>\n<p>This class provides checking for asynchronous APIs, allowing the library to\nverify that all the asynchronous APIs are properly <code>await<\/code>ed before calling\nanother.<\/p>\n<p>For example, it prevents this kind of code:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">tester.pump(); \/\/ forgot to call \"await\"!\ntester.pump();\n<\/code><\/pre>\n<p>...by detecting, in the second call to <code>pump<\/code>, that it should actually be:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">await tester.pump();\nawait tester.pump();\n<\/code><\/pre>\n<p>It does this while still allowing nested calls, e.g. so that you can\ncall <a href=\"flutter_test\/expect.html\">expect<\/a> from inside callbacks.<\/p>\n<p>You can use this in your own test functions, if you have some asynchronous\nfunctions that must be used with \"await\". Wrap the contents of the function\nin a call to TestAsyncUtils.guard(), as follows:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; myTestFunction() =&gt; TestAsyncUtils.guard(() async {\n  \/\/ ...\n});\n<\/code><\/pre>\n    ",
    "dtype": "class",
    "example": "",
    "href": "flutter_test\/TestAsyncUtils-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "flutter_test",
    "name": "flutter_test.TestAsyncUtils",
    "shortname": "TestAsyncUtils",
    "extends": [],
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": "<p>Calls the given callback in a new async scope. The callback argument is\nthe asynchronous body of the calling method. The calling method is said to\nbe \"guarded\". Nested calls to guarded methods from within the body of this\none are fine, but calls to other guarded methods from outside the body of\nthis one before this one has finished will throw an exception.<\/p>\n<p>This method first calls <a href=\"flutter_test\/TestAsyncUtils\/guardSync.html\">guardSync<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;T&gt; guard&lt;T&gt;(Future&lt;T&gt; body()) {\n  guardSync();\n  final Zone zone = Zone.current.fork(\n    zoneValues: &lt;dynamic, dynamic&gt;{\n      _scopeStack: true, \/\/ so we can recognize this as our own zone\n    }\n  );\n  final _AsyncScope scope = _AsyncScope(StackTrace.current, zone);\n  _scopeStack.add(scope);\n  final Future&lt;T&gt; result = scope.zone.run&lt;Future&lt;T&gt;&gt;(body);\n  T resultValue; \/\/ This is set when the body of work completes with a result value.\n  Future&lt;T&gt; completionHandler(dynamic error, StackTrace stack) {\n    assert(_scopeStack.isNotEmpty);\n    assert(_scopeStack.contains(scope));\n    bool leaked = false;\n    _AsyncScope closedScope;\n    final StringBuffer message = StringBuffer();\n    while (_scopeStack.isNotEmpty) {\n      closedScope = _scopeStack.removeLast();\n      if (closedScope == scope)\n        break;\n      if (!leaked) {\n        message.writeln('Asynchronous call to guarded function leaked. You must use \"await\" with all Future-returning test APIs.');\n        leaked = true;\n      }\n      final _StackEntry originalGuarder = _findResponsibleMethod(closedScope.creationStack, 'guard', message);\n      if (originalGuarder != null) {\n        message.writeln(\n          'The test API method \"${originalGuarder.methodName}\" '\n          'from class ${originalGuarder.className} '\n          'was called from ${originalGuarder.callerFile} '\n          'on line ${originalGuarder.callerLine}, '\n          'but never completed before its parent scope closed.'\n        );\n      }\n    }\n    if (leaked) {\n      if (error != null) {\n        message.writeln('An uncaught exception may have caused the guarded function leak. The exception was:');\n        message.writeln('$error');\n        message.writeln('The stack trace associated with this exception was:');\n        FlutterError.defaultStackFilter(stack.toString().trimRight().split('\\n')).forEach(message.writeln);\n      }\n      throw FlutterError(message.toString().trimRight());\n    }\n    if (error != null)\n      return Future&lt;T&gt;.error(error, stack);\n    return Future&lt;T&gt;.value(resultValue);\n  }\n  return result.then&lt;T&gt;(\n    (T value) {\n      resultValue = value;\n      return completionHandler(null, null);\n    },\n    onError: completionHandler,\n  );\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/TestAsyncUtils\/guard.html",
            "isDeprecated": false,
            "type": "dart:async.Future",
            "name": "guard",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.TestAsyncUtils",
            "params": [
                {
                    "name": "body",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:async.Future"
                }
            ]
        },
        {
            "desc": "<p>Verifies that there are no guarded methods currently pending (see <a href=\"flutter_test\/TestAsyncUtils\/guard.html\">guard<\/a>).<\/p>\n<p>If a guarded method is currently pending, and this is not a call nested\nfrom inside that method's body (directly or indirectly), then this method\nwill throw a detailed exception.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static void guardSync() {\n  if (_scopeStack.isEmpty) {\n    \/\/ No scopes open, so we must be fine.\n    return;\n  }\n  \/\/ Find the current TestAsyncUtils scope zone so we can see if it's the one we expect.\n  final Zone zone = _currentScopeZone;\n  if (zone == _scopeStack.last.zone) {\n    \/\/ We're still in the current scope zone. All good.\n    return;\n  }\n  \/\/ If we get here, we know we've got a conflict on our hands.\n  \/\/ We got an async barrier, but the current zone isn't the last scope that\n  \/\/ we pushed on the stack.\n  \/\/ Find which scope the conflict happened in, so that we know\n  \/\/ which stack trace to report the conflict as starting from.\n  \/\/\n  \/\/ For example, if we called an async method A, which ran its body in a\n  \/\/ guarded block, and in its body it ran an async method B, which ran its\n  \/\/ body in a guarded block, but we didn't await B, then in A's block we ran\n  \/\/ an async method C, which ran its body in a guarded block, then we should\n  \/\/ complain about the call to B then the call to C. BUT. If we called an async\n  \/\/ method A, which ran its body in a guarded block, and in its body it ran\n  \/\/ an async method B, which ran its body in a guarded block, but we didn't\n  \/\/ await A, and then at the top level we called a method D, then we should\n  \/\/ complain about the call to A then the call to D.\n  \/\/\n  \/\/ In both examples, the scope stack would have two scopes. In the first\n  \/\/ example, the current zone would be the zone of the _scopeStack[0] scope,\n  \/\/ and we would want to show _scopeStack[1]'s creationStack. In the second\n  \/\/ example, the current zone would not be in the _scopeStack, and we would\n  \/\/ want to show _scopeStack[0]'s creationStack.\n  int skipCount = 0;\n  _AsyncScope candidateScope = _scopeStack.last;\n  _AsyncScope scope;\n  do {\n    skipCount += 1;\n    scope = candidateScope;\n    if (skipCount &gt;= _scopeStack.length) {\n      if (zone == null)\n        break;\n      \/\/ Some people have reported reaching this point, but it's not clear\n      \/\/ why. For now, just silently return.\n      \/\/ TODO(ianh): If we ever get a test case that shows how we reach\n      \/\/ this point, reduce it and report the error if there is one.\n      return;\n    }\n    candidateScope = _scopeStack[_scopeStack.length - skipCount - 1];\n    assert(candidateScope != null);\n    assert(candidateScope.zone != null);\n  } while (candidateScope.zone != zone);\n  assert(scope != null);\n  final StringBuffer message = StringBuffer();\n  message.writeln('Guarded function conflict. You must use \"await\" with all Future-returning test APIs.');\n  final _StackEntry originalGuarder = _findResponsibleMethod(scope.creationStack, 'guard', message);\n  final _StackEntry collidingGuarder = _findResponsibleMethod(StackTrace.current, 'guardSync', message);\n  if (originalGuarder != null &amp;&amp; collidingGuarder != null) {\n    String originalName;\n    if (originalGuarder.className == null) {\n      originalName = '(${originalGuarder.methodName}) ';\n      message.writeln(\n        'The guarded \"${originalGuarder.methodName}\" function '\n        'was called from ${originalGuarder.callerFile} '\n        'on line ${originalGuarder.callerLine}.'\n      );\n    } else {\n      originalName = '(${originalGuarder.className}.${originalGuarder.methodName}) ';\n      message.writeln(\n        'The guarded method \"${originalGuarder.methodName}\" '\n        'from class ${originalGuarder.className} '\n        'was called from ${originalGuarder.callerFile} '\n        'on line ${originalGuarder.callerLine}.'\n      );\n    }\n    final String again = (originalGuarder.callerFile == collidingGuarder.callerFile) &amp;&amp;\n                         (originalGuarder.callerLine == collidingGuarder.callerLine) ?\n                         'again ' : '';\n    String collidingName;\n    if ((originalGuarder.className == collidingGuarder.className) &amp;&amp;\n        (originalGuarder.methodName == collidingGuarder.methodName)) {\n      originalName = '';\n      collidingName = '';\n      message.writeln(\n        'Then, it '\n        'was called ${again}from ${collidingGuarder.callerFile} '\n        'on line ${collidingGuarder.callerLine}.'\n      );\n    } else if (collidingGuarder.className == null) {\n      collidingName = '(${collidingGuarder.methodName}) ';\n      message.writeln(\n        'Then, the \"${collidingGuarder.methodName}\" function '\n        'was called ${again}from ${collidingGuarder.callerFile} '\n        'on line ${collidingGuarder.callerLine}.'\n      );\n    } else {\n      collidingName = '(${collidingGuarder.className}.${collidingGuarder.methodName}) ';\n      message.writeln(\n        'Then, the \"${collidingGuarder.methodName}\" method '\n        '${originalGuarder.className == collidingGuarder.className ? \"(also from class ${collidingGuarder.className})\"\n                                                                   : \"from class ${collidingGuarder.className}\"} '\n        'was called ${again}from ${collidingGuarder.callerFile} '\n        'on line ${collidingGuarder.callerLine}.'\n      );\n    }\n    message.writeln(\n      'The first ${originalGuarder.className == null ? \"function\" : \"method\"} $originalName'\n      'had not yet finished executing at the time that '\n      'the second ${collidingGuarder.className == null ? \"function\" : \"method\"} $collidingName'\n      'was called. Since both are guarded, and the second was not a nested call inside the first, the '\n      'first must complete its execution before the second can be called. Typically, this is achieved by '\n      'putting an \"await\" statement in front of the call to the first.'\n    );\n    if (collidingGuarder.className == null &amp;&amp; collidingGuarder.methodName == 'expect') {\n      message.writeln(\n        'If you are confident that all test APIs are being called using \"await\", and '\n        'this expect() call is not being called at the top level but is itself being '\n        'called from some sort of callback registered before the ${originalGuarder.methodName} '\n        'method was called, then consider using expectSync() instead.'\n      );\n    }\n    message.writeln(\n      '\\n'\n      'When the first ${originalGuarder.className == null ? \"function\" : \"method\"} '\n      '$originalName'\n      'was called, this was the stack:'\n    );\n    message.writeln(FlutterError.defaultStackFilter(scope.creationStack.toString().trimRight().split('\\n')).join('\\n'));\n  }\n  throw FlutterError(message.toString().trimRight());\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/TestAsyncUtils\/guardSync.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "guardSync",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.TestAsyncUtils",
            "params": []
        },
        {
            "desc": "<p>Verifies that there are no guarded methods currently pending (see <a href=\"flutter_test\/TestAsyncUtils\/guard.html\">guard<\/a>).<\/p>\n<p>This is used at the end of tests to ensure that nothing leaks out of the test.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static void verifyAllScopesClosed() {\n  if (_scopeStack.isNotEmpty) {\n    final StringBuffer message = StringBuffer();\n    message.writeln('Asynchronous call to guarded function leaked. You must use \"await\" with all Future-returning test APIs.');\n    for (_AsyncScope scope in _scopeStack) {\n      final _StackEntry guarder = _findResponsibleMethod(scope.creationStack, 'guard', message);\n      if (guarder != null) {\n        message.writeln(\n          'The guarded method \"${guarder.methodName}\" '\n          '${guarder.className != null ? \"from class ${guarder.className} \" : \"\"}'\n          'was called from ${guarder.callerFile} '\n          'on line ${guarder.callerLine}, '\n          'but never completed before its parent scope closed.'\n        );\n      }\n    }\n    throw FlutterError(message.toString().trimRight());\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/TestAsyncUtils\/verifyAllScopesClosed.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "verifyAllScopesClosed",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.TestAsyncUtils",
            "params": []
        }
    ],
    "props": []
}