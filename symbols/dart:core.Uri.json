{
    "name": "dart:core.Uri",
    "extends": [],
    "memberOf": "dart:core",
    "events": [],
    "methods": [
        {
            "name": "operator ==",
            "type": "dart:core.bool",
            "desc": "<p>A URI is equal to another URI with the same normalized representation.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "other",
                    "type": "dart:core.Object",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/operator_equals.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool operator ==(Object other);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri",
            "type": "",
            "desc": "<p>Creates a new URI from its components.<\/p>\n<p>Each component is set through a named argument. Any number of\ncomponents can be provided. The <code>path<\/code> and <code>query<\/code> components can be set\nusing either of two different named arguments.<\/p>\n<p>The scheme component is set through <code>scheme<\/code>. The scheme is\nnormalized to all lowercase letters. If the scheme is omitted or empty,\nthe URI will not have a scheme part.<\/p>\n<p>The user info part of the authority component is set through\n<code>userInfo<\/code>. It defaults to the empty string, which will be omitted\nfrom the string representation of the URI.<\/p>\n<p>The host part of the authority component is set through\n<code>host<\/code>. The host can either be a hostname, an IPv4 address or an\nIPv6 address, contained in '<code>' and '<\/code>'. If the host contains a\n':' character, the '<code>' and '<\/code>' are added if not already provided.\nThe host is normalized to all lowercase letters.<\/p>\n<p>The port part of the authority component is set through\n<code>port<\/code>.\nIf <code>port<\/code> is omitted or <code>null<\/code>, it implies the default port for\nthe URI's scheme, and is equivalent to passing that port explicitly.\nThe recognized schemes, and their default ports, are \"http\" (80) and\n\"https\" (443). All other schemes are considered as having zero as the\ndefault port.<\/p>\n<p>If any of <code>userInfo<\/code>, <code>host<\/code> or <code>port<\/code> are provided,\nthe URI has an authority according to <a href=\"dart-core\/Uri\/hasAuthority.html\">hasAuthority<\/a>.<\/p>\n<p>The path component is set through either <code>path<\/code> or\n<code>pathSegments<\/code>.\nWhen <code>path<\/code> is used, it should be a valid URI path,\nbut invalid characters, except the general delimiters ':\/@[]?#',\nwill be escaped if necessary.\nWhen <code>pathSegments<\/code> is used, each of the provided segments\nis first percent-encoded and then joined using the forward slash\nseparator.<\/p>\n<p>The percent-encoding of the path segments encodes all\ncharacters except for the unreserved characters and the following\nlist of characters: <code>!$&amp;'()*+,;=:@<\/code>. If the other components\nnecessitate an absolute path, a leading slash <code>\/<\/code> is prepended if\nnot already there.<\/p>\n<p>The query component is set through either <code>query<\/code> or <code>queryParameters<\/code>.\nWhen <code>query<\/code> is used, the provided string should be a valid URI query,\nbut invalid characters, other than general delimiters,\nwill be escaped if necessary.\nWhen <code>queryParameters<\/code> is used the query is built from the\nprovided map. Each key and value in the map is percent-encoded\nand joined using equal and ampersand characters.\nA value in the map must be either a string, or an <a href=\"dart-core\/Iterable-class.html\">Iterable<\/a> of strings,\nwhere the latter corresponds to multiple values for the same key.<\/p>\n<p>The percent-encoding of the keys and values encodes all characters\nexcept for the unreserved characters, and replaces spaces with <code>+<\/code>.\nIf <code>query<\/code> is the empty string, it is equivalent to omitting it.\nTo have an actual empty query part,\nuse an empty map for <code>queryParameters<\/code>.<\/p>\n<p>If both <code>query<\/code> and <code>queryParameters<\/code> are omitted or <code>null<\/code>,\nthe URI has no query part.<\/p>\n<p>The fragment component is set through <code>fragment<\/code>.\nIt should be a valid URI fragment, but invalid characters other than\ngeneral delimiters, are escaped if necessary.\nIf <code>fragment<\/code> is omitted or <code>null<\/code>, the URI has no fragment part.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "scheme",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "userInfo",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "host",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "port",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "path",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "pathSegments",
                    "type": "dart:core.Iterable<dart:core.String>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Iterable",
                        "dart:core.String"
                    ]
                },
                {
                    "name": "query",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "queryParameters",
                    "type": "dart:core.Map<dart:core.String>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Map",
                        "dart:core.String"
                    ]
                },
                {
                    "name": "fragment",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri(\n    {String scheme,\n    String userInfo,\n    String host,\n    int port,\n    String path,\n    Iterable&lt;String&gt; pathSegments,\n    String query,\n    Map&lt;String, dynamic \/*String|Iterable&lt;String&gt;*\/ &gt; queryParameters,\n    String fragment}) = _Uri;<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri.dataFromBytes",
            "type": "",
            "desc": "<p>Creates a <code>data:<\/code> URI containing an encoding of <code>bytes<\/code>.<\/p>\n<p>Defaults to Base64 encoding the bytes, but if <code>percentEncoded<\/code>\nis <code>true<\/code>, the bytes will instead be percent encoded (any non-ASCII\nor non-valid-ASCII-character byte is replaced by a percent encoding).<\/p>\n<p>To read the bytes back, use <a href=\"dart-core\/UriData\/contentAsBytes.html\">UriData.contentAsBytes<\/a>.<\/p>\n<p>It defaults to having the mime-type <code>application\/octet-stream<\/code>.\nThe <code>mimeType<\/code> and <code>parameters<\/code> are added to the created URI.\nIf any of these contain characters that are not allowed\nin the data URI, the character is percent-escaped. If the character is\nnon-ASCII, it is first UTF-8 encoded and then the bytes are percent\nencoded.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "bytes",
                    "type": "dart:core.List<dart:core.int>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.List",
                        "dart:core.int"
                    ]
                },
                {
                    "name": "mimeType",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "parameters",
                    "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Map",
                        "dart:core.String",
                        "dart:core.String"
                    ]
                },
                {
                    "name": "percentEncoded",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.dataFromBytes.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri.dataFromBytes(List&lt;int&gt; bytes,\n    {mimeType: \"application\/octet-stream\",\n    Map&lt;String, String&gt; parameters,\n    percentEncoded: false}) {\n  UriData data = new UriData.fromBytes(bytes,\n      mimeType: mimeType,\n      parameters: parameters,\n      percentEncoded: percentEncoded);\n  return data.uri;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri.dataFromString",
            "type": "",
            "desc": "<p>Creates a <code>data:<\/code> URI containing the <code>content<\/code> string.<\/p>\n<p>Converts the content to a bytes using <code>encoding<\/code> or the charset specified\nin <code>parameters<\/code> (defaulting to US-ASCII if not specified or unrecognized),\nthen encodes the bytes into the resulting data URI.<\/p>\n<p>Defaults to encoding using percent-encoding (any non-ASCII or non-URI-valid\nbytes is replaced by a percent encoding). If <code>base64<\/code> is true, the bytes\nare instead encoded using <code>base64<\/code>.<\/p>\n<p>If <code>encoding<\/code> is not provided and <code>parameters<\/code> has a <code>charset<\/code> entry,\nthat name is looked up using <a href=\"dart-convert\/Encoding\/getByName.html\">Encoding.getByName<\/a>,\nand if the lookup returns an encoding, that encoding is used to convert\n<code>content<\/code> to bytes.\nIf providing both an <code>encoding<\/code> and a charset in <code>parameters<\/code>, they should\nagree, otherwise decoding won't be able to use the charset parameter\nto determine the encoding.<\/p>\n<p>If <code>mimeType<\/code> and\/or <code>parameters<\/code> are supplied, they are added to the\ncreated URI. If any of these contain characters that are not allowed\nin the data URI, the character is percent-escaped. If the character is\nnon-ASCII, it is first UTF-8 encoded and then the bytes are percent\nencoded. An omitted <code>mimeType<\/code> in a data URI means <code>text\/plain<\/code>, just\nas an omitted <code>charset<\/code> parameter defaults to meaning <code>US-ASCII<\/code>.<\/p>\n<p>To read the content back, use <a href=\"dart-core\/UriData\/contentAsString.html\">UriData.contentAsString<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "content",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "mimeType",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "encoding",
                    "type": "dart:convert.Encoding",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "parameters",
                    "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Map",
                        "dart:core.String",
                        "dart:core.String"
                    ]
                },
                {
                    "name": "base64",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.dataFromString.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri.dataFromString(String content,\n    {String mimeType,\n    Encoding encoding,\n    Map&lt;String, String&gt; parameters,\n    bool base64: false}) {\n  UriData data = new UriData.fromString(content,\n      mimeType: mimeType,\n      encoding: encoding,\n      parameters: parameters,\n      base64: base64);\n  return data.uri;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "decodeComponent",
            "type": "dart:core.String",
            "desc": "<p>Decodes the percent-encoding in <code>encodedComponent<\/code>.<\/p>\n<p>Note that decoding a URI component might change its meaning as\nsome of the decoded characters could be characters with are\ndelimiters for a given URI component type. Always split a URI\ncomponent using the delimiters for the component before decoding\nthe individual parts.<\/p>\n<p>For handling the <a href=\"dart-core\/Uri\/path.html\">path<\/a> and <a href=\"dart-core\/Uri\/query.html\">query<\/a> components consider using\n<a href=\"dart-core\/Uri\/pathSegments.html\">pathSegments<\/a> and <a href=\"dart-core\/Uri\/queryParameters.html\">queryParameters<\/a> to get the separated and\ndecoded component.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "encodedComponent",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/decodeComponent.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String decodeComponent(String encodedComponent) {\n  return _Uri._uriDecode(\n      encodedComponent, 0, encodedComponent.length, utf8, false);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "decodeFull",
            "type": "dart:core.String",
            "desc": "<p>Decodes the percent-encoding in <code>uri<\/code>.<\/p>\n<p>Note that decoding a full URI might change its meaning as some of\nthe decoded characters could be reserved characters. In most\ncases an encoded URI should be parsed into components using\n<a href=\"dart-core\/Uri\/parse.html\">Uri.parse<\/a> before decoding the separate components.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "uri",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/decodeFull.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String decodeFull(String uri) {\n  return _Uri._uriDecode(uri, 0, uri.length, utf8, false);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "decodeQueryComponent",
            "type": "dart:core.String",
            "desc": "<p>Decodes the percent-encoding in <code>encodedComponent<\/code>, converting\npluses to spaces.<\/p>\n<p>It will create a byte-list of the decoded characters, and then use\n<code>encoding<\/code> to decode the byte-list to a String. The default encoding is\nUTF-8.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "encodedComponent",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "encoding",
                    "type": "dart:convert.Encoding",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/decodeQueryComponent.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String decodeQueryComponent(String encodedComponent,\n    {Encoding encoding: utf8}) {\n  return _Uri._uriDecode(\n      encodedComponent, 0, encodedComponent.length, encoding, true);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri.directory",
            "type": "",
            "desc": "<p>Like <a href=\"dart-core\/Uri\/Uri.file.html\">Uri.file<\/a> except that a non-empty URI path ends in a slash.<\/p>\n<p>If <code>path<\/code> is not empty, and it doesn't end in a directory separator,\nthen a slash is added to the returned URI's path.\nIn all other cases, the result is the same as returned by <code>Uri.file<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "path",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "windows",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.directory.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri.directory(String path, {bool windows}) = _Uri.directory;<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "encodeComponent",
            "type": "dart:core.String",
            "desc": "<p>Encode the string <code>component<\/code> using percent-encoding to make it\nsafe for literal use as a URI component.<\/p>\n<p>All characters except uppercase and lowercase letters, digits and\nthe characters <code>-_.!~*'()<\/code> are percent-encoded. This is the\nset of characters specified in RFC 2396 and the which is\nspecified for the encodeUriComponent in ECMA-262 version 5.1.<\/p>\n<p>When manually encoding path segments or query components remember\nto encode each part separately before building the path or query\nstring.<\/p>\n<p>For encoding the query part consider using\n<a href=\"dart-core\/Uri\/encodeQueryComponent.html\">encodeQueryComponent<\/a>.<\/p>\n<p>To avoid the need for explicitly encoding use the <a href=\"dart-core\/Uri\/pathSegments.html\">pathSegments<\/a>\nand <a href=\"dart-core\/Uri\/queryParameters.html\">queryParameters<\/a> optional named arguments when constructing\na <a href=\"dart-core\/Uri-class.html\">Uri<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "component",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/encodeComponent.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String encodeComponent(String component) {\n  return _Uri._uriEncode(_Uri._unreserved2396Table, component, utf8, false);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "encodeFull",
            "type": "dart:core.String",
            "desc": "<p>Encode the string <code>uri<\/code> using percent-encoding to make it\nsafe for literal use as a full URI.<\/p>\n<p>All characters except uppercase and lowercase letters, digits and\nthe characters <code>!#$&amp;'()*+,-.\/:;=?@_~<\/code> are percent-encoded. This\nis the set of characters specified in in ECMA-262 version 5.1 for\nthe encodeURI function .<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "uri",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/encodeFull.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String encodeFull(String uri) {\n  return _Uri._uriEncode(_Uri._encodeFullTable, uri, utf8, false);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "encodeQueryComponent",
            "type": "dart:core.String",
            "desc": "<p>Encode the string <code>component<\/code> according to the HTML 4.01 rules\nfor encoding the posting of a HTML form as a query string\ncomponent.<\/p>\n<p>Encode the string <code>component<\/code> according to the HTML 4.01 rules\nfor encoding the posting of a HTML form as a query string\ncomponent.<\/p>\n<p>The component is first encoded to bytes using <code>encoding<\/code>.\nThe default is to use <a href=\"dart-convert\/utf8-constant.html\">utf8<\/a> encoding, which preserves all\nthe characters that don't need encoding.<\/p>\n<p>Then the resulting bytes are \"percent-encoded\". This transforms\nspaces (U+0020) to a plus sign ('+') and all bytes that are not\nthe ASCII decimal digits, letters or one of '-._~' are written as\na percent sign '%' followed by the two-digit hexadecimal\nrepresentation of the byte.<\/p>\n<p>Note that the set of characters which are percent-encoded is a\nsuperset of what HTML 4.01 requires, since it refers to RFC 1738\nfor reserved characters.<\/p>\n<p>When manually encoding query components remember to encode each\npart separately before building the query string.<\/p>\n<p>To avoid the need for explicitly encoding the query use the\n<a href=\"dart-core\/Uri\/queryParameters.html\">queryParameters<\/a> optional named arguments when constructing a\n<a href=\"dart-core\/Uri-class.html\">Uri<\/a>.<\/p>\n<p>See <a href=\"http:\/\/www.w3.org\/TR\/html401\/interact\/forms.html#h-17.13.4.2\">http:\/\/www.w3.org\/TR\/html401\/interact\/forms.html#h-17.13.4.2<\/a> for more\ndetails.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "component",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "encoding",
                    "type": "dart:convert.Encoding",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/encodeQueryComponent.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String encodeQueryComponent(String component,\n    {Encoding encoding: utf8}) {\n  return _Uri._uriEncode(_Uri._unreservedTable, component, encoding, true);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri.file",
            "type": "",
            "desc": "<p>Creates a new file URI from an absolute or relative file path.<\/p>\n<p>The file path is passed in <code>path<\/code>.<\/p>\n<p>This path is interpreted using either Windows or non-Windows\nsemantics.<\/p>\n<p>With non-Windows semantics the slash (<code>\/<\/code>) is used to separate\npath segments in the input <code>path<\/code>.<\/p>\n<p>With Windows semantics, backslash (<code>\\<\/code>) and forward-slash (<code>\/<\/code>)\nare used to separate path segments in the input <code>path<\/code>,\nexcept if the path starts with <code>\\\\?\\<\/code> in which case\nonly backslash (<code>\\<\/code>) separates path segments in <code>path<\/code>.<\/p>\n<p>If the path starts with a path separator, an absolute URI (with the\n<code>file<\/code> scheme and an empty authority) is created.\nOtherwise a relative URI reference with no scheme or authority is created.\nOne exception from this rule is that when Windows semantics is used\nand the path starts with a drive letter followed by a colon (\":\") and a\npath separator, then an absolute URI is created.<\/p>\n<p>The default for whether to use Windows or non-Windows semantics\ndetermined from the platform Dart is running on. When running in\nthe standalone VM, this is detected by the VM based on the\noperating system. When running in a browser non-Windows semantics\nis always used.<\/p>\n<p>To override the automatic detection of which semantics to use pass\na value for <code>windows<\/code>. Passing <code>true<\/code> will use Windows\nsemantics and passing <code>false<\/code> will use non-Windows semantics.<\/p>\n<p>Examples using non-Windows semantics:<\/p>\n<pre class=\"language-dart\"><code>\/\/ xxx\/yyy\nnew Uri.file(\"xxx\/yyy\", windows: false);\n\n\/\/ xxx\/yyy\/\nnew Uri.file(\"xxx\/yyy\/\", windows: false);\n\n\/\/ file:\/\/\/xxx\/yyy\nnew Uri.file(\"\/xxx\/yyy\", windows: false);\n\n\/\/ file:\/\/\/xxx\/yyy\/\nnew Uri.file(\"\/xxx\/yyy\/\", windows: false);\n\n\/\/ C%3A\nnew Uri.file(\"C:\", windows: false);\n<\/code><\/pre>\n<p>Examples using Windows semantics:<\/p>\n<pre class=\"language-dart\"><code>\/\/ xxx\/yyy\nnew Uri.file(r\"xxx\\yyy\", windows: true);\n\n\/\/ xxx\/yyy\/\nnew Uri.file(r\"xxx\\yyy\\\", windows: true);\n\nfile:\/\/\/xxx\/yyy\nnew Uri.file(r\"\\xxx\\yyy\", windows: true);\n\nfile:\/\/\/xxx\/yyy\/\nnew Uri.file(r\"\\xxx\\yyy\/\", windows: true);\n\n\/\/ file:\/\/\/C:\/xxx\/yyy\nnew Uri.file(r\"C:\\xxx\\yyy\", windows: true);\n\n\/\/ This throws an error. A path with a drive letter, but no following\n\/\/ path, is not allowed.\nnew Uri.file(r\"C:\", windows: true);\n\n\/\/ This throws an error. A path with a drive letter is not absolute.\nnew Uri.file(r\"C:xxx\\yyy\", windows: true);\n\n\/\/ file:\/\/server\/share\/file\nnew Uri.file(r\"\\\\server\\share\\file\", windows: true);\n<\/code><\/pre>\n<p>If the path passed is not a valid file path, an error is thrown.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "path",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "windows",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.file.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri.file(String path, {bool windows}) = _Uri.file;<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri.http",
            "type": "",
            "desc": "<p>Creates a new <code>http<\/code> URI from authority, path and query.<\/p>\n<p>Examples:<\/p>\n<pre class=\"language-dart\"><code>\/\/ http:\/\/example.org\/path?q=dart.\nnew Uri.http(\"example.org\", \"\/path\", { \"q\" : \"dart\" });\n\n\/\/ http:\/\/user:pass@localhost:8080\nnew Uri.http(\"user:pass@localhost:8080\", \"\");\n\n\/\/ http:\/\/example.org\/a%20b\nnew Uri.http(\"example.org\", \"a b\");\n\n\/\/ http:\/\/example.org\/a%252F\nnew Uri.http(\"example.org\", \"\/a%2F\");\n<\/code><\/pre>\n<p>The <code>scheme<\/code> is always set to <code>http<\/code>.<\/p>\n<p>The <code>userInfo<\/code>, <code>host<\/code> and <code>port<\/code> components are set from the\n<code>authority<\/code> argument. If <code>authority<\/code> is <code>null<\/code> or empty,\nthe created <code>Uri<\/code> has no authority, and isn't directly usable\nas an HTTP URL, which must have a non-empty host.<\/p>\n<p>The <code>path<\/code> component is set from the <code>unencodedPath<\/code>\nargument. The path passed must not be encoded as this constructor\nencodes the path.<\/p>\n<p>The <code>query<\/code> component is set from the optional <code>queryParameters<\/code>\nargument.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "authority",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "unencodedPath",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "queryParameters",
                    "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Map",
                        "dart:core.String",
                        "dart:core.String"
                    ]
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.http.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri.http(String authority, String unencodedPath,\n    [Map&lt;String, String&gt; queryParameters]) = _Uri.http;<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "Uri.https",
            "type": "",
            "desc": "<p>Creates a new <code>https<\/code> URI from authority, path and query.<\/p>\n<p>This constructor is the same as <a href=\"dart-core\/Uri\/Uri.http.html\">Uri.http<\/a> except for the scheme\nwhich is set to <code>https<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "authority",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "unencodedPath",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "queryParameters",
                    "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Map",
                        "dart:core.String",
                        "dart:core.String"
                    ]
                }
            ],
            "isConstructor": true,
            "href": "dart-core\/Uri\/Uri.https.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Uri.https(String authority, String unencodedPath,\n    [Map&lt;String, String&gt; queryParameters]) = _Uri.https;<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "isScheme",
            "type": "dart:core.bool",
            "desc": "<p>Whether the scheme of this <a href=\"dart-core\/Uri-class.html\">Uri<\/a> is <code>scheme<\/code>.<\/p>\n<p>The <code>scheme<\/code> should be the same as the one returned by <a href=\"dart-core\/Uri\/scheme.html\">Uri.scheme<\/a>,\nbut doesn't have to be case-normalized to lower-case characters.<\/p>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">var uri = Uri.parse(\"http:\/\/example.com\/\");\nprint(uri.isScheme(\"HTTP\"));  \/\/ Prints true.\n<\/code><\/pre>\n<p>A <code>null<\/code> or empty <code>scheme<\/code> string matches a URI with no scheme\n(one where <a href=\"dart-core\/Uri\/hasScheme.html\">hasScheme<\/a> returns false).<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "scheme",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/isScheme.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool isScheme(String scheme);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "normalizePath",
            "type": "dart:core.Uri",
            "desc": "<p>Returns a URI where the path has been normalized.<\/p>\n<p>A normalized path does not contain <code>.<\/code> segments or non-leading <code>..<\/code>\nsegments.\nOnly a relative path with no scheme or authority may contain\nleading <code>..<\/code> segments,\na path that starts with <code>\/<\/code> will also drop any leading <code>..<\/code> segments.<\/p>\n<p>This uses the same normalization strategy as <code>new Uri().resolve(this)<\/code>.<\/p>\n<p>Does not change any part of the URI except the path.<\/p>\n<p>The default implementation of <code>Uri<\/code> always normalizes paths, so calling\nthis function has no effect.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "dart-core\/Uri\/normalizePath.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Uri normalizePath();<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "parse",
            "type": "dart:core.Uri",
            "desc": "<p>Creates a new <code>Uri<\/code> object by parsing a URI string.<\/p>\n<p>If <code>start<\/code> and <code>end<\/code> are provided, they must specify a valid substring\nof <code>uri<\/code>, and only the substring from <code>start<\/code> to <code>end<\/code> is parsed as a URI.<\/p>\n<p>The <code>uri<\/code> must not be <code>null<\/code>.\nIf the <code>uri<\/code> string is not valid as a URI or URI reference,\na <a href=\"dart-core\/FormatException-class.html\">FormatException<\/a> is thrown.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "uri",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "start",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "end",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/parse.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Uri parse(String uri, [int start = 0, int end]) {\n  \/\/ This parsing will not validate percent-encoding, IPv6, etc.\n  \/\/ When done splitting into parts, it will call, e.g., [_makeFragment]\n  \/\/ to do the final parsing.\n  \/\/\n  \/\/ Important parts of the RFC 3986 used here:\n  \/\/ URI           = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n  \/\/\n  \/\/ hier-part     = \"\/\/\" authority path-abempty\n  \/\/               \/ path-absolute\n  \/\/               \/ path-rootless\n  \/\/               \/ path-empty\n  \/\/\n  \/\/ URI-reference = URI \/ relative-ref\n  \/\/\n  \/\/ absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n  \/\/\n  \/\/ relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\n  \/\/\n  \/\/ relative-part = \"\/\/\" authority path-abempty\n  \/\/               \/ path-absolute\n  \/\/               \/ path-noscheme\n  \/\/               \/ path-empty\n  \/\/\n  \/\/ scheme        = ALPHA *( ALPHA \/ DIGIT \/ \"+\" \/ \"-\" \/ \".\" )\n  \/\/\n  \/\/ authority     = [ userinfo \"@\" ] host [ \":\" port ]\n  \/\/ userinfo      = *( unreserved \/ pct-encoded \/ sub-delims \/ \":\" )\n  \/\/ host          = IP-literal \/ IPv4address \/ reg-name\n  \/\/ port          = *DIGIT\n  \/\/ reg-name      = *( unreserved \/ pct-encoded \/ sub-delims )\n  \/\/\n  \/\/ path          = path-abempty    ; begins with \"\/\" or is empty\n  \/\/               \/ path-absolute   ; begins with \"\/\" but not \"\/\/\"\n  \/\/               \/ path-noscheme   ; begins with a non-colon segment\n  \/\/               \/ path-rootless   ; begins with a segment\n  \/\/               \/ path-empty      ; zero characters\n  \/\/\n  \/\/ path-abempty  = *( \"\/\" segment )\n  \/\/ path-absolute = \"\/\" [ segment-nz *( \"\/\" segment ) ]\n  \/\/ path-noscheme = segment-nz-nc *( \"\/\" segment )\n  \/\/ path-rootless = segment-nz *( \"\/\" segment )\n  \/\/ path-empty    = 0&lt;pchar&gt;\n  \/\/\n  \/\/ segment       = *pchar\n  \/\/ segment-nz    = 1*pchar\n  \/\/ segment-nz-nc = 1*( unreserved \/ pct-encoded \/ sub-delims \/ \"@\" )\n  \/\/               ; non-zero-length segment without any colon \":\"\n  \/\/\n  \/\/ pchar         = unreserved \/ pct-encoded \/ sub-delims \/ \":\" \/ \"@\"\n  \/\/\n  \/\/ query         = *( pchar \/ \"\/\" \/ \"?\" )\n  \/\/\n  \/\/ fragment      = *( pchar \/ \"\/\" \/ \"?\" )\n  end ??= uri.length;\n\n  \/\/ Special case data:URIs. Ignore case when testing.\n  if (end &gt;= start + 5) {\n    int dataDelta = _startsWithData(uri, start);\n    if (dataDelta == 0) {\n      \/\/ The case is right.\n      if (start &gt; 0 || end &lt; uri.length) uri = uri.substring(start, end);\n      return UriData._parse(uri, 5, null).uri;\n    } else if (dataDelta == 0x20) {\n      return UriData._parse(uri.substring(start + 5, end), 0, null).uri;\n    }\n    \/\/ Otherwise the URI doesn't start with \"data:\" or any case variant of it.\n  }\n\n  \/\/ The following index-normalization belongs with the scanning, but is\n  \/\/ easier to do here because we already have extracted variables from the\n  \/\/ indices list.\n  var indices = new List&lt;int&gt;(8);\n\n  \/\/ Set default values for each position.\n  \/\/ The value will either be correct in some cases where it isn't set\n  \/\/ by the scanner, or it is clearly recognizable as an unset value.\n  indices\n    ..[0] = 0\n    ..[_schemeEndIndex] = start - 1\n    ..[_hostStartIndex] = start - 1\n    ..[_notSimpleIndex] = start - 1\n    ..[_portStartIndex] = start\n    ..[_pathStartIndex] = start\n    ..[_queryStartIndex] = end\n    ..[_fragmentStartIndex] = end;\n  var state = _scan(uri, start, end, _uriStart, indices);\n  \/\/ Some states that should be non-simple, but the URI ended early.\n  \/\/ Paths that end at a \"..\" must be normalized to end in \"..\/\".\n  if (state &gt;= _nonSimpleEndStates) {\n    indices[_notSimpleIndex] = end;\n  }\n  int schemeEnd = indices[_schemeEndIndex];\n  if (schemeEnd &gt;= start) {\n    \/\/ Rescan the scheme part now that we know it's not a path.\n    state = _scan(uri, start, schemeEnd, _schemeStart, indices);\n    if (state == _schemeStart) {\n      \/\/ Empty scheme.\n      indices[_notSimpleIndex] = schemeEnd;\n    }\n  }\n  \/\/ The returned positions are limited by the scanners ability to write only\n  \/\/ one position per character, and only the current position.\n  \/\/ Scanning from left to right, we only know whether something is a scheme\n  \/\/ or a path when we see a `:` or `\/`, and likewise we only know if the first\n  \/\/ `\/` is part of the path or is leading an authority component when we see\n  \/\/ the next character.\n\n  int hostStart = indices[_hostStartIndex] + 1;\n  int portStart = indices[_portStartIndex];\n  int pathStart = indices[_pathStartIndex];\n  int queryStart = indices[_queryStartIndex];\n  int fragmentStart = indices[_fragmentStartIndex];\n\n  \/\/ We may discover scheme while handling special cases.\n  String scheme;\n\n  \/\/ Derive some positions that weren't set to normalize the indices.\n  if (fragmentStart &lt; queryStart) queryStart = fragmentStart;\n  \/\/ If pathStart isn't set (it's before scheme end or host start), then\n  \/\/ the path is empty, or there is no authority part and the path\n  \/\/ starts with a non-simple character.\n  if (pathStart &lt; hostStart) {\n    \/\/ There is an authority, but no path. The path would start with `\/`\n    \/\/ if it was there.\n    pathStart = queryStart;\n  } else if (pathStart &lt;= schemeEnd) {\n    \/\/ There is a scheme, but no authority.\n    pathStart = schemeEnd + 1;\n  }\n  \/\/ If there is an authority with no port, set the port position\n  \/\/ to be at the end of the authority (equal to pathStart).\n  \/\/ This also handles a \":\" in a user-info component incorrectly setting\n  \/\/ the port start position.\n  if (portStart &lt; hostStart) portStart = pathStart;\n\n  assert(hostStart == start || schemeEnd &lt;= hostStart);\n  assert(hostStart &lt;= portStart);\n  assert(schemeEnd &lt;= pathStart);\n  assert(portStart &lt;= pathStart);\n  assert(pathStart &lt;= queryStart);\n  assert(queryStart &lt;= fragmentStart);\n\n  bool isSimple = indices[_notSimpleIndex] &lt; start;\n\n  if (isSimple) {\n    \/\/ Check\/do normalizations that weren't detected by the scanner.\n    \/\/ This includes removal of empty port or userInfo,\n    \/\/ or scheme specific port and path normalizations.\n    if (hostStart &gt; schemeEnd + 3) {\n      \/\/ Always be non-simple if URI contains user-info.\n      \/\/ The scanner doesn't set the not-simple position in this case because\n      \/\/ it's setting the host-start position instead.\n      isSimple = false;\n    } else if (portStart &gt; start &amp;&amp; portStart + 1 == pathStart) {\n      \/\/ If the port is empty, it should be omitted.\n      \/\/ Pathological case, don't bother correcting it.\n      isSimple = false;\n    } else if (queryStart &lt; end &amp;&amp;\n            (queryStart == pathStart + 2 &amp;&amp;\n                uri.startsWith(\"..\", pathStart)) ||\n        (queryStart &gt; pathStart + 2 &amp;&amp;\n            uri.startsWith(\"\/..\", queryStart - 3))) {\n      \/\/ The path ends in a \"..\" segment. This should be normalized to \"..\/\".\n      \/\/ We didn't detect this while scanning because a query or fragment was\n      \/\/ detected at the same time (which is why we only need to check this\n      \/\/ if there is something after the path).\n      isSimple = false;\n    } else {\n      \/\/ There are a few scheme-based normalizations that\n      \/\/ the scanner couldn't check.\n      \/\/ That means that the input is very close to simple, so just do\n      \/\/ the normalizations.\n      if (schemeEnd == start + 4) {\n        \/\/ Do scheme based normalizations for file, http.\n        if (uri.startsWith(\"file\", start)) {\n          scheme = \"file\";\n          if (hostStart &lt;= start) {\n            \/\/ File URIs should have an authority.\n            \/\/ Paths after an authority should be absolute.\n            String schemeAuth = \"file:\/\/\";\n            int delta = 2;\n            if (!uri.startsWith(\"\/\", pathStart)) {\n              schemeAuth = \"file:\/\/\/\";\n              delta = 3;\n            }\n            uri = schemeAuth + uri.substring(pathStart, end);\n            schemeEnd -= start;\n            hostStart = 7;\n            portStart = 7;\n            pathStart = 7;\n            queryStart += delta - start;\n            fragmentStart += delta - start;\n            start = 0;\n            end = uri.length;\n          } else if (pathStart == queryStart) {\n            \/\/ Uri has authority and empty path. Add \"\/\" as path.\n            if (start == 0 &amp;&amp; end == uri.length) {\n              uri = uri.replaceRange(pathStart, queryStart, \"\/\");\n              queryStart += 1;\n              fragmentStart += 1;\n              end += 1;\n            } else {\n              uri = \"${uri.substring(start, pathStart)}\/\"\n                  \"${uri.substring(queryStart, end)}\";\n              schemeEnd -= start;\n              hostStart -= start;\n              portStart -= start;\n              pathStart -= start;\n              queryStart += 1 - start;\n              fragmentStart += 1 - start;\n              start = 0;\n              end = uri.length;\n            }\n          }\n        } else if (uri.startsWith(\"http\", start)) {\n          scheme = \"http\";\n          \/\/ HTTP URIs should not have an explicit port of 80.\n          if (portStart &gt; start &amp;&amp;\n              portStart + 3 == pathStart &amp;&amp;\n              uri.startsWith(\"80\", portStart + 1)) {\n            if (start == 0 &amp;&amp; end == uri.length) {\n              uri = uri.replaceRange(portStart, pathStart, \"\");\n              pathStart -= 3;\n              queryStart -= 3;\n              fragmentStart -= 3;\n              end -= 3;\n            } else {\n              uri = uri.substring(start, portStart) +\n                  uri.substring(pathStart, end);\n              schemeEnd -= start;\n              hostStart -= start;\n              portStart -= start;\n              pathStart -= 3 + start;\n              queryStart -= 3 + start;\n              fragmentStart -= 3 + start;\n              start = 0;\n              end = uri.length;\n            }\n          }\n        }\n      } else if (schemeEnd == start + 5 &amp;&amp; uri.startsWith(\"https\", start)) {\n        scheme = \"https\";\n        \/\/ HTTPS URIs should not have an explicit port of 443.\n        if (portStart &gt; start &amp;&amp;\n            portStart + 4 == pathStart &amp;&amp;\n            uri.startsWith(\"443\", portStart + 1)) {\n          if (start == 0 &amp;&amp; end == uri.length) {\n            uri = uri.replaceRange(portStart, pathStart, \"\");\n            pathStart -= 4;\n            queryStart -= 4;\n            fragmentStart -= 4;\n            end -= 3;\n          } else {\n            uri = uri.substring(start, portStart) +\n                uri.substring(pathStart, end);\n            schemeEnd -= start;\n            hostStart -= start;\n            portStart -= start;\n            pathStart -= 4 + start;\n            queryStart -= 4 + start;\n            fragmentStart -= 4 + start;\n            start = 0;\n            end = uri.length;\n          }\n        }\n      }\n    }\n  }\n\n  if (isSimple) {\n    if (start &gt; 0 || end &lt; uri.length) {\n      uri = uri.substring(start, end);\n      schemeEnd -= start;\n      hostStart -= start;\n      portStart -= start;\n      pathStart -= start;\n      queryStart -= start;\n      fragmentStart -= start;\n    }\n    return new _SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart,\n        queryStart, fragmentStart, scheme);\n  }\n\n  return new _Uri.notSimple(uri, start, end, schemeEnd, hostStart, portStart,\n      pathStart, queryStart, fragmentStart, scheme);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "parseIPv4Address",
            "type": "dart:core.List<dart:core.int>",
            "desc": "<p>Parse the <code>host<\/code> as an IP version 4 (IPv4) address, returning the address\nas a list of 4 bytes in network byte order (big endian).<\/p>\n<p>Throws a <a href=\"dart-core\/FormatException-class.html\">FormatException<\/a> if <code>host<\/code> is not a valid IPv4 address\nrepresentation.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "host",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/parseIPv4Address.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static List&lt;int&gt; parseIPv4Address(String host) =&gt;\n    _parseIPv4Address(host, 0, host.length);<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": [
                "dart:core.List",
                "dart:core.int"
            ]
        },
        {
            "name": "parseIPv6Address",
            "type": "dart:core.List<dart:core.int>",
            "desc": "<p>Parse the <code>host<\/code> as an IP version 6 (IPv6) address, returning the address\nas a list of 16 bytes in network byte order (big endian).<\/p>\n<p>Throws a <a href=\"dart-core\/FormatException-class.html\">FormatException<\/a> if <code>host<\/code> is not a valid IPv6 address\nrepresentation.<\/p>\n<p>Acts on the substring from <code>start<\/code> to <code>end<\/code>. If <code>end<\/code> is omitted, it\ndefaults ot the end of the string.<\/p>\n<p>Some examples of IPv6 addresses:<\/p>\n<ul>\n<li>::1<\/li>\n<li>FEDC:BA98:7654:3210:FEDC:BA98:7654:3210<\/li>\n<li>3ffe:2a00\ud83d\udcaf7031::1<\/li>\n<li>::FFFF:129.144.52.38<\/li>\n<li>2010:836B:4179::836B:4179<\/li>\n<\/ul>",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "host",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "start",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "end",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/parseIPv6Address.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static List&lt;int&gt; parseIPv6Address(String host, [int start = 0, int end]) {\n  end ??= host.length;\n  \/\/ An IPv6 address consists of exactly 8 parts of 1-4 hex digits, separated\n  \/\/ by `:`'s, with the following exceptions:\n  \/\/\n  \/\/  - One (and only one) wildcard (`::`) may be present, representing a fill\n  \/\/    of 0's. The IPv6 `::` is thus 16 bytes of `0`.\n  \/\/  - The last two parts may be replaced by an IPv4 \"dotted-quad\" address.\n\n  \/\/ Helper function for reporting a badly formatted IPv6 address.\n  void error(String msg, [position]) {\n    throw new FormatException('Illegal IPv6 address, $msg', host, position);\n  }\n\n  \/\/ Parse a hex block.\n  int parseHex(int start, int end) {\n    if (end - start &gt; 4) {\n      error('an IPv6 part can only contain a maximum of 4 hex digits', start);\n    }\n    int value = int.parse(host.substring(start, end), radix: 16);\n    if (value &lt; 0 || value &gt; 0xFFFF) {\n      error('each part must be in the range of `0x0..0xFFFF`', start);\n    }\n    return value;\n  }\n\n  if (host.length &lt; 2) error('address is too short');\n  List&lt;int&gt; parts = [];\n  bool wildcardSeen = false;\n  \/\/ Set if seeing a \".\", suggesting that there is an IPv4 address.\n  bool seenDot = false;\n  int partStart = start;\n  \/\/ Parse all parts, except a potential last one.\n  for (int i = start; i &lt; end; i++) {\n    int char = host.codeUnitAt(i);\n    if (char == _COLON) {\n      if (i == start) {\n        \/\/ If we see a `:` in the beginning, expect wildcard.\n        i++;\n        if (host.codeUnitAt(i) != _COLON) {\n          error('invalid start colon.', i);\n        }\n        partStart = i;\n      }\n      if (i == partStart) {\n        \/\/ Wildcard. We only allow one.\n        if (wildcardSeen) {\n          error('only one wildcard `::` is allowed', i);\n        }\n        wildcardSeen = true;\n        parts.add(-1);\n      } else {\n        \/\/ Found a single colon. Parse [partStart..i] as a hex entry.\n        parts.add(parseHex(partStart, i));\n      }\n      partStart = i + 1;\n    } else if (char == _DOT) {\n      seenDot = true;\n    }\n  }\n  if (parts.length == 0) error('too few parts');\n  bool atEnd = (partStart == end);\n  bool isLastWildcard = (parts.last == -1);\n  if (atEnd &amp;&amp; !isLastWildcard) {\n    error('expected a part after last `:`', end);\n  }\n  if (!atEnd) {\n    if (!seenDot) {\n      parts.add(parseHex(partStart, end));\n    } else {\n      List&lt;int&gt; last = _parseIPv4Address(host, partStart, end);\n      parts.add(last[0] &lt;&lt; 8 | last[1]);\n      parts.add(last[2] &lt;&lt; 8 | last[3]);\n    }\n  }\n  if (wildcardSeen) {\n    if (parts.length &gt; 7) {\n      error('an address with a wildcard must have less than 7 parts');\n    }\n  } else if (parts.length != 8) {\n    error('an address without a wildcard must contain exactly 8 parts');\n  }\n  List&lt;int&gt; bytes = new Uint8List(16);\n  for (int i = 0, index = 0; i &lt; parts.length; i++) {\n    int value = parts[i];\n    if (value == -1) {\n      int wildCardLength = 9 - parts.length;\n      for (int j = 0; j &lt; wildCardLength; j++) {\n        bytes[index] = 0;\n        bytes[index + 1] = 0;\n        index += 2;\n      }\n    } else {\n      bytes[index] = value &gt;&gt; 8;\n      bytes[index + 1] = value &amp; 0xff;\n      index += 2;\n    }\n  }\n  return bytes;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": [
                "dart:core.List",
                "dart:core.int"
            ]
        },
        {
            "name": "removeFragment",
            "type": "dart:core.Uri",
            "desc": "<p>Returns a <code>Uri<\/code> that differs from this only in not having a fragment.<\/p>\n<p>If this <code>Uri<\/code> does not have a fragment, it is itself returned.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "dart-core\/Uri\/removeFragment.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Uri removeFragment();<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "replace",
            "type": "dart:core.Uri",
            "desc": "<p>Returns a new <code>Uri<\/code> based on this one, but with some parts replaced.<\/p>\n<p>This method takes the same parameters as the <a href=\"dart-core\/Uri\/Uri.html\">new Uri<\/a> constructor,\nand they have the same meaning.<\/p>\n<p>At most one of <code>path<\/code> and <code>pathSegments<\/code> must be provided.\nLikewise, at most one of <code>query<\/code> and <code>queryParameters<\/code> must be provided.<\/p>\n<p>Each part that is not provided will default to the corresponding\nvalue from this <code>Uri<\/code> instead.<\/p>\n<p>This method is different from <a href=\"dart-core\/Uri\/resolve.html\">Uri.resolve<\/a> which overrides in a\nhierarchical manner,\nand can instead replace each part of a <code>Uri<\/code> individually.<\/p>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code>Uri uri1 = Uri.parse(\"a:\/\/b@c:4\/d\/e?f#g\");\nUri uri2 = uri1.replace(scheme: \"A\", path: \"D\/E\/E\", fragment: \"G\");\nprint(uri2);  \/\/ prints \"a:\/\/b@c:4\/D\/E\/E?f#G\"\n<\/code><\/pre>\n<p>This method acts similarly to using the <code>new Uri<\/code> constructor with\nsome of the arguments taken from this <code>Uri<\/code>. Example:<\/p>\n<pre class=\"language-dart\"><code>Uri uri3 = new Uri(\n    scheme: \"A\",\n    userInfo: uri1.userInfo,\n    host: uri1.host,\n    port: uri1.port,\n    path: \"D\/E\/E\",\n    query: uri1.query,\n    fragment: \"G\");\nprint(uri3);  \/\/ prints \"a:\/\/b@c:4\/D\/E\/E?f#G\"\nprint(uri2 == uri3);  \/\/ prints true.\n<\/code><\/pre>\n<p>Using this method can be seen as a shorthand for the <code>Uri<\/code> constructor\ncall above, but may also be slightly faster because the parts taken\nfrom this <code>Uri<\/code> need not be checked for validity again.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "scheme",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "userInfo",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "host",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "port",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "path",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "pathSegments",
                    "type": "dart:core.Iterable<dart:core.String>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Iterable",
                        "dart:core.String"
                    ]
                },
                {
                    "name": "query",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "queryParameters",
                    "type": "dart:core.Map<dart:core.String>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.Map",
                        "dart:core.String"
                    ]
                },
                {
                    "name": "fragment",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/replace.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Uri replace(\n    {String scheme,\n    String userInfo,\n    String host,\n    int port,\n    String path,\n    Iterable&lt;String&gt; pathSegments,\n    String query,\n    Map&lt;String, dynamic \/*String|Iterable&lt;String&gt;*\/ &gt; queryParameters,\n    String fragment});<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "resolve",
            "type": "dart:core.Uri",
            "desc": "<p>Resolve <code>reference<\/code> as an URI relative to <code>this<\/code>.<\/p>\n<p>First turn <code>reference<\/code> into a URI using <a href=\"dart-core\/Uri\/parse.html\">Uri.parse<\/a>. Then resolve the\nresulting URI relative to <code>this<\/code>.<\/p>\n<p>Returns the resolved URI.<\/p>\n<p>See <a href=\"dart-core\/Uri\/resolveUri.html\">resolveUri<\/a> for details.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "reference",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/resolve.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Uri resolve(String reference);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "resolveUri",
            "type": "dart:core.Uri",
            "desc": "<p>Resolve <code>reference<\/code> as an URI relative to <code>this<\/code>.<\/p>\n<p>Returns the resolved URI.<\/p>\n<p>The algorithm \"Transform Reference\" for resolving a reference is described\nin <a href=\"http:\/\/tools.ietf.org\/html\/rfc3986#section-5\" title=\"RFC-1123\">RFC-3986 Section 5<\/a>.<\/p>\n<p>Updated to handle the case where the base URI is just a relative path -\nthat is: when it has no scheme and no authority and the path does not start\nwith a slash.\nIn that case, the paths are combined without removing leading \"..\", and\nan empty path is not converted to \"\/\".<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "reference",
                    "type": "dart:core.Uri",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/resolveUri.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Uri resolveUri(Uri reference);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "splitQueryString",
            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
            "desc": "<p>Returns the <code>query<\/code> split into a map according to the rules\nspecified for FORM post in the <a href=\"http:\/\/www.w3.org\/TR\/REC-html40\/interact\/forms.html#h-17.13.4\" title=\"HTML 4.01 section 17.13.4\">HTML 4.01 specification section\n17.13.4<\/a>.\nEach key and value in the returned map has been decoded. If the <code>query<\/code>\nis the empty string an empty map is returned.<\/p>\n<p>Keys in the query string that have no value are mapped to the\nempty string.<\/p>\n<p>Each query component will be decoded using <code>encoding<\/code>. The default encoding\nis UTF-8.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "query",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "encoding",
                    "type": "dart:convert.Encoding",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/splitQueryString.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Map&lt;String, String&gt; splitQueryString(String query,\n    {Encoding encoding: utf8}) {\n  return query.split(\"&amp;\").fold({}, (map, element) {\n    int index = element.indexOf(\"=\");\n    if (index == -1) {\n      if (element != \"\") {\n        map[decodeQueryComponent(element, encoding: encoding)] = \"\";\n      }\n    } else if (index != 0) {\n      var key = element.substring(0, index);\n      var value = element.substring(index + 1);\n      map[decodeQueryComponent(key, encoding: encoding)] =\n          decodeQueryComponent(value, encoding: encoding);\n    }\n    return map;\n  });\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": [
                "dart:core.Map",
                "dart:core.String",
                "dart:core.String"
            ]
        },
        {
            "name": "toFilePath",
            "type": "dart:core.String",
            "desc": "<p>Returns the file path from a file URI.<\/p>\n<p>The returned path has either Windows or non-Windows\nsemantics.<\/p>\n<p>For non-Windows semantics the slash (\"\/\") is used to separate\npath segments.<\/p>\n<p>For Windows semantics the backslash (\"\\\") separator is used to\nseparate path segments.<\/p>\n<p>If the URI is absolute the path starts with a path separator\nunless Windows semantics is used and the first path segment is a\ndrive letter. When Windows semantics is used a host component in\nthe uri in interpreted as a file server and a UNC path is\nreturned.<\/p>\n<p>The default for whether to use Windows or non-Windows semantics\ndetermined from the platform Dart is running on. When running in\nthe standalone VM this is detected by the VM based on the\noperating system. When running in a browser non-Windows semantics\nis always used.<\/p>\n<p>To override the automatic detection of which semantics to use pass\na value for <code>windows<\/code>. Passing <code>true<\/code> will use Windows\nsemantics and passing <code>false<\/code> will use non-Windows semantics.<\/p>\n<p>If the URI ends with a slash (i.e. the last path component is\nempty) the returned file path will also end with a slash.<\/p>\n<p>With Windows semantics URIs starting with a drive letter cannot\nbe relative to the current drive on the designated drive. That is\nfor the URI <code>file:\/\/\/c:abc<\/code> calling <code>toFilePath<\/code> will throw as a\npath segment cannot contain colon on Windows.<\/p>\n<p>Examples using non-Windows semantics (resulting of calling\ntoFilePath in comment):<\/p>\n<pre class=\"language-dart\"><code>Uri.parse(\"xxx\/yyy\");  \/\/ xxx\/yyy\nUri.parse(\"xxx\/yyy\/\");  \/\/ xxx\/yyy\/\nUri.parse(\"file:\/\/\/xxx\/yyy\");  \/\/ \/xxx\/yyy\nUri.parse(\"file:\/\/\/xxx\/yyy\/\");  \/\/ \/xxx\/yyy\/\nUri.parse(\"file:\/\/\/C:\");  \/\/ \/C:\nUri.parse(\"file:\/\/\/C:a\");  \/\/ \/C:a\n<\/code><\/pre>\n<p>Examples using Windows semantics (resulting URI in comment):<\/p>\n<pre class=\"language-dart\"><code>Uri.parse(\"xxx\/yyy\");  \/\/ xxx\\yyy\nUri.parse(\"xxx\/yyy\/\");  \/\/ xxx\\yyy\\\nUri.parse(\"file:\/\/\/xxx\/yyy\");  \/\/ \\xxx\\yyy\nUri.parse(\"file:\/\/\/xxx\/yyy\/\");  \/\/ \\xxx\\yyy\\\nUri.parse(\"file:\/\/\/C:\/xxx\/yyy\");  \/\/ C:\\xxx\\yyy\nUri.parse(\"file:C:xxx\/yyy\");  \/\/ Throws as a path segment\n                              \/\/ cannot contain colon on Windows.\nUri.parse(\"file:\/\/server\/share\/file\");  \/\/ \\\\server\\share\\file\n<\/code><\/pre>\n<p>If the URI is not a file URI calling this throws\n<a href=\"dart-core\/UnsupportedError-class.html\">UnsupportedError<\/a>.<\/p>\n<p>If the URI cannot be converted to a file path calling this throws\n<a href=\"dart-core\/UnsupportedError-class.html\">UnsupportedError<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "windows",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/toFilePath.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">\/\/ TODO(lrn): Deprecate and move functionality to File class or similar.\n\/\/ The core libraries should not worry about the platform.\nString toFilePath({bool windows});<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "toString",
            "type": "dart:core.String",
            "desc": "<p>Returns the normalized string representation of the URI.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "dart-core\/Uri\/toString.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">String toString();<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "tryParse",
            "type": "dart:core.Uri",
            "desc": "<p>Creates a new <code>Uri<\/code> object by parsing a URI string.<\/p>\n<p>If <code>start<\/code> and <code>end<\/code> are provided, they must specify a valid substring\nof <code>uri<\/code>, and only the substring from <code>start<\/code> to <code>end<\/code> is parsed as a URI.\nThe <code>uri<\/code> must not be <code>null<\/code>.<\/p>\n<p>Returns <code>null<\/code> if the <code>uri<\/code> string is not valid as a URI or URI reference.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:core.Uri",
            "sig": "",
            "params": [
                {
                    "name": "uri",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "start",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "end",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "dart-core\/Uri\/tryParse.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Uri tryParse(String uri, [int start = 0, int end]) {\n  \/\/ TODO: Optimize to avoid throwing-and-recatching.\n  try {\n    return parse(uri, start, end);\n  } on FormatException {\n    return null;\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        }
    ],
    "props": [
        {
            "name": "authority",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the authority component.<\/p>\n<p>The authority is formatted from the <a href=\"dart-core\/Uri\/userInfo.html\">userInfo<\/a>, <a href=\"dart-core\/Uri\/host.html\">host<\/a> and <a href=\"dart-core\/Uri\/port.html\">port<\/a>\nparts.<\/p>\n<p>Returns the empty string if there is no authority component.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/authority.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get authority;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "base",
            "type": "dart:core.Uri",
            "types": [],
            "desc": "<p>Returns the natural base URI for the current platform.<\/p>\n<p>When running in a browser this is the current URL of the current page\n(from <code>window.location.href<\/code>).<\/p>\n<p>When not running in a browser this is the file URI referencing\nthe current working directory.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/base.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">external static Uri get base;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "data",
            "type": "dart:core.UriData",
            "types": [],
            "desc": "<p>Access the structure of a <code>data:<\/code> URI.<\/p>\n<p>Returns a <a href=\"dart-core\/UriData-class.html\">UriData<\/a> object for <code>data:<\/code> URIs and <code>null<\/code> for all other\nURIs.\nThe <a href=\"dart-core\/UriData-class.html\">UriData<\/a> object can be used to access the media type and data\nof a <code>data:<\/code> URI.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/data.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">UriData get data;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "fragment",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the fragment identifier component.<\/p>\n<p>Returns the empty string if there is no fragment identifier\ncomponent.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/fragment.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get fragment;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasAbsolutePath",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has an absolute path (starting with '\/').<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasAbsolutePath.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasAbsolutePath;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasAuthority",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has an <a href=\"dart-core\/Uri\/authority.html\">authority<\/a> component.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasAuthority.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasAuthority;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasEmptyPath",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has an empty path.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasEmptyPath.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasEmptyPath;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasFragment",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has a fragment part.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasFragment.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasFragment;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasPort",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has an explicit port.<\/p>\n<p>If the port number is the default port number\n(zero for unrecognized schemes, with http (80) and https (443) being\nrecognized),\nthen the port is made implicit and omitted from the URI.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasPort.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasPort;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasQuery",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has a query part.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasQuery.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasQuery;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasScheme",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI has a <a href=\"dart-core\/Uri\/scheme.html\">scheme<\/a> component.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hasScheme.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasScheme =&gt; scheme.isNotEmpty;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hashCode",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>Returns a hash code computed as <code>toString().hashCode<\/code>.<\/p>\n<p>This guarantees that URIs with the same normalized<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/hashCode.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get hashCode;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "host",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the host part of the authority component.<\/p>\n<p>Returns the empty string if there is no authority component and\nhence no host.<\/p>\n<p>If the host is an IP version 6 address, the surrounding <code>[<\/code> and <code>]<\/code> is\nremoved.<\/p>\n<p>The host string is case-insensitive.\nThe returned host name is canonicalized to lower-case\nwith upper-case percent-escapes.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/host.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get host;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "isAbsolute",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the URI is absolute.<\/p>\n<p>A URI is an absolute URI in the sense of RFC 3986 if it has a scheme\nand no fragment.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/isAbsolute.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isAbsolute;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "origin",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the origin of the URI in the form scheme:\/\/host:port for the\nschemes http and https.<\/p>\n<p>It is an error if the scheme is not \"http\" or \"https\", or if the host name\nis missing or empty.<\/p>\n<p>See: <a href=\"http:\/\/www.w3.org\/TR\/2011\/WD-html5-20110405\/origin-0.html#origin\">http:\/\/www.w3.org\/TR\/2011\/WD-html5-20110405\/origin-0.html#origin<\/a><\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/origin.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get origin;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "path",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the path component.<\/p>\n<p>The returned path is encoded. To get direct access to the decoded\npath use <a href=\"dart-core\/Uri\/pathSegments.html\">pathSegments<\/a>.<\/p>\n<p>Returns the empty string if there is no path component.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/path.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get path;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "pathSegments",
            "type": "dart:core.List<dart:core.String>",
            "types": [
                "dart:core.List",
                "dart:core.String"
            ],
            "desc": "<p>Returns the URI path split into its segments. Each of the segments in the\nreturned list have been decoded. If the path is empty the empty list will\nbe returned. A leading slash <code>\/<\/code> does not affect the segments returned.<\/p>\n<p>The returned list is unmodifiable and will throw <a href=\"dart-core\/UnsupportedError-class.html\">UnsupportedError<\/a> on any\ncalls that would mutate it.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/pathSegments.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">List&lt;String&gt; get pathSegments;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "port",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>Returns the port part of the authority component.<\/p>\n<p>Returns the default port if there is no port number in the authority\ncomponent. That's 80 for http, 443 for https, and 0 for everything else.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/port.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get port;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "query",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the query component. The returned query is encoded. To get\ndirect access to the decoded query use <a href=\"dart-core\/Uri\/queryParameters.html\">queryParameters<\/a>.<\/p>\n<p>Returns the empty string if there is no query component.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/query.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get query;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "queryParameters",
            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
            "types": [
                "dart:core.Map",
                "dart:core.String",
                "dart:core.String"
            ],
            "desc": "<p>Returns the URI query split into a map according to the rules\nspecified for FORM post in the <a href=\"http:\/\/www.w3.org\/TR\/REC-html40\/interact\/forms.html#h-17.13.4\" title=\"HTML 4.01 section 17.13.4\">HTML 4.01 specification section\n17.13.4<\/a>.\nEach key and value in the returned map has been decoded.\nIf there is no query the empty map is returned.<\/p>\n<p>Keys in the query string that have no value are mapped to the\nempty string.\nIf a key occurs more than once in the query string, it is mapped to\nan arbitrary choice of possible value.\nThe <a href=\"dart-core\/Uri\/queryParametersAll.html\">queryParametersAll<\/a> getter can provide a map\nthat maps keys to all of their values.<\/p>\n<p>The returned map is unmodifiable.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/queryParameters.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Map&lt;String, String&gt; get queryParameters;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "queryParametersAll",
            "type": "dart:core.Map<dart:core.String<dart:core.List<dart:core.String>>>",
            "types": [
                "dart:core.Map",
                "dart:core.String",
                "dart:core.List",
                "dart:core.String"
            ],
            "desc": "<p>Returns the URI query split into a map according to the rules\nspecified for FORM post in the <a href=\"http:\/\/www.w3.org\/TR\/REC-html40\/interact\/forms.html#h-17.13.4\" title=\"HTML 4.01 section 17.13.4\">HTML 4.01 specification section\n17.13.4<\/a>.\nEach key and value in the returned map has been decoded. If there is no\nquery the empty map is returned.<\/p>\n<p>Keys are mapped to lists of their values. If a key occurs only once,\nits value is a singleton list. If a key occurs with no value, the\nempty string is used as the value for that occurrence.<\/p>\n<p>The returned map and the lists it contains are unmodifiable.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/queryParametersAll.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Map&lt;String, List&lt;String&gt;&gt; get queryParametersAll;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "scheme",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>The scheme component of the URI.<\/p>\n<p>Returns the empty string if there is no scheme component.<\/p>\n<p>A URI scheme is case insensitive.\nThe returned scheme is canonicalized to lowercase letters.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/scheme.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get scheme;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "userInfo",
            "type": "dart:core.String",
            "types": [],
            "desc": "<p>Returns the user info part of the authority component.<\/p>\n<p>Returns the empty string if there is no user info in the\nauthority component.<\/p>\n        ",
            "memberOf": "dart:core.Uri",
            "isConstant": false,
            "href": "dart-core\/Uri\/userInfo.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get userInfo;<\/code><\/pre>\n        ",
            "isDeprecated": false
        }
    ],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": true,
    "implementors": [],
    "realImplementors": [],
    "cn": [],
    "href": "dart-core\/Uri-class.html",
    "desc": "<p>A parsed URI, such as a URL.<\/p>\n<p><strong>See also:<\/strong><\/p>\n<ul>\n<li>\n<a href=\"https:\/\/www.dartlang.org\/docs\/dart-up-and-running\/ch03.html#uris\">URIs<\/a> in the <a href=\"https:\/\/www.dartlang.org\/docs\/dart-up-and-running\/contents\/ch03.html\">library tour<\/a>\n<\/li>\n<li><a href=\"http:\/\/tools.ietf.org\/html\/rfc3986\">RFC-3986<\/a><\/li>\n<\/ul>",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "Uri"
}