{
    "name": "rendering.RenderViewport",
    "extends": [
        "rendering.SliverPhysicalContainerParentData",
        "rendering.RenderViewportBase",
        "rendering.RenderBox",
        "rendering.RenderObject",
        "foundation.AbstractNode",
        "dart:core.Object"
    ],
    "memberOf": "rendering",
    "events": [],
    "methods": [
        {
            "name": "RenderViewport",
            "type": "",
            "desc": "<p>Creates a viewport for <a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a> objects.<\/p>\n<p>If the <code>center<\/code> is not specified, then the first child in the <code>children<\/code>\nlist, if any, is used.<\/p>\n<p>The <code>offset<\/code> must be specified. For testing purposes, consider passing a\n<a href=\"rendering\/ViewportOffset\/ViewportOffset.zero.html\">new ViewportOffset.zero<\/a> or <a href=\"rendering\/ViewportOffset\/ViewportOffset.fixed.html\">new ViewportOffset.fixed<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "axisDirection",
                    "type": "painting.AxisDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "crossAxisDirection",
                    "type": "painting.AxisDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "offset",
                    "type": "rendering.ViewportOffset",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "anchor",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "children",
                    "type": "dart:core.List<rendering.RenderSliver>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.List",
                        "rendering.RenderSliver"
                    ]
                },
                {
                    "name": "center",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "cacheExtent",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "rendering\/RenderViewport\/RenderViewport.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RenderViewport({\n  AxisDirection axisDirection = AxisDirection.down,\n  @required AxisDirection crossAxisDirection,\n  @required ViewportOffset offset,\n  double anchor = 0.0,\n  List&lt;RenderSliver&gt; children,\n  RenderSliver center,\n  double cacheExtent,\n}) : assert(anchor != null),\n     assert(anchor &gt;= 0.0 &amp;&amp; anchor &lt;= 1.0),\n     _anchor = anchor,\n     _center = center,\n     super(axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, offset: offset, cacheExtent: cacheExtent) {\n  addAll(children);\n  if (center == null &amp;&amp; firstChild != null)\n    _center = firstChild;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "applyPaintTransform",
            "type": "",
            "desc": "<p>Multiply the transform from the parent's coordinate system to this box's\ncoordinate system into the given transform.<\/p>\n<p>This function is used to convert coordinate systems between boxes.\nSubclasses that apply transforms during painting should override this\nfunction to factor those transforms into the calculation.<\/p>\n<p>The <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> implementation takes care of adjusting the matrix for the\nposition of the given child as determined during layout and stored on the\nchild's <a href=\"rendering\/RenderObject\/parentData.html\">parentData<\/a> in the <a href=\"rendering\/RenderViewportBase\/offset.html\">BoxParentData.offset<\/a> field.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderObject",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "transform",
                    "type": "vector_math_64.Matrix4",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/applyPaintTransform.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid applyPaintTransform(RenderObject child, Matrix4 transform) {\n  assert(child != null);\n  final SliverPhysicalParentData childParentData = child.parentData;\n  childParentData.applyPaintTransform(transform);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "computeChildMainAxisPosition",
            "type": "dart:core.double",
            "desc": "<p>Converts the <code>parentMainAxisPosition<\/code> into the child's coordinate system.<\/p>\n<p>The <code>parentMainAxisPosition<\/code> is a distance from the top edge (for vertical\nviewports) or left edge (for horizontal viewports) of the viewport bounds.\nThis describes a line, perpendicular to the viewport's main axis, heretofor\nknown as the target line.<\/p>\n<p>The child's coordinate system's origin in the main axis is at the leading\nedge of the given child, as given by the child's\n<a href=\"rendering\/RenderViewportBase\/axisDirection.html\">SliverConstraints.axisDirection<\/a> and <a href=\"rendering\/SliverConstraints\/growthDirection.html\">SliverConstraints.growthDirection<\/a>.<\/p>\n<p>This method returns the distance from the leading edge of the given child to\nthe target line described above.<\/p>\n<p>(The <code>parentMainAxisPosition<\/code> is not from the leading edge of the\nviewport, it's always the top or left edge.)<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "parentMainAxisPosition",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/computeChildMainAxisPosition.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeChildMainAxisPosition(RenderSliver child, double parentMainAxisPosition) {\n  assert(child != null);\n  assert(child.constraints != null);\n  final SliverPhysicalParentData childParentData = child.parentData;\n  switch (applyGrowthDirectionToAxisDirection(child.constraints.axisDirection, child.constraints.growthDirection)) {\n    case AxisDirection.down:\n      return parentMainAxisPosition - childParentData.paintOffset.dy;\n    case AxisDirection.right:\n      return parentMainAxisPosition - childParentData.paintOffset.dx;\n    case AxisDirection.up:\n      return child.geometry.paintExtent - (parentMainAxisPosition - childParentData.paintOffset.dy);\n    case AxisDirection.left:\n      return child.geometry.paintExtent - (parentMainAxisPosition - childParentData.paintOffset.dx);\n  }\n  return 0.0;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "debugFillProperties",
            "type": "",
            "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"rendering\/RenderViewport\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/DiagnosticableTreeMixin\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"rendering\/RenderObject\/toString.html\">toString<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "properties",
                    "type": "foundation.DiagnosticPropertiesBuilder",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/debugFillProperties.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.add(DoubleProperty('anchor', anchor));\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "labelForChild",
            "type": "dart:core.String",
            "desc": "<p>A short string to identify the child with the given index.<\/p>\n<p>Used by <a href=\"rendering\/RenderViewportBase\/debugDescribeChildren.html\">debugDescribeChildren<\/a> to label the children.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "index",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/labelForChild.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString labelForChild(int index) {\n  if (index == 0)\n    return 'center child';\n  return 'child $index';\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "maxScrollObstructionExtentBefore",
            "type": "dart:core.double",
            "desc": "<p>Returns the total scroll obstruction extent of all slivers in the viewport\nbefore <code>child<\/code>.<\/p>\n<p>This is the extent by which the actual area in which content can scroll\nis reduced. For example, an app bar that is pinned at the top will reduce\nthe area in which content can actually scroll by the height of the app bar.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/maxScrollObstructionExtentBefore.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble maxScrollObstructionExtentBefore(RenderSliver child) {\n  assert(child.parent == this);\n  final GrowthDirection growthDirection = child.constraints.growthDirection;\n  assert(growthDirection != null);\n  switch (growthDirection) {\n    case GrowthDirection.forward:\n      double pinnedExtent = 0.0;\n      RenderSliver current = center;\n      while (current != child) {\n        pinnedExtent += current.geometry.maxScrollObstructionExtent;\n        current = childAfter(current);\n      }\n      return pinnedExtent;\n    case GrowthDirection.reverse:\n      double pinnedExtent = 0.0;\n      RenderSliver current = childBefore(center);\n      while (current != child) {\n        pinnedExtent += current.geometry.maxScrollObstructionExtent;\n        current = childBefore(current);\n      }\n      return pinnedExtent;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "paintOffsetOf",
            "type": "dart:ui.Offset",
            "desc": "<p>The offset at which the given <code>child<\/code> should be painted.<\/p>\n<p>The returned offset is from the top left corner of the inside of the\nviewport to the top left corner of the paint coordinate system of the\n<code>child<\/code>.<\/p>\n<p>See also <a href=\"rendering\/RenderViewportBase\/computeAbsolutePaintOffset.html\">computeAbsolutePaintOffset<\/a>, which computes the paint offset\nfrom an explicit layout offset and growth direction instead of using the\nvalues computed for the child during layout.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/paintOffsetOf.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nOffset paintOffsetOf(RenderSliver child) {\n  final SliverPhysicalParentData childParentData = child.parentData;\n  return childParentData.paintOffset;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "performLayout",
            "type": "",
            "desc": "<p>Do the work of computing the layout for this render object.<\/p>\n<p>Do not call this function directly: call <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> instead. This function\nis called by <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> when there is actually work to be done by this\nrender object during layout. The layout constraints provided by your\nparent are available via the <a href=\"rendering\/RenderBox\/constraints.html\">constraints<\/a> getter.<\/p>\n<p>If <a href=\"rendering\/RenderViewport\/sizedByParent.html\">sizedByParent<\/a> is true, then this function should not actually change\nthe dimensions of this render object. Instead, that work should be done by\n<a href=\"rendering\/RenderViewport\/performResize.html\">performResize<\/a>. If <a href=\"rendering\/RenderViewport\/sizedByParent.html\">sizedByParent<\/a> is false, then this function should\nboth change the dimensions of this render object and instruct its children\nto layout.<\/p>\n<p>In implementing this function, you must call <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> on each of your\nchildren, passing true for parentUsesSize if your layout information is\ndependent on your child's layout information. Passing true for\nparentUsesSize ensures that this render object will undergo layout if the\nchild undergoes layout. Otherwise, the child can change its layout\ninformation without informing this render object.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/performLayout.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid performLayout() {\n  if (center == null) {\n    assert(firstChild == null);\n    _minScrollExtent = 0.0;\n    _maxScrollExtent = 0.0;\n    _hasVisualOverflow = false;\n    offset.applyContentDimensions(0.0, 0.0);\n    return;\n  }\n  assert(center.parent == this);\n\n  double mainAxisExtent;\n  double crossAxisExtent;\n  switch (axis) {\n    case Axis.vertical:\n      mainAxisExtent = size.height;\n      crossAxisExtent = size.width;\n      break;\n    case Axis.horizontal:\n      mainAxisExtent = size.width;\n      crossAxisExtent = size.height;\n      break;\n  }\n\n  final double centerOffsetAdjustment = center.centerOffsetAdjustment;\n\n  double correction;\n  int count = 0;\n  do {\n    assert(offset.pixels != null);\n    correction = _attemptLayout(mainAxisExtent, crossAxisExtent, offset.pixels + centerOffsetAdjustment);\n    if (correction != 0.0) {\n      offset.correctBy(correction);\n    } else {\n      if (offset.applyContentDimensions(\n            math.min(0.0, _minScrollExtent + mainAxisExtent * anchor),\n            math.max(0.0, _maxScrollExtent - mainAxisExtent * (1.0 - anchor)),\n         ))\n        break;\n    }\n    count += 1;\n  } while (count &lt; _maxLayoutCycles);\n  assert(() {\n    if (count &gt;= _maxLayoutCycles) {\n      assert(count != 1);\n      throw FlutterError(\n        'A RenderViewport exceeded its maximum number of layout cycles.\\n'\n        'RenderViewport render objects, during layout, can retry if either their '\n        'slivers or their ViewportOffset decide that the offset should be corrected '\n        'to take into account information collected during that layout.\\n'\n        'In the case of this RenderViewport object, however, this happened $count '\n        'times and still there was no consensus on the scroll offset. This usually '\n        'indicates a bug. Specifically, it means that one of the following three '\n        'problems is being experienced by the RenderViewport object:\\n'\n        ' * One of the RenderSliver children or the ViewportOffset have a bug such'\n        ' that they always think that they need to correct the offset regardless.\\n'\n        ' * Some combination of the RenderSliver children and the ViewportOffset'\n        ' have a bad interaction such that one applies a correction then another'\n        ' applies a reverse correction, leading to an infinite loop of corrections.\\n'\n        ' * There is a pathological case that would eventually resolve, but it is'\n        ' so complicated that it cannot be resolved in any reasonable number of'\n        ' layout passes.'\n      );\n    }\n    return true;\n  }());\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "performResize",
            "type": "",
            "desc": "<p>Updates the render objects size using only the constraints.<\/p>\n<p>Do not call this function directly: call <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> instead. This function\nis called by <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> when there is actually work to be done by this\nrender object during layout. The layout constraints provided by your\nparent are available via the <a href=\"rendering\/RenderBox\/constraints.html\">constraints<\/a> getter.<\/p>\n<p>Subclasses that set <a href=\"rendering\/RenderViewport\/sizedByParent.html\">sizedByParent<\/a> to true should override this method\nto compute their size.<\/p>\n<p>This function is called only if <a href=\"rendering\/RenderViewport\/sizedByParent.html\">sizedByParent<\/a> is true.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/performResize.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid performResize() {\n  assert(() {\n    if (!constraints.hasBoundedHeight || !constraints.hasBoundedWidth) {\n      switch (axis) {\n        case Axis.vertical:\n          if (!constraints.hasBoundedHeight) {\n            throw FlutterError(\n              'Vertical viewport was given unbounded height.\\n'\n              'Viewports expand in the scrolling direction to fill their container.'\n              'In this case, a vertical viewport was given an unlimited amount of '\n              'vertical space in which to expand. This situation typically happens '\n              'when a scrollable widget is nested inside another scrollable widget.\\n'\n              'If this widget is always nested in a scrollable widget there '\n              'is no need to use a viewport because there will always be enough '\n              'vertical space for the children. In this case, consider using a '\n              'Column instead. Otherwise, consider using the \"shrinkWrap\" property '\n              '(or a ShrinkWrappingViewport) to size the height of the viewport '\n              'to the sum of the heights of its children.'\n            );\n          }\n          if (!constraints.hasBoundedWidth) {\n            throw FlutterError(\n              'Vertical viewport was given unbounded width.\\n'\n              'Viewports expand in the cross axis to fill their container and '\n              'constrain their children to match their extent in the cross axis. '\n              'In this case, a vertical viewport was given an unlimited amount of '\n              'horizontal space in which to expand.'\n            );\n          }\n          break;\n        case Axis.horizontal:\n          if (!constraints.hasBoundedWidth) {\n            throw FlutterError(\n              'Horizontal viewport was given unbounded width.\\n'\n              'Viewports expand in the scrolling direction to fill their container.'\n              'In this case, a horizontal viewport was given an unlimited amount of '\n              'horizontal space in which to expand. This situation typically happens '\n              'when a scrollable widget is nested inside another scrollable widget.\\n'\n              'If this widget is always nested in a scrollable widget there '\n              'is no need to use a viewport because there will always be enough '\n              'horizontal space for the children. In this case, consider using a '\n              'Row instead. Otherwise, consider using the \"shrinkWrap\" property '\n              '(or a ShrinkWrappingViewport) to size the width of the viewport '\n              'to the sum of the widths of its children.'\n            );\n          }\n          if (!constraints.hasBoundedHeight) {\n            throw FlutterError(\n              'Horizontal viewport was given unbounded height.\\n'\n              'Viewports expand in the cross axis to fill their container and '\n              'constrain their children to match their extent in the cross axis. '\n              'In this case, a horizontal viewport was given an unlimited amount of '\n              'vertical space in which to expand.'\n            );\n          }\n          break;\n      }\n    }\n    return true;\n  }());\n  size = constraints.biggest;\n  \/\/ We ignore the return value of applyViewportDimension below because we are\n  \/\/ going to go through performLayout next regardless.\n  switch (axis) {\n    case Axis.vertical:\n      offset.applyViewportDimension(size.height);\n      break;\n    case Axis.horizontal:\n      offset.applyViewportDimension(size.width);\n      break;\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "scrollOffsetOf",
            "type": "dart:core.double",
            "desc": "<p>Returns the scroll offset within the viewport for the given\n<code>scrollOffsetWithinChild<\/code> within the given <code>child<\/code>.<\/p>\n<p>The returned value is an estimate that assumes the slivers within the\nviewport do not change the layout extent in response to changes in their\nscroll offset.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "scrollOffsetWithinChild",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/scrollOffsetOf.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble scrollOffsetOf(RenderSliver child, double scrollOffsetWithinChild) {\n  assert(child.parent == this);\n  final GrowthDirection growthDirection = child.constraints.growthDirection;\n  assert(growthDirection != null);\n  switch (growthDirection) {\n    case GrowthDirection.forward:\n      double scrollOffsetToChild = 0.0;\n      RenderSliver current = center;\n      while (current != child) {\n        scrollOffsetToChild += current.geometry.scrollExtent;\n        current = childAfter(current);\n      }\n      return scrollOffsetToChild + scrollOffsetWithinChild;\n    case GrowthDirection.reverse:\n      double scrollOffsetToChild = 0.0;\n      RenderSliver current = childBefore(center);\n      while (current != child) {\n        scrollOffsetToChild -= current.geometry.scrollExtent;\n        current = childBefore(current);\n      }\n      return scrollOffsetToChild - scrollOffsetWithinChild;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "setupParentData",
            "type": "",
            "desc": "<p>Override to setup parent data correctly for your children.<\/p>\n<p>You can call this function to set up the parent data for child before the\nchild is added to the parent's child list.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderObject",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/setupParentData.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid setupParentData(RenderObject child) {\n  if (child.parentData is! SliverPhysicalContainerParentData)\n    child.parentData = SliverPhysicalContainerParentData();\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "updateChildLayoutOffset",
            "type": "",
            "desc": "<p>Called during <a href=\"rendering\/RenderViewportBase\/layoutChildSequence.html\">layoutChildSequence<\/a> to store the layout offset for the\ngiven child.<\/p>\n<p>Different subclasses using different representations for their children's\nlayout offset (e.g., logical or physical coordinates). This function lets\nsubclasses transform the child's layout offset before storing it in the\nchild's parent data.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "layoutOffset",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "growthDirection",
                    "type": "rendering.GrowthDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/updateChildLayoutOffset.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid updateChildLayoutOffset(RenderSliver child, double layoutOffset, GrowthDirection growthDirection) {\n  final SliverPhysicalParentData childParentData = child.parentData;\n  childParentData.paintOffset = computeAbsolutePaintOffset(child, layoutOffset, growthDirection);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "updateOutOfBandData",
            "type": "",
            "desc": "<p>Called during <a href=\"rendering\/RenderViewportBase\/layoutChildSequence.html\">layoutChildSequence<\/a> for each child.<\/p>\n<p>Typically used by subclasses to update any out-of-band data, such as the\nmax scroll extent, for each child.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewport",
            "sig": "",
            "params": [
                {
                    "name": "growthDirection",
                    "type": "rendering.GrowthDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "childLayoutGeometry",
                    "type": "rendering.SliverGeometry",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewport\/updateOutOfBandData.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid updateOutOfBandData(GrowthDirection growthDirection, SliverGeometry childLayoutGeometry) {\n  switch (growthDirection) {\n    case GrowthDirection.forward:\n      _maxScrollExtent += childLayoutGeometry.scrollExtent;\n      break;\n    case GrowthDirection.reverse:\n      _minScrollExtent -= childLayoutGeometry.scrollExtent;\n      break;\n  }\n  if (childLayoutGeometry.hasVisualOverflow)\n    _hasVisualOverflow = true;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        }
    ],
    "props": [
        {
            "name": "anchor",
            "type": "dart:core.double",
            "types": [],
            "desc": "<p>The relative position of the zero scroll offset.<\/p>\n<p>For example, if <a href=\"rendering\/RenderViewport\/anchor.html\">anchor<\/a> is 0.5 and the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> is\n<a href=\"painting\/AxisDirection-class.html\">AxisDirection.down<\/a> or <a href=\"painting\/AxisDirection-class.html\">AxisDirection.up<\/a>, then the zero scroll offset is\nvertically centered within the viewport. If the <a href=\"rendering\/RenderViewport\/anchor.html\">anchor<\/a> is 1.0, and the\n<a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> is <a href=\"painting\/AxisDirection-class.html\">AxisDirection.right<\/a>, then the zero scroll offset is\non the left edge of the viewport.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/anchor.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get anchor =&gt; _anchor;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "center",
            "type": "rendering.RenderSliver",
            "types": [],
            "desc": "<p>The first child in the <a href=\"rendering\/GrowthDirection-class.html\">GrowthDirection.forward<\/a> growth direction.<\/p>\n<p>Children after <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> will be placed in the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> relative to\nthe <a href=\"rendering\/RenderViewport\/center.html\">center<\/a>. Children before <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> will be placed in the opposite of\nthe <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> relative to the <a href=\"rendering\/RenderViewport\/center.html\">center<\/a>.<\/p>\n<p>The <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> must be a child of the viewport.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/center.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RenderSliver get center =&gt; _center;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "childrenInHitTestOrder",
            "type": "dart:core.Iterable<rendering.RenderSliver>",
            "types": [
                "dart:core.Iterable",
                "rendering.RenderSliver"
            ],
            "desc": "<p>Provides an iterable that walks the children of the viewport, in the order\nthat hit-testing should use.<\/p>\n<p>This should be the reverse order of <a href=\"rendering\/RenderViewport\/childrenInPaintOrder.html\">childrenInPaintOrder<\/a>.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/childrenInHitTestOrder.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nIterable&lt;RenderSliver&gt; get childrenInHitTestOrder sync* {\n  if (firstChild == null)\n    return;\n  RenderSliver child = center;\n  while (child != null) {\n    yield child;\n    child = childAfter(child);\n  }\n  child = childBefore(center);\n  while (child != null) {\n    yield child;\n    child = childBefore(child);\n  }\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "childrenInPaintOrder",
            "type": "dart:core.Iterable<rendering.RenderSliver>",
            "types": [
                "dart:core.Iterable",
                "rendering.RenderSliver"
            ],
            "desc": "<p>Provides an iterable that walks the children of the viewport, in the order\nthat they should be painted.<\/p>\n<p>This should be the reverse order of <a href=\"rendering\/RenderViewport\/childrenInHitTestOrder.html\">childrenInHitTestOrder<\/a>.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/childrenInPaintOrder.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nIterable&lt;RenderSliver&gt; get childrenInPaintOrder sync* {\n  if (firstChild == null)\n    return;\n  RenderSliver child = firstChild;\n  while (child != center) {\n    yield child;\n    child = childAfter(child);\n  }\n  child = lastChild;\n  while (true) {\n    yield child;\n    if (child == center)\n      return;\n    child = childBefore(child);\n  }\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "type": "",
            "href": "rendering\/RenderViewport\/excludeFromScrolling-constant.html",
            "desc": "<p>When a top-level <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a> below a <a href=\"rendering\/RenderAbstractViewport-class.html\">RenderAbstractViewport<\/a> is\ntagged with <a href=\"rendering\/RenderViewport\/excludeFromScrolling-constant.html\">excludeFromScrolling<\/a> it will not be part of the scrolling\narea for semantic purposes.<\/p>\n<p>This behavior is only active if the <a href=\"rendering\/RenderAbstractViewport-class.html\">RenderAbstractViewport<\/a>\ntagged its <a href=\"semantics\/SemanticsConfiguration-class.html\">SemanticsConfiguration<\/a> with <a href=\"rendering\/RenderViewport\/useTwoPaneSemantics-constant.html\">useTwoPaneSemantics<\/a>.\nOtherwise, the <a href=\"rendering\/RenderViewport\/excludeFromScrolling-constant.html\">excludeFromScrolling<\/a> tag is ignored.<\/p>\n<p>As an example, a <a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a> that stays on the screen within a\n<a href=\"widgets\/Scrollable-class.html\">Scrollable<\/a> even though the user has scrolled past it (e.g. a pinned app\nbar) can tag its <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a> with <a href=\"rendering\/RenderViewport\/excludeFromScrolling-constant.html\">excludeFromScrolling<\/a> to indicate\nthat it should no longer be considered for semantic actions related to\nscrolling.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const SemanticsTag excludeFromScrolling = SemanticsTag('RenderViewport.excludeFromScrolling')\n\n<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "name": "excludeFromScrolling",
            "memberOf": "rendering.RenderViewport"
        },
        {
            "name": "hasVisualOverflow",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether the contents of this viewport would paint outside the bounds of\nthe viewport if <a href=\"rendering\/RenderViewportBase\/paint.html\">paint<\/a> did not clip.<\/p>\n<p>This property enables an optimization whereby <a href=\"rendering\/RenderViewportBase\/paint.html\">paint<\/a> can skip apply a\nclip of the contents of the viewport are known to paint entirely within\nthe bounds of the viewport.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/hasVisualOverflow.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get hasVisualOverflow =&gt; _hasVisualOverflow;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "indexOfFirstChild",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>The index of the first child of the viewport relative to the center child.<\/p>\n<p>For example, the center child has index zero and the first child in the\nreverse growth direction has index -1.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/indexOfFirstChild.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get indexOfFirstChild {\n  assert(center != null);\n  assert(center.parent == this);\n  assert(firstChild != null);\n  int count = 0;\n  RenderSliver child = center;\n  while (child != firstChild) {\n    count -= 1;\n    child = childBefore(child);\n  }\n  return count;\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "sizedByParent",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether the constraints are the only input to the sizing algorithm (in\nparticular, child nodes have no impact).<\/p>\n<p>Returning false is always correct, but returning true can be more\nefficient when computing the size of this render object because we don't\nneed to recompute the size if the constraints don't change.<\/p>\n<p>Typically, subclasses will always return the same value. If the value can\nchange, then, when it does change, the subclass should make sure to call\n<a href=\"rendering\/RenderObject\/markNeedsLayoutForSizedByParentChange.html\">markNeedsLayoutForSizedByParentChange<\/a>.<\/p>\n        ",
            "memberOf": "rendering.RenderViewport",
            "isConstant": false,
            "href": "rendering\/RenderViewport\/sizedByParent.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get sizedByParent =&gt; true;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "type": "",
            "href": "rendering\/RenderViewport\/useTwoPaneSemantics-constant.html",
            "desc": "<p>If a <a href=\"rendering\/RenderAbstractViewport-class.html\">RenderAbstractViewport<\/a> overrides\n<a href=\"rendering\/RenderViewportBase\/describeSemanticsConfiguration.html\">RenderObject.describeSemanticsConfiguration<\/a> to add the <a href=\"semantics\/SemanticsTag-class.html\">SemanticsTag<\/a>\n<a href=\"rendering\/RenderViewport\/useTwoPaneSemantics-constant.html\">useTwoPaneSemantics<\/a> to its <a href=\"semantics\/SemanticsConfiguration-class.html\">SemanticsConfiguration<\/a>, two semantics nodes\nwill be used to represent the viewport with its associated scrolling\nactions in the semantics tree.<\/p>\n<p>Two semantics nodes (an inner and an outer node) are necessary to exclude\ncertain child nodes (via the <a href=\"rendering\/RenderViewport\/excludeFromScrolling-constant.html\">excludeFromScrolling<\/a> tag) from the\nscrollable area for semantic purposes: The <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a>s of children\nthat should be excluded from scrolling will be attached to the outer node.\nThe semantic scrolling actions and the <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a>s of scrollable\nchildren will be attached to the inner node, which itself is a child of\nthe outer node.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const SemanticsTag useTwoPaneSemantics = SemanticsTag('RenderViewport.twoPane')\n\n<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "name": "useTwoPaneSemantics",
            "memberOf": "rendering.RenderViewport"
        }
    ],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": false,
    "implementors": [
        "widgets.RenderNestedScrollViewViewport"
    ],
    "realImplementors": [
        "widgets.RenderNestedScrollViewViewport"
    ],
    "cn": [],
    "href": "rendering\/RenderViewport-class.html",
    "desc": "<p>A render object that is bigger on the inside.<\/p>\n<p><a href=\"rendering\/RenderViewport-class.html\">RenderViewport<\/a> is the visual workhorse of the scrolling machinery. It\ndisplays a subset of its children according to its own dimensions and the\ngiven <a href=\"rendering\/RenderViewportBase\/offset.html\">offset<\/a>. As the offset varies, different children are visible through\nthe viewport.<\/p>\n<p><a href=\"rendering\/RenderViewport-class.html\">RenderViewport<\/a> hosts a bidirectional list of slivers, anchored on a\n<a href=\"rendering\/RenderViewport\/center.html\">center<\/a> sliver, which is placed at the zero scroll offset. The center\nwidget is displayed in the viewport according to the <a href=\"rendering\/RenderViewport\/anchor.html\">anchor<\/a> property.<\/p>\n<p>Slivers that are earlier in the child list than <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> are displayed in\nreverse order in the reverse <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> starting from the <a href=\"rendering\/RenderViewport\/center.html\">center<\/a>. For\nexample, if the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> is <a href=\"painting\/AxisDirection-class.html\">AxisDirection.down<\/a>, the first sliver\nbefore <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> is placed above the <a href=\"rendering\/RenderViewport\/center.html\">center<\/a>. The slivers that are later in\nthe child list than <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> are placed in order in the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a>. For\nexample, in the preceding scenario, the first sliver after <a href=\"rendering\/RenderViewport\/center.html\">center<\/a> is\nplaced below the <a href=\"rendering\/RenderViewport\/center.html\">center<\/a>.<\/p>\n<p><a href=\"rendering\/RenderViewport-class.html\">RenderViewport<\/a> cannot contain <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> children directly. Instead, use\na <a href=\"rendering\/RenderSliverList-class.html\">RenderSliverList<\/a>, <a href=\"rendering\/RenderSliverFixedExtentList-class.html\">RenderSliverFixedExtentList<\/a>, <a href=\"rendering\/RenderSliverGrid-class.html\">RenderSliverGrid<\/a>, or\na <a href=\"rendering\/RenderSliverToBoxAdapter-class.html\">RenderSliverToBoxAdapter<\/a>, for example.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a>, which explains more about the Sliver protocol.<\/li>\n<li>\n<a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>, which explains more about the Box protocol.<\/li>\n<li>\n<a href=\"rendering\/RenderSliverToBoxAdapter-class.html\">RenderSliverToBoxAdapter<\/a>, which allows a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> object to be\nplaced inside a <a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a> (the opposite of this class).<\/li>\n<li>\n<a href=\"rendering\/RenderShrinkWrappingViewport-class.html\">RenderShrinkWrappingViewport<\/a>, a variant of <a href=\"rendering\/RenderViewport-class.html\">RenderViewport<\/a> that\nshrink-wraps its contents along the main axis.<\/li>\n<\/ul>",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "RenderViewport"
}