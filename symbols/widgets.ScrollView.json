{
    "desc": "<p>A widget that scrolls.<\/p>\n<p>Scrollable widgets consist of three pieces:<\/p>\n<ol>\n<li>A <a href=\"widgets\/Scrollable-class.html\">Scrollable<\/a> widget, which listens for various user gestures and\nimplements the interaction design for scrolling.<\/li>\n<li>A viewport widget, such as <a href=\"widgets\/Viewport-class.html\">Viewport<\/a> or <a href=\"widgets\/ShrinkWrappingViewport-class.html\">ShrinkWrappingViewport<\/a>, which\nimplements the visual design for scrolling by displaying only a portion\nof the widgets inside the scroll view.<\/li>\n<li>One or more slivers, which are widgets that can be composed to created\nvarious scrolling effects, such as lists, grids, and expanding headers.<\/li>\n<\/ol>\n<p><a href=\"widgets\/ScrollView-class.html\">ScrollView<\/a> helps orchestrate these pieces by creating the <a href=\"widgets\/Scrollable-class.html\">Scrollable<\/a> and\nthe viewport and deferring to its subclass to create the slivers.<\/p>\n<p>To control the initial scroll offset of the scroll view, provide a\n<a href=\"widgets\/ScrollView\/controller.html\">controller<\/a> with its <a href=\"widgets\/ScrollController\/initialScrollOffset.html\">ScrollController.initialScrollOffset<\/a> property set.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/ListView-class.html\">ListView<\/a>, which is a commonly used <a href=\"widgets\/ScrollView-class.html\">ScrollView<\/a> that displays a\nscrolling, linear list of child widgets.<\/li>\n<li>\n<a href=\"widgets\/PageView-class.html\">PageView<\/a>, which is a scrolling list of child widgets that are each the\nsize of the viewport.<\/li>\n<li>\n<a href=\"widgets\/GridView-class.html\">GridView<\/a>, which is a <a href=\"widgets\/ScrollView-class.html\">ScrollView<\/a> that displays a scrolling, 2D array\nof child widgets.<\/li>\n<li>\n<a href=\"widgets\/CustomScrollView-class.html\">CustomScrollView<\/a>, which is a <a href=\"widgets\/ScrollView-class.html\">ScrollView<\/a> that creates custom scroll\neffects using slivers.<\/li>\n<li>\n<a href=\"widgets\/ScrollNotification-class.html\">ScrollNotification<\/a> and <a href=\"widgets\/NotificationListener-class.html\">NotificationListener<\/a>, which can be used to watch\nthe scroll position without using a <a href=\"widgets\/ScrollController-class.html\">ScrollController<\/a>.<\/li>\n<\/ul>",
    "dtype": "class",
    "example": "",
    "href": "widgets\/ScrollView-class.html",
    "isAbstract": true,
    "isConstant": "0",
    "isDeprecated": false,
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "widgets",
    "name": "widgets.ScrollView",
    "shortname": "ScrollView",
    "extends": [
        "widgets.StatelessWidget",
        "widgets.Widget",
        "foundation.DiagnosticableTree",
        "foundation.Diagnosticable",
        "dart:core.Object"
    ],
    "realImplementors": [
        "widgets.CustomScrollView",
        "widgets.GridView",
        "widgets.ListView"
    ],
    "events": [],
    "methods": [
        {
            "desc": "<p>Creates a widget that scrolls.<\/p>\n<p>If the <code>primary<\/code> argument is true, the <code>controller<\/code> must be null.<\/p>\n<p>If the <code>shrinkWrap<\/code> argument is true, the <code>center<\/code> argument must be null.<\/p>\n<p>The <code>scrollDirection<\/code>, <code>reverse<\/code>, and <code>shrinkWrap<\/code> arguments must not be null.<\/p>\n<p>The <code>anchor<\/code> argument must be non-null and in the range 0.0 to 1.0.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ScrollView({\n  Key key,\n  this.scrollDirection = Axis.vertical,\n  this.reverse = false,\n  this.controller,\n  bool primary,\n  ScrollPhysics physics,\n  this.shrinkWrap = false,\n  this.center,\n  this.anchor = 0.0,\n  this.cacheExtent,\n  this.semanticChildCount,\n  this.dragStartBehavior = DragStartBehavior.start,\n}) : assert(scrollDirection != null),\n     assert(reverse != null),\n     assert(shrinkWrap != null),\n     assert(dragStartBehavior != null),\n     assert(!(controller != null &amp;&amp; primary == true),\n         'Primary ScrollViews obtain their ScrollController via inheritance from a PrimaryScrollController widget. '\n         'You cannot both set primary to true and pass an explicit controller.'\n     ),\n     assert(!shrinkWrap || center == null),\n     assert(anchor != null),\n     assert(anchor &gt;= 0.0 &amp;&amp; anchor &lt;= 1.0),\n     primary = primary ?? controller == null &amp;&amp; identical(scrollDirection, Axis.vertical),\n     physics = physics ?? (primary == true || (primary == null &amp;&amp; controller == null &amp;&amp; identical(scrollDirection, Axis.vertical)) ? const AlwaysScrollableScrollPhysics() : null),\n     super(key: key);<\/code><\/pre>\n    ",
            "href": "widgets\/ScrollView\/ScrollView.html",
            "isDeprecated": "0",
            "type": "",
            "name": "ScrollView",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "widgets.ScrollView",
            "params": [
                {
                    "name": "anchor",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "cacheExtent",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "center",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "foundation.Key"
                },
                {
                    "name": "controller",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "widgets.ScrollController"
                },
                {
                    "name": "dragStartBehavior",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "gestures.DragStartBehavior"
                },
                {
                    "name": "key",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "foundation.Key"
                },
                {
                    "name": "physics",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "widgets.ScrollPhysics"
                },
                {
                    "name": "primary",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "dart:core.bool"
                },
                {
                    "name": "reverse",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "dart:core.bool"
                },
                {
                    "name": "scrollDirection",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "painting.Axis"
                },
                {
                    "name": "semanticChildCount",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "dart:core.int"
                },
                {
                    "name": "shrinkWrap",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "dart:core.bool"
                }
            ]
        },
        {
            "desc": "<p>Describes the part of the user interface represented by this widget.<\/p>\n<p>The framework calls this method when this widget is inserted into the\ntree in a given <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> and when the dependencies of this widget\nchange (e.g., an <a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a> referenced by this widget changes).<\/p>\n<p>The framework replaces the subtree below this widget with the widget\nreturned by this method, either by updating the existing subtree or by\nremoving the subtree and inflating a new subtree, depending on whether the\nwidget returned by this method can update the root of the existing\nsubtree, as determined by calling <a href=\"widgets\/Widget\/canUpdate.html\">Widget.canUpdate<\/a>.<\/p>\n<p>Typically implementations return a newly created constellation of widgets\nthat are configured with information from this widget's constructor and\nfrom the given <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>.<\/p>\n<p>The given <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> contains information about the location in the\ntree at which this widget is being built. For example, the context\nprovides the set of inherited widgets for this location in the tree. A\ngiven widget might be built with multiple different <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>\narguments over time if the widget is moved around the tree or if the\nwidget is inserted into the tree in multiple places at once.<\/p>\n<p>The implementation of this method must only depend on:<\/p>\n<ul>\n<li>the fields of the widget, which themselves must not change over time,\nand<\/li>\n<li>any ambient state obtained from the <code>context<\/code> using\n<a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a>.<\/li>\n<\/ul>\n<p>If a widget's <a href=\"widgets\/ScrollView\/build.html\">build<\/a> method is to depend on anything else, use a\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> instead.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/StatelessWidget-class.html\">StatelessWidget<\/a>, which contains the discussion on performance considerations.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nWidget build(BuildContext context) {\n  final List&lt;Widget&gt; slivers = buildSlivers(context);\n  final AxisDirection axisDirection = getDirection(context);\n\n  final ScrollController scrollController = primary\n    ? PrimaryScrollController.of(context)\n    : controller;\n  final Scrollable scrollable = Scrollable(\n    dragStartBehavior: dragStartBehavior,\n    axisDirection: axisDirection,\n    controller: scrollController,\n    physics: physics,\n    semanticChildCount: semanticChildCount,\n    viewportBuilder: (BuildContext context, ViewportOffset offset) {\n      return buildViewport(context, offset, axisDirection, slivers);\n    },\n  );\n  return primary &amp;&amp; scrollController != null\n    ? PrimaryScrollController.none(child: scrollable)\n    : scrollable;\n}<\/code><\/pre>\n    ",
            "href": "widgets\/ScrollView\/build.html",
            "isDeprecated": "0",
            "type": "widgets.Widget",
            "name": "build",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.ScrollView",
            "params": [
                {
                    "name": "context",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.BuildContext"
                }
            ]
        },
        {
            "desc": "<p>Build the list of widgets to place inside the viewport.<\/p>\n<p>Subclasses should override this method to build the slivers for the inside\nof the viewport.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nList&lt;Widget&gt; buildSlivers(BuildContext context);<\/code><\/pre>\n    ",
            "href": "widgets\/ScrollView\/buildSlivers.html",
            "isDeprecated": "0",
            "type": "dart:core.List<widgets.Widget>",
            "name": "buildSlivers",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.ScrollView",
            "params": [
                {
                    "name": "context",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.BuildContext"
                }
            ]
        },
        {
            "desc": "<p>Build the viewport.<\/p>\n<p>Subclasses may override this method to change how the viewport is built.\nThe default implementation uses a <a href=\"widgets\/ShrinkWrappingViewport-class.html\">ShrinkWrappingViewport<\/a> if <a href=\"widgets\/ScrollView\/shrinkWrap.html\">shrinkWrap<\/a>\nis true, and a regular <a href=\"widgets\/Viewport-class.html\">Viewport<\/a> otherwise.<\/p>\n<p>The <code>offset<\/code> argument is the value obtained from\n<a href=\"widgets\/Scrollable\/viewportBuilder.html\">Scrollable.viewportBuilder<\/a>.<\/p>\n<p>The <code>axisDirection<\/code> argument is the value obtained from <a href=\"widgets\/ScrollView\/getDirection.html\">getDirection<\/a>,\nwhich by default uses <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> and <a href=\"widgets\/ScrollView\/reverse.html\">reverse<\/a>.<\/p>\n<p>The <code>slivers<\/code> argument is the value obtained from <a href=\"widgets\/ScrollView\/buildSlivers.html\">buildSlivers<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nWidget buildViewport(\n  BuildContext context,\n  ViewportOffset offset,\n  AxisDirection axisDirection,\n  List&lt;Widget&gt; slivers,\n) {\n  if (shrinkWrap) {\n    return ShrinkWrappingViewport(\n      axisDirection: axisDirection,\n      offset: offset,\n      slivers: slivers,\n    );\n  }\n  return Viewport(\n    axisDirection: axisDirection,\n    offset: offset,\n    slivers: slivers,\n    cacheExtent: cacheExtent,\n    center: center,\n    anchor: anchor,\n  );\n}<\/code><\/pre>\n    ",
            "href": "widgets\/ScrollView\/buildViewport.html",
            "isDeprecated": "0",
            "type": "widgets.Widget",
            "name": "buildViewport",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.ScrollView",
            "params": [
                {
                    "name": "axisDirection",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "painting.AxisDirection"
                },
                {
                    "name": "context",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.BuildContext"
                },
                {
                    "name": "offset",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "rendering.ViewportOffset"
                },
                {
                    "name": "slivers",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.List<widgets.Widget>"
                }
            ]
        },
        {
            "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"widgets\/ScrollView\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/DiagnosticableTree\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.add(EnumProperty&lt;Axis&gt;('scrollDirection', scrollDirection));\n  properties.add(FlagProperty('reverse', value: reverse, ifTrue: 'reversed', showName: true));\n  properties.add(DiagnosticsProperty&lt;ScrollController&gt;('controller', controller, showName: false, defaultValue: null));\n  properties.add(FlagProperty('primary', value: primary, ifTrue: 'using primary controller', showName: true));\n  properties.add(DiagnosticsProperty&lt;ScrollPhysics&gt;('physics', physics, showName: false, defaultValue: null));\n  properties.add(FlagProperty('shrinkWrap', value: shrinkWrap, ifTrue: 'shrink-wrapping', showName: true));\n}<\/code><\/pre>\n    ",
            "href": "widgets\/ScrollView\/debugFillProperties.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "debugFillProperties",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.ScrollView",
            "params": [
                {
                    "name": "properties",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "foundation.DiagnosticPropertiesBuilder"
                }
            ]
        },
        {
            "desc": "<p>Returns the <a href=\"painting\/AxisDirection-class.html\">AxisDirection<\/a> in which the scroll view scrolls.<\/p>\n<p>Combines the <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> with the <a href=\"widgets\/ScrollView\/reverse.html\">reverse<\/a> boolean to obtain the\nconcrete <a href=\"painting\/AxisDirection-class.html\">AxisDirection<\/a>.<\/p>\n<p>If the <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> is <a href=\"painting\/Axis-class.html\">Axis.horizontal<\/a>, the ambient\n<a href=\"widgets\/Directionality-class.html\">Directionality<\/a> is also considered when selecting the concrete\n<a href=\"painting\/AxisDirection-class.html\">AxisDirection<\/a>. For example, if the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a> is\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a>, then the non-reversed <a href=\"painting\/AxisDirection-class.html\">AxisDirection<\/a> is\n<a href=\"painting\/AxisDirection-class.html\">AxisDirection.left<\/a> and the reversed <a href=\"painting\/AxisDirection-class.html\">AxisDirection<\/a> is\n<a href=\"painting\/AxisDirection-class.html\">AxisDirection.right<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nAxisDirection getDirection(BuildContext context) {\n  return getAxisDirectionFromAxisReverseAndDirectionality(context, scrollDirection, reverse);\n}<\/code><\/pre>\n    ",
            "href": "widgets\/ScrollView\/getDirection.html",
            "isDeprecated": "0",
            "type": "painting.AxisDirection",
            "name": "getDirection",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.ScrollView",
            "params": [
                {
                    "name": "context",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.BuildContext"
                }
            ]
        }
    ],
    "props": [
        {
            "desc": "<p>The relative position of the zero scroll offset.<\/p>\n<p>For example, if <a href=\"widgets\/ScrollView\/anchor.html\">anchor<\/a> is 0.5 and the <code>axisDirection<\/code> is\n<a href=\"painting\/AxisDirection-class.html\">AxisDirection.down<\/a> or <a href=\"painting\/AxisDirection-class.html\">AxisDirection.up<\/a>, then the zero scroll offset is\nvertically centered within the viewport. If the <a href=\"widgets\/ScrollView\/anchor.html\">anchor<\/a> is 1.0, and the\n<code>axisDirection<\/code> is <a href=\"painting\/AxisDirection-class.html\">AxisDirection.right<\/a>, then the zero scroll offset is\non the left edge of the viewport.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double anchor\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/anchor.html",
            "name": "anchor",
            "isDeprecated": false,
            "type": "dart:core.double",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>The viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.<\/p>\n<p>Items that fall in this cache area are laid out even though they are not\n(yet) visible on screen. The <a href=\"widgets\/ScrollView\/cacheExtent.html\">cacheExtent<\/a> describes how many pixels\nthe cache area extends before the leading edge and after the trailing edge\nof the viewport.<\/p>\n<p>The total extent, which the viewport will try to cover with children, is\n<a href=\"widgets\/ScrollView\/cacheExtent.html\">cacheExtent<\/a> before the leading edge + extent of the main axis +\n<a href=\"widgets\/ScrollView\/cacheExtent.html\">cacheExtent<\/a> after the trailing edge.<\/p>\n<p>The cache area is also used to implement implicit accessibility scrolling\non iOS: When the accessibility focus moves from an item in the visible\nviewport to an invisible item in the cache area, the framework will bring\nthat item into view with an (implicit) scroll action.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double cacheExtent\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/cacheExtent.html",
            "name": "cacheExtent",
            "isDeprecated": false,
            "type": "dart:core.double",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>The first child in the <a href=\"rendering\/GrowthDirection-class.html\">GrowthDirection.forward<\/a> growth direction.<\/p>\n<p>Children after <a href=\"widgets\/ScrollView\/center.html\">center<\/a> will be placed in the <code>axisDirection<\/code> relative to\nthe <a href=\"widgets\/ScrollView\/center.html\">center<\/a>. Children before <a href=\"widgets\/ScrollView\/center.html\">center<\/a> will be placed in the opposite of\nthe <code>axisDirection<\/code> relative to the <a href=\"widgets\/ScrollView\/center.html\">center<\/a>.<\/p>\n<p>The <a href=\"widgets\/ScrollView\/center.html\">center<\/a> must be the key of one of the slivers built by <a href=\"widgets\/ScrollView\/buildSlivers.html\">buildSlivers<\/a>.<\/p>\n<p>Of the built-in subclasses of <a href=\"widgets\/ScrollView-class.html\">ScrollView<\/a>, only <a href=\"widgets\/CustomScrollView-class.html\">CustomScrollView<\/a>\nsupports <a href=\"widgets\/ScrollView\/center.html\">center<\/a>; for that class, the given key must be the key of one of\nthe slivers in the <a href=\"widgets\/CustomScrollView\/slivers.html\">CustomScrollView.slivers<\/a> list.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/ScrollView\/anchor.html\">anchor<\/a>, which controls where the <a href=\"widgets\/ScrollView\/center.html\">center<\/a> as aligned in the viewport.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Key center\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/center.html",
            "name": "center",
            "isDeprecated": false,
            "type": "foundation.Key",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>An object that can be used to control the position to which this scroll\nview is scrolled.<\/p>\n<p>Must be null if <a href=\"widgets\/ScrollView\/primary.html\">primary<\/a> is true.<\/p>\n<p>A <a href=\"widgets\/ScrollController-class.html\">ScrollController<\/a> serves several purposes. It can be used to control\nthe initial scroll position (see <a href=\"widgets\/ScrollController\/initialScrollOffset.html\">ScrollController.initialScrollOffset<\/a>).\nIt can be used to control whether the scroll view should automatically\nsave and restore its scroll position in the <a href=\"widgets\/PageStorage-class.html\">PageStorage<\/a> (see\n<a href=\"widgets\/ScrollController\/keepScrollOffset.html\">ScrollController.keepScrollOffset<\/a>). It can be used to read the current\nscroll position (see <a href=\"widgets\/ScrollController\/offset.html\">ScrollController.offset<\/a>), or change it (see\n<a href=\"widgets\/ScrollController\/animateTo.html\">ScrollController.animateTo<\/a>).<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ScrollController controller\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/controller.html",
            "name": "controller",
            "isDeprecated": false,
            "type": "widgets.ScrollController",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>Determines the way that drag start behavior is handled.<\/p>\n<p>If set to <a href=\"gestures\/DragStartBehavior-class.html\">DragStartBehavior.start<\/a>, scrolling drag behavior will\nbegin upon the detection of a drag gesture. If set to\n<a href=\"gestures\/DragStartBehavior-class.html\">DragStartBehavior.down<\/a> it will begin when a down event is first detected.<\/p>\n<p>In general, setting this to <a href=\"gestures\/DragStartBehavior-class.html\">DragStartBehavior.start<\/a> will make drag\nanimation smoother and setting it to <a href=\"gestures\/DragStartBehavior-class.html\">DragStartBehavior.down<\/a> will make\ndrag behavior feel slightly more reactive.<\/p>\n<p>By default, the drag start behavior is <a href=\"gestures\/DragStartBehavior-class.html\">DragStartBehavior.start<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/ScrollView\/dragStartBehavior.html\">DragGestureRecognizer.dragStartBehavior<\/a>, which gives an example for the different behaviors.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final DragStartBehavior dragStartBehavior\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/dragStartBehavior.html",
            "name": "dragStartBehavior",
            "isDeprecated": false,
            "type": "gestures.DragStartBehavior",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>How the scroll view should respond to user input.<\/p>\n<p>For example, determines how the scroll view continues to animate after the\nuser stops dragging the scroll view.<\/p>\n<p>Defaults to matching platform conventions. Furthermore, if <a href=\"widgets\/ScrollView\/primary.html\">primary<\/a> is\nfalse, then the user cannot scroll if there is insufficient content to\nscroll, while if <a href=\"widgets\/ScrollView\/primary.html\">primary<\/a> is true, they can always attempt to scroll.<\/p>\n<p>To force the scroll view to always be scrollable even if there is\ninsufficient content, as if <a href=\"widgets\/ScrollView\/primary.html\">primary<\/a> was true but without necessarily\nsetting it to true, provide an <a href=\"widgets\/AlwaysScrollableScrollPhysics-class.html\">AlwaysScrollableScrollPhysics<\/a> physics\nobject, as in:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">  physics: const AlwaysScrollableScrollPhysics(),\n<\/code><\/pre>\n<p>To force the scroll view to use the default platform conventions and not\nbe scrollable if there is insufficient content, regardless of the value of\n<a href=\"widgets\/ScrollView\/primary.html\">primary<\/a>, provide an explicit <a href=\"widgets\/ScrollPhysics-class.html\">ScrollPhysics<\/a> object, as in:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">  physics: const ScrollPhysics(),\n<\/code><\/pre>\n<p>The physics can be changed dynamically (by providing a new object in a\nsubsequent build), but new physics will only take effect if the <em>class<\/em> of\nthe provided object changes. Merely constructing a new instance with a\ndifferent configuration is insufficient to cause the physics to be\nreapplied. (This is because the final object used is generated\ndynamically, which can be relatively expensive, and it would be\ninefficient to speculatively create this object each frame to see if the\nphysics should be updated.)<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ScrollPhysics physics\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/physics.html",
            "name": "physics",
            "isDeprecated": false,
            "type": "widgets.ScrollPhysics",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>Whether this is the primary scroll view associated with the parent\n<a href=\"widgets\/PrimaryScrollController-class.html\">PrimaryScrollController<\/a>.<\/p>\n<p>When this is true, the scroll view is scrollable even if it does not have\nsufficient content to actually scroll. Otherwise, by default the user can\nonly scroll the view if it has sufficient content. See <a href=\"widgets\/ScrollView\/physics.html\">physics<\/a>.<\/p>\n<p>On iOS, this also identifies the scroll view that will scroll to top in\nresponse to a tap in the status bar.<\/p>\n<p>Defaults to true when <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> is <a href=\"painting\/Axis-class.html\">Axis.vertical<\/a> and\n<a href=\"widgets\/ScrollView\/controller.html\">controller<\/a> is null.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final bool primary\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/primary.html",
            "name": "primary",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>Whether the scroll view scrolls in the reading direction.<\/p>\n<p>For example, if the reading direction is left-to-right and\n<a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> is <a href=\"painting\/Axis-class.html\">Axis.horizontal<\/a>, then the scroll view scrolls from\nleft to right when <a href=\"widgets\/ScrollView\/reverse.html\">reverse<\/a> is false and from right to left when\n<a href=\"widgets\/ScrollView\/reverse.html\">reverse<\/a> is true.<\/p>\n<p>Similarly, if <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> is <a href=\"painting\/Axis-class.html\">Axis.vertical<\/a>, then the scroll view\nscrolls from top to bottom when <a href=\"widgets\/ScrollView\/reverse.html\">reverse<\/a> is false and from bottom to top\nwhen <a href=\"widgets\/ScrollView\/reverse.html\">reverse<\/a> is true.<\/p>\n<p>Defaults to false.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final bool reverse\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/reverse.html",
            "name": "reverse",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>The axis along which the scroll view scrolls.<\/p>\n<p>Defaults to <a href=\"painting\/Axis-class.html\">Axis.vertical<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Axis scrollDirection\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/scrollDirection.html",
            "name": "scrollDirection",
            "isDeprecated": false,
            "type": "painting.Axis",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>The number of children that will contribute semantic information.<\/p>\n<p>Some subtypes of <a href=\"widgets\/ScrollView-class.html\">ScrollView<\/a> can infer this value automatically. For\nexample <a href=\"widgets\/ListView-class.html\">ListView<\/a> will use the number of widgets in the child list,\nwhile the <a href=\"widgets\/ListView\/ListView.separated.html\">new ListView.separated<\/a> constructor will use half that amount.<\/p>\n<p>For <a href=\"widgets\/CustomScrollView-class.html\">CustomScrollView<\/a> and other types which do not receive a builder\nor list of widgets, the child count must be explicitly provided. If the\nnumber is unknown or unbounded this should be left unset or set to null.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"semantics\/SemanticsConfiguration\/scrollChildCount.html\">SemanticsConfiguration.scrollChildCount<\/a>, the corresponding semantics property.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final int semanticChildCount\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/semanticChildCount.html",
            "name": "semanticChildCount",
            "isDeprecated": false,
            "type": "dart:core.int",
            "memberOf": "widgets.ScrollView",
            "params": []
        },
        {
            "desc": "<p>Whether the extent of the scroll view in the <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a> should be\ndetermined by the contents being viewed.<\/p>\n<p>If the scroll view does not shrink wrap, then the scroll view will expand\nto the maximum allowed size in the <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a>. If the scroll view\nhas unbounded constraints in the <a href=\"widgets\/ScrollView\/scrollDirection.html\">scrollDirection<\/a>, then <a href=\"widgets\/ScrollView\/shrinkWrap.html\">shrinkWrap<\/a> must\nbe true.<\/p>\n<p>Shrink wrapping the content of the scroll view is significantly more\nexpensive than expanding to the maximum allowed size because the content\ncan expand and contract during scrolling, which means the size of the\nscroll view needs to be recomputed whenever the scroll position changes.<\/p>\n<p>Defaults to false.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final bool shrinkWrap\n\n<\/code><\/pre>\n        ",
            "href": "widgets\/ScrollView\/shrinkWrap.html",
            "name": "shrinkWrap",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "widgets.ScrollView",
            "params": []
        }
    ]
}