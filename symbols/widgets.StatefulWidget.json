{
    "desc": "<p>A widget that has mutable state.<\/p>\n<p>State is information that (1) can be read synchronously when the widget is\nbuilt and (2) might change during the lifetime of the widget. It is the\nresponsibility of the widget implementer to ensure that the <a href=\"widgets\/State-class.html\">State<\/a> is\npromptly notified when such state changes, using <a href=\"widgets\/State\/setState.html\">State.setState<\/a>.<\/p>\n<p>A stateful widget is a widget that describes part of the user interface by\nbuilding a constellation of other widgets that describe the user interface\nmore concretely. The building process continues recursively until the\ndescription of the user interface is fully concrete (e.g., consists\nentirely of <a href=\"widgets\/RenderObjectWidget-class.html\">RenderObjectWidget<\/a>s, which describe concrete <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a>s).<\/p>\n<p>Stateful widgets are useful when the part of the user interface you are\ndescribing can change dynamically, e.g. due to having an internal\nclock-driven state, or depending on some system state. For compositions that\ndepend only on the configuration information in the object itself and the\n<a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> in which the widget is inflated, consider using\n<a href=\"widgets\/StatelessWidget-class.html\">StatelessWidget<\/a>.<\/p>\n<p><a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> instances themselves are immutable and store their mutable\nstate either in separate <a href=\"widgets\/State-class.html\">State<\/a> objects that are created by the\n<a href=\"widgets\/StatefulWidget\/createState.html\">createState<\/a> method, or in objects to which that <a href=\"widgets\/State-class.html\">State<\/a> subscribes, for\nexample <a href=\"dart-async\/Stream-class.html\">Stream<\/a> or <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> objects, to which references are stored\nin final fields on the <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> itself.<\/p>\n<p>The framework calls <a href=\"widgets\/StatefulWidget\/createState.html\">createState<\/a> whenever it inflates a\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, which means that multiple <a href=\"widgets\/State-class.html\">State<\/a> objects might be\nassociated with the same <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> if that widget has been inserted\ninto the tree in multiple places. Similarly, if a <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> is\nremoved from the tree and later inserted in to the tree again, the framework\nwill call <a href=\"widgets\/StatefulWidget\/createState.html\">createState<\/a> again to create a fresh <a href=\"widgets\/State-class.html\">State<\/a> object, simplifying\nthe lifecycle of <a href=\"widgets\/State-class.html\">State<\/a> objects.<\/p>\n<p>A <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> keeps the same <a href=\"widgets\/State-class.html\">State<\/a> object when moving from one\nlocation in the tree to another if its creator used a <a href=\"widgets\/GlobalKey-class.html\">GlobalKey<\/a> for its\n<a href=\"widgets\/Widget\/key.html\">key<\/a>. Because a widget with a <a href=\"widgets\/GlobalKey-class.html\">GlobalKey<\/a> can be used in at most one\nlocation in the tree, a widget that uses a <a href=\"widgets\/GlobalKey-class.html\">GlobalKey<\/a> has at most one\nassociated element. The framework takes advantage of this property when\nmoving a widget with a global key from one location in the tree to another\nby grafting the (unique) subtree associated with that widget from the old\nlocation to the new location (instead of recreating the subtree at the new\nlocation). The <a href=\"widgets\/State-class.html\">State<\/a> objects associated with <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> are grafted\nalong with the rest of the subtree, which means the <a href=\"widgets\/State-class.html\">State<\/a> object is reused\n(instead of being recreated) in the new location. However, in order to be\neligible for grafting, the widget must be inserted into the new location in\nthe same animation frame in which it was removed from the old location.<\/p>\n<h2 id=\"performance-considerations\">Performance considerations<\/h2>\n<p>There are two primary categories of <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>s.<\/p>\n<p>The first is one which allocates resources in <a href=\"widgets\/State\/initState.html\">State.initState<\/a> and disposes\nof them in <a href=\"widgets\/State\/dispose.html\">State.dispose<\/a>, but which does not depend on <a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a>s\nor call <a href=\"widgets\/State\/setState.html\">State.setState<\/a>. Such widgets are commonly used at the root of an\napplication or page, and communicate with subwidgets via <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a>s,\n<a href=\"dart-async\/Stream-class.html\">Stream<\/a>s, or other such objects. Stateful widgets following such a pattern\nare relatively cheap (in terms of CPU and GPU cycles), because they are\nbuilt once then never update. They can, therefore, have somewhat complicated\nand deep build methods.<\/p>\n<p>The second category is widgets that use <a href=\"widgets\/State\/setState.html\">State.setState<\/a> or depend on\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a>s. These will typically rebuild many times during the\napplication's lifetime, and it is therefore important to minimize the impact\nof rebuilding such a widget. (They may also use <a href=\"widgets\/State\/initState.html\">State.initState<\/a> or\n<a href=\"widgets\/State\/didChangeDependencies.html\">State.didChangeDependencies<\/a> and allocate resources, but the important part\nis that they rebuild.)<\/p>\n<p>There are several techniques one can use to minimize the impact of\nrebuilding a stateful widget:<\/p>\n<ul>\n<li>\n<p>Push the state to the leaves. For example, if your page has a ticking\nclock, rather than putting the state at the top of the page and\nrebuilding the entire page each time the clock ticks, create a dedicated\nclock widget that only updates itself.<\/p>\n<\/li>\n<li>\n<p>Minimize the number of nodes transitively created by the build method and\nany widgets it creates. Ideally, a stateful widget would only create a\nsingle widget, and that widget would be a <a href=\"widgets\/RenderObjectWidget-class.html\">RenderObjectWidget<\/a>.\n(Obviously this isn't always practical, but the closer a widget gets to\nthis ideal, the more efficient it will be.)<\/p>\n<\/li>\n<li>\n<p>If a subtree does not change, cache the widget that represents that\nsubtree and re-use it each time it can be used. It is massively more\nefficient for a widget to be re-used than for a new (but\nidentically-configured) widget to be created. Factoring out the stateful\npart into a widget that takes a child argument is a common way of doing\nthis.<\/p>\n<\/li>\n<li>\n<p>Use <code>const<\/code> widgets where possible. (This is equivalent to caching a\nwidget and re-using it.)<\/p>\n<\/li>\n<li>\n<p>Avoid changing the depth of any created subtrees or changing the type of\nany widgets in the subtree. For example, rather than returning either the\nchild or the child wrapped in an <a href=\"widgets\/IgnorePointer-class.html\">IgnorePointer<\/a>, always wrap the child\nwidget in an <a href=\"widgets\/IgnorePointer-class.html\">IgnorePointer<\/a> and control the <a href=\"widgets\/IgnorePointer\/ignoring.html\">IgnorePointer.ignoring<\/a>\nproperty. This is because changing the depth of the subtree requires\nrebuilding, laying out, and painting the entire subtree, whereas just\nchanging the property will require the least possible change to the\nrender tree (in the case of <a href=\"widgets\/IgnorePointer-class.html\">IgnorePointer<\/a>, for example, no layout or\nrepaint is necessary at all).<\/p>\n<\/li>\n<li>\n<p>If the depth must be changed for some reason, consider wrapping the\ncommon parts of the subtrees in widgets that have a <a href=\"widgets\/GlobalKey-class.html\">GlobalKey<\/a> that\nremains consistent for the life of the stateful widget. (The\n<a href=\"widgets\/KeyedSubtree-class.html\">KeyedSubtree<\/a> widget may be useful for this purpose if no other widget\ncan conveniently be assigned the key.)<\/p>\n<\/li>\n<\/ul>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe following is a skeleton of a stateful widget subclass called <code>YellowBird<\/code>:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class YellowBird extends StatefulWidget {\n  const YellowBird({ Key key }) : super(key: key);\n\n  @override\n  _YellowBirdState createState() =&gt; _YellowBirdState();\n}\n\nclass _YellowBirdState extends State&lt;YellowBird&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return Container(color: const Color(0xFFFFE306));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nIn this example. the <a href=\"widgets\/State-class.html\">State<\/a> has no actual state. State is normally\nrepresented as private member fields. Also, normally widgets have more\nconstructor arguments, each of which corresponds to a <code>final<\/code> property.\n<p>The next example shows the more generic widget <code>Bird<\/code> which can be given a\ncolor and a child, and which has some internal state with a method that\ncan be called to mutate it:\n<\/p>\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class Bird extends StatefulWidget {\n  const Bird({\n    Key key,\n    this.color: const Color(0xFFFFE306),\n    this.child,\n  }) : super(key: key);\n\n  final Color color;\n\n  final Widget child;\n\n  _BirdState createState() =&gt; _BirdState();\n}\n\nclass _BirdState extends State&lt;Bird&gt; {\n  double _size = 1.0;\n\n  void grow() {\n    setState(() { _size += 0.1; });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: widget.color,\n      transform: Matrix4.diagonal3Values(_size, _size, 1.0),\n      child: widget.child,\n    );\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>By convention, widget constructors only use named arguments. Named arguments\ncan be marked as required using <code>@required<\/code>. Also by convention, the first\nargument is <a href=\"widgets\/Widget\/key.html\">key<\/a>, and the last argument is <code>child<\/code>, <code>children<\/code>, or the\nequivalent.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/State-class.html\">State<\/a>, where the logic behind a <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> is hosted.<\/li>\n<li>\n<a href=\"widgets\/StatelessWidget-class.html\">StatelessWidget<\/a>, for widgets that always build the same way given a\nparticular configuration and ambient state.<\/li>\n<li>\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a>, for widgets that introduce ambient state that can\nbe read by descendant widgets.<\/li>\n<\/ul>",
    "dtype": "class",
    "example": "",
    "href": "widgets\/StatefulWidget-class.html",
    "isAbstract": true,
    "isConstant": "0",
    "isDeprecated": false,
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "widgets",
    "name": "widgets.StatefulWidget",
    "shortname": "StatefulWidget",
    "extends": [
        "widgets.Widget",
        "foundation.DiagnosticableTree",
        "foundation.Diagnosticable",
        "dart:core.Object"
    ],
    "realImplementors": [
        "cupertino.CupertinoActivityIndicator",
        "cupertino.CupertinoApp",
        "cupertino.CupertinoButton",
        "cupertino.CupertinoDatePicker",
        "cupertino.CupertinoNavigationBar",
        "cupertino.CupertinoPicker",
        "cupertino.CupertinoScrollbar",
        "cupertino.CupertinoSegmentedControl",
        "cupertino.CupertinoSlider",
        "cupertino.CupertinoSliverNavigationBar",
        "cupertino.CupertinoSliverRefreshControl",
        "cupertino.CupertinoSwitch",
        "cupertino.CupertinoTabScaffold",
        "cupertino.CupertinoTabView",
        "cupertino.CupertinoTextField",
        "cupertino.CupertinoTimerPicker",
        "material.AnimatedTheme",
        "material.AppBar",
        "material.BottomAppBar",
        "material.BottomNavigationBar",
        "material.BottomSheet",
        "material.Checkbox",
        "material.CheckedPopupMenuItem",
        "material.CircularProgressIndicator",
        "material.DefaultTabController",
        "material.DrawerController",
        "material.DropdownButton",
        "material.DropdownButtonFormField",
        "material.ExpandIcon",
        "material.ExpansionPanelList",
        "material.ExpansionTile",
        "material.FlexibleSpaceBar",
        "material.Ink",
        "material.InkResponse",
        "material.InkWell",
        "material.InputDecorator",
        "material.LicensePage",
        "material.LinearProgressIndicator",
        "material.Material",
        "material.MaterialApp",
        "material.MergeableMaterial",
        "material.MonthPicker",
        "material.PaginatedDataTable",
        "material.PopupMenuButton",
        "material.PopupMenuDivider",
        "material.PopupMenuItem",
        "material.Radio",
        "material.RawChip",
        "material.RawMaterialButton",
        "material.RefreshIndicator",
        "material.RefreshProgressIndicator",
        "material.ReorderableListView",
        "material.Scaffold",
        "material.Scrollbar",
        "material.Slider",
        "material.SliverAppBar",
        "material.SnackBarAction",
        "material.Stepper",
        "material.Switch",
        "material.TabBar",
        "material.TabBarView",
        "material.TableRowInkWell",
        "material.TextField",
        "material.TextFormField",
        "material.Tooltip",
        "material.UserAccountsDrawerHeader",
        "material.YearPicker",
        "widgets.AlignTransition",
        "widgets.AndroidView",
        "widgets.AnimatedAlign",
        "widgets.AnimatedBuilder",
        "widgets.AnimatedContainer",
        "widgets.AnimatedCrossFade",
        "widgets.AnimatedDefaultTextStyle",
        "widgets.AnimatedList",
        "widgets.AnimatedModalBarrier",
        "widgets.AnimatedOpacity",
        "widgets.AnimatedPadding",
        "widgets.AnimatedPhysicalModel",
        "widgets.AnimatedPositioned",
        "widgets.AnimatedPositionedDirectional",
        "widgets.AnimatedSwitcher",
        "widgets.AutomaticKeepAlive",
        "widgets.DecoratedBoxTransition",
        "widgets.DefaultTextStyleTransition",
        "widgets.Dismissible",
        "widgets.DragTarget",
        "widgets.Draggable",
        "widgets.EditableText",
        "widgets.FadeInImage",
        "widgets.FocusScope",
        "widgets.Form",
        "widgets.FormField",
        "widgets.FutureBuilder",
        "widgets.GlowingOverscrollIndicator",
        "widgets.Hero",
        "widgets.Image",
        "widgets.ListWheelScrollView",
        "widgets.Localizations",
        "widgets.LongPressDraggable",
        "widgets.Navigator",
        "widgets.NestedScrollView",
        "widgets.Overlay",
        "widgets.PageView",
        "widgets.PositionedTransition",
        "widgets.RawGestureDetector",
        "widgets.RawKeyboardListener",
        "widgets.RelativePositionedTransition",
        "widgets.RotationTransition",
        "widgets.ScaleTransition",
        "widgets.Scrollable",
        "widgets.SemanticsDebugger",
        "widgets.SizeTransition",
        "widgets.SlideTransition",
        "widgets.StatefulBuilder",
        "widgets.StreamBuilder",
        "widgets.TextSelectionGestureDetector",
        "widgets.UiKitView",
        "widgets.ValueListenableBuilder",
        "widgets.WidgetInspector",
        "widgets.WidgetsApp",
        "widgets.WillPopScope"
    ],
    "events": [],
    "methods": [
        {
            "desc": "<p>Initializes <code>key<\/code> for subclasses.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const StatefulWidget({ Key key }) : super(key: key);<\/code><\/pre>\n    ",
            "href": "widgets\/StatefulWidget\/StatefulWidget.html",
            "isDeprecated": "0",
            "type": "",
            "name": "StatefulWidget",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "widgets.StatefulWidget",
            "params": [
                {
                    "name": "key",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": true,
                    "type": "foundation.Key"
                }
            ]
        },
        {
            "desc": "<p>Creates a <a href=\"widgets\/StatefulElement-class.html\">StatefulElement<\/a> to manage this widget's location in the tree.<\/p>\n<p>It is uncommon for subclasses to override this method.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nStatefulElement createElement() =&gt; StatefulElement(this);<\/code><\/pre>\n    ",
            "href": "widgets\/StatefulWidget\/createElement.html",
            "isDeprecated": "0",
            "type": "widgets.StatefulElement",
            "name": "createElement",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.StatefulWidget",
            "params": []
        },
        {
            "desc": "<p>Creates the mutable state for this widget at a given location in the tree.<\/p>\n<p>Subclasses should override this method to return a newly created\ninstance of their associated <a href=\"widgets\/State-class.html\">State<\/a> subclass:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">@override\n_MyState createState() =&gt; _MyState();\n<\/code><\/pre>\n<p>The framework can call this method multiple times over the lifetime of\na <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>. For example, if the widget is inserted into the tree\nin multiple locations, the framework will create a separate <a href=\"widgets\/State-class.html\">State<\/a> object\nfor each location. Similarly, if the widget is removed from the tree and\nlater inserted into the tree again, the framework will call <a href=\"widgets\/StatefulWidget\/createState.html\">createState<\/a>\nagain to create a fresh <a href=\"widgets\/State-class.html\">State<\/a> object, simplifying the lifecycle of\n<a href=\"widgets\/State-class.html\">State<\/a> objects.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nState createState();<\/code><\/pre>\n    ",
            "href": "widgets\/StatefulWidget\/createState.html",
            "isDeprecated": "0",
            "type": "widgets.State<widgets.StatefulWidget>",
            "name": "createState",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.StatefulWidget",
            "params": []
        }
    ],
    "props": []
}