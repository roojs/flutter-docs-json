{
    "name": "scheduler.SchedulerBinding",
    "extends": [],
    "memberOf": "scheduler",
    "events": [],
    "methods": [
        {
            "name": "SchedulerBinding",
            "type": "",
            "desc": "",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": true,
            "href": "scheduler\/SchedulerBinding\/SchedulerBinding.html",
            "example": "",
            "isDeprecated": false
        },
        {
            "name": "addPersistentFrameCallback",
            "type": "",
            "desc": "<p>Adds a persistent frame callback.<\/p>\n<p>Persistent callbacks are called after transient\n(non-persistent) frame callbacks.<\/p>\n<p>Does <em>not<\/em> request a new frame. Conceptually, persistent frame\ncallbacks are observers of \"begin frame\" events. Since they are\nexecuted after the transient frame callbacks they can drive the\nrendering pipeline.<\/p>\n<p>Persistent frame callbacks cannot be unregistered. Once registered, they\nare called for every frame for the lifetime of the application.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "callback",
                    "type": "scheduler.FrameCallback",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/addPersistentFrameCallback.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addPersistentFrameCallback(FrameCallback callback) {\n  _persistentCallbacks.add(callback);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "addPostFrameCallback",
            "type": "",
            "desc": "<p>Schedule a callback for the end of this frame.<\/p>\n<p>Does <em>not<\/em> request a new frame.<\/p>\n<p>This callback is run during a frame, just after the persistent\nframe callbacks (which is when the main rendering pipeline has\nbeen flushed). If a frame is in progress and post-frame\ncallbacks haven't been executed yet, then the registered\ncallback is still executed during the frame. Otherwise, the\nregistered callback is executed during the next frame.<\/p>\n<p>The callbacks are executed in the order in which they have been\nadded.<\/p>\n<p>Post-frame callbacks cannot be unregistered. They are called exactly once.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>, which registers a callback for the start of\nthe next frame.<\/li><\/ul>",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "callback",
                    "type": "scheduler.FrameCallback",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/addPostFrameCallback.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addPostFrameCallback(FrameCallback callback) {\n  _postFrameCallbacks.add(callback);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "cancelFrameCallbackWithId",
            "type": "",
            "desc": "<p>Cancels the transient frame callback with the given <code>id<\/code>.<\/p>\n<p>Removes the given callback from the list of frame callbacks. If a frame\nhas been requested, this does not also cancel that request.<\/p>\n<p>Transient frame callbacks are those registered using\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "id",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/cancelFrameCallbackWithId.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void cancelFrameCallbackWithId(int id) {\n  assert(id &gt; 0);\n  _transientCallbacks.remove(id);\n  _removedIds.add(id);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "debugAssertNoTransientCallbacks",
            "type": "dart:core.bool",
            "desc": "<p>Asserts that there are no registered transient callbacks; if\nthere are, prints their locations and throws an exception.<\/p>\n<p>A transient frame callback is one that was registered with\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>.<\/p>\n<p>This is expected to be called at the end of tests (the\nflutter_test framework does it automatically in normal cases).<\/p>\n<p>Call this method when you expect there to be no transient\ncallbacks registered, in an assert statement with a message that\nyou want printed when a transient callback is registered:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">assert(SchedulerBinding.instance.debugAssertNoTransientCallbacks(\n  'A leak of transient callbacks was detected while doing foo.'\n));\n<\/code><\/pre>\n<p>Does nothing if asserts are disabled. Always returns true.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "reason",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/debugAssertNoTransientCallbacks.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool debugAssertNoTransientCallbacks(String reason) {\n  assert(() {\n    if (transientCallbackCount &gt; 0) {\n      \/\/ We cache the values so that we can produce them later\n      \/\/ even if the information collector is called after\n      \/\/ the problem has been resolved.\n      final int count = transientCallbackCount;\n      final Map&lt;int, _FrameCallbackEntry&gt; callbacks = Map&lt;int, _FrameCallbackEntry&gt;.from(_transientCallbacks);\n      FlutterError.reportError(FlutterErrorDetails(\n        exception: reason,\n        library: 'scheduler library',\n        informationCollector: (StringBuffer information) {\n          if (count == 1) {\n            information.writeln(\n              'There was one transient callback left. '\n              'The stack trace for when it was registered is as follows:'\n            );\n          } else {\n            information.writeln(\n              'There were $count transient callbacks left. '\n              'The stack traces for when they were registered are as follows:'\n            );\n          }\n          for (int id in callbacks.keys) {\n            final _FrameCallbackEntry entry = callbacks[id];\n            information.writeln('\u2500\u2500 callback $id \u2500\u2500');\n            FlutterError.defaultStackFilter(entry.debugStack.toString().trimRight().split('\\n')).forEach(information.writeln);\n          }\n        },\n      ));\n    }\n    return true;\n  }());\n  return true;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "debugPrintTransientCallbackRegistrationStack",
            "type": "",
            "desc": "<p>Prints the stack for where the current transient callback was registered.<\/p>\n<p>A transient frame callback is one that was registered with\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>.<\/p>\n<p>When called in debug more and in the context of a transient callback, this\nfunction prints the stack trace from where the current transient callback\nwas registered (i.e. where it first called <a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>).<\/p>\n<p>When called in debug mode in other contexts, it prints a message saying\nthat this function was not called in the context a transient callback.<\/p>\n<p>In release mode, this function does nothing.<\/p>\n<p>To call this function, use the following code:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">SchedulerBinding.debugPrintTransientCallbackRegistrationStack();\n<\/code><\/pre>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/debugPrintTransientCallbackRegistrationStack.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static void debugPrintTransientCallbackRegistrationStack() {\n  assert(() {\n    if (_FrameCallbackEntry.debugCurrentCallbackStack != null) {\n      debugPrint('When the current transient callback was registered, this was the stack:');\n      debugPrint(\n        FlutterError.defaultStackFilter(\n          _FrameCallbackEntry.debugCurrentCallbackStack.toString().trimRight().split('\\n')\n        ).join('\\n')\n      );\n    } else {\n      debugPrint('No transient callback is currently executing.');\n    }\n    return true;\n  }());\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "ensureVisualUpdate",
            "type": "",
            "desc": "<p>Schedules a new frame using <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">scheduleFrame<\/a> if this object is not\ncurrently producing a frame.<\/p>\n<p>Calling this method ensures that <a href=\"scheduler\/SchedulerBinding\/handleDrawFrame.html\">handleDrawFrame<\/a> will eventually be\ncalled, unless it's already in progress.<\/p>\n<p>This has no effect if <a href=\"scheduler\/SchedulerBinding\/schedulerPhase.html\">schedulerPhase<\/a> is\n<a href=\"scheduler\/SchedulerPhase-class.html\">SchedulerPhase.transientCallbacks<\/a> or <a href=\"scheduler\/SchedulerPhase-class.html\">SchedulerPhase.midFrameMicrotasks<\/a>\n(because a frame is already being prepared in that case), or\n<a href=\"scheduler\/SchedulerPhase-class.html\">SchedulerPhase.persistentCallbacks<\/a> (because a frame is actively being\nrendered in that case). It will schedule a frame if the <a href=\"scheduler\/SchedulerBinding\/schedulerPhase.html\">schedulerPhase<\/a>\nis <a href=\"scheduler\/SchedulerPhase-class.html\">SchedulerPhase.idle<\/a> (in between frames) or\n<a href=\"scheduler\/SchedulerPhase-class.html\">SchedulerPhase.postFrameCallbacks<\/a> (after a frame).<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/ensureVisualUpdate.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void ensureVisualUpdate() {\n  switch (schedulerPhase) {\n    case SchedulerPhase.idle:\n    case SchedulerPhase.postFrameCallbacks:\n      scheduleFrame();\n      return;\n    case SchedulerPhase.transientCallbacks:\n    case SchedulerPhase.midFrameMicrotasks:\n    case SchedulerPhase.persistentCallbacks:\n      return;\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "handleAppLifecycleStateChanged",
            "type": "",
            "desc": "<p>Called when the application lifecycle state changes.<\/p>\n<p>Notifies all the observers using\n<a href=\"widgets\/WidgetsBindingObserver\/didChangeAppLifecycleState.html\">WidgetsBindingObserver.didChangeAppLifecycleState<\/a>.<\/p>\n<p>This method exposes notifications from <a href=\"services\/SystemChannels\/lifecycle-constant.html\">SystemChannels.lifecycle<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "state",
                    "type": "dart:ui.AppLifecycleState",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/handleAppLifecycleStateChanged.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\n@mustCallSuper\nvoid handleAppLifecycleStateChanged(AppLifecycleState state) {\n  assert(state != null);\n  _lifecycleState = state;\n  switch (state) {\n    case AppLifecycleState.resumed:\n    case AppLifecycleState.inactive:\n      _setFramesEnabledState(true);\n      break;\n    case AppLifecycleState.paused:\n    case AppLifecycleState.suspending:\n      _setFramesEnabledState(false);\n      break;\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "handleBeginFrame",
            "type": "",
            "desc": "<p>Called by the engine to prepare the framework to produce a new frame.<\/p>\n<p>This function calls all the transient frame callbacks registered by\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>. It then returns, any scheduled microtasks are run\n(e.g. handlers for any <a href=\"dart-async\/Future-class.html\">Future<\/a>s resolved by transient frame callbacks),\nand <a href=\"scheduler\/SchedulerBinding\/handleDrawFrame.html\">handleDrawFrame<\/a> is called to continue the frame.<\/p>\n<p>If the given time stamp is null, the time stamp from the last frame is\nreused.<\/p>\n<p>To have a banner shown at the start of every frame in debug mode, set\n<a href=\"scheduler\/debugPrintBeginFrameBanner.html\">debugPrintBeginFrameBanner<\/a> to true. The banner will be printed to the\nconsole using <a href=\"foundation\/debugPrint.html\">debugPrint<\/a> and will contain the frame number (which\nincrements by one for each frame), and the time stamp of the frame. If the\ngiven time stamp was null, then the string \"warm-up frame\" is shown\ninstead of the time stamp. This allows frames eagerly pushed by the\nframework to be distinguished from those requested by the engine in\nresponse to the \"Vsync\" signal from the operating system.<\/p>\n<p>You can also show a banner at the end of every frame by setting\n<a href=\"scheduler\/debugPrintEndFrameBanner.html\">debugPrintEndFrameBanner<\/a> to true. This allows you to distinguish log\nstatements printed during a frame from those printed between frames (e.g.\nin response to events or timers).<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "rawTimeStamp",
                    "type": "dart:core.Duration",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/handleBeginFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void handleBeginFrame(Duration rawTimeStamp) {\n  Timeline.startSync('Frame', arguments: timelineWhitelistArguments);\n  _firstRawTimeStampInEpoch ??= rawTimeStamp;\n  _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp);\n  if (rawTimeStamp != null)\n    _lastRawTimeStamp = rawTimeStamp;\n\n  if (!kReleaseMode) {\n    _profileFrameNumber += 1;\n    _profileFrameStopwatch.reset();\n    _profileFrameStopwatch.start();\n  }\n\n  assert(() {\n    if (debugPrintBeginFrameBanner || debugPrintEndFrameBanner) {\n      final StringBuffer frameTimeStampDescription = StringBuffer();\n      if (rawTimeStamp != null) {\n        _debugDescribeTimeStamp(_currentFrameTimeStamp, frameTimeStampDescription);\n      } else {\n        frameTimeStampDescription.write('(warm-up frame)');\n      }\n      _debugBanner = '\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584 Frame ${_profileFrameNumber.toString().padRight(7)}   ${frameTimeStampDescription.toString().padLeft(18)} \u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584';\n      if (debugPrintBeginFrameBanner)\n        debugPrint(_debugBanner);\n    }\n    return true;\n  }());\n\n  assert(schedulerPhase == SchedulerPhase.idle);\n  _hasScheduledFrame = false;\n  try {\n    \/\/ TRANSIENT FRAME CALLBACKS\n    Timeline.startSync('Animate', arguments: timelineWhitelistArguments);\n    _schedulerPhase = SchedulerPhase.transientCallbacks;\n    final Map&lt;int, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;\n    _transientCallbacks = &lt;int, _FrameCallbackEntry&gt;{};\n    callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) {\n      if (!_removedIds.contains(id))\n        _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);\n    });\n    _removedIds.clear();\n  } finally {\n    _schedulerPhase = SchedulerPhase.midFrameMicrotasks;\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "handleDrawFrame",
            "type": "",
            "desc": "<p>Called by the engine to produce a new frame.<\/p>\n<p>This method is called immediately after <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>. It calls all\nthe callbacks registered by <a href=\"scheduler\/SchedulerBinding\/addPersistentFrameCallback.html\">addPersistentFrameCallback<\/a>, which typically\ndrive the rendering pipeline, and then calls the callbacks registered by\n<a href=\"scheduler\/SchedulerBinding\/addPostFrameCallback.html\">addPostFrameCallback<\/a>.<\/p>\n<p>See <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a> for a discussion about debugging hooks that may be\nuseful when working with frame callbacks.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/handleDrawFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void handleDrawFrame() {\n  assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);\n  Timeline.finishSync(); \/\/ end the \"Animate\" phase\n  try {\n    \/\/ PERSISTENT FRAME CALLBACKS\n    _schedulerPhase = SchedulerPhase.persistentCallbacks;\n    for (FrameCallback callback in _persistentCallbacks)\n      _invokeFrameCallback(callback, _currentFrameTimeStamp);\n\n    \/\/ POST-FRAME CALLBACKS\n    _schedulerPhase = SchedulerPhase.postFrameCallbacks;\n    final List&lt;FrameCallback&gt; localPostFrameCallbacks =\n        List&lt;FrameCallback&gt;.from(_postFrameCallbacks);\n    _postFrameCallbacks.clear();\n    for (FrameCallback callback in localPostFrameCallbacks)\n      _invokeFrameCallback(callback, _currentFrameTimeStamp);\n  } finally {\n    _schedulerPhase = SchedulerPhase.idle;\n    Timeline.finishSync(); \/\/ end the Frame\n    if (!kReleaseMode) {\n      _profileFrameStopwatch.stop();\n      _profileFramePostEvent();\n    }\n    assert(() {\n      if (debugPrintEndFrameBanner)\n        debugPrint('\u2580' * _debugBanner.length);\n      _debugBanner = null;\n      return true;\n    }());\n    _currentFrameTimeStamp = null;\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "handleEventLoopCallback",
            "type": "dart:core.bool",
            "desc": "<p>Execute the highest-priority task, if it is of a high enough priority.<\/p>\n<p>Returns true if a task was executed and there are other tasks remaining\n(even if they are not high-enough priority).<\/p>\n<p>Returns false if no task was executed, which can occur if there are no\ntasks scheduled, if the scheduler is <a href=\"foundation\/BindingBase\/locked.html\">locked<\/a>, or if the highest-priority\ntask is of too low a priority given the current <a href=\"scheduler\/SchedulerBinding\/schedulingStrategy.html\">schedulingStrategy<\/a>.<\/p>\n<p>Also returns false if there are no tasks remaining.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/handleEventLoopCallback.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@visibleForTesting\nbool handleEventLoopCallback() {\n  if (_taskQueue.isEmpty || locked)\n    return false;\n  final _TaskEntry&lt;dynamic&gt; entry = _taskQueue.first;\n  if (schedulingStrategy(priority: entry.priority, scheduler: this)) {\n    try {\n      _taskQueue.removeFirst();\n      entry.run();\n    } catch (exception, exceptionStack) {\n      StackTrace callbackStack;\n      assert(() {\n        callbackStack = entry.debugStack;\n        return true;\n      }());\n      FlutterError.reportError(FlutterErrorDetails(\n        exception: exception,\n        stack: exceptionStack,\n        library: 'scheduler library',\n        context: 'during a task callback',\n        informationCollector: (callbackStack == null) ? null : (StringBuffer information) {\n          information.writeln(\n            '\\nThis exception was thrown in the context of a task callback. '\n            'When the task callback was _registered_ (as opposed to when the '\n            'exception was thrown), this was the stack:'\n          );\n          FlutterError.defaultStackFilter(callbackStack.toString().trimRight().split('\\n')).forEach(information.writeln);\n        },\n      ));\n    }\n    return _taskQueue.isNotEmpty;\n  }\n  return false;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "initInstances",
            "type": "",
            "desc": "<p>The initialization method. Subclasses override this method to hook into\nthe platform and otherwise configure their services. Subclasses must call\n\"super.initInstances()\".<\/p>\n<p>By convention, if the service is to be provided as a singleton, it should\nbe exposed as <code>MixinClassName.instance<\/code>, a static getter that returns\n<code>MixinClassName._instance<\/code>, a static field that is set by\n<code>initInstances()<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/initInstances.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initInstances() {\n  super.initInstances();\n  _instance = this;\n  window.onBeginFrame = _handleBeginFrame;\n  window.onDrawFrame = _handleDrawFrame;\n  SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);\n  readInitialLifecycleStateFromNativeWindow();\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "initServiceExtensions",
            "type": "",
            "desc": "<p>Called when the binding is initialized, to register service\nextensions.<\/p>\n<p>Bindings that want to expose service extensions should overload\nthis method to register them using calls to\n<a href=\"foundation\/BindingBase\/registerSignalServiceExtension.html\">registerSignalServiceExtension<\/a>,\n<a href=\"foundation\/BindingBase\/registerBoolServiceExtension.html\">registerBoolServiceExtension<\/a>,\n<a href=\"foundation\/BindingBase\/registerNumericServiceExtension.html\">registerNumericServiceExtension<\/a>, and\n<a href=\"foundation\/BindingBase\/registerServiceExtension.html\">registerServiceExtension<\/a> (in increasing order of complexity).<\/p>\n<p>Implementations of this method must call their superclass\nimplementation.<\/p>\n<p>A registered service extension can only be activated if the vm-service\nis included in the build, which only happens in debug and profile mode.\nAlthough a service extension cannot be used in release mode its code may\nstill be included in the Dart snapshot and blow up binary size if it is\nnot wrapped in a guard that allows the tree shaker to remove it (see\nsample code below).<\/p>\n<p>{@inject-html}<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">{@end-inject-html}The following code registers a service extension that is only included in\ndebug builds.{@inject-html}<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">void myRegistrationFunction() {\n  assert(() {\n    \/\/ Register your service extension here.\n    return true;\n  }());\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n{@end-inject-html}\n<p>{@inject-html}<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">{@end-inject-html}A service extension registered with the following code snippet is\navailable in debug and profile mode.{@inject-html}<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">void myRegistrationFunction() {\n  \/\/ kReleaseMode is defined in the 'flutter\/foundation.dart' package.\n  if (!kReleaseMode) {\n    \/\/ Register your service extension here.\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n{@end-inject-html}\n<p>Both guards ensure that Dart's tree shaker can remove the code for the\nservice extension in release builds.<\/p>\n<p>See also:<\/p>\n<ul><li><a href=\"https:\/\/github.com\/dart-lang\/sdk\/blob\/master\/runtime\/vm\/service\/service.md#rpcs-requests-and-responses\">github.com\/dart-lang\/sdk\/blob\/master\/runtime\/vm\/service\/service.md#rpcs-requests-and-responses<\/a><\/li><\/ul>",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/initServiceExtensions.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initServiceExtensions() {\n  super.initServiceExtensions();\n\n  if (!kReleaseMode) {\n    registerNumericServiceExtension(\n      name: 'timeDilation',\n      getter: () async =&gt; timeDilation,\n      setter: (double value) async {\n        timeDilation = value;\n      },\n    );\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "readInitialLifecycleStateFromNativeWindow",
            "type": "",
            "desc": "<p>Initializes the <a href=\"scheduler\/SchedulerBinding\/lifecycleState.html\">lifecycleState<\/a> with the <code>initialLifecycleState<\/code> from the\nwindow.<\/p>\n<p>Once the <a href=\"scheduler\/SchedulerBinding\/lifecycleState.html\">lifecycleState<\/a> is populated through any means (including this\nmethod), this method will do nothing. This is because the\n<code>initialLifecycleState<\/code> may already be stale and it no longer makes sense\nto use the initial state at dart vm startup as the current state anymore.<\/p>\n<p>The latest state should be obtained by subscribing to\n<a href=\"widgets\/WidgetsBindingObserver\/didChangeAppLifecycleState.html\">WidgetsBindingObserver.didChangeAppLifecycleState<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/readInitialLifecycleStateFromNativeWindow.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid readInitialLifecycleStateFromNativeWindow() {\n  if (_lifecycleState == null &amp;&amp; _parseAppLifecycleMessage(window.initialLifecycleState) != null) {\n    _handleLifecycleMessage(window.initialLifecycleState);\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "resetEpoch",
            "type": "",
            "desc": "<p>Prepares the scheduler for a non-monotonic change to how time stamps are\ncalculated.<\/p>\n<p>Callbacks received from the scheduler assume that their time stamps are\nmonotonically increasing. The raw time stamp passed to <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>\nis monotonic, but the scheduler might adjust those time stamps to provide\n<a href=\"scheduler\/timeDilation.html\">timeDilation<\/a>. Without careful handling, these adjusts could cause time\nto appear to run backwards.<\/p>\n<p>The <a href=\"scheduler\/SchedulerBinding\/resetEpoch.html\">resetEpoch<\/a> function ensures that the time stamps are monotonic by\nresetting the base time stamp used for future time stamp adjustments to the\ncurrent value. For example, if the <a href=\"scheduler\/timeDilation.html\">timeDilation<\/a> decreases, rather than\nscaling down the <a href=\"dart-core\/Duration-class.html\">Duration<\/a> since the beginning of time, <a href=\"scheduler\/SchedulerBinding\/resetEpoch.html\">resetEpoch<\/a> will\nensure that we only scale down the duration since <a href=\"scheduler\/SchedulerBinding\/resetEpoch.html\">resetEpoch<\/a> was called.<\/p>\n<p>Setting <a href=\"scheduler\/timeDilation.html\">timeDilation<\/a> calls <a href=\"scheduler\/SchedulerBinding\/resetEpoch.html\">resetEpoch<\/a> automatically. You don't need to\ncall <a href=\"scheduler\/SchedulerBinding\/resetEpoch.html\">resetEpoch<\/a> yourself.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/resetEpoch.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void resetEpoch() {\n  _epochStart = _adjustForEpoch(_lastRawTimeStamp);\n  _firstRawTimeStampInEpoch = null;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "scheduleForcedFrame",
            "type": "",
            "desc": "<p>Schedules a new frame by calling <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">Window.scheduleFrame<\/a>.<\/p>\n<p>After this is called, the engine will call <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>, even if\nframes would normally not be scheduled by <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">scheduleFrame<\/a> (e.g. even if\nthe device's screen is turned off).<\/p>\n<p>The framework uses this to force a frame to be rendered at the correct\nsize when the phone is rotated, so that a correctly-sized rendering is\navailable when the screen is turned back on.<\/p>\n<p>To have a stack trace printed to the console any time this function\nschedules a frame, set <a href=\"scheduler\/debugPrintScheduleFrameStacks.html\">debugPrintScheduleFrameStacks<\/a> to true.<\/p>\n<p>Prefer using <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">scheduleFrame<\/a> unless it is imperative that a frame be\nscheduled immediately, since using <code>scheduleForceFrame<\/code> will cause\nsignificantly higher battery usage when the device should be idle.<\/p>\n<p>Consider using <a href=\"scheduler\/SchedulerBinding\/scheduleWarmUpFrame.html\">scheduleWarmUpFrame<\/a> instead if the goal is to update the\nrendering as soon as possible (e.g. at application startup).<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/scheduleForcedFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void scheduleForcedFrame() {\n  if (_hasScheduledFrame)\n    return;\n  assert(() {\n    if (debugPrintScheduleFrameStacks)\n      debugPrintStack(label: 'scheduleForcedFrame() called. Current phase is $schedulerPhase.');\n    return true;\n  }());\n  window.scheduleFrame();\n  _hasScheduledFrame = true;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "scheduleFrame",
            "type": "",
            "desc": "<p>If necessary, schedules a new frame by calling\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">Window.scheduleFrame<\/a>.<\/p>\n<p>After this is called, the engine will (eventually) call\n<a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>. (This call might be delayed, e.g. if the device's\nscreen is turned off it will typically be delayed until the screen is on\nand the application is visible.) Calling this during a frame forces\nanother frame to be scheduled, even if the current frame has not yet\ncompleted.<\/p>\n<p>Scheduled frames are serviced when triggered by a \"Vsync\" signal provided\nby the operating system. The \"Vsync\" signal, or vertical synchronization\nsignal, was historically related to the display refresh, at a time when\nhardware physically moved a beam of electrons vertically between updates\nof the display. The operation of contemporary hardware is somewhat more\nsubtle and complicated, but the conceptual \"Vsync\" refresh signal continue\nto be used to indicate when applications should update their rendering.<\/p>\n<p>To have a stack trace printed to the console any time this function\nschedules a frame, set <a href=\"scheduler\/debugPrintScheduleFrameStacks.html\">debugPrintScheduleFrameStacks<\/a> to true.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"scheduler\/SchedulerBinding\/scheduleForcedFrame.html\">scheduleForcedFrame<\/a>, which ignores the <a href=\"scheduler\/SchedulerBinding\/lifecycleState.html\">lifecycleState<\/a> when\nscheduling a frame.<\/li>\n<li>\n<a href=\"scheduler\/SchedulerBinding\/scheduleWarmUpFrame.html\">scheduleWarmUpFrame<\/a>, which ignores the \"Vsync\" signal entirely and\ntriggers a frame immediately.<\/li>\n<\/ul>",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/scheduleFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void scheduleFrame() {\n  if (_hasScheduledFrame || !_framesEnabled)\n    return;\n  assert(() {\n    if (debugPrintScheduleFrameStacks)\n      debugPrintStack(label: 'scheduleFrame() called. Current phase is $schedulerPhase.');\n    return true;\n  }());\n  window.scheduleFrame();\n  _hasScheduledFrame = true;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "scheduleFrameCallback",
            "type": "dart:core.int",
            "desc": "<p>Schedules the given transient frame callback.<\/p>\n<p>Adds the given callback to the list of frame callbacks and ensures that a\nframe is scheduled.<\/p>\n<p>If this is a one-off registration, ignore the <code>rescheduling<\/code> argument.<\/p>\n<p>If this is a callback that will be re-registered each time it fires, then\nwhen you re-register the callback, set the <code>rescheduling<\/code> argument to\ntrue. This has no effect in release builds, but in debug builds, it\nensures that the stack trace that is stored for this callback is the\noriginal stack trace for when the callback was <em>first<\/em> registered, rather\nthan the stack trace for when the callback is re-registered. This makes it\neasier to track down the original reason that a particular callback was\ncalled. If <code>rescheduling<\/code> is true, the call must be in the context of a\nframe callback.<\/p>\n<p>Callbacks registered with this method can be canceled using\n<a href=\"scheduler\/SchedulerBinding\/cancelFrameCallbackWithId.html\">cancelFrameCallbackWithId<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "callback",
                    "type": "scheduler.FrameCallback",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "rescheduling",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/scheduleFrameCallback.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">int scheduleFrameCallback(FrameCallback callback, { bool rescheduling = false }) {\n  scheduleFrame();\n  _nextFrameCallbackId += 1;\n  _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling);\n  return _nextFrameCallbackId;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "scheduleTask",
            "type": "dart:async.Future",
            "desc": "<p>Schedules the given <code>task<\/code> with the given <code>priority<\/code> and returns a\n<a href=\"dart-async\/Future-class.html\">Future<\/a> that completes to the <code>task<\/code>'s eventual return value.<\/p>\n<p>The <code>debugLabel<\/code> and <code>flow<\/code> are used to report the task to the <a href=\"dart-developer\/Timeline-class.html\">Timeline<\/a>,\nfor use when profiling.<\/p>\n<h2 id=\"processing-model\">Processing model<\/h2>\n<p>Tasks will be executed between frames, in priority order,\nexcluding tasks that are skipped by the current\n<a href=\"scheduler\/SchedulerBinding\/schedulingStrategy.html\">schedulingStrategy<\/a>. Tasks should be short (as in, up to a\nmillisecond), so as to not cause the regular frame callbacks to\nget delayed.<\/p>\n<p>If an animation is running, including, for instance, a <a href=\"material\/ProgressIndicator-class.html\">ProgressIndicator<\/a>\nindicating that there are pending tasks, then tasks with a priority below\n<a href=\"scheduler\/Priority\/animation-constant.html\">Priority.animation<\/a> won't run (at least, not with the\n<a href=\"scheduler\/defaultSchedulingStrategy.html\">defaultSchedulingStrategy<\/a>; this can be configured using\n<a href=\"scheduler\/SchedulerBinding\/schedulingStrategy.html\">schedulingStrategy<\/a>).<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [
                {
                    "name": "task",
                    "type": "scheduler.TaskCallback",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "priority",
                    "type": "scheduler.Priority",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "debugLabel",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "flow",
                    "type": "dart:developer.Flow",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/scheduleTask.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; scheduleTask&lt;T&gt;(\n  TaskCallback&lt;T&gt; task,\n  Priority priority, {\n  String debugLabel,\n  Flow flow,\n}) {\n  final bool isFirstTask = _taskQueue.isEmpty;\n  final _TaskEntry&lt;T&gt; entry = _TaskEntry&lt;T&gt;(\n    task,\n    priority.value,\n    debugLabel,\n    flow,\n  );\n  _taskQueue.add(entry);\n  if (isFirstTask &amp;&amp; !locked)\n    _ensureEventLoopCallback();\n  return entry.completer.future;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "scheduleWarmUpFrame",
            "type": "",
            "desc": "<p>Schedule a frame to run as soon as possible, rather than waiting for\nthe engine to request a frame in response to a system \"Vsync\" signal.<\/p>\n<p>This is used during application startup so that the first frame (which is\nlikely to be quite expensive) gets a few extra milliseconds to run.<\/p>\n<p>Locks events dispatching until the scheduled frame has completed.<\/p>\n<p>If a frame has already been scheduled with <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">scheduleFrame<\/a> or\n<a href=\"scheduler\/SchedulerBinding\/scheduleForcedFrame.html\">scheduleForcedFrame<\/a>, this call may delay that frame.<\/p>\n<p>If any scheduled frame has already begun or if another\n<a href=\"scheduler\/SchedulerBinding\/scheduleWarmUpFrame.html\">scheduleWarmUpFrame<\/a> was already called, this call will be ignored.<\/p>\n<p>Prefer <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">scheduleFrame<\/a> to update the display in normal operation.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/scheduleWarmUpFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void scheduleWarmUpFrame() {\n  if (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)\n    return;\n\n  _warmUpFrame = true;\n  Timeline.startSync('Warm-up frame');\n  final bool hadScheduledFrame = _hasScheduledFrame;\n  \/\/ We use timers here to ensure that microtasks flush in between.\n  Timer.run(() {\n    assert(_warmUpFrame);\n    handleBeginFrame(null);\n  });\n  Timer.run(() {\n    assert(_warmUpFrame);\n    handleDrawFrame();\n    \/\/ We call resetEpoch after this frame so that, in the hot reload case,\n    \/\/ the very next frame pretends to have occurred immediately after this\n    \/\/ warm-up frame. The warm-up frame's timestamp will typically be far in\n    \/\/ the past (the time of the last real frame), so if we didn't reset the\n    \/\/ epoch we would see a sudden jump from the old time in the warm-up frame\n    \/\/ to the new time in the \"real\" frame. The biggest problem with this is\n    \/\/ that implicit animations end up being triggered at the old time and\n    \/\/ then skipping every frame and finishing in the new time.\n    resetEpoch();\n    _warmUpFrame = false;\n    if (hadScheduledFrame)\n      scheduleFrame();\n  });\n\n  \/\/ Lock events so touch events etc don't insert themselves until the\n  \/\/ scheduled frame has finished.\n  lockEvents(() async {\n    await endOfFrame;\n    Timeline.finishSync();\n  });\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "unlocked",
            "type": "",
            "desc": "<p>Called by <a href=\"foundation\/BindingBase\/lockEvents.html\">lockEvents<\/a> when events get unlocked.<\/p>\n<p>This should flush any events that were queued while <a href=\"foundation\/BindingBase\/locked.html\">locked<\/a> was true.<\/p>\n    ",
            "static": false,
            "memberOf": "scheduler.SchedulerBinding",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "scheduler\/SchedulerBinding\/unlocked.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid unlocked() {\n  super.unlocked();\n  if (_taskQueue.isNotEmpty)\n    _ensureEventLoopCallback();\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        }
    ],
    "props": [
        {
            "name": "currentFrameTimeStamp",
            "type": "dart:core.Duration",
            "types": [],
            "desc": "<p>The time stamp for the frame currently being processed.<\/p>\n<p>This is only valid while <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a> is running, i.e. while a frame\nis being produced.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/currentFrameTimeStamp.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Duration get currentFrameTimeStamp {\n  assert(_currentFrameTimeStamp != null);\n  return _currentFrameTimeStamp;\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "endOfFrame",
            "type": "dart:async.Future",
            "types": [],
            "desc": "<p>Returns a Future that completes after the frame completes.<\/p>\n<p>If this is called between frames, a frame is immediately scheduled if\nnecessary. If this is called during a frame, the Future completes after\nthe current frame.<\/p>\n<p>If the device's screen is currently turned off, this may wait a very long\ntime, since frames are not scheduled while the device's screen is turned\noff.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/endOfFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; get endOfFrame {\n  if (_nextFrameCompleter == null) {\n    if (schedulerPhase == SchedulerPhase.idle)\n      scheduleFrame();\n    _nextFrameCompleter = Completer&lt;void&gt;();\n    addPostFrameCallback((Duration timeStamp) {\n      _nextFrameCompleter.complete();\n      _nextFrameCompleter = null;\n    });\n  }\n  return _nextFrameCompleter.future;\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "framesEnabled",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether frames are currently being scheduled when <a href=\"scheduler\/SchedulerBinding\/scheduleFrame.html\">scheduleFrame<\/a> is called.<\/p>\n<p>This value depends on the value of the <a href=\"scheduler\/SchedulerBinding\/lifecycleState.html\">lifecycleState<\/a>.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/framesEnabled.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get framesEnabled =&gt; _framesEnabled;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasScheduledFrame",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether this scheduler has requested that <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">handleBeginFrame<\/a> be called soon.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/hasScheduledFrame.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasScheduledFrame =&gt; _hasScheduledFrame;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "instance",
            "type": "scheduler.SchedulerBinding",
            "types": [],
            "desc": "<p>The current <a href=\"scheduler\/SchedulerBinding-mixin.html\">SchedulerBinding<\/a>, if one has been created.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/instance.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">static SchedulerBinding get instance =&gt; _instance;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "lifecycleState",
            "type": "dart:ui.AppLifecycleState",
            "types": [],
            "desc": "<p>Whether the application is visible, and if so, whether it is currently\ninteractive.<\/p>\n<p>This is set by <a href=\"scheduler\/SchedulerBinding\/handleAppLifecycleStateChanged.html\">handleAppLifecycleStateChanged<\/a> when the\n<a href=\"services\/SystemChannels\/lifecycle-constant.html\">SystemChannels.lifecycle<\/a> notification is dispatched.<\/p>\n<p>The preferred way to watch for changes to this value is using\n<a href=\"widgets\/WidgetsBindingObserver\/didChangeAppLifecycleState.html\">WidgetsBindingObserver.didChangeAppLifecycleState<\/a>.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/lifecycleState.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">AppLifecycleState get lifecycleState =&gt; _lifecycleState;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "schedulerPhase",
            "type": "scheduler.SchedulerPhase",
            "types": [],
            "desc": "<p>The phase that the scheduler is currently operating under.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/schedulerPhase.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">SchedulerPhase get schedulerPhase =&gt; _schedulerPhase;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "schedulingStrategy",
            "type": "scheduler.SchedulingStrategy",
            "types": [],
            "desc": "<p>The strategy to use when deciding whether to run a task or not.<\/p>\n<p>Defaults to <a href=\"scheduler\/defaultSchedulingStrategy.html\">defaultSchedulingStrategy<\/a>.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/schedulingStrategy.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">SchedulingStrategy schedulingStrategy = defaultSchedulingStrategy\n\n<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "transientCallbackCount",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>The current number of transient frame callbacks scheduled.<\/p>\n<p>This is reset to zero just before all the currently scheduled\ntransient callbacks are called, at the start of a frame.<\/p>\n<p>This number is primarily exposed so that tests can verify that\nthere are no unexpected transient callbacks still registered\nafter a test's resources have been gracefully disposed.<\/p>\n        ",
            "memberOf": "scheduler.SchedulerBinding",
            "isConstant": false,
            "href": "scheduler\/SchedulerBinding\/transientCallbackCount.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get transientCallbackCount =&gt; _transientCallbacks.length;<\/code><\/pre>\n        ",
            "isDeprecated": false
        }
    ],
    "isMixin": true,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": false,
    "implementors": [],
    "realImplementors": [],
    "cn": [],
    "href": "scheduler\/SchedulerBinding-mixin.html",
    "desc": "<p>Scheduler for running the following:<\/p>\n<ul>\n<li>\n<p><em>Transient callbacks<\/em>, triggered by the system's <a href=\"dart-ui\/Window\/onBeginFrame.html\">Window.onBeginFrame<\/a>\ncallback, for synchronizing the application's behavior to the system's\ndisplay. For example, <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a>s and <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>s trigger from\nthese.<\/p>\n<\/li>\n<li>\n<p><em>Persistent callbacks<\/em>, triggered by the system's <a href=\"dart-ui\/Window\/onDrawFrame.html\">Window.onDrawFrame<\/a>\ncallback, for updating the system's display after transient callbacks have\nexecuted. For example, the rendering layer uses this to drive its\nrendering pipeline.<\/p>\n<\/li>\n<li>\n<p><em>Post-frame callbacks<\/em>, which are run after persistent callbacks, just\nbefore returning from the <a href=\"dart-ui\/Window\/onDrawFrame.html\">Window.onDrawFrame<\/a> callback.<\/p>\n<\/li>\n<li>\n<p>Non-rendering tasks, to be run between frames. These are given a\npriority and are executed in priority order according to a\n<a href=\"scheduler\/SchedulerBinding\/schedulingStrategy.html\">schedulingStrategy<\/a>.<\/p>\n<\/li>\n<\/ul>",
    "example": "",
    "isDeprecated": false,
    "dtype": "mixin",
    "shortname": "SchedulerBinding"
}