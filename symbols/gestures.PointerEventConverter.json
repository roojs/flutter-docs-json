{
    "desc": "<p>Converts from engine pointer data to framework pointer events.<\/p>\n<p>This takes <a href=\"dart-ui\/PointerDataPacket-class.html\">PointerDataPacket<\/a> objects, as received from the engine via\n<a href=\"dart-ui\/Window\/onPointerDataPacket.html\">dart:ui.Window.onPointerDataPacket<\/a>, and converts them to <a href=\"gestures\/PointerEvent-class.html\">PointerEvent<\/a>\nobjects.<\/p>\n    ",
    "dtype": "class",
    "example": "",
    "href": "gestures\/PointerEventConverter-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "memberOf": "gestures",
    "name": "gestures.PointerEventConverter",
    "shortname": "PointerEventConverter",
    "extends": [],
    "is_enum": false,
    "is_mixin": false,
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": "<p>Clears internal state mapping platform pointer identifiers to\n<a href=\"gestures\/PointerEvent-class.html\">PointerEvent<\/a> pointer identifiers.<\/p>\n<p>Visible only so that tests can reset the global state contained in\n<a href=\"gestures\/PointerEventConverter-class.html\">PointerEventConverter<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@visibleForTesting\nstatic void clearPointers() =&gt; _pointers.clear();<\/code><\/pre>\n    ",
            "href": "gestures\/PointerEventConverter\/clearPointers.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "clearPointers",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "gestures.PointerEventConverter",
            "params": []
        },
        {
            "desc": "<p>Expand the given packet of pointer data into a sequence of framework\npointer events.<\/p>\n<p>The <code>devicePixelRatio<\/code> argument (usually given the value from\n<a href=\"dart-ui\/Window\/devicePixelRatio.html\">dart:ui.Window.devicePixelRatio<\/a>) is used to convert the incoming data\nfrom physical coordinates to logical pixels. See the discussion at\n<a href=\"gestures\/PointerEvent-class.html\">PointerEvent<\/a> for more details on the <a href=\"gestures\/PointerEvent-class.html\">PointerEvent<\/a> coordinate space.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Iterable&lt;PointerEvent&gt; expand(Iterable&lt;ui.PointerData&gt; data, double devicePixelRatio) sync* {\n  for (ui.PointerData datum in data) {\n    final Offset position = Offset(datum.physicalX, datum.physicalY) \/ devicePixelRatio;\n    final double radiusMinor = _toLogicalPixels(datum.radiusMinor, devicePixelRatio);\n    final double radiusMajor = _toLogicalPixels(datum.radiusMajor, devicePixelRatio);\n    final double radiusMin = _toLogicalPixels(datum.radiusMin, devicePixelRatio);\n    final double radiusMax = _toLogicalPixels(datum.radiusMax, devicePixelRatio);\n    final Duration timeStamp = datum.timeStamp;\n    final PointerDeviceKind kind = datum.kind;\n    assert(datum.change != null);\n    if (datum.signalKind == null || datum.signalKind == ui.PointerSignalKind.none) {\n      switch (datum.change) {\n        case ui.PointerChange.add:\n          assert(!_pointers.containsKey(datum.device));\n          final _PointerState state = _ensureStateForPointer(datum, position);\n          assert(state.lastPosition == position);\n          yield PointerAddedEvent(\n            timeStamp: timeStamp,\n            kind: kind,\n            device: datum.device,\n            position: position,\n            obscured: datum.obscured,\n            pressureMin: datum.pressureMin,\n            pressureMax: datum.pressureMax,\n            distance: datum.distance,\n            distanceMax: datum.distanceMax,\n            radiusMin: radiusMin,\n            radiusMax: radiusMax,\n            orientation: datum.orientation,\n            tilt: datum.tilt,\n          );\n          break;\n        case ui.PointerChange.hover:\n          final bool alreadyAdded = _pointers.containsKey(datum.device);\n          final _PointerState state = _ensureStateForPointer(datum, position);\n          assert(!state.down);\n          if (!alreadyAdded) {\n            assert(state.lastPosition == position);\n            yield PointerAddedEvent(\n              timeStamp: timeStamp,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              obscured: datum.obscured,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distance: datum.distance,\n              distanceMax: datum.distanceMax,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n            );\n          }\n          final Offset offset = position - state.lastPosition;\n          state.lastPosition = position;\n          yield PointerHoverEvent(\n            timeStamp: timeStamp,\n            kind: kind,\n            device: datum.device,\n            position: position,\n            delta: offset,\n            buttons: datum.buttons,\n            obscured: datum.obscured,\n            pressureMin: datum.pressureMin,\n            pressureMax: datum.pressureMax,\n            distance: datum.distance,\n            distanceMax: datum.distanceMax,\n            size: datum.size,\n            radiusMajor: radiusMajor,\n            radiusMinor: radiusMinor,\n            radiusMin: radiusMin,\n            radiusMax: radiusMax,\n            orientation: datum.orientation,\n            tilt: datum.tilt,\n          );\n          state.lastPosition = position;\n          break;\n        case ui.PointerChange.down:\n          final bool alreadyAdded = _pointers.containsKey(datum.device);\n          final _PointerState state = _ensureStateForPointer(datum, position);\n          assert(!state.down);\n          if (!alreadyAdded) {\n            assert(state.lastPosition == position);\n            yield PointerAddedEvent(\n              timeStamp: timeStamp,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              obscured: datum.obscured,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distance: datum.distance,\n              distanceMax: datum.distanceMax,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n            );\n          }\n          if (state.lastPosition != position) {\n            \/\/ Not all sources of pointer packets respect the invariant that\n            \/\/ they hover the pointer to the down location before sending the\n            \/\/ down event. We restore the invariant here for our clients.\n            final Offset offset = position - state.lastPosition;\n            state.lastPosition = position;\n            yield PointerHoverEvent(\n              timeStamp: timeStamp,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              delta: offset,\n              buttons: datum.buttons,\n              obscured: datum.obscured,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distance: datum.distance,\n              distanceMax: datum.distanceMax,\n              size: datum.size,\n              radiusMajor: radiusMajor,\n              radiusMinor: radiusMinor,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n              synthesized: true,\n            );\n            state.lastPosition = position;\n          }\n          state.startNewPointer();\n          state.setDown();\n          yield PointerDownEvent(\n            timeStamp: timeStamp,\n            pointer: state.pointer,\n            kind: kind,\n            device: datum.device,\n            position: position,\n            buttons: datum.buttons,\n            obscured: datum.obscured,\n            pressure: datum.pressure,\n            pressureMin: datum.pressureMin,\n            pressureMax: datum.pressureMax,\n            distanceMax: datum.distanceMax,\n            size: datum.size,\n            radiusMajor: radiusMajor,\n            radiusMinor: radiusMinor,\n            radiusMin: radiusMin,\n            radiusMax: radiusMax,\n            orientation: datum.orientation,\n            tilt: datum.tilt,\n          );\n          break;\n        case ui.PointerChange.move:\n          \/\/ If the service starts supporting hover pointers, then it must also\n          \/\/ start sending us ADDED and REMOVED data points.\n          \/\/ See also: https:\/\/github.com\/flutter\/flutter\/issues\/720\n          assert(_pointers.containsKey(datum.device));\n          final _PointerState state = _pointers[datum.device];\n          assert(state.down);\n          final Offset offset = position - state.lastPosition;\n          state.lastPosition = position;\n          yield PointerMoveEvent(\n            timeStamp: timeStamp,\n            pointer: state.pointer,\n            kind: kind,\n            device: datum.device,\n            position: position,\n            delta: offset,\n            buttons: datum.buttons,\n            obscured: datum.obscured,\n            pressure: datum.pressure,\n            pressureMin: datum.pressureMin,\n            pressureMax: datum.pressureMax,\n            distanceMax: datum.distanceMax,\n            size: datum.size,\n            radiusMajor: radiusMajor,\n            radiusMinor: radiusMinor,\n            radiusMin: radiusMin,\n            radiusMax: radiusMax,\n            orientation: datum.orientation,\n            tilt: datum.tilt,\n            platformData: datum.platformData,\n          );\n          break;\n        case ui.PointerChange.up:\n        case ui.PointerChange.cancel:\n          assert(_pointers.containsKey(datum.device));\n          final _PointerState state = _pointers[datum.device];\n          assert(state.down);\n          if (position != state.lastPosition) {\n            \/\/ Not all sources of pointer packets respect the invariant that\n            \/\/ they move the pointer to the up location before sending the up\n            \/\/ event. For example, in the iOS simulator, of you drag outside the\n            \/\/ window, you'll get a stream of pointers that violates that\n            \/\/ invariant. We restore the invariant here for our clients.\n            final Offset offset = position - state.lastPosition;\n            state.lastPosition = position;\n            yield PointerMoveEvent(\n              timeStamp: timeStamp,\n              pointer: state.pointer,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              delta: offset,\n              buttons: datum.buttons,\n              obscured: datum.obscured,\n              pressure: datum.pressure,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distanceMax: datum.distanceMax,\n              size: datum.size,\n              radiusMajor: radiusMajor,\n              radiusMinor: radiusMinor,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n              synthesized: true,\n            );\n            state.lastPosition = position;\n          }\n          assert(position == state.lastPosition);\n          state.setUp();\n          if (datum.change == ui.PointerChange.up) {\n            yield PointerUpEvent(\n              timeStamp: timeStamp,\n              pointer: state.pointer,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              buttons: datum.buttons,\n              obscured: datum.obscured,\n              pressure: datum.pressure,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distance: datum.distance,\n              distanceMax: datum.distanceMax,\n              size: datum.size,\n              radiusMajor: radiusMajor,\n              radiusMinor: radiusMinor,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n            );\n          } else {\n            yield PointerCancelEvent(\n              timeStamp: timeStamp,\n              pointer: state.pointer,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              buttons: datum.buttons,\n              obscured: datum.obscured,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distance: datum.distance,\n              distanceMax: datum.distanceMax,\n              size: datum.size,\n              radiusMajor: radiusMajor,\n              radiusMinor: radiusMinor,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n            );\n          }\n          break;\n        case ui.PointerChange.remove:\n          assert(_pointers.containsKey(datum.device));\n          final _PointerState state = _pointers[datum.device];\n          if (state.down) {\n            yield PointerCancelEvent(\n              timeStamp: timeStamp,\n              pointer: state.pointer,\n              kind: kind,\n              device: datum.device,\n              position: position,\n              buttons: datum.buttons,\n              obscured: datum.obscured,\n              pressureMin: datum.pressureMin,\n              pressureMax: datum.pressureMax,\n              distance: datum.distance,\n              distanceMax: datum.distanceMax,\n              size: datum.size,\n              radiusMajor: radiusMajor,\n              radiusMinor: radiusMinor,\n              radiusMin: radiusMin,\n              radiusMax: radiusMax,\n              orientation: datum.orientation,\n              tilt: datum.tilt,\n            );\n          }\n          _pointers.remove(datum.device);\n          yield PointerRemovedEvent(\n            timeStamp: timeStamp,\n            kind: kind,\n            device: datum.device,\n            obscured: datum.obscured,\n            pressureMin: datum.pressureMin,\n            pressureMax: datum.pressureMax,\n            distanceMax: datum.distanceMax,\n            radiusMin: radiusMin,\n            radiusMax: radiusMax,\n          );\n          break;\n      }\n    } else {\n      switch (datum.signalKind) {\n        case ui.PointerSignalKind.scroll:\n          \/\/ Devices must be added before they send scroll events.\n          assert(_pointers.containsKey(datum.device));\n          final _PointerState state = _ensureStateForPointer(datum, position);\n          if (state.lastPosition != position) {\n            \/\/ Synthesize a hover\/move of the pointer to the scroll location\n            \/\/ before sending the scroll event, if necessary, so that clients\n            \/\/ don't have to worry about native ordering of hover and scroll\n            \/\/ events.\n            final Offset offset = position - state.lastPosition;\n            state.lastPosition = position;\n            if (state.down) {\n              yield PointerMoveEvent(\n                timeStamp: timeStamp,\n                pointer: state.pointer,\n                kind: kind,\n                device: datum.device,\n                position: position,\n                delta: offset,\n                buttons: datum.buttons,\n                obscured: datum.obscured,\n                pressureMin: datum.pressureMin,\n                pressureMax: datum.pressureMax,\n                distanceMax: datum.distanceMax,\n                size: datum.size,\n                radiusMajor: radiusMajor,\n                radiusMinor: radiusMinor,\n                radiusMin: radiusMin,\n                radiusMax: radiusMax,\n                orientation: datum.orientation,\n                tilt: datum.tilt,\n                synthesized: true,\n              );\n            } else {\n              yield PointerHoverEvent(\n                timeStamp: timeStamp,\n                kind: kind,\n                device: datum.device,\n                position: position,\n                delta: offset,\n                buttons: datum.buttons,\n                obscured: datum.obscured,\n                pressureMin: datum.pressureMin,\n                pressureMax: datum.pressureMax,\n                distance: datum.distance,\n                distanceMax: datum.distanceMax,\n                size: datum.size,\n                radiusMajor: radiusMajor,\n                radiusMinor: radiusMinor,\n                radiusMin: radiusMin,\n                radiusMax: radiusMax,\n                orientation: datum.orientation,\n                tilt: datum.tilt,\n                synthesized: true,\n              );\n            }\n          }\n          final Offset scrollDelta =\n              Offset(datum.scrollDeltaX, datum.scrollDeltaY) \/ devicePixelRatio;\n          yield PointerScrollEvent(\n            timeStamp: timeStamp,\n            kind: kind,\n            device: datum.device,\n            position: position,\n            scrollDelta: scrollDelta,\n          );\n          break;\n        case ui.PointerSignalKind.none:\n          assert(false); \/\/ This branch should already have 'none' filtered out.\n          break;\n        case ui.PointerSignalKind.unknown:\n          \/\/ Ignore unknown signals.\n          break;\n      }\n    }\n  }\n}<\/code><\/pre>\n    ",
            "href": "gestures\/PointerEventConverter\/expand.html",
            "isDeprecated": false,
            "type": "dart:core.Iterable<gestures.PointerEvent>",
            "name": "expand",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "gestures.PointerEventConverter",
            "params": [
                {
                    "name": "data",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Iterable<dart:ui.PointerData>"
                },
                {
                    "name": "devicePixelRatio",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.double"
                }
            ]
        }
    ],
    "props": []
}