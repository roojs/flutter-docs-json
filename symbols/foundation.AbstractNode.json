{
    "desc": "<p>An abstract node in a tree.<\/p>\n<p>AbstractNode has as notion of depth, attachment, and parent, but does not\nhave a model for children.<\/p>\n<p>When a subclass is changing the parent of a child, it should call either\n<code>parent.adoptChild(child)<\/code> or <code>parent.dropChild(child)<\/code> as appropriate.\nSubclasses can expose an API for manipulating the tree if desired (e.g. a\nsetter for a <code>child<\/code> property, or an <code>add()<\/code> method to manipulate a list).<\/p>\n<p>The current parent node is exposed by the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a> property.<\/p>\n<p>The current attachment state is exposed by <a href=\"foundation\/AbstractNode\/attached.html\">attached<\/a>. The root of any tree\nthat is to be considered attached should be manually attached by calling\n<a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a>. Other than that, the <a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a> and <a href=\"foundation\/AbstractNode\/detach.html\">detach<\/a> methods should not be\ncalled directly; attachment is managed automatically by the aforementioned\n<a href=\"foundation\/AbstractNode\/adoptChild.html\">adoptChild<\/a> and <a href=\"foundation\/AbstractNode\/dropChild.html\">dropChild<\/a> methods.<\/p>\n<p>Subclasses that have children must override <a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a> and <a href=\"foundation\/AbstractNode\/detach.html\">detach<\/a> as\ndescribed in the documentation for those methods.<\/p>\n<p>Nodes always have a <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> greater than their ancestors'. There's no\nguarantee regarding depth between siblings. The depth of a node is used to\nensure that nodes are processed in depth order. The <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> of a child can\nbe more than one greater than the <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> of the parent, because the <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a>\nvalues are never decreased: all that matters is that it's greater than the\nparent. Consider a tree with a root node A, a child B, and a grandchild C.\nInitially, A will have <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> 0, B <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> 1, and C <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> 2. If C is\nmoved to be a child of A, sibling of B, then the numbers won't change. C's\n<a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> will still be 2. The <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> is automatically maintained by the\n<a href=\"foundation\/AbstractNode\/adoptChild.html\">adoptChild<\/a> and <a href=\"foundation\/AbstractNode\/dropChild.html\">dropChild<\/a> methods.<\/p>\n    ",
    "dtype": "class",
    "example": "",
    "href": "foundation\/AbstractNode-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "memberOf": "foundation",
    "name": "foundation.AbstractNode",
    "shortname": "AbstractNode",
    "extends": [],
    "is_enum": false,
    "is_mixin": false,
    "realImplementors": [
        "rendering.AnnotatedRegionLayer",
        "rendering.BackdropFilterLayer",
        "rendering.ClipPathLayer",
        "rendering.ClipRRectLayer",
        "rendering.ClipRectLayer",
        "rendering.ContainerLayer",
        "rendering.FollowerLayer",
        "rendering.LeaderLayer",
        "rendering.OffsetLayer",
        "rendering.OpacityLayer",
        "rendering.PerformanceOverlayLayer",
        "rendering.PhysicalModelLayer",
        "rendering.PictureLayer",
        "rendering.PlatformViewLayer",
        "rendering.RenderAbsorbPointer",
        "rendering.RenderAndroidView",
        "rendering.RenderAnimatedOpacity",
        "rendering.RenderAnimatedSize",
        "rendering.RenderAnnotatedRegion",
        "rendering.RenderAspectRatio",
        "rendering.RenderBackdropFilter",
        "rendering.RenderBaseline",
        "rendering.RenderBlockSemantics",
        "rendering.RenderClipOval",
        "rendering.RenderClipPath",
        "rendering.RenderClipRRect",
        "rendering.RenderClipRect",
        "rendering.RenderConstrainedBox",
        "rendering.RenderConstrainedOverflowBox",
        "rendering.RenderCustomMultiChildLayoutBox",
        "rendering.RenderCustomPaint",
        "rendering.RenderCustomSingleChildLayoutBox",
        "rendering.RenderDecoratedBox",
        "rendering.RenderEditable",
        "rendering.RenderErrorBox",
        "rendering.RenderExcludeSemantics",
        "rendering.RenderFittedBox",
        "rendering.RenderFlex",
        "rendering.RenderFlow",
        "rendering.RenderFollowerLayer",
        "rendering.RenderFractionalTranslation",
        "rendering.RenderFractionallySizedOverflowBox",
        "rendering.RenderIgnorePointer",
        "rendering.RenderImage",
        "rendering.RenderIndexedSemantics",
        "rendering.RenderIndexedStack",
        "rendering.RenderIntrinsicHeight",
        "rendering.RenderIntrinsicWidth",
        "rendering.RenderLeaderLayer",
        "rendering.RenderLimitedBox",
        "rendering.RenderListBody",
        "rendering.RenderListWheelViewport",
        "rendering.RenderMergeSemantics",
        "rendering.RenderMetaData",
        "rendering.RenderOffstage",
        "rendering.RenderOpacity",
        "rendering.RenderPadding",
        "rendering.RenderParagraph",
        "rendering.RenderPerformanceOverlay",
        "rendering.RenderPhysicalModel",
        "rendering.RenderPhysicalShape",
        "rendering.RenderPointerListener",
        "rendering.RenderPositionedBox",
        "rendering.RenderProxyBox",
        "rendering.RenderRepaintBoundary",
        "rendering.RenderRotatedBox",
        "rendering.RenderSemanticsAnnotations",
        "rendering.RenderSemanticsGestureHandler",
        "rendering.RenderShaderMask",
        "rendering.RenderShrinkWrappingViewport",
        "rendering.RenderSizedOverflowBox",
        "rendering.RenderSliverFillRemaining",
        "rendering.RenderSliverFillViewport",
        "rendering.RenderSliverFixedExtentList",
        "rendering.RenderSliverGrid",
        "rendering.RenderSliverList",
        "rendering.RenderSliverPadding",
        "rendering.RenderSliverToBoxAdapter",
        "rendering.RenderStack",
        "rendering.RenderTable",
        "rendering.RenderTransform",
        "rendering.RenderUiKitView",
        "rendering.RenderUnconstrainedBox",
        "rendering.RenderView",
        "rendering.RenderViewport",
        "rendering.RenderWrap",
        "rendering.ShaderMaskLayer",
        "rendering.TextureBox",
        "rendering.TextureLayer",
        "rendering.TransformLayer",
        "semantics.SemanticsNode",
        "widgets.RenderNestedScrollViewViewport",
        "widgets.RenderSliverOverlapAbsorber",
        "widgets.RenderSliverOverlapInjector"
    ],
    "events": [],
    "methods": [
        {
            "desc": "",
            "example": "",
            "href": "foundation\/AbstractNode\/AbstractNode.html",
            "isDeprecated": false,
            "type": "",
            "name": "AbstractNode",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        },
        {
            "desc": "<p>Mark the given node as being a child of this node.<\/p>\n<p>Subclasses should call this function when they acquire a new child.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\n@mustCallSuper\nvoid adoptChild(covariant AbstractNode child) {\n  assert(child != null);\n  assert(child._parent == null);\n  assert(() {\n    AbstractNode node = this;\n    while (node.parent != null)\n      node = node.parent;\n    assert(node != child); \/\/ indicates we are about to create a cycle\n    return true;\n  }());\n  child._parent = this;\n  if (attached)\n    child.attach(_owner);\n  redepthChild(child);\n}<\/code><\/pre>\n    ",
            "href": "foundation\/AbstractNode\/adoptChild.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "adoptChild",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": [
                {
                    "name": "child",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "foundation.AbstractNode"
                }
            ]
        },
        {
            "desc": "<p>Mark this node as attached to the given owner.<\/p>\n<p>Typically called only from the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a>'s <a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a> method, and by the\n<code>owner<\/code> to mark the root of a tree as attached.<\/p>\n<p>Subclasses with children should override this method to first call their\ninherited <a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a> method, and then <a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a> all their children to the\nsame <code>owner<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@mustCallSuper\nvoid attach(covariant Object owner) {\n  assert(owner != null);\n  assert(_owner == null);\n  _owner = owner;\n}<\/code><\/pre>\n    ",
            "href": "foundation\/AbstractNode\/attach.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "attach",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": [
                {
                    "name": "owner",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Object"
                }
            ]
        },
        {
            "desc": "<p>Mark this node as detached.<\/p>\n<p>Typically called only from the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a>'s <a href=\"foundation\/AbstractNode\/detach.html\">detach<\/a>, and by the <a href=\"foundation\/AbstractNode\/owner.html\">owner<\/a> to\nmark the root of a tree as detached.<\/p>\n<p>Subclasses with children should override this method to first call their\ninherited <a href=\"foundation\/AbstractNode\/detach.html\">detach<\/a> method, and then <a href=\"foundation\/AbstractNode\/detach.html\">detach<\/a> all their children.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@mustCallSuper\nvoid detach() {\n  assert(_owner != null);\n  _owner = null;\n  assert(parent == null || attached == parent.attached);\n}<\/code><\/pre>\n    ",
            "href": "foundation\/AbstractNode\/detach.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "detach",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        },
        {
            "desc": "<p>Disconnect the given node from this node.<\/p>\n<p>Subclasses should call this function when they lose a child.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\n@mustCallSuper\nvoid dropChild(covariant AbstractNode child) {\n  assert(child != null);\n  assert(child._parent == this);\n  assert(child.attached == attached);\n  child._parent = null;\n  if (attached)\n    child.detach();\n}<\/code><\/pre>\n    ",
            "href": "foundation\/AbstractNode\/dropChild.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "dropChild",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": [
                {
                    "name": "child",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "foundation.AbstractNode"
                }
            ]
        },
        {
            "desc": "<p>Adjust the <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> of the given <code>child<\/code> to be greater than this node's own\n<a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a>.<\/p>\n<p>Only call this method from overrides of <a href=\"foundation\/AbstractNode\/redepthChildren.html\">redepthChildren<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid redepthChild(AbstractNode child) {\n  assert(child.owner == owner);\n  if (child._depth &lt;= _depth) {\n    child._depth = _depth + 1;\n    child.redepthChildren();\n  }\n}<\/code><\/pre>\n    ",
            "href": "foundation\/AbstractNode\/redepthChild.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "redepthChild",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": [
                {
                    "name": "child",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "foundation.AbstractNode"
                }
            ]
        },
        {
            "desc": "<p>Adjust the <a href=\"foundation\/AbstractNode\/depth.html\">depth<\/a> of this node's children, if any.<\/p>\n<p>Override this method in subclasses with child nodes to call <a href=\"foundation\/AbstractNode\/redepthChild.html\">redepthChild<\/a>\nfor each child. Do not call this method directly.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void redepthChildren() { }<\/code><\/pre>\n    ",
            "href": "foundation\/AbstractNode\/redepthChildren.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "redepthChildren",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        }
    ],
    "props": [
        {
            "desc": "<p>Whether this node is in a tree whose root is attached to something.<\/p>\n<p>This becomes true during the call to <a href=\"foundation\/AbstractNode\/attach.html\">attach<\/a>.<\/p>\n<p>This becomes false during the call to <a href=\"foundation\/AbstractNode\/detach.html\">detach<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get attached =&gt; _owner != null;<\/code><\/pre>\n        ",
            "href": "foundation\/AbstractNode\/attached.html",
            "name": "attached",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        },
        {
            "desc": "<p>The depth of this node in the tree.<\/p>\n<p>The depth of nodes in a tree monotonically increases as you traverse down\nthe tree.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get depth =&gt; _depth;<\/code><\/pre>\n        ",
            "href": "foundation\/AbstractNode\/depth.html",
            "name": "depth",
            "isDeprecated": false,
            "type": "dart:core.int",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        },
        {
            "desc": "<p>The owner for this node (null if unattached).<\/p>\n<p>The entire subtree that this node belongs to will have the same owner.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Object get owner =&gt; _owner;<\/code><\/pre>\n        ",
            "href": "foundation\/AbstractNode\/owner.html",
            "name": "owner",
            "isDeprecated": false,
            "type": "dart:core.Object",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        },
        {
            "desc": "<p>The parent of this node in the tree.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">AbstractNode get parent =&gt; _parent;<\/code><\/pre>\n        ",
            "href": "foundation\/AbstractNode\/parent.html",
            "name": "parent",
            "isDeprecated": false,
            "type": "foundation.AbstractNode",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "foundation.AbstractNode",
            "params": []
        }
    ]
}