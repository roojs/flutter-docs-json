{
    "desc": "<p>Render, onto a wheel, a bigger sequential set of objects inside this viewport.<\/p>\n<p>Takes a scrollable set of fixed sized <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>es and renders them\nsequentially from top down on a vertical scrolling axis.<\/p>\n<p>It starts with the first scrollable item in the center of the main axis\nand ends with the last scrollable item in the center of the main axis. This\nis in contrast to typical lists that start with the first scrollable item\nat the start of the main axis and ends with the last scrollable item at the\nend of the main axis.<\/p>\n<p>Instead of rendering its children on a flat plane, it renders them\nas if each child is broken into its own plane and that plane is\nperpendicularly fixed onto a cylinder which rotates along the scrolling\naxis.<\/p>\n<p>This class works in 3 coordinate systems:<\/p>\n<ol>\n<li>\n<p>The <strong>scrollable layout coordinates<\/strong>. This coordinate system is used to\ncommunicate with <a href=\"rendering\/ViewportOffset-class.html\">ViewportOffset<\/a> and describes its children's abstract\noffset from the beginning of the scrollable list at (0.0, 0.0).<\/p>\n<p>The list is scrollable from the start of the first child item to the\nstart of the last child item.<\/p>\n<p>Children's layout coordinates don't change as the viewport scrolls.<\/p>\n<\/li>\n<li>\n<p>The <strong>untransformed plane's viewport painting coordinates<\/strong>. Children are\nnot painted in this coordinate system. It's an abstract intermediary used\nbefore transforming into the next cylindrical coordinate system.<\/p>\n<p>This system is the <strong>scrollable layout coordinates<\/strong> translated by the\nscroll offset such that (0.0, 0.0) is the top left corner of the\nviewport.<\/p>\n<p>Because the viewport is centered at the scrollable list's scroll offset\ninstead of starting at the scroll offset, there are paintable children\n~1\/2 viewport length before and after the scroll offset instead of ~1\nviewport length after the scroll offset.<\/p>\n<p>Children's visibility inclusion in the viewport is determined in this\nsystem regardless of the cylinder's properties such as <a href=\"rendering\/RenderListWheelViewport\/diameterRatio.html\">diameterRatio<\/a>\nor <a href=\"rendering\/RenderListWheelViewport\/perspective.html\">perspective<\/a>. In other words, a 100px long viewport will always\npaint 10-11 visible 10px children if there are enough children in the\nviewport.<\/p>\n<\/li>\n<li>\n<p>The <strong>transformed cylindrical space viewport painting coordinates<\/strong>.\nChildren from system 2 get their positions transformed into a cylindrical\nprojection matrix instead of its Cartesian offset with respect to the\nscroll offset.<\/p>\n<p>Children in this coordinate system are painted.<\/p>\n<p>The wheel's size and the maximum and minimum visible angles are both\ncontrolled by <a href=\"rendering\/RenderListWheelViewport\/diameterRatio.html\">diameterRatio<\/a>. Children visible in the <strong>untransformed\nplane's viewport painting coordinates<\/strong>'s viewport will be radially\nevenly laid out between the maximum and minimum angles determined by\nintersecting the viewport's main axis length with a cylinder whose\ndiameter is <a href=\"rendering\/RenderListWheelViewport\/diameterRatio.html\">diameterRatio<\/a> times longer, as long as those angles are\nbetween -pi\/2 and pi\/2.<\/p>\n<p>For example, if <a href=\"rendering\/RenderListWheelViewport\/diameterRatio.html\">diameterRatio<\/a> is 2.0 and this <a href=\"rendering\/RenderListWheelViewport-class.html\">RenderListWheelViewport<\/a>\nis 100.0px in the main axis, then the diameter is 200.0. And children\nwill be evenly laid out between that cylinder's -arcsin(1\/2) and\narcsin(1\/2) angles.<\/p>\n<p>The cylinder's 0 degree side is always centered in the\n<a href=\"rendering\/RenderListWheelViewport-class.html\">RenderListWheelViewport<\/a>. The transformation from <strong>untransformed\nplane's viewport painting coordinates<\/strong> is also done such that the child\nin the center of that plane will be mostly untransformed with children\nabove and below it being transformed more as the angle increases.<\/p>\n<\/li>\n<\/ol>",
    "dtype": "class",
    "example": "",
    "href": "rendering\/RenderListWheelViewport-class.html",
    "isAbstract": "0",
    "isConstant": "0",
    "isDeprecated": "0",
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "rendering",
    "name": "rendering.RenderListWheelViewport",
    "shortname": "RenderListWheelViewport",
    "extends": [
        "rendering.RenderBox",
        "rendering.RenderObject",
        "foundation.AbstractNode",
        "dart:core.Object"
    ],
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": "<p>Creates a <a href=\"rendering\/RenderListWheelViewport-class.html\">RenderListWheelViewport<\/a> which renders children on a wheel.<\/p>\n<p>All arguments must not be null. Optional arguments have reasonable defaults.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RenderListWheelViewport({\n  @required this.childManager,\n  @required ViewportOffset offset,\n  double diameterRatio = defaultDiameterRatio,\n  double perspective = defaultPerspective,\n  double offAxisFraction = 0.0,\n  bool useMagnifier = false,\n  double magnification = 1.0,\n  @required double itemExtent,\n  bool clipToSize = true,\n  bool renderChildrenOutsideViewport = false,\n  List&lt;RenderBox&gt; children,\n}) : assert(childManager != null),\n     assert(offset != null),\n     assert(diameterRatio != null),\n     assert(diameterRatio &gt; 0, diameterRatioZeroMessage),\n     assert(perspective != null),\n     assert(perspective &gt; 0),\n     assert(perspective &lt;= 0.01, perspectiveTooHighMessage),\n     assert(offAxisFraction != null),\n     assert(useMagnifier != null),\n     assert(magnification != null),\n     assert(magnification &gt; 0),\n     assert(itemExtent != null),\n     assert(itemExtent &gt; 0),\n     assert(clipToSize != null),\n     assert(renderChildrenOutsideViewport != null),\n     assert(\n       !renderChildrenOutsideViewport || !clipToSize,\n       clipToSizeAndRenderChildrenOutsideViewportConflict,\n     ),\n     _offset = offset,\n     _diameterRatio = diameterRatio,\n     _perspective = perspective,\n     _offAxisFraction = offAxisFraction,\n     _useMagnifier = useMagnifier,\n     _magnification = magnification,\n     _itemExtent = itemExtent,\n     _clipToSize = clipToSize,\n     _renderChildrenOutsideViewport = renderChildrenOutsideViewport {\n  addAll(children);\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/RenderListWheelViewport.html",
            "isDeprecated": "0",
            "type": "",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "childManager",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "rendering.ListWheelChildManager"
                },
                {
                    "name": "children",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.List<rendering.RenderBox>"
                },
                {
                    "name": "clipToSize",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.bool"
                },
                {
                    "name": "diameterRatio",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "itemExtent",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "magnification",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "offAxisFraction",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "offset",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "rendering.ViewportOffset"
                },
                {
                    "name": "perspective",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.double"
                },
                {
                    "name": "renderChildrenOutsideViewport",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.bool"
                },
                {
                    "name": "useMagnifier",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": true,
                    "type": "dart:core.bool"
                }
            ]
        },
        {
            "desc": "<p>This returns the matrices relative to the <strong>untransformed plane's viewport\npainting coordinates<\/strong> system.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid applyPaintTransform(RenderBox child, Matrix4 transform) {\n  final ListWheelParentData parentData = child?.parentData;\n  transform.translate(0.0, _getUntransformedPaintingCoordinateY(parentData.offset.dy));\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/applyPaintTransform.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "child",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.RenderBox"
                },
                {
                    "name": "transform",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "vector_math_64.Matrix4"
                }
            ]
        },
        {
            "desc": "<p>Mark this node as attached to the given owner.<\/p>\n<p>Typically called only from the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a>'s <a href=\"rendering\/RenderListWheelViewport\/attach.html\">attach<\/a> method, and by the\n<code>owner<\/code> to mark the root of a tree as attached.<\/p>\n<p>Subclasses with children should override this method to first call their\ninherited <a href=\"rendering\/RenderListWheelViewport\/attach.html\">attach<\/a> method, and then <a href=\"rendering\/RenderListWheelViewport\/attach.html\">attach<\/a> all their children to the\nsame <code>owner<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid attach(PipelineOwner owner) {\n  super.attach(owner);\n  _offset.addListener(_hasScrolled);\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/attach.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "owner",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.PipelineOwner"
                }
            ]
        },
        {
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMaxIntrinsicHeight.html\">getMaxIntrinsicHeight<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMaxIntrinsicHeight.html\">getMaxIntrinsicHeight<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderListWheelViewport\/performLayout.html\">performLayout<\/a>. Should return the\nsmallest height beyond which increasing the height never decreases the\npreferred width. The preferred width is the value that would be returned\nby <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> for that height.<\/p>\n<p>If the layout algorithm is strictly width-in-height-out, or is\nwidth-in-height-out when the height is unconstrained, then this should\nreturn the same value as <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a> for the same width.<\/p>\n<p>Otherwise, the width argument should be ignored, and the returned value\nshould be equal to or bigger than the value returned by\n<a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a>.<\/p>\n<p>The <code>width<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>The value returned by this method might not match the size that the object\nwould actually take. For example, a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> subclass that always\nexactly sizes itself using <a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a> might well size itself\nbigger than its max intrinsic size.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<p>See also examples in the definition of <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMaxIntrinsicHeight(double width) {\n  if (childManager.childCount == null)\n    return 0.0;\n  return childManager.childCount * _itemExtent;\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/computeMaxIntrinsicHeight.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "width",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.double"
                }
            ]
        },
        {
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMaxIntrinsicWidth.html\">getMaxIntrinsicWidth<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMaxIntrinsicWidth.html\">getMaxIntrinsicWidth<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderListWheelViewport\/performLayout.html\">performLayout<\/a>. This should return\nthe smallest width beyond which increasing the width never decreases the\npreferred height. The preferred height is the value that would be returned\nby <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a> for that width.<\/p>\n<p>If the layout algorithm is strictly height-in-width-out, or is\nheight-in-width-out when the width is unconstrained, then this should\nreturn the same value as <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> for the same height.<\/p>\n<p>Otherwise, the height argument should be ignored, and the returned value\nshould be equal to or bigger than the value returned by\n<a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n<p>The <code>height<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>The value returned by this method might not match the size that the object\nwould actually take. For example, a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> subclass that always\nexactly sizes itself using <a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a> might well size itself\nbigger than its max intrinsic size.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<p>See also examples in the definition of <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMaxIntrinsicWidth(double height) {\n  return _getIntrinsicCrossAxis(\n    (RenderBox child) =&gt; child.getMaxIntrinsicWidth(height)\n  );\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/computeMaxIntrinsicWidth.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "height",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.double"
                }
            ]
        },
        {
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMinIntrinsicHeight.html\">getMinIntrinsicHeight<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMinIntrinsicHeight.html\">getMinIntrinsicHeight<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderListWheelViewport\/performLayout.html\">performLayout<\/a>. Should return the\nminimum height that this box could be without failing to correctly paint\nits contents within itself, without clipping.<\/p>\n<p>If the layout algorithm is independent of the context (e.g. it always\ntries to be a particular size), or if the layout algorithm is\nheight-in-width-out, or if the layout algorithm uses both the incoming\nheight and width constraints (e.g. it always sizes itself to\n<a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a>), then the <code>width<\/code> argument should be ignored.<\/p>\n<p>If the layout algorithm is strictly width-in-height-out, or is\nwidth-in-height-out when the height is unconstrained, then the width\nargument is the width to use.<\/p>\n<p>The <code>width<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<p>See also examples in the definition of <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMinIntrinsicHeight(double width) {\n  if (childManager.childCount == null)\n    return 0.0;\n  return childManager.childCount * _itemExtent;\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/computeMinIntrinsicHeight.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "width",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.double"
                }
            ]
        },
        {
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMinIntrinsicWidth.html\">getMinIntrinsicWidth<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMinIntrinsicWidth.html\">getMinIntrinsicWidth<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderListWheelViewport\/performLayout.html\">performLayout<\/a>. This method should\nreturn the minimum width that this box could be without failing to\ncorrectly paint its contents within itself, without clipping.<\/p>\n<p>If the layout algorithm is independent of the context (e.g. it always\ntries to be a particular size), or if the layout algorithm is\nwidth-in-height-out, or if the layout algorithm uses both the incoming\nwidth and height constraints (e.g. it always sizes itself to\n<a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a>), then the <code>height<\/code> argument should be ignored.<\/p>\n<p>If the layout algorithm is strictly height-in-width-out, or is\nheight-in-width-out when the width is unconstrained, then the height\nargument is the height to use.<\/p>\n<p>The <code>height<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<h2 id=\"examples\">Examples<\/h2>\n<h3 id=\"text\">Text<\/h3>\n<p>Text is the canonical example of a width-in-height-out algorithm. The\n<code>height<\/code> argument is therefore ignored.<\/p>\n<p>Consider the string \"Hello World\" The <em>maximum<\/em> intrinsic width (as\nreturned from <a href=\"rendering\/RenderListWheelViewport\/computeMaxIntrinsicWidth.html\">computeMaxIntrinsicWidth<\/a>) would be the width of the string\nwith no line breaks.<\/p>\n<p>The minimum intrinsic width would be the width of the widest word, \"Hello\"\nor \"World\". If the text is rendered in an even narrower width, however, it\nmight still not overflow. For example, maybe the rendering would put a\nline-break half-way through the words, as in \"Hel\u205elo\u205eWor\u205eld\". However,\nthis wouldn't be a <em>correct<\/em> rendering, and <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> is\nsupposed to render the minimum width that the box could be without failing\nto <em>correctly<\/em> paint the contents within itself.<\/p>\n<p>The minimum intrinsic <em>height<\/em> for a given width smaller than the minimum\nintrinsic width could therefore be greater than the minimum intrinsic\nheight for the minimum intrinsic width.<\/p>\n<h3 id=\"viewports-eg-scrolling-lists\">Viewports (e.g. scrolling lists)<\/h3>\n<p>Some render boxes are intended to clip their children. For example, the\nrender box for a scrolling list might always size itself to its parents'\nsize (or rather, to the maximum incoming constraints), regardless of the\nchildren's sizes, and then clip the children and position them based on\nthe current scroll offset.<\/p>\n<p>The intrinsic dimensions in these cases still depend on the children, even\nthough the layout algorithm sizes the box in a way independent of the\nchildren. It is the size that is needed to paint the box's contents (in\nthis case, the children) <em>without clipping<\/em> that matters.<\/p>\n<h3 id=\"when-the-intrinsic-dimensions-cannot-be-known\">When the intrinsic dimensions cannot be known<\/h3>\n<p>There are cases where render objects do not have an efficient way to\ncompute their intrinsic dimensions. For example, it may be prohibitively\nexpensive to reify and measure every child of a lazy viewport (viewports\ngenerally only instantiate the actually visible children), or the\ndimensions may be computed by a callback about which the render object\ncannot reason.<\/p>\n<p>In such cases, it may be impossible (or at least impractical) to actually\nreturn a valid answer. In such cases, the intrinsic functions should throw\nwhen <a href=\"rendering\/RenderObject\/debugCheckingIntrinsics.html\">RenderObject.debugCheckingIntrinsics<\/a> is false and asserts are\nenabled, and return 0.0 otherwise.<\/p>\n<p>See the implementations of <a href=\"widgets\/LayoutBuilder-class.html\">LayoutBuilder<\/a> or <a href=\"rendering\/RenderViewportBase-class.html\">RenderViewportBase<\/a> for\nexamples (in particular,\n<a href=\"rendering\/RenderViewportBase\/debugThrowIfNotCheckingIntrinsics.html\">RenderViewportBase.debugThrowIfNotCheckingIntrinsics<\/a>).<\/p>\n<h3 id=\"aspect-ratio-driven-boxes\">Aspect-ratio-driven boxes<\/h3>\n<p>Some boxes always return a fixed size based on the constraints. For these\nboxes, the intrinsic functions should return the appropriate size when the\nincoming <code>height<\/code> or <code>width<\/code> argument is finite, treating that as a tight\nconstraint in the respective direction and treating the other direction's\nconstraints as unbounded. This is because the definitions of\n<a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> and <a href=\"rendering\/RenderListWheelViewport\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a> are in terms of\nwhat the dimensions <em>could be<\/em>, and such boxes can only be one size in\nsuch cases.<\/p>\n<p>When the incoming argument is not finite, then they should return the\nactual intrinsic dimensions based on the contents, as any other box would.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMinIntrinsicWidth(double height) {\n  return _getIntrinsicCrossAxis(\n    (RenderBox child) =&gt; child.getMinIntrinsicWidth(height)\n  );\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/computeMinIntrinsicWidth.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "height",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.double"
                }
            ]
        },
        {
            "desc": "<p>Returns a rect in this object's coordinate system that describes\nthe approximate bounding box of the clip rect that would be\napplied to the given child during the paint phase, if any.<\/p>\n<p>Returns null if the child would not be clipped.<\/p>\n<p>This is used in the semantics phase to avoid including children\nthat are not physically visible.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nRect describeApproximatePaintClip(RenderObject child) {\n  if (child != null &amp;&amp; _shouldClipAtCurrentOffset()) {\n    return Offset.zero &amp; size;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/describeApproximatePaintClip.html",
            "isDeprecated": "0",
            "type": "dart:ui.Rect",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "child",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.RenderObject"
                }
            ]
        },
        {
            "desc": "<p>Mark this node as detached.<\/p>\n<p>Typically called only from the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a>'s <a href=\"rendering\/RenderListWheelViewport\/detach.html\">detach<\/a>, and by the <a href=\"rendering\/RenderObject\/owner.html\">owner<\/a> to\nmark the root of a tree as detached.<\/p>\n<p>Subclasses with children should override this method to first call their\ninherited <a href=\"rendering\/RenderListWheelViewport\/detach.html\">detach<\/a> method, and then <a href=\"rendering\/RenderListWheelViewport\/detach.html\">detach<\/a> all their children.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid detach() {\n  _offset.removeListener(_hasScrolled);\n  super.detach();\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/detach.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Returns the offset that would be needed to reveal the <code>target<\/code>\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a>.<\/p>\n<p>The optional <code>rect<\/code> parameter describes which area of that <code>target<\/code> object\nshould be revealed in the viewport. If <code>rect<\/code> is null, the entire\n<code>target<\/code> <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> (as defined by its <a href=\"rendering\/RenderBox\/paintBounds.html\">RenderObject.paintBounds<\/a>)\nwill be revealed. If <code>rect<\/code> is provided it has to be given in the\ncoordinate system of the <code>target<\/code> object.<\/p>\n<p>The <code>alignment<\/code> argument describes where the target should be positioned\nafter applying the returned offset. If <code>alignment<\/code> is 0.0, the child must\nbe positioned as close to the leading edge of the viewport as possible. If\n<code>alignment<\/code> is 1.0, the child must be positioned as close to the trailing\nedge of the viewport as possible. If <code>alignment<\/code> is 0.5, the child must be\npositioned as close to the center of the viewport as possible.<\/p>\n<p>The <code>target<\/code> might not be a direct child of this viewport but it must be a\ndescendant of the viewport. Other viewports in between this viewport and\nthe <code>target<\/code> will not be adjusted.<\/p>\n<p>This method assumes that the content of the viewport moves linearly, i.e.\nwhen the offset of the viewport is changed by x then <code>target<\/code> also moves\nby x within the viewport.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"rendering\/RevealedOffset-class.html\">RevealedOffset<\/a>, which describes the return value of this method.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nRevealedOffset getOffsetToReveal(RenderObject target, double alignment, { Rect rect }) {\n  \/\/ `target` is only fully revealed when in the selected\/center position. Therefore,\n  \/\/ this method always returns the offset that shows `target` in the center position,\n  \/\/ which is the same offset for all `alignment` values.\n\n  rect ??= target.paintBounds;\n\n  \/\/ `child` will be the last RenderObject before the viewport when walking up from `target`.\n  RenderObject child = target;\n  while (child.parent != this)\n    child = child.parent;\n\n  final ListWheelParentData parentData = child.parentData;\n  final double targetOffset = parentData.offset.dy; \/\/ the so-called \"centerPosition\"\n\n  final Matrix4 transform = target.getTransformTo(this);\n  final Rect bounds = MatrixUtils.transformRect(transform, rect);\n  final Rect targetRect = bounds.translate(0.0, (size.height - itemExtent) \/ 2);\n\n  return RevealedOffset(offset: targetOffset, rect: targetRect);\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/getOffsetToReveal.html",
            "isDeprecated": "0",
            "type": "rendering.RevealedOffset",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "alignment",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.double"
                },
                {
                    "name": "rect",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:ui.Rect"
                },
                {
                    "name": "target",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.RenderObject"
                }
            ]
        },
        {
            "desc": "<p>Override this method to check whether any children are located at the\ngiven position.<\/p>\n<p>Typically children should be hit-tested in reverse paint order so that\nhit tests at locations where children overlap hit the child that is\nvisually \"on top\" (i.e., paints later).<\/p>\n<p>The caller is responsible for transforming <code>position<\/code> from global\ncoordinates to its location relative to the origin of this <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>.\nThis <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> is responsible for checking whether the given position is\nwithin its bounds.<\/p>\n<p>Used by <a href=\"rendering\/RenderBox\/hitTest.html\">hitTest<\/a>. If you override <a href=\"rendering\/RenderBox\/hitTest.html\">hitTest<\/a> and do not call this\nfunction, then you don't need to implement this function.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool hitTestChildren(HitTestResult result, { Offset position }) {\n  return false;\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/hitTestChildren.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "position",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:ui.Offset"
                },
                {
                    "name": "result",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "gestures.HitTestResult"
                }
            ]
        },
        {
            "desc": "<p>Gets the index of a child by looking at its parentData.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">int indexOf(RenderBox child) {\n  assert(child != null);\n  final ListWheelParentData childParentData = child.parentData;\n  assert(childParentData.index != null);\n  return childParentData.index;\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/indexOf.html",
            "isDeprecated": "0",
            "type": "dart:core.int",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "child",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.RenderBox"
                }
            ]
        },
        {
            "desc": "<p>Returns the scroll offset of the child with the given index.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">double indexToScrollOffset(int index) =&gt; index * itemExtent;<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/indexToScrollOffset.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "index",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.int"
                }
            ]
        },
        {
            "desc": "<p>Paint this render object into the given context at the given offset.<\/p>\n<p>Subclasses should override this method to provide a visual appearance\nfor themselves. The render object's local coordinate system is\naxis-aligned with the coordinate system of the context's canvas and the\nrender object's local origin (i.e, x=0 and y=0) is placed at the given\noffset in the context's canvas.<\/p>\n<p>Do not call this function directly. If you wish to paint yourself, call\n<a href=\"rendering\/RenderObject\/markNeedsPaint.html\">markNeedsPaint<\/a> instead to schedule a call to this function. If you wish\nto paint one of your children, call <a href=\"rendering\/PaintingContext\/paintChild.html\">PaintingContext.paintChild<\/a> on the\ngiven <code>context<\/code>.<\/p>\n<p>When painting one of your children (via a paint child function on the\ngiven context), the current canvas held by the context might change\nbecause draw operations before and after painting children might need to\nbe recorded on separate compositing layers.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(PaintingContext context, Offset offset) {\n  if (childCount &gt; 0) {\n    if (_clipToSize &amp;&amp; _shouldClipAtCurrentOffset()) {\n      context.pushClipRect(\n        needsCompositing,\n        offset,\n        Offset.zero &amp; size,\n        _paintVisibleChildren,\n      );\n    } else {\n      _paintVisibleChildren(context, offset);\n    }\n  }\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/paint.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "context",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.PaintingContext"
                },
                {
                    "name": "offset",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:ui.Offset"
                }
            ]
        },
        {
            "desc": "<p>Performs layout based on how <a href=\"rendering\/RenderListWheelViewport\/childManager.html\">childManager<\/a> provides children.<\/p>\n<p>From the current scroll offset, the minimum index and maximum index that\nis visible in the viewport can be calculated. The index range of the\ncurrently active children can also be acquired by looking directly at\nthe current child list. This function has to modify the current index\nrange to match the target index range by removing children that are no\nlonger visible and creating those that are visible but not yet provided\nby <a href=\"rendering\/RenderListWheelViewport\/childManager.html\">childManager<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid performLayout() {\n  final BoxConstraints childConstraints =\n    constraints.copyWith(\n      minHeight: _itemExtent,\n      maxHeight: _itemExtent,\n      minWidth: 0.0,\n    );\n\n  \/\/ The height, in pixel, that children will be visible and might be laid out\n  \/\/ and painted.\n  double visibleHeight = size.height;\n  \/\/ If renderChildrenOutsideViewport is true, we spawn extra children by\n  \/\/ doubling the visibility range, those that are in the backside of the\n  \/\/ cylinder won't be painted anyway.\n  if (renderChildrenOutsideViewport)\n    visibleHeight *= 2;\n\n  final double firstVisibleOffset =\n      offset.pixels + _itemExtent \/ 2 - visibleHeight \/ 2;\n  final double lastVisibleOffset = firstVisibleOffset + visibleHeight;\n\n  \/\/ The index range that we want to spawn children. We find indexes that\n  \/\/ are in the interval [firstVisibleOffset, lastVisibleOffset).\n  int targetFirstIndex = scrollOffsetToIndex(firstVisibleOffset);\n  int targetLastIndex = scrollOffsetToIndex(lastVisibleOffset);\n  \/\/ Because we exclude lastVisibleOffset, if there's a new child starting at\n  \/\/ that offset, it is removed.\n  if (targetLastIndex * _itemExtent == lastVisibleOffset)\n    targetLastIndex--;\n\n  \/\/ Validates the target index range.\n  while (!childManager.childExistsAt(targetFirstIndex) &amp;&amp; targetFirstIndex &lt;= targetLastIndex)\n    targetFirstIndex++;\n  while (!childManager.childExistsAt(targetLastIndex) &amp;&amp; targetFirstIndex &lt;= targetLastIndex)\n    targetLastIndex--;\n\n  \/\/ If it turns out there's no children to layout, we remove old children and\n  \/\/ return.\n  if (targetFirstIndex &gt; targetLastIndex) {\n    while (firstChild != null)\n      _destroyChild(firstChild);\n    return;\n  }\n\n  \/\/ Now there are 2 cases:\n  \/\/  - The target index range and our current index range have intersection:\n  \/\/    We shorten and extend our current child list so that the two lists\n  \/\/    match. Most of the time we are in this case.\n  \/\/  - The target list and our current child list have no intersection:\n  \/\/    We first remove all children and then add one child from the target\n  \/\/    list =&gt; this case becomes the other case.\n\n  \/\/ Case when there is no intersection.\n  if (childCount &gt; 0 &amp;&amp;\n      (indexOf(firstChild) &gt; targetLastIndex || indexOf(lastChild) &lt; targetFirstIndex)) {\n    while (firstChild != null)\n      _destroyChild(firstChild);\n  }\n\n  \/\/ If there is no child at this stage, we add the first one that is in\n  \/\/ target range.\n  if (childCount == 0) {\n    _createChild(targetFirstIndex);\n    _layoutChild(firstChild, childConstraints, targetFirstIndex);\n  }\n\n  int currentFirstIndex = indexOf(firstChild);\n  int currentLastIndex = indexOf(lastChild);\n\n  \/\/ Remove all unnecessary children by shortening the current child list, in\n  \/\/ both directions.\n  while (currentFirstIndex &lt; targetFirstIndex) {\n    _destroyChild(firstChild);\n    currentFirstIndex++;\n  }\n  while (currentLastIndex &gt; targetLastIndex) {\n    _destroyChild(lastChild);\n    currentLastIndex--;\n  }\n\n  \/\/ Relayout all active children.\n  RenderBox child = firstChild;\n  while (child != null) {\n    child.layout(childConstraints, parentUsesSize: true);\n    child = childAfter(child);\n  }\n\n  \/\/ Spawning new children that are actually visible but not in child list yet.\n  while (currentFirstIndex &gt; targetFirstIndex) {\n    _createChild(currentFirstIndex - 1);\n    _layoutChild(firstChild, childConstraints, --currentFirstIndex);\n  }\n  while (currentLastIndex &lt; targetLastIndex) {\n    _createChild(currentLastIndex + 1, after: lastChild);\n    _layoutChild(lastChild, childConstraints, ++currentLastIndex);\n  }\n\n  offset.applyViewportDimension(_viewportExtent);\n\n  \/\/ Applying content dimensions bases on how the childManager builds widgets:\n  \/\/ if it is available to provide a child just out of target range, then\n  \/\/ we don't know whether there's a limit yet, and set the dimension to the\n  \/\/ estimated value. Otherwise, we set the dimension limited to our target\n  \/\/ range.\n  final double minScrollExtent = childManager.childExistsAt(targetFirstIndex - 1)\n    ? _minEstimatedScrollExtent\n    : indexToScrollOffset(targetFirstIndex);\n  final double maxScrollExtent = childManager.childExistsAt(targetLastIndex + 1)\n      ? _maxEstimatedScrollExtent\n      : indexToScrollOffset(targetLastIndex);\n  offset.applyContentDimensions(minScrollExtent, maxScrollExtent);\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/performLayout.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Updates the render objects size using only the constraints.<\/p>\n<p>Do not call this function directly: call <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> instead. This function\nis called by <a href=\"rendering\/RenderObject\/layout.html\">layout<\/a> when there is actually work to be done by this\nrender object during layout. The layout constraints provided by your\nparent are available via the <a href=\"rendering\/RenderBox\/constraints.html\">constraints<\/a> getter.<\/p>\n<p>Subclasses that set <a href=\"rendering\/RenderListWheelViewport\/sizedByParent.html\">sizedByParent<\/a> to true should override this method\nto compute their size.<\/p>\n<p>This function is called only if <a href=\"rendering\/RenderListWheelViewport\/sizedByParent.html\">sizedByParent<\/a> is true.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid performResize() {\n  size = constraints.biggest;\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/performResize.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Returns the index of the child at the given offset.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">int scrollOffsetToIndex(double scrollOffset) =&gt; (scrollOffset \/ itemExtent).floor();<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/scrollOffsetToIndex.html",
            "isDeprecated": "0",
            "type": "dart:core.int",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "scrollOffset",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.double"
                }
            ]
        },
        {
            "desc": "<p>Override to setup parent data correctly for your children.<\/p>\n<p>You can call this function to set up the parent data for child before the\nchild is added to the parent's child list.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid setupParentData(RenderObject child) {\n  if (child.parentData is! ListWheelParentData)\n    child.parentData = ListWheelParentData();\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/setupParentData.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "child",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.RenderObject"
                }
            ]
        },
        {
            "desc": "<p>Attempt to make (a portion of) this or a descendant <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> visible\non screen.<\/p>\n<p>If <code>descendant<\/code> is provided, that <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> is made visible. If\n<code>descendant<\/code> is omitted, this <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> is made visible.<\/p>\n<p>The optional <code>rect<\/code> parameter describes which area of that <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a>\nshould be shown on screen. If <code>rect<\/code> is null, the entire\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> (as defined by its <a href=\"rendering\/RenderBox\/paintBounds.html\">paintBounds<\/a>) will be revealed. The\n<code>rect<\/code> parameter is interpreted relative to the coordinate system of\n<code>descendant<\/code> if that argument is provided and relative to this\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> otherwise.<\/p>\n<p>The <code>duration<\/code> parameter can be set to a non-zero value to bring the\ntarget object on screen in an animation defined by <code>curve<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid showOnScreen({\n  RenderObject descendant,\n  Rect rect,\n  Duration duration = Duration.zero,\n  Curve curve = Curves.ease,\n}) {\n  if (descendant != null) {\n    \/\/ Shows the descendant in the selected\/center position.\n    final RevealedOffset revealedOffset = getOffsetToReveal(descendant, 0.5, rect: rect);\n    if (duration == Duration.zero) {\n      offset.jumpTo(revealedOffset.offset);\n    } else {\n      offset.animateTo(revealedOffset.offset, duration: duration, curve: curve);\n    }\n    rect = revealedOffset.rect;\n  }\n\n  super.showOnScreen(\n    rect: rect,\n    duration: duration,\n    curve: curve,\n  );\n}<\/code><\/pre>\n    ",
            "href": "rendering\/RenderListWheelViewport\/showOnScreen.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "rendering.RenderListWheelViewport",
            "params": [
                {
                    "name": "curve",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "animation.Curve"
                },
                {
                    "name": "descendant",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "rendering.RenderObject"
                },
                {
                    "name": "duration",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "rect",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:ui.Rect"
                }
            ]
        }
    ],
    "props": [
        {
            "desc": "<p>The delegate that manages the children of this object.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ListWheelChildManager childManager\n\n<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/childManager.html",
            "isDeprecated": "0",
            "type": "rendering.ListWheelChildManager",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Whether to clip painted children to the inside of this viewport.<\/p>\n<p>Defaults to <code>true<\/code>. Must not be null.<\/p>\n<p>If this is false and <a href=\"rendering\/RenderListWheelViewport\/renderChildrenOutsideViewport.html\">renderChildrenOutsideViewport<\/a> is false, the\nfirst and last children may be painted partly outside of this scroll view.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get clipToSize =&gt; _clipToSize;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/clipToSize.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>A ratio between the diameter of the cylinder and the viewport's size\nin the main axis.<\/p>\n<p>A value of 1 means the cylinder has the same diameter as the viewport's\nsize.<\/p>\n<p>A value smaller than 1 means items at the edges of the cylinder are\nentirely contained inside the viewport.<\/p>\n<p>A value larger than 1 means angles less than \u00b1<a href=\"dart-math\/pi-constant.html\">pi<\/a> \/ 2 from the\ncenter of the cylinder are visible.<\/p>\n<p>The same number of children will be visible in the viewport regardless of\nthe <a href=\"rendering\/RenderListWheelViewport\/diameterRatio.html\">diameterRatio<\/a>. The number of children visible is based on the\nviewport's length along the main axis divided by the children's\n<a href=\"rendering\/RenderListWheelViewport\/itemExtent.html\">itemExtent<\/a>. Then the children are evenly distributed along the visible\nangles up to \u00b1<a href=\"dart-math\/pi-constant.html\">pi<\/a> \/ 2.<\/p>\n<p>Just as it's impossible to stretch a paper to cover the an entire\nhalf of a cylinder's surface where the cylinder has the same diameter\nas the paper's length, choosing a <a href=\"rendering\/RenderListWheelViewport\/diameterRatio.html\">diameterRatio<\/a> smaller than <a href=\"dart-math\/pi-constant.html\">pi<\/a>\nwill leave same gaps between the children.<\/p>\n<p>Defaults to an arbitrary but aesthetically reasonable number of 2.0.<\/p>\n<p>Must not be null and must be positive.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get diameterRatio =&gt; _diameterRatio;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/diameterRatio.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Whether this render object repaints separately from its parent.<\/p>\n<p>Override this in subclasses to indicate that instances of your class ought\nto repaint independently. For example, render objects that repaint\nfrequently might want to repaint themselves without requiring their parent\nto repaint.<\/p>\n<p>If this getter returns true, the <a href=\"rendering\/RenderBox\/paintBounds.html\">paintBounds<\/a> are applied to this object\nand all descendants.<\/p>\n<p>Warning: This getter must not change value over the lifetime of this object.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isRepaintBoundary =&gt; true;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/isRepaintBoundary.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>The size of the children along the main axis. Children <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>es will\nbe given the <a href=\"rendering\/BoxConstraints-class.html\">BoxConstraints<\/a> of this exact size.<\/p>\n<p>Must not be null and must be positive.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get itemExtent =&gt; _itemExtent;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/itemExtent.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>The zoomed-in rate of the magnifier, if it is used.<\/p>\n<p>The default value is 1.0, which will not change anything.\nIf the value is &gt; 1.0, the center item will be zoomed in by that rate, and\nit will also be rendered as flat, not cylindrical like the rest of the list.\nThe item will be zoomed out if magnification &lt; 1.0.<\/p>\n<p>Must be positive.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get magnification =&gt; _magnification;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/magnification.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>How much the wheel is horizontally off-center, as a fraction of its width.\nThis property creates the visual effect of looking at a vertical wheel from\nits side where its vanishing points at the edge curves to one side instead\nof looking at the wheel head-on.<\/p>\n<p>The value is horizontal distance between the wheel's center and the vertical\nvanishing line at the edges of the wheel, represented as a fraction of the\nwheel's width.<\/p>\n<p>The value <code>0.0<\/code> means the wheel is looked at head-on and its vanishing\nline runs through the center of the wheel. Negative values means moving\nthe wheel to the left of the observer, thus the edges curve to the right.\nPositive values means moving the wheel to the right of the observer,\nthus the edges curve to the left.<\/p>\n<p>The visual effect causes the wheel's edges to curve rather than moving\nthe center. So a value of <code>0.5<\/code> means the edges' vanishing line will touch\nthe wheel's size's left edge.<\/p>\n<p>Defaults to 0.0, which means looking at the wheel head-on.\nThe visual effect can be unaesthetic if this value is too far from the\nrange <code>-0.5, 0.5<\/code>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">\/\/\/ This property creates the visual effect of looking at a vertical wheel from\n\/\/\/ its side where its vanishing points at the edge curves to one side instead\n\/\/\/ of looking at the wheel head-on.\n\/\/\/\n\/\/\/ The value is horizontal distance between the wheel's center and the vertical\n\/\/\/ vanishing line at the edges of the wheel, represented as a fraction of the\n\/\/\/ wheel's width.\n\/\/\/\n\/\/\/ The value `0.0` means the wheel is looked at head-on and its vanishing\n\/\/\/ line runs through the center of the wheel. Negative values means moving\n\/\/\/ the wheel to the left of the observer, thus the edges curve to the right.\n\/\/\/ Positive values means moving the wheel to the right of the observer,\n\/\/\/ thus the edges curve to the left.\n\/\/\/\n\/\/\/ The visual effect causes the wheel's edges to curve rather than moving\n\/\/\/ the center. So a value of `0.5` means the edges' vanishing line will touch\n\/\/\/ the wheel's size's left edge.\n\/\/\/\n\/\/\/ Defaults to 0.0, which means looking at the wheel head-on.\n\/\/\/ The visual effect can be unaesthetic if this value is too far from the\n\/\/\/ range [-0.5, 0.5].\n\/\/\/ {@endtemplate}\ndouble get offAxisFraction =&gt; _offAxisFraction;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/offAxisFraction.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>The associated ViewportOffset object for the viewport describing the part\nof the content inside that's visible.<\/p>\n<p>The <a href=\"rendering\/ViewportOffset\/pixels.html\">ViewportOffset.pixels<\/a> value determines the scroll offset that the\nviewport uses to select which part of its content to display. As the user\nscrolls the viewport, this value changes, which changes the content that\nis displayed.<\/p>\n<p>Must not be null.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ViewportOffset get offset =&gt; _offset;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/offset.html",
            "isDeprecated": "0",
            "type": "rendering.ViewportOffset",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Perspective of the cylindrical projection.<\/p>\n<p>A number between 0 and 0.01 where 0 means looking at the cylinder from\ninfinitely far with an infinitely small field of view and 1 means looking\nat the cylinder from infinitely close with an infinitely large field of\nview (which cannot be rendered).<\/p>\n<p>Defaults to an arbitrary but aesthetically reasonable number of 0.003.\nA larger number brings the vanishing point closer and a smaller number\npushes the vanishing point further.<\/p>\n<p>Must not be null and must be positive.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get perspective =&gt; _perspective;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/perspective.html",
            "isDeprecated": "0",
            "type": "dart:core.double",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Whether to paint children inside the viewport only.<\/p>\n<p>If false, every child will be painted. However the <a href=\"widgets\/Scrollable-class.html\">Scrollable<\/a> is still\nthe size of the viewport and detects gestures inside only.<\/p>\n<p>Defaults to <code>false<\/code>. Must not be null. Cannot be true if <a href=\"rendering\/RenderListWheelViewport\/clipToSize.html\">clipToSize<\/a>\nis also true since children outside the viewport will be clipped, and\ntherefore cannot render children outside the viewport.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get renderChildrenOutsideViewport =&gt; _renderChildrenOutsideViewport;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/renderChildrenOutsideViewport.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Whether the constraints are the only input to the sizing algorithm (in\nparticular, child nodes have no impact).<\/p>\n<p>Returning false is always correct, but returning true can be more\nefficient when computing the size of this render object because we don't\nneed to recompute the size if the constraints don't change.<\/p>\n<p>Typically, subclasses will always return the same value. If the value can\nchange, then, when it does change, the subclass should make sure to call\n<a href=\"rendering\/RenderObject\/markNeedsLayoutForSizedByParentChange.html\">markNeedsLayoutForSizedByParentChange<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get sizedByParent =&gt; true;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/sizedByParent.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        },
        {
            "desc": "<p>Whether to use the magnifier for the center item of the wheel.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get useMagnifier =&gt; _useMagnifier;<\/code><\/pre>\n        ",
            "href": "rendering\/RenderListWheelViewport\/useMagnifier.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "rendering.RenderListWheelViewport",
            "params": []
        }
    ]
}