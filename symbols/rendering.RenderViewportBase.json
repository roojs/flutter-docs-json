{
    "name": "rendering.RenderViewportBase",
    "extends": [
        "rendering.RenderBox",
        "rendering.RenderObject",
        "foundation.AbstractNode",
        "dart:core.Object"
    ],
    "memberOf": "rendering",
    "events": [],
    "methods": [
        {
            "name": "RenderViewportBase",
            "type": "",
            "desc": "<p>Initializes fields for subclasses.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "axisDirection",
                    "type": "painting.AxisDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "crossAxisDirection",
                    "type": "painting.AxisDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "offset",
                    "type": "rendering.ViewportOffset",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "cacheExtent",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "rendering\/RenderViewportBase\/RenderViewportBase.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RenderViewportBase({\n  AxisDirection axisDirection = AxisDirection.down,\n  @required AxisDirection crossAxisDirection,\n  @required ViewportOffset offset,\n  double cacheExtent,\n}) : assert(axisDirection != null),\n     assert(crossAxisDirection != null),\n     assert(offset != null),\n     assert(axisDirectionToAxis(axisDirection) != axisDirectionToAxis(crossAxisDirection)),\n     _axisDirection = axisDirection,\n     _crossAxisDirection = crossAxisDirection,\n     _offset = offset,\n     _cacheExtent = cacheExtent ?? RenderAbstractViewport.defaultCacheExtent;<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "attach",
            "type": "",
            "desc": "<p>Mark this node as attached to the given owner.<\/p>\n<p>Typically called only from the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a>'s <a href=\"rendering\/RenderViewportBase\/attach.html\">attach<\/a> method, and by the\n<code>owner<\/code> to mark the root of a tree as attached.<\/p>\n<p>Subclasses with children should override this method to first call their\ninherited <a href=\"rendering\/RenderViewportBase\/attach.html\">attach<\/a> method, and then <a href=\"rendering\/RenderViewportBase\/attach.html\">attach<\/a> all their children to the\nsame <code>owner<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "owner",
                    "type": "rendering.PipelineOwner",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/attach.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid attach(PipelineOwner owner) {\n  super.attach(owner);\n  _offset.addListener(markNeedsLayout);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "computeAbsolutePaintOffset",
            "type": "dart:ui.Offset",
            "desc": "<p>The offset at which the given <code>child<\/code> should be painted.<\/p>\n<p>The returned offset is from the top left corner of the inside of the\nviewport to the top left corner of the paint coordinate system of the\n<code>child<\/code>.<\/p>\n<p>See also <a href=\"rendering\/RenderViewportBase\/paintOffsetOf.html\">paintOffsetOf<\/a>, which uses the layout offset and growth\ndirection computed for the child during layout.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "layoutOffset",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "growthDirection",
                    "type": "rendering.GrowthDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/computeAbsolutePaintOffset.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nOffset computeAbsolutePaintOffset(RenderSliver child, double layoutOffset, GrowthDirection growthDirection) {\n  assert(hasSize); \/\/ this is only usable once we have a size\n  assert(axisDirection != null);\n  assert(growthDirection != null);\n  assert(child != null);\n  assert(child.geometry != null);\n  switch (applyGrowthDirectionToAxisDirection(axisDirection, growthDirection)) {\n    case AxisDirection.up:\n      return Offset(0.0, size.height - (layoutOffset + child.geometry.paintExtent));\n    case AxisDirection.right:\n      return Offset(layoutOffset, 0.0);\n    case AxisDirection.down:\n      return Offset(0.0, layoutOffset);\n    case AxisDirection.left:\n      return Offset(size.width - (layoutOffset + child.geometry.paintExtent), 0.0);\n  }\n  return null;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "computeChildMainAxisPosition",
            "type": "dart:core.double",
            "desc": "<p>Converts the <code>parentMainAxisPosition<\/code> into the child's coordinate system.<\/p>\n<p>The <code>parentMainAxisPosition<\/code> is a distance from the top edge (for vertical\nviewports) or left edge (for horizontal viewports) of the viewport bounds.\nThis describes a line, perpendicular to the viewport's main axis, heretofor\nknown as the target line.<\/p>\n<p>The child's coordinate system's origin in the main axis is at the leading\nedge of the given child, as given by the child's\n<a href=\"rendering\/RenderViewportBase\/axisDirection.html\">SliverConstraints.axisDirection<\/a> and <a href=\"rendering\/SliverConstraints\/growthDirection.html\">SliverConstraints.growthDirection<\/a>.<\/p>\n<p>This method returns the distance from the leading edge of the given child to\nthe target line described above.<\/p>\n<p>(The <code>parentMainAxisPosition<\/code> is not from the leading edge of the\nviewport, it's always the top or left edge.)<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "parentMainAxisPosition",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/computeChildMainAxisPosition.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\ndouble computeChildMainAxisPosition(RenderSliver child, double parentMainAxisPosition);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "computeMaxIntrinsicHeight",
            "type": "dart:core.double",
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMaxIntrinsicHeight.html\">getMaxIntrinsicHeight<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMaxIntrinsicHeight.html\">getMaxIntrinsicHeight<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderBox\/performLayout.html\">performLayout<\/a>. Should return the\nsmallest height beyond which increasing the height never decreases the\npreferred width. The preferred width is the value that would be returned\nby <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> for that height.<\/p>\n<p>If the layout algorithm is strictly width-in-height-out, or is\nwidth-in-height-out when the height is unconstrained, then this should\nreturn the same value as <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a> for the same width.<\/p>\n<p>Otherwise, the width argument should be ignored, and the returned value\nshould be equal to or bigger than the value returned by\n<a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a>.<\/p>\n<p>The <code>width<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>The value returned by this method might not match the size that the object\nwould actually take. For example, a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> subclass that always\nexactly sizes itself using <a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a> might well size itself\nbigger than its max intrinsic size.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<p>See also examples in the definition of <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "width",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/computeMaxIntrinsicHeight.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMaxIntrinsicHeight(double width) {\n  assert(debugThrowIfNotCheckingIntrinsics());\n  return 0.0;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "computeMaxIntrinsicWidth",
            "type": "dart:core.double",
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMaxIntrinsicWidth.html\">getMaxIntrinsicWidth<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMaxIntrinsicWidth.html\">getMaxIntrinsicWidth<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderBox\/performLayout.html\">performLayout<\/a>. This should return\nthe smallest width beyond which increasing the width never decreases the\npreferred height. The preferred height is the value that would be returned\nby <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a> for that width.<\/p>\n<p>If the layout algorithm is strictly height-in-width-out, or is\nheight-in-width-out when the width is unconstrained, then this should\nreturn the same value as <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> for the same height.<\/p>\n<p>Otherwise, the height argument should be ignored, and the returned value\nshould be equal to or bigger than the value returned by\n<a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n<p>The <code>height<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>The value returned by this method might not match the size that the object\nwould actually take. For example, a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> subclass that always\nexactly sizes itself using <a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a> might well size itself\nbigger than its max intrinsic size.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<p>See also examples in the definition of <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "height",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/computeMaxIntrinsicWidth.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMaxIntrinsicWidth(double height) {\n  assert(debugThrowIfNotCheckingIntrinsics());\n  return 0.0;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "computeMinIntrinsicHeight",
            "type": "dart:core.double",
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMinIntrinsicHeight.html\">getMinIntrinsicHeight<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMinIntrinsicHeight.html\">getMinIntrinsicHeight<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderBox\/performLayout.html\">performLayout<\/a>. Should return the\nminimum height that this box could be without failing to correctly paint\nits contents within itself, without clipping.<\/p>\n<p>If the layout algorithm is independent of the context (e.g. it always\ntries to be a particular size), or if the layout algorithm is\nheight-in-width-out, or if the layout algorithm uses both the incoming\nheight and width constraints (e.g. it always sizes itself to\n<a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a>), then the <code>width<\/code> argument should be ignored.<\/p>\n<p>If the layout algorithm is strictly width-in-height-out, or is\nwidth-in-height-out when the height is unconstrained, then the width\nargument is the width to use.<\/p>\n<p>The <code>width<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<p>See also examples in the definition of <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "width",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/computeMinIntrinsicHeight.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMinIntrinsicHeight(double width) {\n  assert(debugThrowIfNotCheckingIntrinsics());\n  return 0.0;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "computeMinIntrinsicWidth",
            "type": "dart:core.double",
            "desc": "<p>Computes the value returned by <a href=\"rendering\/RenderBox\/getMinIntrinsicWidth.html\">getMinIntrinsicWidth<\/a>. Do not call this\nfunction directly, instead, call <a href=\"rendering\/RenderBox\/getMinIntrinsicWidth.html\">getMinIntrinsicWidth<\/a>.<\/p>\n<p>Override in subclasses that implement <a href=\"rendering\/RenderBox\/performLayout.html\">performLayout<\/a>. This method should\nreturn the minimum width that this box could be without failing to\ncorrectly paint its contents within itself, without clipping.<\/p>\n<p>If the layout algorithm is independent of the context (e.g. it always\ntries to be a particular size), or if the layout algorithm is\nwidth-in-height-out, or if the layout algorithm uses both the incoming\nwidth and height constraints (e.g. it always sizes itself to\n<a href=\"rendering\/BoxConstraints\/biggest.html\">BoxConstraints.biggest<\/a>), then the <code>height<\/code> argument should be ignored.<\/p>\n<p>If the layout algorithm is strictly height-in-width-out, or is\nheight-in-width-out when the width is unconstrained, then the height\nargument is the height to use.<\/p>\n<p>The <code>height<\/code> argument will never be negative or null. It may be infinite.<\/p>\n<p>If this algorithm depends on the intrinsic dimensions of a child, the\nintrinsic dimensions of that child should be obtained using the functions\nwhose names start with <code>get<\/code>, not <code>compute<\/code>.<\/p>\n<p>This function should never return a negative or infinite value.<\/p>\n<h2 id=\"examples\">Examples<\/h2>\n<h3 id=\"text\">Text<\/h3>\n<p>Text is the canonical example of a width-in-height-out algorithm. The\n<code>height<\/code> argument is therefore ignored.<\/p>\n<p>Consider the string \"Hello World\" The <em>maximum<\/em> intrinsic width (as\nreturned from <a href=\"rendering\/RenderViewportBase\/computeMaxIntrinsicWidth.html\">computeMaxIntrinsicWidth<\/a>) would be the width of the string\nwith no line breaks.<\/p>\n<p>The minimum intrinsic width would be the width of the widest word, \"Hello\"\nor \"World\". If the text is rendered in an even narrower width, however, it\nmight still not overflow. For example, maybe the rendering would put a\nline-break half-way through the words, as in \"Hel\u205elo\u205eWor\u205eld\". However,\nthis wouldn't be a <em>correct<\/em> rendering, and <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> is\nsupposed to render the minimum width that the box could be without failing\nto <em>correctly<\/em> paint the contents within itself.<\/p>\n<p>The minimum intrinsic <em>height<\/em> for a given width smaller than the minimum\nintrinsic width could therefore be greater than the minimum intrinsic\nheight for the minimum intrinsic width.<\/p>\n<h3 id=\"viewports-eg-scrolling-lists\">Viewports (e.g. scrolling lists)<\/h3>\n<p>Some render boxes are intended to clip their children. For example, the\nrender box for a scrolling list might always size itself to its parents'\nsize (or rather, to the maximum incoming constraints), regardless of the\nchildren's sizes, and then clip the children and position them based on\nthe current scroll offset.<\/p>\n<p>The intrinsic dimensions in these cases still depend on the children, even\nthough the layout algorithm sizes the box in a way independent of the\nchildren. It is the size that is needed to paint the box's contents (in\nthis case, the children) <em>without clipping<\/em> that matters.<\/p>\n<h3 id=\"when-the-intrinsic-dimensions-cannot-be-known\">When the intrinsic dimensions cannot be known<\/h3>\n<p>There are cases where render objects do not have an efficient way to\ncompute their intrinsic dimensions. For example, it may be prohibitively\nexpensive to reify and measure every child of a lazy viewport (viewports\ngenerally only instantiate the actually visible children), or the\ndimensions may be computed by a callback about which the render object\ncannot reason.<\/p>\n<p>In such cases, it may be impossible (or at least impractical) to actually\nreturn a valid answer. In such cases, the intrinsic functions should throw\nwhen <a href=\"rendering\/RenderObject\/debugCheckingIntrinsics.html\">RenderObject.debugCheckingIntrinsics<\/a> is false and asserts are\nenabled, and return 0.0 otherwise.<\/p>\n<p>See the implementations of <a href=\"widgets\/LayoutBuilder-class.html\">LayoutBuilder<\/a> or <a href=\"rendering\/RenderViewportBase-class.html\">RenderViewportBase<\/a> for\nexamples (in particular,\n<a href=\"rendering\/RenderViewportBase\/debugThrowIfNotCheckingIntrinsics.html\">RenderViewportBase.debugThrowIfNotCheckingIntrinsics<\/a>).<\/p>\n<h3 id=\"aspect-ratio-driven-boxes\">Aspect-ratio-driven boxes<\/h3>\n<p>Some boxes always return a fixed size based on the constraints. For these\nboxes, the intrinsic functions should return the appropriate size when the\nincoming <code>height<\/code> or <code>width<\/code> argument is finite, treating that as a tight\nconstraint in the respective direction and treating the other direction's\nconstraints as unbounded. This is because the definitions of\n<a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> and <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicHeight.html\">computeMinIntrinsicHeight<\/a> are in terms of\nwhat the dimensions <em>could be<\/em>, and such boxes can only be one size in\nsuch cases.<\/p>\n<p>When the incoming argument is not finite, then they should return the\nactual intrinsic dimensions based on the contents, as any other box would.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "height",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\ndouble computeMinIntrinsicWidth(double height) {\n  assert(debugThrowIfNotCheckingIntrinsics());\n  return 0.0;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "debugDescribeChildren",
            "type": "dart:core.List<foundation.DiagnosticsNode>",
            "desc": "<p>Returns a list of <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> objects describing this node's\nchildren.<\/p>\n<p>Children that are offstage should be added with <code>style<\/code> set to\n<a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle.offstage<\/a> to indicate that they are offstage.<\/p>\n<p>The list must not contain any null entries. If there are explicit null\nchildren to report, consider <a href=\"foundation\/DiagnosticsNode\/DiagnosticsNode.message.html\">new DiagnosticsNode.message<\/a> or\n<a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty&lt;Object&gt;<\/a> as possible <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> objects to\nprovide.<\/p>\n<p>Used by <a href=\"rendering\/RenderObject\/toStringDeep.html\">toStringDeep<\/a>, <a href=\"foundation\/DiagnosticableTreeMixin\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"rendering\/RenderObject\/toStringShallow.html\">toStringShallow<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"rendering\/RenderViewportBase\/debugDescribeChildren.html\">RenderTable.debugDescribeChildren<\/a>, which provides high quality custom\ndescriptions for its child nodes.<\/li><\/ul>",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/debugDescribeChildren.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nList&lt;DiagnosticsNode&gt; debugDescribeChildren() {\n  final List&lt;DiagnosticsNode&gt; children = &lt;DiagnosticsNode&gt;[];\n  RenderSliver child = firstChild;\n  if (child == null)\n    return children;\n\n  int count = indexOfFirstChild;\n  while (true) {\n    children.add(child.toDiagnosticsNode(name: labelForChild(count)));\n    if (child == lastChild)\n      break;\n    count += 1;\n    child = childAfter(child);\n  }\n  return children;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": [
                "dart:core.List",
                "foundation.DiagnosticsNode"
            ]
        },
        {
            "name": "debugFillProperties",
            "type": "",
            "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"rendering\/RenderViewportBase\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/DiagnosticableTreeMixin\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"rendering\/RenderObject\/toString.html\">toString<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "properties",
                    "type": "foundation.DiagnosticPropertiesBuilder",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/debugFillProperties.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.add(EnumProperty&lt;AxisDirection&gt;('axisDirection', axisDirection));\n  properties.add(EnumProperty&lt;AxisDirection&gt;('crossAxisDirection', crossAxisDirection));\n  properties.add(DiagnosticsProperty&lt;ViewportOffset&gt;('offset', offset));\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "debugPaintSize",
            "type": "",
            "desc": "<p>In debug mode, paints a border around this render box.<\/p>\n<p>Called for every <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> when <a href=\"rendering\/debugPaintSizeEnabled.html\">debugPaintSizeEnabled<\/a> is true.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "context",
                    "type": "rendering.PaintingContext",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "offset",
                    "type": "dart:ui.Offset",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/debugPaintSize.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugPaintSize(PaintingContext context, Offset offset) {\n  assert(() {\n    super.debugPaintSize(context, offset);\n    final Paint paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = 1.0\n      ..color = const Color(0xFF00FF00);\n    final Canvas canvas = context.canvas;\n    RenderSliver child = firstChild;\n    while (child != null) {\n      Size size;\n      switch (axis) {\n        case Axis.vertical:\n          size = Size(child.constraints.crossAxisExtent, child.geometry.layoutExtent);\n          break;\n        case Axis.horizontal:\n          size = Size(child.geometry.layoutExtent, child.constraints.crossAxisExtent);\n          break;\n      }\n      assert(size != null);\n      canvas.drawRect(((offset + paintOffsetOf(child)) &amp; size).deflate(0.5), paint);\n      child = childAfter(child);\n    }\n    return true;\n  }());\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "debugThrowIfNotCheckingIntrinsics",
            "type": "dart:core.bool",
            "desc": "<p>Throws an exception saying that the object does not support returning\nintrinsic dimensions if, in checked mode, we are not in the\n<a href=\"rendering\/RenderObject\/debugCheckingIntrinsics.html\">RenderObject.debugCheckingIntrinsics<\/a> mode.<\/p>\n<p>This is used by <a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a> et al because viewports do not\ngenerally support returning intrinsic dimensions. See the discussion at\n<a href=\"rendering\/RenderViewportBase\/computeMinIntrinsicWidth.html\">computeMinIntrinsicWidth<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/debugThrowIfNotCheckingIntrinsics.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nbool debugThrowIfNotCheckingIntrinsics() {\n  assert(() {\n    if (!RenderObject.debugCheckingIntrinsics) {\n      assert(this is! RenderShrinkWrappingViewport); \/\/ it has its own message\n      throw FlutterError(\n        '$runtimeType does not support returning intrinsic dimensions.\\n'\n        'Calculating the intrinsic dimensions would require instantiating every child of '\n        'the viewport, which defeats the point of viewports being lazy.\\n'\n        'If you are merely trying to shrink-wrap the viewport in the main axis direction, '\n        'consider a RenderShrinkWrappingViewport render object (ShrinkWrappingViewport widget), '\n        'which achieves that effect without implementing the intrinsic dimension API.'\n      );\n    }\n    return true;\n  }());\n  return true;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "describeApproximatePaintClip",
            "type": "dart:ui.Rect",
            "desc": "<p>Returns a rect in this object's coordinate system that describes\nthe approximate bounding box of the clip rect that would be\napplied to the given child during the paint phase, if any.<\/p>\n<p>Returns null if the child would not be clipped.<\/p>\n<p>This is used in the semantics phase to avoid including children\nthat are not physically visible.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/describeApproximatePaintClip.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nRect describeApproximatePaintClip(RenderSliver child) {\n  final Rect viewportClip = Offset.zero &amp; size;\n  if (child.constraints.overlap == 0) {\n    return viewportClip;\n  }\n\n  \/\/ Adjust the clip rect for this sliver by the overlap from the previous sliver.\n  double left = viewportClip.left;\n  double right = viewportClip.right;\n  double top = viewportClip.top;\n  double bottom = viewportClip.bottom;\n  final double startOfOverlap = child.constraints.viewportMainAxisExtent - child.constraints.remainingPaintExtent;\n  final double overlapCorrection = startOfOverlap + child.constraints.overlap;\n  switch (applyGrowthDirectionToAxisDirection(axisDirection, child.constraints.growthDirection)) {\n    case AxisDirection.down:\n      top += overlapCorrection;\n      break;\n    case AxisDirection.up:\n      bottom -= overlapCorrection;\n      break;\n    case AxisDirection.right:\n      left += overlapCorrection;\n      break;\n    case AxisDirection.left:\n      right -= overlapCorrection;\n      break;\n  }\n  return Rect.fromLTRB(left, top, right, bottom);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "describeSemanticsClip",
            "type": "dart:ui.Rect",
            "desc": "<p>Returns a rect in this object's coordinate system that describes\nwhich <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a>s produced by the <code>child<\/code> should be included in the\nsemantics tree. <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a>s from the <code>child<\/code> that are positioned\noutside of this rect will be dropped. Child <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a>s that are\npositioned inside this rect, but outside of <a href=\"rendering\/RenderViewportBase\/describeApproximatePaintClip.html\">describeApproximatePaintClip<\/a>\nwill be included in the tree marked as hidden. Child <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a>s\nthat are inside of both rect will be included in the tree as regular\nnodes.<\/p>\n<p>This method only returns a non-null value if the semantics clip rect\nis different from the rect returned by <a href=\"rendering\/RenderViewportBase\/describeApproximatePaintClip.html\">describeApproximatePaintClip<\/a>.\nIf the semantics clip rect and the paint clip rect are the same, this\nmethod returns null.<\/p>\n<p>A viewport would typically implement this method to include semantic nodes\nin the semantics tree that are currently hidden just before the leading\nor just after the trailing edge. These nodes have to be included in the\nsemantics tree to implement implicit accessibility scrolling on iOS where\nthe viewport scrolls implicitly when moving the accessibility focus from\na the last visible node in the viewport to the first hidden one.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/describeSemanticsClip.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nRect describeSemanticsClip(RenderSliver child) {\n  assert (axis != null);\n  switch (axis) {\n    case Axis.vertical:\n      return Rect.fromLTRB(\n        semanticBounds.left,\n        semanticBounds.top - cacheExtent,\n        semanticBounds.right,\n        semanticBounds.bottom + cacheExtent,\n      );\n    case Axis.horizontal:\n      return Rect.fromLTRB(\n        semanticBounds.left - cacheExtent,\n        semanticBounds.top,\n        semanticBounds.right + cacheExtent,\n        semanticBounds.bottom,\n      );\n  }\n  return null;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "describeSemanticsConfiguration",
            "type": "",
            "desc": "<p>Report the semantics of this node, for example for accessibility purposes.<\/p>\n<p>This method should be overridden by subclasses that have interesting\nsemantic information.<\/p>\n<p>The given <a href=\"semantics\/SemanticsConfiguration-class.html\">SemanticsConfiguration<\/a> object is mutable and should be\nannotated in a manner that describes the current state. No reference\nshould be kept to that object; mutating it outside of the context of the\n<a href=\"rendering\/RenderViewportBase\/describeSemanticsConfiguration.html\">describeSemanticsConfiguration<\/a> call (for example as a result of\nasynchronous computation) will at best have no useful effect and at worse\nwill cause crashes as the data will be in an inconsistent state.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe following snippet will describe the node as a button that responds to\ntap actions.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">abstract class SemanticButtonRenderObject extends RenderObject {\n  @override\n  void describeSemanticsConfiguration(SemanticsConfiguration config) {\n    super.describeSemanticsConfiguration(config);\n    config\n      ..onTap = _handleTap\n      ..label = 'I am a button'\n      ..isButton = true;\n  }\n\n  void _handleTap() {\n    \/\/ Do something.\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "config",
                    "type": "semantics.SemanticsConfiguration",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/describeSemanticsConfiguration.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid describeSemanticsConfiguration(SemanticsConfiguration config) {\n  super.describeSemanticsConfiguration(config);\n\n  config.addTagForChildren(RenderViewport.useTwoPaneSemantics);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "detach",
            "type": "",
            "desc": "<p>Mark this node as detached.<\/p>\n<p>Typically called only from the <a href=\"foundation\/AbstractNode\/parent.html\">parent<\/a>'s <a href=\"rendering\/RenderViewportBase\/detach.html\">detach<\/a>, and by the <a href=\"rendering\/RenderObject\/owner.html\">owner<\/a> to\nmark the root of a tree as detached.<\/p>\n<p>Subclasses with children should override this method to first call their\ninherited <a href=\"rendering\/RenderViewportBase\/detach.html\">detach<\/a> method, and then <a href=\"rendering\/RenderViewportBase\/detach.html\">detach<\/a> all their children.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/detach.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid detach() {\n  _offset.removeListener(markNeedsLayout);\n  super.detach();\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "getOffsetToReveal",
            "type": "rendering.RevealedOffset",
            "desc": "<p>Returns the offset that would be needed to reveal the <code>target<\/code>\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a>.<\/p>\n<p>The optional <code>rect<\/code> parameter describes which area of that <code>target<\/code> object\nshould be revealed in the viewport. If <code>rect<\/code> is null, the entire\n<code>target<\/code> <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> (as defined by its <a href=\"rendering\/RenderBox\/paintBounds.html\">RenderObject.paintBounds<\/a>)\nwill be revealed. If <code>rect<\/code> is provided it has to be given in the\ncoordinate system of the <code>target<\/code> object.<\/p>\n<p>The <code>alignment<\/code> argument describes where the target should be positioned\nafter applying the returned offset. If <code>alignment<\/code> is 0.0, the child must\nbe positioned as close to the leading edge of the viewport as possible. If\n<code>alignment<\/code> is 1.0, the child must be positioned as close to the trailing\nedge of the viewport as possible. If <code>alignment<\/code> is 0.5, the child must be\npositioned as close to the center of the viewport as possible.<\/p>\n<p>The <code>target<\/code> might not be a direct child of this viewport but it must be a\ndescendant of the viewport. Other viewports in between this viewport and\nthe <code>target<\/code> will not be adjusted.<\/p>\n<p>This method assumes that the content of the viewport moves linearly, i.e.\nwhen the offset of the viewport is changed by x then <code>target<\/code> also moves\nby x within the viewport.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"rendering\/RevealedOffset-class.html\">RevealedOffset<\/a>, which describes the return value of this method.<\/li><\/ul>",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "target",
                    "type": "rendering.RenderObject",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "alignment",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "rect",
                    "type": "dart:ui.Rect",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/getOffsetToReveal.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nRevealedOffset getOffsetToReveal(RenderObject target, double alignment, { Rect rect }) {\n  double leadingScrollOffset = 0.0;\n  double targetMainAxisExtent;\n  rect ??= target.paintBounds;\n\n  \/\/ Starting at `target` and walking towards the root:\n  \/\/  - `child` will be the last object before we reach this viewport, and\n  \/\/  - `pivot` will be the last RenderBox before we reach this viewport.\n  RenderObject child = target;\n  RenderBox pivot;\n  bool onlySlivers = target is RenderSliver; \/\/ ... between viewport and `target` (`target` included).\n  while (child.parent != this) {\n    assert(child.parent != null, '$target must be a descendant of $this');\n    if (child is RenderBox) {\n      pivot = child;\n    }\n    if (child.parent is RenderSliver) {\n      final RenderSliver parent = child.parent;\n      leadingScrollOffset += parent.childScrollOffset(child);\n    } else {\n      onlySlivers = false;\n      leadingScrollOffset = 0.0;\n    }\n    child = child.parent;\n  }\n\n  if (pivot != null) {\n    assert(pivot.parent != null);\n    assert(pivot.parent != this);\n    assert(pivot != this);\n    assert(pivot.parent is RenderSliver);  \/\/ TODO(abarth): Support other kinds of render objects besides slivers.\n    final RenderSliver pivotParent = pivot.parent;\n\n    final Matrix4 transform = target.getTransformTo(pivot);\n    final Rect bounds = MatrixUtils.transformRect(transform, rect);\n\n    final GrowthDirection growthDirection = pivotParent.constraints.growthDirection;\n    switch (applyGrowthDirectionToAxisDirection(axisDirection, growthDirection)) {\n      case AxisDirection.up:\n        double offset;\n        switch (growthDirection) {\n          case GrowthDirection.forward:\n            offset = bounds.bottom;\n            break;\n          case GrowthDirection.reverse:\n            offset = bounds.top;\n            break;\n        }\n        leadingScrollOffset += pivot.size.height - offset;\n        targetMainAxisExtent = bounds.height;\n        break;\n      case AxisDirection.right:\n        leadingScrollOffset += bounds.left;\n        targetMainAxisExtent = bounds.width;\n        break;\n      case AxisDirection.down:\n        leadingScrollOffset += bounds.top;\n        targetMainAxisExtent = bounds.height;\n        break;\n      case AxisDirection.left:\n        double offset;\n        switch (growthDirection) {\n          case GrowthDirection.forward:\n            offset = bounds.right;\n            break;\n          case GrowthDirection.reverse:\n            offset = bounds.left;\n            break;\n        }\n        leadingScrollOffset += pivot.size.width - offset;\n        targetMainAxisExtent = bounds.width;\n        break;\n    }\n  } else if (onlySlivers) {\n    final RenderSliver targetSliver = target;\n    targetMainAxisExtent = targetSliver.geometry.scrollExtent;\n  } else {\n    return RevealedOffset(offset: offset.pixels, rect: rect);\n  }\n\n  assert(child.parent == this);\n  assert(child is RenderSliver);\n  final RenderSliver sliver = child;\n  final double extentOfPinnedSlivers = maxScrollObstructionExtentBefore(sliver);\n  leadingScrollOffset = scrollOffsetOf(sliver, leadingScrollOffset);\n  switch (sliver.constraints.growthDirection) {\n    case GrowthDirection.forward:\n      leadingScrollOffset -= extentOfPinnedSlivers;\n      break;\n    case GrowthDirection.reverse:\n      \/\/ Nothing to do.\n      break;\n  }\n\n  double mainAxisExtent;\n  switch (axis) {\n    case Axis.horizontal:\n      mainAxisExtent = size.width - extentOfPinnedSlivers;\n      break;\n    case Axis.vertical:\n      mainAxisExtent = size.height - extentOfPinnedSlivers;\n      break;\n  }\n\n  final double targetOffset = leadingScrollOffset - (mainAxisExtent - targetMainAxisExtent) * alignment;\n  final double offsetDifference = offset.pixels - targetOffset;\n\n  final Matrix4 transform = target.getTransformTo(this);\n  applyPaintTransform(child, transform);\n  Rect targetRect = MatrixUtils.transformRect(transform, rect);\n\n  switch (axisDirection) {\n    case AxisDirection.down:\n      targetRect = targetRect.translate(0.0, offsetDifference);\n      break;\n    case AxisDirection.right:\n      targetRect = targetRect.translate(offsetDifference, 0.0);\n      break;\n    case AxisDirection.up:\n      targetRect = targetRect.translate(0.0, -offsetDifference);\n      break;\n    case AxisDirection.left:\n      targetRect = targetRect.translate(-offsetDifference, 0.0);\n      break;\n  }\n\n  return RevealedOffset(offset: targetOffset, rect: targetRect);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "hitTestChildren",
            "type": "dart:core.bool",
            "desc": "<p>Override this method to check whether any children are located at the\ngiven position.<\/p>\n<p>Typically children should be hit-tested in reverse paint order so that\nhit tests at locations where children overlap hit the child that is\nvisually \"on top\" (i.e., paints later).<\/p>\n<p>The caller is responsible for transforming <code>position<\/code> from global\ncoordinates to its location relative to the origin of this <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>.\nThis <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> is responsible for checking whether the given position is\nwithin its bounds.<\/p>\n<p>Used by <a href=\"rendering\/RenderBox\/hitTest.html\">hitTest<\/a>. If you override <a href=\"rendering\/RenderBox\/hitTest.html\">hitTest<\/a> and do not call this\nfunction, then you don't need to implement this function.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "result",
                    "type": "gestures.HitTestResult",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "position",
                    "type": "dart:ui.Offset",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/hitTestChildren.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool hitTestChildren(HitTestResult result, { Offset position }) {\n  double mainAxisPosition, crossAxisPosition;\n  switch (axis) {\n    case Axis.vertical:\n      mainAxisPosition = position.dy;\n      crossAxisPosition = position.dx;\n      break;\n    case Axis.horizontal:\n      mainAxisPosition = position.dx;\n      crossAxisPosition = position.dy;\n      break;\n  }\n  assert(mainAxisPosition != null);\n  assert(crossAxisPosition != null);\n  for (RenderSliver child in childrenInHitTestOrder) {\n    if (child.geometry.visible &amp;&amp; child.hitTest(\n      result,\n      mainAxisPosition: computeChildMainAxisPosition(child, mainAxisPosition),\n      crossAxisPosition: crossAxisPosition,\n    )) {\n      return true;\n    }\n  }\n  return false;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "labelForChild",
            "type": "dart:core.String",
            "desc": "<p>A short string to identify the child with the given index.<\/p>\n<p>Used by <a href=\"rendering\/RenderViewportBase\/debugDescribeChildren.html\">debugDescribeChildren<\/a> to label the children.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "index",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/labelForChild.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nString labelForChild(int index);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "layoutChildSequence",
            "type": "dart:core.double",
            "desc": "<p>Determines the size and position of some of the children of the viewport.<\/p>\n<p>This function is the workhorse of <code>performLayout<\/code> implementations in\nsubclasses.<\/p>\n<p>Layout starts with <code>child<\/code>, proceeds according to the <code>advance<\/code> callback,\nand stops once <code>advance<\/code> returns null.<\/p>\n<ul>\n<li>\n<code>scrollOffset<\/code> is the <a href=\"rendering\/SliverConstraints\/scrollOffset.html\">SliverConstraints.scrollOffset<\/a> to pass the\nfirst child. The scroll offset is adjusted by\n<a href=\"rendering\/SliverGeometry\/scrollExtent.html\">SliverGeometry.scrollExtent<\/a> for subsequent children.<\/li>\n<li>\n<code>overlap<\/code> is the <a href=\"rendering\/SliverConstraints\/overlap.html\">SliverConstraints.overlap<\/a> to pass the first child.\nThe overlay is adjusted by the <a href=\"rendering\/SliverGeometry\/paintOrigin.html\">SliverGeometry.paintOrigin<\/a> and\n<a href=\"rendering\/SliverGeometry\/paintExtent.html\">SliverGeometry.paintExtent<\/a> for subsequent children.<\/li>\n<li>\n<code>layoutOffset<\/code> is the layout offset at which to place the first child.\nThe layout offset is updated by the <a href=\"rendering\/SliverGeometry\/layoutExtent.html\">SliverGeometry.layoutExtent<\/a> for\nsubsequent children.<\/li>\n<li>\n<code>remainingPaintExtent<\/code> is <a href=\"rendering\/SliverConstraints\/remainingPaintExtent.html\">SliverConstraints.remainingPaintExtent<\/a> to\npass the first child. The remaining paint extent is updated by the\n<a href=\"rendering\/SliverGeometry\/layoutExtent.html\">SliverGeometry.layoutExtent<\/a> for subsequent children.<\/li>\n<li>\n<code>mainAxisExtent<\/code> is the <a href=\"rendering\/SliverConstraints\/viewportMainAxisExtent.html\">SliverConstraints.viewportMainAxisExtent<\/a> to\npass to each child.<\/li>\n<li>\n<code>crossAxisExtent<\/code> is the <a href=\"rendering\/SliverConstraints\/crossAxisExtent.html\">SliverConstraints.crossAxisExtent<\/a> to pass to\neach child.<\/li>\n<li>\n<code>growthDirection<\/code> is the <a href=\"rendering\/SliverConstraints\/growthDirection.html\">SliverConstraints.growthDirection<\/a> to pass to\neach child.<\/li>\n<\/ul>\n<p>Returns the first non-zero <a href=\"rendering\/SliverGeometry\/scrollOffsetCorrection.html\">SliverGeometry.scrollOffsetCorrection<\/a>\nencountered, if any. Otherwise returns 0.0. Typical callers will call this\nfunction repeatedly until it returns 0.0.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "scrollOffset",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "overlap",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "layoutOffset",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "remainingPaintExtent",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "mainAxisExtent",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "crossAxisExtent",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "growthDirection",
                    "type": "rendering.GrowthDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "remainingCacheExtent",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "cacheOrigin",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/layoutChildSequence.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\ndouble layoutChildSequence({\n  @required RenderSliver child,\n  @required double scrollOffset,\n  @required double overlap,\n  @required double layoutOffset,\n  @required double remainingPaintExtent,\n  @required double mainAxisExtent,\n  @required double crossAxisExtent,\n  @required GrowthDirection growthDirection,\n  @required RenderSliver advance(RenderSliver child),\n  @required double remainingCacheExtent,\n  @required double cacheOrigin,\n}) {\n  assert(scrollOffset.isFinite);\n  assert(scrollOffset &gt;= 0.0);\n  final double initialLayoutOffset = layoutOffset;\n  final ScrollDirection adjustedUserScrollDirection =\n      applyGrowthDirectionToScrollDirection(offset.userScrollDirection, growthDirection);\n  assert(adjustedUserScrollDirection != null);\n  double maxPaintOffset = layoutOffset + overlap;\n  double precedingScrollExtent = 0.0;\n\n  while (child != null) {\n    final double sliverScrollOffset = scrollOffset &lt;= 0.0 ? 0.0 : scrollOffset;\n    \/\/ If the scrollOffset is too small we adjust the paddedOrigin because it\n    \/\/ doesn't make sense to ask a sliver for content before its scroll\n    \/\/ offset.\n    final double correctedCacheOrigin = math.max(cacheOrigin, -sliverScrollOffset);\n    final double cacheExtentCorrection = cacheOrigin - correctedCacheOrigin;\n\n    assert(sliverScrollOffset &gt;= correctedCacheOrigin.abs());\n    assert(correctedCacheOrigin &lt;= 0.0);\n    assert(sliverScrollOffset &gt;= 0.0);\n    assert(cacheExtentCorrection &lt;= 0.0);\n\n    child.layout(SliverConstraints(\n      axisDirection: axisDirection,\n      growthDirection: growthDirection,\n      userScrollDirection: adjustedUserScrollDirection,\n      scrollOffset: sliverScrollOffset,\n      precedingScrollExtent: precedingScrollExtent,\n      overlap: maxPaintOffset - layoutOffset,\n      remainingPaintExtent: math.max(0.0, remainingPaintExtent - layoutOffset + initialLayoutOffset),\n      crossAxisExtent: crossAxisExtent,\n      crossAxisDirection: crossAxisDirection,\n      viewportMainAxisExtent: mainAxisExtent,\n      remainingCacheExtent: math.max(0.0, remainingCacheExtent + cacheExtentCorrection),\n      cacheOrigin: correctedCacheOrigin,\n    ), parentUsesSize: true);\n\n    final SliverGeometry childLayoutGeometry = child.geometry;\n    assert(childLayoutGeometry.debugAssertIsValid());\n\n    \/\/ If there is a correction to apply, we'll have to start over.\n    if (childLayoutGeometry.scrollOffsetCorrection != null)\n      return childLayoutGeometry.scrollOffsetCorrection;\n\n    \/\/ We use the child's paint origin in our coordinate system as the\n    \/\/ layoutOffset we store in the child's parent data.\n    final double effectiveLayoutOffset = layoutOffset + childLayoutGeometry.paintOrigin;\n\n    \/\/ `effectiveLayoutOffset` becomes meaningless once we moved past the trailing edge\n    \/\/ because `childLayoutGeometry.layoutExtent` is zero. Using the still increasing\n    \/\/ 'scrollOffset` to roughly position these invisible slivers in the right order.\n    if (childLayoutGeometry.visible || scrollOffset &gt; 0) {\n      updateChildLayoutOffset(child, effectiveLayoutOffset, growthDirection);\n    } else {\n      updateChildLayoutOffset(child, -scrollOffset + initialLayoutOffset, growthDirection);\n    }\n\n    maxPaintOffset = math.max(effectiveLayoutOffset + childLayoutGeometry.paintExtent, maxPaintOffset);\n    scrollOffset -= childLayoutGeometry.scrollExtent;\n    precedingScrollExtent += childLayoutGeometry.scrollExtent;\n    layoutOffset += childLayoutGeometry.layoutExtent;\n    if (childLayoutGeometry.cacheExtent != 0.0) {\n      remainingCacheExtent -= childLayoutGeometry.cacheExtent - cacheExtentCorrection;\n      cacheOrigin = math.min(correctedCacheOrigin + childLayoutGeometry.cacheExtent, 0.0);\n    }\n\n    updateOutOfBandData(growthDirection, childLayoutGeometry);\n\n    \/\/ move on to the next child\n    child = advance(child);\n  }\n\n  \/\/ we made it without a correction, whee!\n  return 0.0;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "maxScrollObstructionExtentBefore",
            "type": "dart:core.double",
            "desc": "<p>Returns the total scroll obstruction extent of all slivers in the viewport\nbefore <code>child<\/code>.<\/p>\n<p>This is the extent by which the actual area in which content can scroll\nis reduced. For example, an app bar that is pinned at the top will reduce\nthe area in which content can actually scroll by the height of the app bar.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/maxScrollObstructionExtentBefore.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\ndouble maxScrollObstructionExtentBefore(RenderSliver child);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "paint",
            "type": "",
            "desc": "<p>Paint this render object into the given context at the given offset.<\/p>\n<p>Subclasses should override this method to provide a visual appearance\nfor themselves. The render object's local coordinate system is\naxis-aligned with the coordinate system of the context's canvas and the\nrender object's local origin (i.e, x=0 and y=0) is placed at the given\noffset in the context's canvas.<\/p>\n<p>Do not call this function directly. If you wish to paint yourself, call\n<a href=\"rendering\/RenderObject\/markNeedsPaint.html\">markNeedsPaint<\/a> instead to schedule a call to this function. If you wish\nto paint one of your children, call <a href=\"rendering\/PaintingContext\/paintChild.html\">PaintingContext.paintChild<\/a> on the\ngiven <code>context<\/code>.<\/p>\n<p>When painting one of your children (via a paint child function on the\ngiven context), the current canvas held by the context might change\nbecause draw operations before and after painting children might need to\nbe recorded on separate compositing layers.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "context",
                    "type": "rendering.PaintingContext",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "offset",
                    "type": "dart:ui.Offset",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/paint.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(PaintingContext context, Offset offset) {\n  if (firstChild == null)\n    return;\n  if (hasVisualOverflow) {\n    context.pushClipRect(needsCompositing, offset, Offset.zero &amp; size, _paintContents);\n  } else {\n    _paintContents(context, offset);\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "paintOffsetOf",
            "type": "dart:ui.Offset",
            "desc": "<p>The offset at which the given <code>child<\/code> should be painted.<\/p>\n<p>The returned offset is from the top left corner of the inside of the\nviewport to the top left corner of the paint coordinate system of the\n<code>child<\/code>.<\/p>\n<p>See also <a href=\"rendering\/RenderViewportBase\/computeAbsolutePaintOffset.html\">computeAbsolutePaintOffset<\/a>, which computes the paint offset\nfrom an explicit layout offset and growth direction instead of using the\nvalues computed for the child during layout.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/paintOffsetOf.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nOffset paintOffsetOf(RenderSliver child);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "scrollOffsetOf",
            "type": "dart:core.double",
            "desc": "<p>Returns the scroll offset within the viewport for the given\n<code>scrollOffsetWithinChild<\/code> within the given <code>child<\/code>.<\/p>\n<p>The returned value is an estimate that assumes the slivers within the\nviewport do not change the layout extent in response to changes in their\nscroll offset.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "scrollOffsetWithinChild",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/scrollOffsetOf.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\ndouble scrollOffsetOf(RenderSliver child, double scrollOffsetWithinChild);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "showInViewport",
            "type": "dart:ui.Rect",
            "desc": "<p>Make (a portion of) the given <code>descendant<\/code> of the given <code>viewport<\/code> fully\nvisible in the <code>viewport<\/code> by manipulating the provided <a href=\"rendering\/ViewportOffset-class.html\">ViewportOffset<\/a>\n<code>offset<\/code>.<\/p>\n<p>The optional <code>rect<\/code> parameter describes which area of the <code>descendant<\/code>\nshould be shown in the viewport. If <code>rect<\/code> is null, the entire\n<code>descendant<\/code> will be revealed. The <code>rect<\/code> parameter is interpreted\nrelative to the coordinate system of <code>descendant<\/code>.<\/p>\n<p>The returned <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> describes the new location of <code>descendant<\/code> or <code>rect<\/code>\nin the viewport after it has been revealed. See <a href=\"rendering\/RevealedOffset\/rect.html\">RevealedOffset.rect<\/a>\nfor a full definition of this <a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>The parameters <code>viewport<\/code> and <code>offset<\/code> are required and cannot be null.\nIf <code>descendant<\/code> is null, this is a no-op and <code>rect<\/code> is returned.<\/p>\n<p>If both <code>descendant<\/code> and <code>rect<\/code> are null, null is returned because there is\nnothing to be shown in the viewport.<\/p>\n<p>The <code>duration<\/code> parameter can be set to a non-zero value to animate the\ntarget object into the viewport with an animation defined by <code>curve<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "descendant",
                    "type": "rendering.RenderObject",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "rect",
                    "type": "dart:ui.Rect",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "viewport",
                    "type": "rendering.RenderAbstractViewport",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "offset",
                    "type": "rendering.ViewportOffset",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "duration",
                    "type": "dart:core.Duration",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "curve",
                    "type": "animation.Curve",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/showInViewport.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Rect showInViewport({\n  RenderObject descendant,\n  Rect rect,\n  @required RenderAbstractViewport viewport,\n  @required ViewportOffset offset,\n  Duration duration = Duration.zero,\n  Curve curve = Curves.ease,\n}) {\n  assert(viewport != null);\n  assert(offset != null);\n  if (descendant == null) {\n    return rect;\n  }\n  final RevealedOffset leadingEdgeOffset = viewport.getOffsetToReveal(descendant, 0.0, rect: rect);\n  final RevealedOffset trailingEdgeOffset = viewport.getOffsetToReveal(descendant, 1.0, rect: rect);\n  final double currentOffset = offset.pixels;\n\n  \/\/           scrollOffset\n  \/\/                       0 +---------+\n  \/\/                         |         |\n  \/\/                       _ |         |\n  \/\/    viewport position |  |         |\n  \/\/ with `descendant` at |  |         | _\n  \/\/        trailing edge |_ | xxxxxxx |  | viewport position\n  \/\/                         |         |  | with `descendant` at\n  \/\/                         |         | _| leading edge\n  \/\/                         |         |\n  \/\/                     800 +---------+\n  \/\/\n  \/\/ `trailingEdgeOffset`: Distance from scrollOffset 0 to the start of the\n  \/\/                       viewport on the left in image above.\n  \/\/ `leadingEdgeOffset`: Distance from scrollOffset 0 to the start of the\n  \/\/                      viewport on the right in image above.\n  \/\/\n  \/\/ The viewport position on the left is achieved by setting `offset.pixels`\n  \/\/ to `trailingEdgeOffset`, the one on the right by setting it to\n  \/\/ `leadingEdgeOffset`.\n\n  RevealedOffset targetOffset;\n  if (leadingEdgeOffset.offset &lt; trailingEdgeOffset.offset) {\n    \/\/ `descendant` is too big to be visible on screen in its entirety. Let's\n    \/\/ align it with the edge that requires the least amount of scrolling.\n    final double leadingEdgeDiff = (offset.pixels - leadingEdgeOffset.offset).abs();\n    final double trailingEdgeDiff = (offset.pixels - trailingEdgeOffset.offset).abs();\n    targetOffset = leadingEdgeDiff &lt; trailingEdgeDiff ? leadingEdgeOffset : trailingEdgeOffset;\n  } else if (currentOffset &gt; leadingEdgeOffset.offset) {\n    \/\/ `descendant` currently starts above the leading edge and can be shown\n    \/\/ fully on screen by scrolling down (which means: moving viewport up).\n    targetOffset = leadingEdgeOffset;\n  } else if (currentOffset &lt; trailingEdgeOffset.offset) {\n    \/\/ `descendant currently ends below the trailing edge and can be shown\n    \/\/ fully on screen by scrolling up (which means: moving viewport down)\n    targetOffset = trailingEdgeOffset;\n  } else {\n    \/\/ `descendant` is between leading and trailing edge and hence already\n    \/\/  fully shown on screen. No action necessary.\n    final Matrix4 transform = descendant.getTransformTo(viewport.parent);\n    return MatrixUtils.transformRect(transform, rect ?? descendant.paintBounds);\n  }\n\n  assert(targetOffset != null);\n\n  offset.moveTo(targetOffset.offset, duration: duration, curve: curve);\n  return targetOffset.rect;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "showOnScreen",
            "type": "",
            "desc": "<p>Attempt to make (a portion of) this or a descendant <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> visible\non screen.<\/p>\n<p>If <code>descendant<\/code> is provided, that <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> is made visible. If\n<code>descendant<\/code> is omitted, this <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> is made visible.<\/p>\n<p>The optional <code>rect<\/code> parameter describes which area of that <a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a>\nshould be shown on screen. If <code>rect<\/code> is null, the entire\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> (as defined by its <a href=\"rendering\/RenderBox\/paintBounds.html\">paintBounds<\/a>) will be revealed. The\n<code>rect<\/code> parameter is interpreted relative to the coordinate system of\n<code>descendant<\/code> if that argument is provided and relative to this\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> otherwise.<\/p>\n<p>The <code>duration<\/code> parameter can be set to a non-zero value to bring the\ntarget object on screen in an animation defined by <code>curve<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "descendant",
                    "type": "rendering.RenderObject",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "rect",
                    "type": "dart:ui.Rect",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "duration",
                    "type": "dart:core.Duration",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "curve",
                    "type": "animation.Curve",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/showOnScreen.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid showOnScreen({\n  RenderObject descendant,\n  Rect rect,\n  Duration duration = Duration.zero,\n  Curve curve = Curves.ease,\n}) {\n  if (!offset.allowImplicitScrolling) {\n    return super.showOnScreen(\n      descendant: descendant,\n      rect: rect,\n      duration: duration,\n      curve: curve,\n    );\n  }\n\n  final Rect newRect = RenderViewportBase.showInViewport(\n    descendant: descendant,\n    viewport: this,\n    offset: offset,\n    rect: rect,\n    duration: duration,\n    curve: curve,\n  );\n  super.showOnScreen(\n    rect: newRect,\n    duration: duration,\n    curve: curve,\n  );\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "updateChildLayoutOffset",
            "type": "",
            "desc": "<p>Called during <a href=\"rendering\/RenderViewportBase\/layoutChildSequence.html\">layoutChildSequence<\/a> to store the layout offset for the\ngiven child.<\/p>\n<p>Different subclasses using different representations for their children's\nlayout offset (e.g., logical or physical coordinates). This function lets\nsubclasses transform the child's layout offset before storing it in the\nchild's parent data.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "child",
                    "type": "rendering.RenderSliver",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "layoutOffset",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "growthDirection",
                    "type": "rendering.GrowthDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/updateChildLayoutOffset.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid updateChildLayoutOffset(RenderSliver child, double layoutOffset, GrowthDirection growthDirection);<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "updateOutOfBandData",
            "type": "",
            "desc": "<p>Called during <a href=\"rendering\/RenderViewportBase\/layoutChildSequence.html\">layoutChildSequence<\/a> for each child.<\/p>\n<p>Typically used by subclasses to update any out-of-band data, such as the\nmax scroll extent, for each child.<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "growthDirection",
                    "type": "rendering.GrowthDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "childLayoutGeometry",
                    "type": "rendering.SliverGeometry",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/updateOutOfBandData.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid updateOutOfBandData(GrowthDirection growthDirection, SliverGeometry childLayoutGeometry);<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "visitChildrenForSemantics",
            "type": "",
            "desc": "<p>Called when collecting the semantics of this node.<\/p>\n<p>The implementation has to return the children in paint order skipping all\nchildren that are not semantically relevant (e.g. because they are\ninvisible).<\/p>\n<p>The default implementation mirrors the behavior of\n<a href=\"rendering\/ContainerRenderObjectMixin\/visitChildren.html\">visitChildren()<\/a> (which is supposed to walk all the children).<\/p>\n    ",
            "static": false,
            "memberOf": "rendering.RenderViewportBase",
            "sig": "",
            "params": [
                {
                    "name": "visitor",
                    "type": "rendering.RenderObjectVisitor",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "rendering\/RenderViewportBase\/visitChildrenForSemantics.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid visitChildrenForSemantics(RenderObjectVisitor visitor) {\n  childrenInPaintOrder\n      .where((RenderSliver sliver) =&gt; sliver.geometry.visible || sliver.geometry.cacheExtent &gt; 0.0)\n      .forEach(visitor);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        }
    ],
    "props": [
        {
            "name": "axis",
            "type": "painting.Axis",
            "types": [],
            "desc": "<p>The axis along which the viewport scrolls.<\/p>\n<p>For example, if the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> is <a href=\"painting\/AxisDirection-class.html\">AxisDirection.down<\/a>, then the\n<a href=\"rendering\/RenderViewportBase\/axis.html\">axis<\/a> is <a href=\"painting\/Axis-class.html\">Axis.vertical<\/a> and the viewport scrolls vertically.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/axis.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Axis get axis =&gt; axisDirectionToAxis(axisDirection);<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "axisDirection",
            "type": "painting.AxisDirection",
            "types": [],
            "desc": "<p>The direction in which the <a href=\"rendering\/SliverConstraints\/scrollOffset.html\">SliverConstraints.scrollOffset<\/a> increases.<\/p>\n<p>For example, if the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> is <a href=\"painting\/AxisDirection-class.html\">AxisDirection.down<\/a>, a scroll\noffset of zero is at the top of the viewport and increases towards the\nbottom of the viewport.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/axisDirection.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">AxisDirection get axisDirection =&gt; _axisDirection;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "cacheExtent",
            "type": "dart:core.double",
            "types": [],
            "desc": "<p>The viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.<\/p>\n<p>Items that fall in this cache area are laid out even though they are not\n(yet) visible on screen. The <a href=\"rendering\/RenderViewportBase\/cacheExtent.html\">cacheExtent<\/a> describes how many pixels\nthe cache area extends before the leading edge and after the trailing edge\nof the viewport.<\/p>\n<p>The total extent, which the viewport will try to cover with children, is\n<a href=\"rendering\/RenderViewportBase\/cacheExtent.html\">cacheExtent<\/a> before the leading edge + extent of the main axis +\n<a href=\"rendering\/RenderViewportBase\/cacheExtent.html\">cacheExtent<\/a> after the trailing edge.<\/p>\n<p>The cache area is also used to implement implicit accessibility scrolling\non iOS: When the accessibility focus moves from an item in the visible\nviewport to an invisible item in the cache area, the framework will bring\nthat item into view with an (implicit) scroll action.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/cacheExtent.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get cacheExtent =&gt; _cacheExtent;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "childrenInHitTestOrder",
            "type": "dart:core.Iterable<rendering.RenderSliver>",
            "types": [
                "dart:core.Iterable",
                "rendering.RenderSliver"
            ],
            "desc": "<p>Provides an iterable that walks the children of the viewport, in the order\nthat hit-testing should use.<\/p>\n<p>This should be the reverse order of <a href=\"rendering\/RenderViewportBase\/childrenInPaintOrder.html\">childrenInPaintOrder<\/a>.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/childrenInHitTestOrder.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nIterable&lt;RenderSliver&gt; get childrenInHitTestOrder;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "childrenInPaintOrder",
            "type": "dart:core.Iterable<rendering.RenderSliver>",
            "types": [
                "dart:core.Iterable",
                "rendering.RenderSliver"
            ],
            "desc": "<p>Provides an iterable that walks the children of the viewport, in the order\nthat they should be painted.<\/p>\n<p>This should be the reverse order of <a href=\"rendering\/RenderViewportBase\/childrenInHitTestOrder.html\">childrenInHitTestOrder<\/a>.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/childrenInPaintOrder.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nIterable&lt;RenderSliver&gt; get childrenInPaintOrder;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "crossAxisDirection",
            "type": "painting.AxisDirection",
            "types": [],
            "desc": "<p>The direction in which child should be laid out in the cross axis.<\/p>\n<p>For example, if the <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a> is <a href=\"painting\/AxisDirection-class.html\">AxisDirection.down<\/a>, this property\nis typically <a href=\"painting\/AxisDirection-class.html\">AxisDirection.left<\/a> if the ambient <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a> is\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a> and <a href=\"painting\/AxisDirection-class.html\">AxisDirection.right<\/a> if the ambient\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a> is <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a>.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/crossAxisDirection.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">AxisDirection get crossAxisDirection =&gt; _crossAxisDirection;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hasVisualOverflow",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether the contents of this viewport would paint outside the bounds of\nthe viewport if <a href=\"rendering\/RenderViewportBase\/paint.html\">paint<\/a> did not clip.<\/p>\n<p>This property enables an optimization whereby <a href=\"rendering\/RenderViewportBase\/paint.html\">paint<\/a> can skip apply a\nclip of the contents of the viewport are known to paint entirely within\nthe bounds of the viewport.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/hasVisualOverflow.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nbool get hasVisualOverflow;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "indexOfFirstChild",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>The index of the first child of the viewport relative to the center child.<\/p>\n<p>For example, the center child has index zero and the first child in the\nreverse growth direction has index -1.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/indexOfFirstChild.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nint get indexOfFirstChild;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "isRepaintBoundary",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether this render object repaints separately from its parent.<\/p>\n<p>Override this in subclasses to indicate that instances of your class ought\nto repaint independently. For example, render objects that repaint\nfrequently might want to repaint themselves without requiring their parent\nto repaint.<\/p>\n<p>If this getter returns true, the <a href=\"rendering\/RenderBox\/paintBounds.html\">paintBounds<\/a> are applied to this object\nand all descendants.<\/p>\n<p>Warning: This getter must not change value over the lifetime of this object.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/isRepaintBoundary.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isRepaintBoundary =&gt; true;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "offset",
            "type": "rendering.ViewportOffset",
            "types": [],
            "desc": "<p>Which part of the content inside the viewport should be visible.<\/p>\n<p>The <a href=\"rendering\/ViewportOffset\/pixels.html\">ViewportOffset.pixels<\/a> value determines the scroll offset that the\nviewport uses to select which part of its content to display. As the user\nscrolls the viewport, this value changes, which changes the content that\nis displayed.<\/p>\n        ",
            "memberOf": "rendering.RenderViewportBase",
            "isConstant": false,
            "href": "rendering\/RenderViewportBase\/offset.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ViewportOffset get offset =&gt; _offset;<\/code><\/pre>\n        ",
            "isDeprecated": false
        }
    ],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": true,
    "implementors": [
        "rendering.RenderShrinkWrappingViewport",
        "rendering.RenderViewport",
        "widgets.RenderNestedScrollViewViewport"
    ],
    "realImplementors": [
        "rendering.RenderShrinkWrappingViewport",
        "rendering.RenderViewport",
        "widgets.RenderNestedScrollViewViewport"
    ],
    "cn": [],
    "href": "rendering\/RenderViewportBase-class.html",
    "desc": "<p>A base class for render objects that are bigger on the inside.<\/p>\n<p>This render object provides the shared code for render objects that host\n<a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a> render objects inside a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>. The viewport establishes\nan <a href=\"rendering\/RenderViewportBase\/axisDirection.html\">axisDirection<\/a>, which orients the sliver's coordinate system, which is\nbased on scroll offsets rather than Cartesian coordinates.<\/p>\n<p>The viewport also listens to an <a href=\"rendering\/RenderViewportBase\/offset.html\">offset<\/a>, which determines the\n<a href=\"rendering\/SliverConstraints\/scrollOffset.html\">SliverConstraints.scrollOffset<\/a> input to the sliver layout protocol.<\/p>\n<p>Subclasses typically override <a href=\"rendering\/RenderBox\/performLayout.html\">performLayout<\/a> and call\n<a href=\"rendering\/RenderViewportBase\/layoutChildSequence.html\">layoutChildSequence<\/a>, perhaps multiple times.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a>, which explains more about the Sliver protocol.<\/li>\n<li>\n<a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a>, which explains more about the Box protocol.<\/li>\n<li>\n<a href=\"rendering\/RenderSliverToBoxAdapter-class.html\">RenderSliverToBoxAdapter<\/a>, which allows a <a href=\"rendering\/RenderBox-class.html\">RenderBox<\/a> object to be\nplaced inside a <a href=\"rendering\/RenderSliver-class.html\">RenderSliver<\/a> (the opposite of this class).<\/li>\n<\/ul>",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "RenderViewportBase"
}