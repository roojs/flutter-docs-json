{
    "desc": "<p>A variant of <a href=\"flutter_test\/TestWidgetsFlutterBinding-class.html\">TestWidgetsFlutterBinding<\/a> for executing tests in\nthe <code>flutter run<\/code> environment, on a device. This is intended to\nallow interactive test development.<\/p>\n<p>This is not the way to run a remote-control test. To run a test on\na device from a development computer, see the <a href=\"flutter_driver\/flutter_driver-library.html\">flutter_driver<\/a>\npackage and the <code>flutter drive<\/code> command.<\/p>\n<p>When running tests using <code>flutter run<\/code>, consider adding the\n<code>--use-test-fonts<\/code> argument so that the fonts used match those used under\n<code>flutter test<\/code>. (This forces all text to use the \"Ahem\" font, which is a\nfont that covers ASCII characters and gives them all the appearance of a\nsquare whose size equals the font size.)<\/p>\n<p>This binding overrides the default <a href=\"scheduler\/SchedulerBinding-mixin.html\">SchedulerBinding<\/a> behavior to ensure\nthat tests work in the same way in this environment as they would under the\n<a href=\"flutter_test\/AutomatedTestWidgetsFlutterBinding-class.html\">AutomatedTestWidgetsFlutterBinding<\/a>. To override this (and see intermediate\nframes that the test does not explicitly trigger), set <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/framePolicy.html\">framePolicy<\/a> to\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.fullyLive<\/a>. (This is likely to\nmake tests fail, though, especially if e.g. they test how many times a\nparticular widget was built.) The default behavior is to show pumped frames\nand a few additional frames when pointers are triggered (to animate the\npointer crosshairs).<\/p>\n<p>This binding does not support the <a href=\"flutter_test\/EnginePhase-class.html\">EnginePhase<\/a> argument to\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/pump.html\">pump<\/a>. (There would be no point setting it to a value that\ndoesn't trigger a paint, since then you could not see anything\nanyway.)<\/p>\n    ",
    "dtype": "class",
    "example": "",
    "href": "flutter_test\/LiveTestWidgetsFlutterBinding-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "memberOf": "flutter_test",
    "name": "flutter_test.LiveTestWidgetsFlutterBinding",
    "shortname": "LiveTestWidgetsFlutterBinding",
    "extends": [
        "flutter_test.TestWidgetsFlutterBinding",
        "foundation.BindingBase",
        "dart:core.Object"
    ],
    "is_enum": false,
    "is_mixin": false,
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": "",
            "example": "",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/LiveTestWidgetsFlutterBinding.html",
            "isDeprecated": false,
            "type": "",
            "name": "LiveTestWidgetsFlutterBinding",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Returns a <a href=\"rendering\/ViewConfiguration-class.html\">ViewConfiguration<\/a> configured for the <a href=\"rendering\/RenderView-class.html\">RenderView<\/a> based on the\ncurrent environment.<\/p>\n<p>This is called during construction and also in response to changes to the\nsystem metrics.<\/p>\n<p>Bindings can override this method to change what size or device pixel\nratio the <a href=\"rendering\/RenderView-class.html\">RenderView<\/a> will use. For example, the testing framework uses\nthis to force the display into 800x600 when a test is run on the device\nusing <code>flutter run<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nViewConfiguration createViewConfiguration() {\n  return TestViewConfiguration(\n    size: _surfaceSize ?? _kDefaultTestViewportSize,\n    window: window,\n  );\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/createViewConfiguration.html",
            "isDeprecated": false,
            "type": "rendering.ViewConfiguration",
            "name": "createViewConfiguration",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Dispatch an event to a hit test result's path.<\/p>\n<p>This sends the given event to every <a href=\"gestures\/HitTestTarget-class.html\">HitTestTarget<\/a> in the entries of the\ngiven <a href=\"gestures\/HitTestResult-class.html\">HitTestResult<\/a>, and catches exceptions that any of the handlers\nmight throw. The <code>hitTestResult<\/code> argument may only be null for\n<a href=\"gestures\/PointerHoverEvent-class.html\">PointerHoverEvent<\/a>, <a href=\"gestures\/PointerAddedEvent-class.html\">PointerAddedEvent<\/a>, or <a href=\"gestures\/PointerRemovedEvent-class.html\">PointerRemovedEvent<\/a> events.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid dispatchEvent(\n  PointerEvent event,\n  HitTestResult hitTestResult, {\n  TestBindingEventSource source = TestBindingEventSource.device,\n}) {\n  switch (source) {\n    case TestBindingEventSource.test:\n      if (!renderView._pointers.containsKey(event.pointer)) {\n        assert(event.down);\n        renderView._pointers[event.pointer] = _LiveTestPointerRecord(event.pointer, event.position);\n      } else {\n        renderView._pointers[event.pointer].position = event.position;\n        if (!event.down)\n          renderView._pointers[event.pointer].decay = _kPointerDecay;\n      }\n      _handleViewNeedsPaint();\n      super.dispatchEvent(event, hitTestResult, source: source);\n      break;\n    case TestBindingEventSource.device:\n      if (deviceEventDispatcher != null)\n        deviceEventDispatcher.dispatchEvent(event, hitTestResult);\n      break;\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/dispatchEvent.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "dispatchEvent",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "event",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "gestures.PointerEvent"
                },
                {
                    "name": "hitTestResult",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "gestures.HitTestResult"
                },
                {
                    "name": "source",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.TestBindingEventSource"
                }
            ]
        },
        {
            "desc": "<p>Convert the given point from the global coordinate system (as used by\npointer events from the device) to the coordinate system used by the\ntests (an 800 by 600 window).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nOffset globalToLocal(Offset point) {\n  final Matrix4 transform = renderView.configuration.toHitTestMatrix();\n  final double det = transform.invert();\n  assert(det != 0.0);\n  final Offset result = MatrixUtils.transformPoint(transform, point);\n  return result;\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/globalToLocal.html",
            "isDeprecated": false,
            "type": "dart:ui.Offset",
            "name": "globalToLocal",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "point",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:ui.Offset"
                }
            ]
        },
        {
            "desc": "<p>Called by the engine to prepare the framework to produce a new frame.<\/p>\n<p>This function calls all the transient frame callbacks registered by\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">scheduleFrameCallback<\/a>. It then returns, any scheduled microtasks are run\n(e.g. handlers for any <a href=\"dart-async\/Future-class.html\">Future<\/a>s resolved by transient frame callbacks),\nand <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/handleDrawFrame.html\">handleDrawFrame<\/a> is called to continue the frame.<\/p>\n<p>If the given time stamp is null, the time stamp from the last frame is\nreused.<\/p>\n<p>To have a banner shown at the start of every frame in debug mode, set\n<a href=\"scheduler\/debugPrintBeginFrameBanner.html\">debugPrintBeginFrameBanner<\/a> to true. The banner will be printed to the\nconsole using <a href=\"foundation\/debugPrint.html\">debugPrint<\/a> and will contain the frame number (which\nincrements by one for each frame), and the time stamp of the frame. If the\ngiven time stamp was null, then the string \"warm-up frame\" is shown\ninstead of the time stamp. This allows frames eagerly pushed by the\nframework to be distinguished from those requested by the engine in\nresponse to the \"Vsync\" signal from the operating system.<\/p>\n<p>You can also show a banner at the end of every frame by setting\n<a href=\"scheduler\/debugPrintEndFrameBanner.html\">debugPrintEndFrameBanner<\/a> to true. This allows you to distinguish log\nstatements printed during a frame from those printed between frames (e.g.\nin response to events or timers).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid handleBeginFrame(Duration rawTimeStamp) {\n  assert(_doDrawThisFrame == null);\n  if (_expectingFrame ||\n      (framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.fullyLive) ||\n      (framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.benchmark) ||\n      (framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.fadePointers &amp;&amp; _viewNeedsPaint)) {\n    _doDrawThisFrame = true;\n    super.handleBeginFrame(rawTimeStamp);\n  } else {\n    _doDrawThisFrame = false;\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/handleBeginFrame.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "handleBeginFrame",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "rawTimeStamp",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                }
            ]
        },
        {
            "desc": "<p>Called by the engine to produce a new frame.<\/p>\n<p>This method is called immediately after <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>. It calls all\nthe callbacks registered by <a href=\"scheduler\/SchedulerBinding\/addPersistentFrameCallback.html\">addPersistentFrameCallback<\/a>, which typically\ndrive the rendering pipeline, and then calls the callbacks registered by\n<a href=\"scheduler\/SchedulerBinding\/addPostFrameCallback.html\">addPostFrameCallback<\/a>.<\/p>\n<p>See <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/handleBeginFrame.html\">handleBeginFrame<\/a> for a discussion about debugging hooks that may be\nuseful when working with frame callbacks.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid handleDrawFrame() {\n  assert(_doDrawThisFrame != null);\n  if (_doDrawThisFrame)\n    super.handleDrawFrame();\n  _doDrawThisFrame = null;\n  _viewNeedsPaint = false;\n  if (_expectingFrame) { \/\/ set during pump\n    assert(_pendingFrame != null);\n    _pendingFrame.complete(); \/\/ unlocks the test API\n    _pendingFrame = null;\n    _expectingFrame = false;\n  } else if (framePolicy != LiveTestWidgetsFlutterBindingFramePolicy.benchmark) {\n    window.scheduleFrame();\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/handleDrawFrame.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "handleDrawFrame",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>The initialization method. Subclasses override this method to hook into\nthe platform and otherwise configure their services. Subclasses must call\n\"super.initInstances()\".<\/p>\n<p>By convention, if the service is to be provided as a singleton, it should\nbe exposed as <code>MixinClassName.instance<\/code>, a static getter that returns\n<code>MixinClassName._instance<\/code>, a static field that is set by\n<code>initInstances()<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initInstances() {\n  super.initInstances();\n  assert(!autoUpdateGoldenFiles);\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/initInstances.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "initInstances",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Creates a <a href=\"rendering\/RenderView-class.html\">RenderView<\/a> object to be the root of the\n<a href=\"rendering\/RenderObject-class.html\">RenderObject<\/a> rendering tree, and initializes it so that it\nwill be rendered when the engine is next ready to display a\nframe.<\/p>\n<p>Called automatically when the binding is created.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initRenderView() {\n  assert(renderView == null);\n  renderView = _LiveTestRenderView(\n    configuration: createViewConfiguration(),\n    onNeedPaint: _handleViewNeedsPaint,\n    window: window,\n  );\n  renderView.scheduleInitialFrame();\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/initRenderView.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "initRenderView",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Convert the given point from the coordinate system used by the tests (an\n800 by 600 window) to the global coordinate system (as used by pointer\nevents from the device).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nOffset localToGlobal(Offset point) {\n  final Matrix4 transform = renderView.configuration.toHitTestMatrix();\n  return MatrixUtils.transformPoint(transform, point);\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/localToGlobal.html",
            "isDeprecated": false,
            "type": "dart:ui.Offset",
            "name": "localToGlobal",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "point",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:ui.Offset"
                }
            ]
        },
        {
            "desc": "<p>Called by the <a href=\"flutter_test\/testWidgets.html\">testWidgets<\/a> function after a test is executed.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid postTest() {\n  super.postTest();\n  assert(!_expectingFrame);\n  assert(_pendingFrame == null);\n  _inTest = false;\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/postTest.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "postTest",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Triggers a frame sequence (build\/layout\/paint\/etc),\nthen flushes microtasks.<\/p>\n<p>If duration is set, then advances the clock by that much first.\nDoing this flushes microtasks.<\/p>\n<p>The supplied EnginePhase is the final phase reached during the pump pass;\nif not supplied, the whole pass is executed.<\/p>\n<p>See also <a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy<\/a>, which affects how\nthis method works when the test is run with <code>flutter run<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; pump([ Duration duration, EnginePhase newPhase = EnginePhase.sendSemanticsUpdate ]) {\n  assert(newPhase == EnginePhase.sendSemanticsUpdate);\n  assert(inTest);\n  assert(!_expectingFrame);\n  assert(_pendingFrame == null);\n  return TestAsyncUtils.guard&lt;void&gt;(() {\n    if (duration != null) {\n      Timer(duration, () {\n        _expectingFrame = true;\n        scheduleFrame();\n      });\n    } else {\n      _expectingFrame = true;\n      scheduleFrame();\n    }\n    _pendingFrame = Completer&lt;void&gt;();\n    return _pendingFrame.future;\n  });\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/pump.html",
            "isDeprecated": false,
            "type": "dart:async.Future",
            "name": "pump",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "duration",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "newPhase",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.EnginePhase"
                }
            ]
        },
        {
            "desc": "<p>Called when the framework catches an exception, even if that exception is\nbeing handled by <a href=\"flutter_test\/TestWidgetsFlutterBinding\/takeException.html\">takeException<\/a>.<\/p>\n<p>This is called when there is no pending exception; if multiple exceptions\nare thrown and <a href=\"flutter_test\/TestWidgetsFlutterBinding\/takeException.html\">takeException<\/a> isn't used, then subsequent exceptions are\nlogged to the console regardless (and the test will fail).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid reportExceptionNoticed(FlutterErrorDetails exception) {\n  final DebugPrintCallback testPrint = debugPrint;\n  debugPrint = debugPrintOverride;\n  debugPrint('(The following exception is now available via WidgetTester.takeException:)');\n  FlutterError.dumpErrorToConsole(exception, forceReport: true);\n  debugPrint(\n    '(If WidgetTester.takeException is called, the above exception will be ignored. '\n    'If it is not, then the above exception will be dumped when another exception is '\n    'caught by the framework or when the test ends, whichever happens first, and then '\n    'the test will fail due to having not caught or expected the exception.)'\n  );\n  debugPrint = testPrint;\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/reportExceptionNoticed.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "reportExceptionNoticed",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "exception",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "foundation.FlutterErrorDetails"
                }
            ]
        },
        {
            "desc": "<p>Runs a <code>callback<\/code> that performs real asynchronous work.<\/p>\n<p>This is intended for callers who need to call asynchronous methods where\nthe methods spawn isolates or OS threads and thus cannot be executed\nsynchronously by calling <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/pump.html\">pump<\/a>.<\/p>\n<p>If <code>callback<\/code> completes successfully, this will return the future\nreturned by <code>callback<\/code>.<\/p>\n<p>If <code>callback<\/code> completes with an error, the error will be caught by the\nFlutter framework and made available via <a href=\"flutter_test\/TestWidgetsFlutterBinding\/takeException.html\">takeException<\/a>, and this method\nwill return a future that completes will <code>null<\/code>.<\/p>\n<p>Re-entrant calls to this method are not allowed; callers of this method\nare required to wait for the returned future to complete before calling\nthis method again. Attempts to do otherwise will result in a\n<a href=\"package-test_api_test_api\/TestFailure-class.html\">TestFailure<\/a> error being thrown.<\/p>\n<p>The <code>additionalTime<\/code> argument is used by the\n<a href=\"flutter_test\/AutomatedTestWidgetsFlutterBinding-class.html\">AutomatedTestWidgetsFlutterBinding<\/a> implementation to increase the\ncurrent timeout. See <a href=\"flutter_test\/TestWidgetsFlutterBinding\/addTime.html\">AutomatedTestWidgetsFlutterBinding.addTime<\/a> for\ndetails. The value is ignored by the <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding-class.html\">LiveTestWidgetsFlutterBinding<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;T&gt; runAsync&lt;T&gt;(\n  Future&lt;T&gt; callback(), {\n  Duration additionalTime = const Duration(milliseconds: 1000),\n}) async {\n  assert(() {\n    if (!_runningAsyncTasks)\n      return true;\n    throw test_package.TestFailure(\n        'Reentrant call to runAsync() denied.\\n'\n        'runAsync() was called, then before its future completed, it '\n        'was called again. You must wait for the first returned future '\n        'to complete before calling runAsync() again.'\n    );\n  }());\n\n  _runningAsyncTasks = true;\n  try {\n    return await callback();\n  } catch (error, stack) {\n    FlutterError.reportError(FlutterErrorDetails(\n      exception: error,\n      stack: stack,\n      library: 'Flutter test framework',\n      context: 'while running async test code',\n    ));\n    return null;\n  } finally {\n    _runningAsyncTasks = false;\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/runAsync.html",
            "isDeprecated": false,
            "type": "dart:async.Future",
            "name": "runAsync",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "additionalTime",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "callback",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:async.Future"
                }
            ]
        },
        {
            "desc": "<p>Call the testBody inside a <a href=\"quiver.testing.async\/FakeAsync-class.html\">FakeAsync<\/a> scope on which <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/pump.html\">pump<\/a> can\nadvance time.<\/p>\n<p>Returns a future which completes when the test has run.<\/p>\n<p>Called by the <a href=\"flutter_test\/testWidgets.html\">testWidgets<\/a> and <a href=\"flutter_test\/benchmarkWidgets.html\">benchmarkWidgets<\/a> functions to\nrun a test.<\/p>\n<p>The <code>invariantTester<\/code> argument is called after the <code>testBody<\/code>'s <a href=\"dart-async\/Future-class.html\">Future<\/a>\ncompletes. If it throws, then the test is marked as failed.<\/p>\n<p>The <code>description<\/code> is used by the <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding-class.html\">LiveTestWidgetsFlutterBinding<\/a> to\nshow a label on the screen during the test. The description comes from\nthe value passed to <a href=\"flutter_test\/testWidgets.html\">testWidgets<\/a>. It must not be null.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; runTest(Future&lt;void&gt; testBody(), VoidCallback invariantTester, { String description = '' }) async {\n  assert(description != null);\n  assert(!inTest);\n  _inTest = true;\n  renderView._setDescription(description);\n  return _runTest(testBody, invariantTester, description);\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/runTest.html",
            "isDeprecated": false,
            "type": "dart:async.Future",
            "name": "runTest",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": [
                {
                    "name": "description",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.String"
                },
                {
                    "name": "invariantTester",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:ui.VoidCallback"
                },
                {
                    "name": "testBody",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:async.Future"
                }
            ]
        },
        {
            "desc": "<p>Schedules a new frame by calling <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleFrame.html\">Window.scheduleFrame<\/a>.<\/p>\n<p>After this is called, the engine will call <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>, even if\nframes would normally not be scheduled by <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleFrame.html\">scheduleFrame<\/a> (e.g. even if\nthe device's screen is turned off).<\/p>\n<p>The framework uses this to force a frame to be rendered at the correct\nsize when the phone is rotated, so that a correctly-sized rendering is\navailable when the screen is turned back on.<\/p>\n<p>To have a stack trace printed to the console any time this function\nschedules a frame, set <a href=\"scheduler\/debugPrintScheduleFrameStacks.html\">debugPrintScheduleFrameStacks<\/a> to true.<\/p>\n<p>Prefer using <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleFrame.html\">scheduleFrame<\/a> unless it is imperative that a frame be\nscheduled immediately, since using <code>scheduleForceFrame<\/code> will cause\nsignificantly higher battery usage when the device should be idle.<\/p>\n<p>Consider using <a href=\"scheduler\/SchedulerBinding\/scheduleWarmUpFrame.html\">scheduleWarmUpFrame<\/a> instead if the goal is to update the\nrendering as soon as possible (e.g. at application startup).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid scheduleForcedFrame() {\n  if (framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.benchmark)\n    return; \/\/ In benchmark mode, don't actually schedule any engine frames.\n  super.scheduleForcedFrame();\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleForcedFrame.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "scheduleForcedFrame",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>If necessary, schedules a new frame by calling\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleFrame.html\">Window.scheduleFrame<\/a>.<\/p>\n<p>After this is called, the engine will (eventually) call\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/handleBeginFrame.html\">handleBeginFrame<\/a>. (This call might be delayed, e.g. if the device's\nscreen is turned off it will typically be delayed until the screen is on\nand the application is visible.) Calling this during a frame forces\nanother frame to be scheduled, even if the current frame has not yet\ncompleted.<\/p>\n<p>Scheduled frames are serviced when triggered by a \"Vsync\" signal provided\nby the operating system. The \"Vsync\" signal, or vertical synchronization\nsignal, was historically related to the display refresh, at a time when\nhardware physically moved a beam of electrons vertically between updates\nof the display. The operation of contemporary hardware is somewhat more\nsubtle and complicated, but the conceptual \"Vsync\" refresh signal continue\nto be used to indicate when applications should update their rendering.<\/p>\n<p>To have a stack trace printed to the console any time this function\nschedules a frame, set <a href=\"scheduler\/debugPrintScheduleFrameStacks.html\">debugPrintScheduleFrameStacks<\/a> to true.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleForcedFrame.html\">scheduleForcedFrame<\/a>, which ignores the <a href=\"scheduler\/SchedulerBinding\/lifecycleState.html\">lifecycleState<\/a> when\nscheduling a frame.<\/li>\n<li>\n<a href=\"scheduler\/SchedulerBinding\/scheduleWarmUpFrame.html\">scheduleWarmUpFrame<\/a>, which ignores the \"Vsync\" signal entirely and\ntriggers a frame immediately.<\/li>\n<\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid scheduleFrame() {\n  if (framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.benchmark)\n    return; \/\/ In benchmark mode, don't actually schedule any engine frames.\n  super.scheduleFrame();\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/scheduleFrame.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "scheduleFrame",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        }
    ],
    "props": [
        {
            "desc": "<p>The current time.<\/p>\n<p>In the automated test environment (<code>flutter test<\/code>), this is a fake clock\nthat begins in January 2015 at the start of the test and advances each\ntime <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/pump.html\">pump<\/a> is called with a non-zero duration.<\/p>\n<p>In the live testing environment (<code>flutter run<\/code>), this object shows the\nactual current wall-clock time.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nClock get clock =&gt; const Clock();<\/code><\/pre>\n        ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/clock.html",
            "name": "clock",
            "isDeprecated": false,
            "type": "quiver.time.Clock",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>The default test timeout for tests when using this binding.<\/p>\n<p>The <a href=\"flutter_test\/AutomatedTestWidgetsFlutterBinding-class.html\">AutomatedTestWidgetsFlutterBinding<\/a> layers in an additional timeout\nmechanism beyond this, with much more aggressive timeouts. See\n<a href=\"flutter_test\/TestWidgetsFlutterBinding\/addTime.html\">AutomatedTestWidgetsFlutterBinding.addTime<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\ntest_package.Timeout get defaultTestTimeout =&gt; test_package.Timeout.none;<\/code><\/pre>\n        ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/defaultTestTimeout.html",
            "name": "defaultTestTimeout",
            "isDeprecated": false,
            "type": "test_api.Timeout",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>An object to which real device events should be routed.<\/p>\n<p>Normally, device events are silently dropped. However, if this property is\nset to a non-null value, then the events will be routed to its\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/dispatchEvent.html\">HitTestDispatcher.dispatchEvent<\/a> method instead.<\/p>\n<p>Events dispatched by <a href=\"flutter_test\/TestGesture-class.html\">TestGesture<\/a> are not affected by this.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">HitTestDispatcher deviceEventDispatcher\n\n<\/code><\/pre>\n        ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/deviceEventDispatcher.html",
            "name": "deviceEventDispatcher",
            "isDeprecated": false,
            "type": "gestures.HitTestDispatcher",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Whether to have <a href=\"flutter_test\/LiveTestWidgetsFlutterBinding\/pump.html\">pump<\/a> with a duration only pump a single frame\n(as would happen in a normal test environment using\n<a href=\"flutter_test\/AutomatedTestWidgetsFlutterBinding-class.html\">AutomatedTestWidgetsFlutterBinding<\/a>), or whether to instead\npump every frame that the system requests during any\nasynchronous pause in the test (as would normally happen when\nrunning an application with <a href=\"widgets\/WidgetsFlutterBinding-class.html\">WidgetsFlutterBinding<\/a>).<\/p>\n<ul>\n<li>\n<p><a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.fadePointers<\/a> is the default\nbehavior, which is to only pump once, except when there has been some\nactivity with <a href=\"flutter_test\/TestPointer-class.html\">TestPointer<\/a>s, in which case those are shown and may pump\nadditional frames.<\/p>\n<\/li>\n<li>\n<p><a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.onlyPumps<\/a> is the strictest\nbehavior, which is to only pump once. This most closely matches the\n<a href=\"flutter_test\/AutomatedTestWidgetsFlutterBinding-class.html\">AutomatedTestWidgetsFlutterBinding<\/a> (<code>flutter test<\/code>) behavior.<\/p>\n<\/li>\n<li>\n<p><a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.fullyLive<\/a> allows all frame\nrequests from the engine to be serviced, even those the test did not\nexplicitly pump.<\/p>\n<\/li>\n<li>\n<p><a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.benchmark<\/a> allows all frame\nrequests from the engine to be serviced, and allows all frame requests\nthat are artificially triggered to be serviced, but prevents the\nframework from requesting any frames from the engine itself. The\n<a href=\"scheduler\/SchedulerBinding\/hasScheduledFrame.html\">SchedulerBinding.hasScheduledFrame<\/a> property will never be true in this\nmode. This can cause unexpected effects. For instance,\n<a href=\"flutter_test\/WidgetTester\/pumpAndSettle.html\">WidgetTester.pumpAndSettle<\/a> does not function in this mode, as it\nrelies on the <a href=\"scheduler\/SchedulerBinding\/hasScheduledFrame.html\">SchedulerBinding.hasScheduledFrame<\/a> property to determine\nwhen the application has \"settled\".<\/p>\n<\/li>\n<\/ul>\n<p>Setting this to anything other than\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.onlyPumps<\/a> means pumping extra\nframes, which might involve calling builders more, or calling paint\ncallbacks more, etc, which might interfere with the test. If you know your\ntest file wouldn't be affected by this, you can set it to\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.fullyLive<\/a> persistently in that\nparticular test file. To set this to\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.fullyLive<\/a> while still allowing\nthe test file to work as a normal test, add the following code to your\ntest file at the top of your <code>void main() { }<\/code> function, before calls to\n<a href=\"flutter_test\/testWidgets.html\">testWidgets<\/a>:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">TestWidgetsFlutterBinding binding = TestWidgetsFlutterBinding.ensureInitialized();\nif (binding is LiveTestWidgetsFlutterBinding)\n  binding.framePolicy = LiveTestWidgetsFlutterBindingFramePolicy.fullyLive;\n<\/code><\/pre>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">LiveTestWidgetsFlutterBindingFramePolicy framePolicy = LiveTestWidgetsFlutterBindingFramePolicy.fadePointers\n\n<\/code><\/pre>\n        ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/framePolicy.html",
            "name": "framePolicy",
            "isDeprecated": false,
            "type": "flutter_test.LiveTestWidgetsFlutterBindingFramePolicy",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>Whether there is currently a test executing.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get inTest =&gt; _inTest;<\/code><\/pre>\n        ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/inTest.html",
            "name": "inTest",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        },
        {
            "desc": "<p>The number of outstanding microtasks in the queue.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get microtaskCount {\n  \/\/ The Dart SDK doesn't report this number.\n  assert(false, 'microtaskCount cannot be reported when running in real time');\n  return -1;\n}<\/code><\/pre>\n        ",
            "href": "flutter_test\/LiveTestWidgetsFlutterBinding\/microtaskCount.html",
            "name": "microtaskCount",
            "isDeprecated": false,
            "type": "dart:core.int",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "flutter_test.LiveTestWidgetsFlutterBinding",
            "params": []
        }
    ]
}