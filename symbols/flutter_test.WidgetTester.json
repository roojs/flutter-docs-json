{
    "desc": "<p>Class that programmatically interacts with widgets and the test environment.<\/p>\n<p>For convenience, instances of this class (such as the one provided by\n<code>testWidget<\/code>) can be used as the <code>vsync<\/code> for <code>AnimationController<\/code> objects.<\/p>\n    ",
    "dtype": "class",
    "example": "",
    "href": "flutter_test\/WidgetTester-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "flutter_test",
    "name": "flutter_test.WidgetTester",
    "shortname": "WidgetTester",
    "extends": [
        "flutter_test.WidgetController",
        "dart:core.Object"
    ],
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": "<p>Creates a ticker with the given callback.<\/p>\n<p>The kind of ticker provided depends on the kind of ticker provider.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nTicker createTicker(TickerCallback onTick) {\n  _tickers ??= &lt;_TestTicker&gt;{};\n  final _TestTicker result = _TestTicker(onTick, _removeTicker);\n  _tickers.add(result);\n  return result;\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/createTicker.html",
            "isDeprecated": "0",
            "type": "scheduler.Ticker",
            "name": "createTicker",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "onTick",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "scheduler.TickerCallback"
                }
            ]
        },
        {
            "desc": "<p>Handler for device events caught by the binding in live test mode.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid dispatchEvent(PointerEvent event, HitTestResult result) {\n  if (event is PointerDownEvent) {\n    final RenderObject innerTarget = result.path.firstWhere(\n      (HitTestEntry candidate) =&gt; candidate.target is RenderObject,\n    ).target;\n    final Element innerTargetElement = collectAllElementsFrom(\n      binding.renderViewElement,\n      skipOffstage: true,\n    ).lastWhere(\n      (Element element) =&gt; element.renderObject == innerTarget,\n      orElse: () =&gt; null,\n    );\n    if (innerTargetElement == null) {\n      debugPrint('No widgets found at ${binding.globalToLocal(event.position)}.');\n      return;\n    }\n    final List&lt;Element&gt; candidates = &lt;Element&gt;[];\n    innerTargetElement.visitAncestorElements((Element element) {\n      candidates.add(element);\n      return true;\n    });\n    assert(candidates.isNotEmpty);\n    String descendantText;\n    int numberOfWithTexts = 0;\n    int numberOfTypes = 0;\n    int totalNumber = 0;\n    debugPrint('Some possible finders for the widgets at ${binding.globalToLocal(event.position)}:');\n    for (Element element in candidates) {\n      if (totalNumber &gt; 13) \/\/ an arbitrary number of finders that feels useful without being overwhelming\n        break;\n      totalNumber += 1; \/\/ optimistically assume we'll be able to describe it\n\n      if (element.widget is Tooltip) {\n        final Tooltip widget = element.widget;\n        final Iterable&lt;Element&gt; matches = find.byTooltip(widget.message).evaluate();\n        if (matches.length == 1) {\n          debugPrint('  find.byTooltip(\\'${widget.message}\\')');\n          continue;\n        }\n      }\n\n      if (element.widget is Text) {\n        assert(descendantText == null);\n        final Text widget = element.widget;\n        final Iterable&lt;Element&gt; matches = find.text(widget.data).evaluate();\n        descendantText = widget.data;\n        if (matches.length == 1) {\n          debugPrint('  find.text(\\'${widget.data}\\')');\n          continue;\n        }\n      }\n\n      if (element.widget.key is ValueKey&lt;dynamic&gt;) {\n        final ValueKey&lt;dynamic&gt; key = element.widget.key;\n        String keyLabel;\n        if (key is ValueKey&lt;int&gt; ||\n            key is ValueKey&lt;double&gt; ||\n            key is ValueKey&lt;bool&gt;) {\n          keyLabel = 'const ${element.widget.key.runtimeType}(${key.value})';\n        } else if (key is ValueKey&lt;String&gt;) {\n          keyLabel = 'const Key(\\'${key.value}\\')';\n        }\n        if (keyLabel != null) {\n          final Iterable&lt;Element&gt; matches = find.byKey(key).evaluate();\n          if (matches.length == 1) {\n            debugPrint('  find.byKey($keyLabel)');\n            continue;\n          }\n        }\n      }\n\n      if (!_isPrivate(element.widget.runtimeType)) {\n        if (numberOfTypes &lt; 5) {\n          final Iterable&lt;Element&gt; matches = find.byType(element.widget.runtimeType).evaluate();\n          if (matches.length == 1) {\n            debugPrint('  find.byType(${element.widget.runtimeType})');\n            numberOfTypes += 1;\n            continue;\n          }\n        }\n\n        if (descendantText != null &amp;&amp; numberOfWithTexts &lt; 5) {\n          final Iterable&lt;Element&gt; matches = find.widgetWithText(element.widget.runtimeType, descendantText).evaluate();\n          if (matches.length == 1) {\n            debugPrint('  find.widgetWithText(${element.widget.runtimeType}, \\'$descendantText\\')');\n            numberOfWithTexts += 1;\n            continue;\n          }\n        }\n      }\n\n      if (!_isPrivate(element.runtimeType)) {\n        final Iterable&lt;Element&gt; matches = find.byElementType(element.runtimeType).evaluate();\n        if (matches.length == 1) {\n          debugPrint('  find.byElementType(${element.runtimeType})');\n          continue;\n        }\n      }\n\n      totalNumber -= 1; \/\/ if we got here, we didn't actually find something to say about it\n    }\n    if (totalNumber == 0)\n      debugPrint('  &lt;could not come up with any unique finders&gt;');\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/dispatchEvent.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "dispatchEvent",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "event",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "gestures.PointerEvent"
                },
                {
                    "name": "result",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "gestures.HitTestResult"
                }
            ]
        },
        {
            "desc": "<p>Enable semantics in a test by creating a <a href=\"rendering\/SemanticsHandle-class.html\">SemanticsHandle<\/a>.<\/p>\n<p>The handle must be disposed at the end of the test.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">SemanticsHandle ensureSemantics() {\n  return binding.pipelineOwner.ensureSemantics();\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/ensureSemantics.html",
            "isDeprecated": "0",
            "type": "rendering.SemanticsHandle",
            "name": "ensureSemantics",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        },
        {
            "desc": "<p>Given a widget <code>W<\/code> specified by <code>finder<\/code> and a <a href=\"widgets\/Scrollable-class.html\">Scrollable<\/a> widget <code>S<\/code> in\nits ancestry tree, this scrolls <code>S<\/code> so as to make <code>W<\/code> visible.<\/p>\n<p>Shorthand for <code>Scrollable.ensureVisible(tester.element(finder))<\/code><\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; ensureVisible(Finder finder) =&gt; Scrollable.ensureVisible(element(finder));<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/ensureVisible.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "ensureVisible",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "finder",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.Finder"
                }
            ]
        },
        {
            "desc": "<p>Give the text input widget specified by <code>finder<\/code> the focus and\nenter <code>text<\/code> as if it been provided by the onscreen keyboard.<\/p>\n<p>The widget specified by <code>finder<\/code> must be an <a href=\"widgets\/EditableText-class.html\">EditableText<\/a> or have\nan <a href=\"widgets\/EditableText-class.html\">EditableText<\/a> descendant. For example <code>find.byType(TextField)<\/code>\nor <code>find.byType(TextFormField)<\/code>, or <code>find.byType(EditableText)<\/code>.<\/p>\n<p>To just give <code>finder<\/code> the focus without entering any text,\nsee <a href=\"flutter_test\/WidgetTester\/showKeyboard.html\">showKeyboard<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; enterText(Finder finder, String text) async {\n  return TestAsyncUtils.guard&lt;void&gt;(() async {\n    await showKeyboard(finder);\n    testTextInput.enterText(text);\n    await idle();\n  });\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/enterText.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "enterText",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "finder",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.Finder"
                },
                {
                    "name": "text",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Attempts to find the <a href=\"semantics\/SemanticsNode-class.html\">SemanticsNode<\/a> of first result from <code>finder<\/code>.<\/p>\n<p>If the object identified by the finder doesn't own it's semantic node,\nthis will return the semantics data of the first ancestor with semantics.\nThe ancestor's semantic data will include the child's as well as\nother nodes that have been merged together.<\/p>\n<p>Will throw a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if the finder returns more than one element or\nif no semantics are found or are not enabled.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">SemanticsNode getSemantics(Finder finder) {\n  if (binding.pipelineOwner.semanticsOwner == null)\n    throw StateError('Semantics are not enabled.');\n  final Iterable&lt;Element&gt; candidates = finder.evaluate();\n  if (candidates.isEmpty) {\n    throw StateError('Finder returned no matching elements.');\n  }\n  if (candidates.length &gt; 1) {\n    throw StateError('Finder returned more than one element.');\n  }\n  final Element element = candidates.single;\n  RenderObject renderObject = element.findRenderObject();\n  SemanticsNode result = renderObject.debugSemantics;\n  while (renderObject != null &amp;&amp; result == null) {\n    renderObject = renderObject?.parent;\n    result = renderObject?.debugSemantics;\n  }\n  if (result == null)\n    throw StateError('No Semantics data found.');\n  return result;\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/getSemantics.html",
            "isDeprecated": "0",
            "type": "semantics.SemanticsNode",
            "name": "getSemantics",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "finder",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.Finder"
                }
            ]
        },
        {
            "desc": "<p>Forwards the given location to the binding's hitTest logic.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nHitTestResult hitTestOnBinding(Offset location) {\n  location = binding.localToGlobal(location);\n  return super.hitTestOnBinding(location);\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/hitTestOnBinding.html",
            "isDeprecated": "0",
            "type": "gestures.HitTestResult",
            "name": "hitTestOnBinding",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "location",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:ui.Offset"
                }
            ]
        },
        {
            "desc": "<p>Acts as if the application went idle.<\/p>\n<p>Runs all remaining microtasks, including those scheduled as a result of\nrunning them, until there are no more microtasks scheduled.<\/p>\n<p>Does not run timers. May result in an infinite loop or run out of memory\nif microtasks continue to recursively schedule new microtasks.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; idle() {\n  return TestAsyncUtils.guard&lt;void&gt;(() =&gt; binding.idle());\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/idle.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "idle",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        },
        {
            "desc": "<p>Makes an effort to dismiss the current page with a Material <a href=\"material\/Scaffold-class.html\">Scaffold<\/a> or\na <a href=\"cupertino\/CupertinoPageScaffold-class.html\">CupertinoPageScaffold<\/a>.<\/p>\n<p>Will throw an error if there is no back button in the page.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; pageBack() async {\n  return TestAsyncUtils.guard&lt;void&gt;(() async {\n    Finder backButton = find.byTooltip('Back');\n    if (backButton.evaluate().isEmpty) {\n      backButton = find.byType(CupertinoNavigationBarBackButton);\n    }\n\n    expectSync(backButton, findsOneWidget, reason: 'One back button expected on screen');\n\n    await tap(backButton);\n  });\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/pageBack.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "pageBack",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        },
        {
            "desc": "<p>Triggers a frame after <code>duration<\/code> amount of time.<\/p>\n<p>This makes the framework act as if the application had janked (missed\nframes) for <code>duration<\/code> amount of time, and then received a v-sync signal\nto paint the application.<\/p>\n<p>This is a convenience function that just calls\n<a href=\"flutter_test\/WidgetTester\/pump.html\">TestWidgetsFlutterBinding.pump<\/a>.<\/p>\n<p>See also <a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy<\/a>, which affects how\nthis method works when the test is run with <code>flutter run<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; pump([\n  Duration duration,\n  EnginePhase phase = EnginePhase.sendSemanticsUpdate,\n]) {\n  return TestAsyncUtils.guard&lt;void&gt;(() =&gt; binding.pump(duration, phase));\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/pump.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "pump",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "duration",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "phase",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.EnginePhase"
                }
            ]
        },
        {
            "desc": "<p>Repeatedly calls <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> with the given <code>duration<\/code> until there are no\nlonger any frames scheduled. This will call <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> at least once, even if\nno frames are scheduled when the function is called, to flush any pending\nmicrotasks which may themselves schedule a frame.<\/p>\n<p>This essentially waits for all animations to have completed.<\/p>\n<p>If it takes longer that the given <code>timeout<\/code> to settle, then the test will\nfail (this method will throw an exception). In particular, this means that\nif there is an infinite animation in progress (for example, if there is an\nindeterminate progress indicator spinning), this method will throw.<\/p>\n<p>The default timeout is ten minutes, which is longer than most reasonable\nfinite animations would last.<\/p>\n<p>If the function returns, it returns the number of pumps that it performed.<\/p>\n<p>In general, it is better practice to figure out exactly why each frame is\nneeded, and then to <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> exactly as many frames as necessary. This will\nhelp catch regressions where, for instance, an animation is being started\none frame later than it should.<\/p>\n<p>Alternatively, one can check that the return value from this function\nmatches the expected number of pumps.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;int&gt; pumpAndSettle([\n  Duration duration = const Duration(milliseconds: 100),\n  EnginePhase phase = EnginePhase.sendSemanticsUpdate,\n  Duration timeout = const Duration(minutes: 10),\n]) {\n  assert(duration != null);\n  assert(duration &gt; Duration.zero);\n  assert(timeout != null);\n  assert(timeout &gt; Duration.zero);\n  assert(() {\n    final WidgetsBinding binding = this.binding;\n    if (binding is LiveTestWidgetsFlutterBinding &amp;&amp;\n        binding.framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.benchmark) {\n      throw 'When using LiveTestWidgetsFlutterBindingFramePolicy.benchmark, '\n            'hasScheduledFrame is never set to true. This means that pumpAndSettle() '\n            'cannot be used, because it has no way to know if the application has '\n            'stopped registering new frames.';\n    }\n    return true;\n  }());\n  int count = 0;\n  return TestAsyncUtils.guard&lt;void&gt;(() async {\n    final DateTime endTime = binding.clock.fromNowBy(timeout);\n    do {\n      if (binding.clock.now().isAfter(endTime))\n        throw FlutterError('pumpAndSettle timed out');\n      await binding.pump(duration, phase);\n      count += 1;\n    } while (binding.hasScheduledFrame);\n  }).then&lt;int&gt;((_) =&gt; count);\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/pumpAndSettle.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.int>",
            "name": "pumpAndSettle",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "duration",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "phase",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.EnginePhase"
                },
                {
                    "name": "timeout",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                }
            ]
        },
        {
            "desc": "<p>Triggers a frame after <code>duration<\/code> amount of time, return as soon as the frame is drawn.<\/p>\n<p>This enables driving an artificially high CPU load by rendering frames in\na tight loop. It must be used with the frame policy set to\n<a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy.benchmark<\/a>.<\/p>\n<p>Similarly to <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a>, this doesn't actually wait for <code>duration<\/code>, just\nadvances the clock.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; pumpBenchmark(Duration duration) async {\n  assert(() {\n    final TestWidgetsFlutterBinding widgetsBinding = binding;\n    return widgetsBinding is LiveTestWidgetsFlutterBinding &amp;&amp;\n            widgetsBinding.framePolicy == LiveTestWidgetsFlutterBindingFramePolicy.benchmark;\n  }());\n\n  dynamic caughtException;\n  void handleError(dynamic error, StackTrace stackTrace) =&gt; caughtException ??= error;\n\n  await Future&lt;void&gt;.microtask(() { binding.handleBeginFrame(duration); }).catchError(handleError);\n  await idle();\n  await Future&lt;void&gt;.microtask(() { binding.handleDrawFrame(); }).catchError(handleError);\n  await idle();\n\n  if (caughtException != null) {\n    throw caughtException;\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/pumpBenchmark.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "pumpBenchmark",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "duration",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                }
            ]
        },
        {
            "desc": "<p>Renders the UI from the given <code>widget<\/code>.<\/p>\n<p>Calls <a href=\"widgets\/runApp.html\">runApp<\/a> with the given widget, then triggers a frame and flushes\nmicrotasks, by calling <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> with the same <code>duration<\/code> (if any). The\nsupplied <a href=\"flutter_test\/EnginePhase-class.html\">EnginePhase<\/a> is the final phase reached during the pump pass; if\nnot supplied, the whole pass is executed.<\/p>\n<p>Subsequent calls to this is different from <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> in that it forces a full\nrebuild of the tree, even if <code>widget<\/code> is the same as the previous call.\n<a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> will only rebuild the widgets that have changed.<\/p>\n<p>This method should not be used as the first parameter to an <a href=\"flutter_test\/expect.html\">expect<\/a> or\n<a href=\"flutter_test\/expectLater.html\">expectLater<\/a> call to test that a widget throws an exception. Instead, use\n<a href=\"flutter_test\/WidgetTester\/takeException.html\">TestWidgetsFlutterBinding.takeException<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">testWidgets('MyWidget asserts invalid bounds', (WidgetTester tester) async {\n  await tester.pumpWidget(MyWidget(-1));\n  expect(tester.takeException(), isAssertionError); \/\/ or isNull, as appropriate.\n});<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also <a href=\"flutter_test\/LiveTestWidgetsFlutterBindingFramePolicy-class.html\">LiveTestWidgetsFlutterBindingFramePolicy<\/a>, which affects how\nthis method works when the test is run with <code>flutter run<\/code>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; pumpWidget(\n  Widget widget, [\n  Duration duration,\n  EnginePhase phase = EnginePhase.sendSemanticsUpdate,\n]) {\n  return TestAsyncUtils.guard&lt;void&gt;(() {\n    binding.attachRootWidget(widget);\n    binding.scheduleFrame();\n    return binding.pump(duration, phase);\n  });\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/pumpWidget.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "pumpWidget",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "duration",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "phase",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.EnginePhase"
                },
                {
                    "name": "widget",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.Widget"
                }
            ]
        },
        {
            "desc": "<p>Runs a <code>callback<\/code> that performs real asynchronous work.<\/p>\n<p>This is intended for callers who need to call asynchronous methods where\nthe methods spawn isolates or OS threads and thus cannot be executed\nsynchronously by calling <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a>.<\/p>\n<p>If callers were to run these types of asynchronous tasks directly in\ntheir test methods, they run the possibility of encountering deadlocks.<\/p>\n<p>If <code>callback<\/code> completes successfully, this will return the future\nreturned by <code>callback<\/code>.<\/p>\n<p>If <code>callback<\/code> completes with an error, the error will be caught by the\nFlutter framework and made available via <a href=\"flutter_test\/WidgetTester\/takeException.html\">takeException<\/a>, and this method\nwill return a future that completes will <code>null<\/code>.<\/p>\n<p>Re-entrant calls to this method are not allowed; callers of this method\nare required to wait for the returned future to complete before calling\nthis method again. Attempts to do otherwise will result in a\n<a href=\"package-test_api_test_api\/TestFailure-class.html\">TestFailure<\/a> error being thrown.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; runAsync&lt;T&gt;(\n  Future&lt;T&gt; callback(), {\n  Duration additionalTime = const Duration(milliseconds: 1000),\n}) =&gt; binding.runAsync&lt;T&gt;(callback, additionalTime: additionalTime);<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/runAsync.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "runAsync",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "additionalTime",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.Duration"
                },
                {
                    "name": "callback",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:async.Future"
                }
            ]
        },
        {
            "desc": "<p>Forwards the given pointer event to the binding.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; sendEventToBinding(PointerEvent event, HitTestResult result) {\n  return TestAsyncUtils.guard&lt;void&gt;(() async {\n    binding.dispatchEvent(event, result, source: TestBindingEventSource.test);\n  });\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/sendEventToBinding.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "sendEventToBinding",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "event",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "gestures.PointerEvent"
                },
                {
                    "name": "result",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "gestures.HitTestResult"
                }
            ]
        },
        {
            "desc": "<p>Give the text input widget specified by <code>finder<\/code> the focus, as if the\nonscreen keyboard had appeared.<\/p>\n<p>Implies a call to <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a>.<\/p>\n<p>The widget specified by <code>finder<\/code> must be an <a href=\"widgets\/EditableText-class.html\">EditableText<\/a> or have\nan <a href=\"widgets\/EditableText-class.html\">EditableText<\/a> descendant. For example <code>find.byType(TextField)<\/code>\nor <code>find.byType(TextFormField)<\/code>, or <code>find.byType(EditableText)<\/code>.<\/p>\n<p>Tests that just need to add text to widgets like <a href=\"material\/TextField-class.html\">TextField<\/a>\nor <a href=\"material\/TextFormField-class.html\">TextFormField<\/a> only need to call <a href=\"flutter_test\/WidgetTester\/enterText.html\">enterText<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; showKeyboard(Finder finder) async {\n  return TestAsyncUtils.guard&lt;void&gt;(() async {\n    final EditableTextState editable = state&lt;EditableTextState&gt;(\n      find.descendant(\n        of: finder,\n        matching: find.byType(EditableText),\n        matchRoot: true,\n      ),\n    );\n    binding.focusedEditable = editable;\n    await pump();\n  });\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/showKeyboard.html",
            "isDeprecated": "0",
            "type": "dart:async.Future",
            "name": "showKeyboard",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "finder",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "flutter_test.Finder"
                }
            ]
        },
        {
            "desc": "<p>Returns the exception most recently caught by the Flutter framework.<\/p>\n<p>See <a href=\"flutter_test\/WidgetTester\/takeException.html\">TestWidgetsFlutterBinding.takeException<\/a> for details.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">dynamic takeException() {\n  return binding.takeException();\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/takeException.html",
            "isDeprecated": "0",
            "type": "<dynamic>",
            "name": "takeException",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        },
        {
            "desc": "<p>Throws an exception if any tickers created by the <a href=\"flutter_test\/WidgetTester-class.html\">WidgetTester<\/a> are still\nactive when the method is called.<\/p>\n<p>An argument can be specified to provide a string that will be used in the\nerror message. It should be an adverbial phrase describing the current\nsituation, such as \"at the end of the test\".<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void verifyTickersWereDisposed([ String when = 'when none should have been' ]) {\n  assert(when != null);\n  if (_tickers != null) {\n    for (Ticker ticker in _tickers) {\n      if (ticker.isActive) {\n        throw FlutterError(\n          'A Ticker was active $when.\\n'\n          'All Tickers must be disposed. Tickers used by AnimationControllers '\n          'should be disposed by calling dispose() on the AnimationController itself. '\n          'Otherwise, the ticker will leak.\\n'\n          'The offending ticker was: ${ticker.toString(debugIncludeStack: true)}'\n        );\n      }\n    }\n  }\n}<\/code><\/pre>\n    ",
            "href": "flutter_test\/WidgetTester\/verifyTickersWereDisposed.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "verifyTickersWereDisposed",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "flutter_test.WidgetTester",
            "params": [
                {
                    "name": "when",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        }
    ],
    "props": [
        {
            "desc": "<p>The binding instance used by the testing framework.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nTestWidgetsFlutterBinding get binding =&gt; super.binding;<\/code><\/pre>\n        ",
            "href": "flutter_test\/WidgetTester\/binding.html",
            "name": "binding",
            "isDeprecated": false,
            "type": "flutter_test.TestWidgetsFlutterBinding",
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        },
        {
            "desc": "<p>Whether there are any any transient callbacks scheduled.<\/p>\n<p>This essentially checks whether all animations have completed.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"flutter_test\/WidgetTester\/pumpAndSettle.html\">pumpAndSettle<\/a>, which essentially calls <a href=\"flutter_test\/WidgetTester\/pump.html\">pump<\/a> until there are no\nscheduled frames.<\/li>\n<li>\n<a href=\"scheduler\/SchedulerBinding\/transientCallbackCount.html\">SchedulerBinding.transientCallbackCount<\/a>, which is the value on which\nthis is based.<\/li>\n<li>\n<a href=\"scheduler\/SchedulerBinding\/hasScheduledFrame.html\">SchedulerBinding.hasScheduledFrame<\/a>, which is true whenever a frame is\npending. <a href=\"scheduler\/SchedulerBinding\/hasScheduledFrame.html\">SchedulerBinding.hasScheduledFrame<\/a> is made true when a\nwidget calls <a href=\"widgets\/State\/setState.html\">State.setState<\/a>, even if there are no transient callbacks\nscheduled. This is what <a href=\"flutter_test\/WidgetTester\/pumpAndSettle.html\">pumpAndSettle<\/a> uses.<\/li>\n<\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasRunningAnimations =&gt; binding.transientCallbackCount &gt; 0;<\/code><\/pre>\n        ",
            "href": "flutter_test\/WidgetTester\/hasRunningAnimations.html",
            "name": "hasRunningAnimations",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        },
        {
            "desc": "<p>Returns the TestTextInput singleton.<\/p>\n<p>Typical app tests will not need to use this value. To add text to widgets\nlike <a href=\"material\/TextField-class.html\">TextField<\/a> or <a href=\"material\/TextFormField-class.html\">TextFormField<\/a>, call <a href=\"flutter_test\/WidgetTester\/enterText.html\">enterText<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">TestTextInput get testTextInput =&gt; binding.testTextInput;<\/code><\/pre>\n        ",
            "href": "flutter_test\/WidgetTester\/testTextInput.html",
            "name": "testTextInput",
            "isDeprecated": false,
            "type": "flutter_test.TestTextInput",
            "memberOf": "flutter_test.WidgetTester",
            "params": []
        }
    ]
}