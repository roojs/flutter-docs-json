{
    "name": "painting.BorderDirectional",
    "extends": [
        "painting.BoxBorder",
        "painting.ShapeBorder",
        "dart:core.Object"
    ],
    "memberOf": "painting",
    "events": [],
    "methods": [
        {
            "name": "operator ==",
            "type": "dart:core.bool",
            "desc": "<p>The equality operator.<\/p>\n<p>The default behavior for all <a href=\"dart-core\/Object-class.html\">Object<\/a>s is to return true if and\nonly if <code>this<\/code> and <code>other<\/code> are the same object.<\/p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:<\/p>\n<ul>\n<li>\n<p>Total: It must return a boolean for all arguments. It should never throw\nor return <code>null<\/code>.<\/p>\n<\/li>\n<li>\n<p>Reflexive: For all objects <code>o<\/code>, <code>o == o<\/code> must be true.<\/p>\n<\/li>\n<li>\n<p>Symmetric: For all objects <code>o1<\/code> and <code>o2<\/code>, <code>o1 == o2<\/code> and <code>o2 == o1<\/code> must\neither both be true, or both be false.<\/p>\n<\/li>\n<li>\n<p>Transitive: For all objects <code>o1<\/code>, <code>o2<\/code>, and <code>o3<\/code>, if <code>o1 == o2<\/code> and\n<code>o2 == o3<\/code> are true, then <code>o1 == o3<\/code> must be true.<\/p>\n<\/li>\n<\/ul>\n<p>The method should also be consistent over time,\nso whether two objects are equal should only change\nif at least one of the objects was modified.<\/p>\n<p>If a subclass overrides the equality operator it should override\nthe <a href=\"painting\/BorderDirectional\/hashCode.html\">hashCode<\/a> method as well to maintain consistency.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "other",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/operator_equals.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool operator ==(dynamic other) {\n  if (identical(this, other))\n    return true;\n  if (runtimeType != other.runtimeType)\n    return false;\n  final BorderDirectional typedOther = other;\n  return top == typedOther.top &amp;&amp;\n         start == typedOther.start &amp;&amp;\n         end == typedOther.end &amp;&amp;\n         bottom == typedOther.bottom;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "BorderDirectional",
            "type": "",
            "desc": "<p>Creates a border.<\/p>\n<p>The <code>start<\/code> and <code>end<\/code> sides represent the horizontal sides; the start side\nis on the leading edge given the reading direction, and the end side is on\nthe trailing edge. They are resolved during <a href=\"painting\/BorderDirectional\/paint.html\">paint<\/a>.<\/p>\n<p>All the sides of the border default to <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "top",
                    "type": "painting.BorderSide",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "start",
                    "type": "painting.BorderSide",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "end",
                    "type": "painting.BorderSide",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "bottom",
                    "type": "painting.BorderSide",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "painting\/BorderDirectional\/BorderDirectional.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BorderDirectional({\n  this.top = BorderSide.none,\n  this.start = BorderSide.none,\n  this.end = BorderSide.none,\n  this.bottom = BorderSide.none,\n}) : assert(top != null),\n     assert(start != null),\n     assert(end != null),\n     assert(bottom != null);<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "add",
            "type": "painting.BoxBorder",
            "desc": "<p>Attempts to create a new object that represents the amalgamation of <code>this<\/code>\nborder and the <code>other<\/code> border.<\/p>\n<p>If the type of the other border isn't known, or the given instance cannot\nbe reasonably added to this instance, then this should return null.<\/p>\n<p>This method is used by the <a href=\"painting\/ShapeBorder\/operator_plus.html\">operator +<\/a> implementation.<\/p>\n<p>The <code>reversed<\/code> argument is true if this object was the right operand of\nthe <code>+<\/code> operator, and false if it was the left operand.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "other",
                    "type": "painting.ShapeBorder",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "reversed",
                    "type": "dart:core.bool",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/add.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxBorder add(ShapeBorder other, { bool reversed = false }) {\n  if (other is BorderDirectional) {\n    final BorderDirectional typedOther = other;\n    if (BorderSide.canMerge(top, typedOther.top) &amp;&amp;\n        BorderSide.canMerge(start, typedOther.start) &amp;&amp;\n        BorderSide.canMerge(end, typedOther.end) &amp;&amp;\n        BorderSide.canMerge(bottom, typedOther.bottom)) {\n      return BorderDirectional.merge(this, typedOther);\n    }\n    return null;\n  }\n  if (other is Border) {\n    final Border typedOther = other;\n    if (!BorderSide.canMerge(typedOther.top, top) ||\n        !BorderSide.canMerge(typedOther.bottom, bottom))\n      return null;\n    if (start != BorderSide.none ||\n        end != BorderSide.none) {\n      if (typedOther.left != BorderSide.none ||\n          typedOther.right != BorderSide.none)\n        return null;\n      assert(typedOther.left == BorderSide.none);\n      assert(typedOther.right == BorderSide.none);\n      return BorderDirectional(\n        top: BorderSide.merge(typedOther.top, top),\n        start: start,\n        end: end,\n        bottom: BorderSide.merge(typedOther.bottom, bottom),\n      );\n    }\n    assert(start == BorderSide.none);\n    assert(end == BorderSide.none);\n    return Border(\n      top: BorderSide.merge(typedOther.top, top),\n      right: typedOther.right,\n      bottom: BorderSide.merge(typedOther.bottom, bottom),\n      left: typedOther.left,\n    );\n  }\n  return null;\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "lerp",
            "type": "painting.BorderDirectional",
            "desc": "<p>Linearly interpolate between two borders.<\/p>\n<p>If a border is null, it is treated as having four <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>\nborders.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "a",
                    "type": "painting.BorderDirectional",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "b",
                    "type": "painting.BorderDirectional",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "t",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/lerp.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderDirectional lerp(BorderDirectional a, BorderDirectional b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  return BorderDirectional(\n    top: BorderSide.lerp(a.top, b.top, t),\n    end: BorderSide.lerp(a.end, b.end, t),\n    bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n    start: BorderSide.lerp(a.start, b.start, t),\n  );\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "lerpFrom",
            "type": "painting.ShapeBorder",
            "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/BorderDirectional\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/BorderDirectional\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/BorderDirectional\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/BorderDirectional\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "a",
                    "type": "painting.ShapeBorder",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "t",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/lerpFrom.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  if (a is BorderDirectional)\n    return BorderDirectional.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "lerpTo",
            "type": "painting.ShapeBorder",
            "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/BorderDirectional\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/BorderDirectional\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/BorderDirectional\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/BorderDirectional\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "b",
                    "type": "painting.ShapeBorder",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "t",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/lerpTo.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  if (b is BorderDirectional)\n    return BorderDirectional.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "merge",
            "type": "painting.BorderDirectional",
            "desc": "<p>Creates a <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> that represents the addition of the two\ngiven <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>s.<\/p>\n<p>It is only valid to call this if <a href=\"painting\/BorderSide\/canMerge.html\">BorderSide.canMerge<\/a> returns true for\nthe pairwise combination of each side on both <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>s.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "a",
                    "type": "painting.BorderDirectional",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "b",
                    "type": "painting.BorderDirectional",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/merge.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderDirectional merge(BorderDirectional a, BorderDirectional b) {\n  assert(a != null);\n  assert(b != null);\n  assert(BorderSide.canMerge(a.top, b.top));\n  assert(BorderSide.canMerge(a.start, b.start));\n  assert(BorderSide.canMerge(a.end, b.end));\n  assert(BorderSide.canMerge(a.bottom, b.bottom));\n  return BorderDirectional(\n    top: BorderSide.merge(a.top, b.top),\n    start: BorderSide.merge(a.start, b.start),\n    end: BorderSide.merge(a.end, b.end),\n    bottom: BorderSide.merge(a.bottom, b.bottom),\n  );\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "paint",
            "type": "",
            "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>Uniform borders are more efficient to paint than more complex borders.<\/p>\n<p>You can provide a <a href=\"painting\/BoxShape-class.html\">BoxShape<\/a> to draw the border on. If the <code>shape<\/code> in\n<a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a>, there is the requirement that the border <a href=\"painting\/BorderDirectional\/isUniform.html\">isUniform<\/a>.<\/p>\n<p>If you specify a rectangular box shape (<a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>), then you\nmay specify a <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>. If a <code>borderRadius<\/code> is specified, there is\nthe requirement that the border <a href=\"painting\/BorderDirectional\/isUniform.html\">isUniform<\/a>.<\/p>\n<p>The <a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a> and <a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a> methods do not know about the\n<code>shape<\/code> and <code>borderRadius<\/code> arguments.<\/p>\n<p>The <code>textDirection<\/code> argument is used to determine which of <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> and\n<a href=\"painting\/BorderDirectional\/end.html\">end<\/a> map to the left and right. For <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a>, the <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> is\nthe left and the <a href=\"painting\/BorderDirectional\/end.html\">end<\/a> is the right; for <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a>, it is the\nreverse.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/paintBorder.html\">paintBorder<\/a>, which is used if the border is not uniform.<\/li><\/ul>",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "canvas",
                    "type": "dart:ui.Canvas",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "rect",
                    "type": "dart:ui.Rect",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "textDirection",
                    "type": "dart:ui.TextDirection",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "shape",
                    "type": "painting.BoxShape",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "borderRadius",
                    "type": "painting.BorderRadius",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/paint.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(\n  Canvas canvas,\n  Rect rect, {\n  TextDirection textDirection,\n  BoxShape shape = BoxShape.rectangle,\n  BorderRadius borderRadius,\n}) {\n  if (isUniform) {\n    switch (top.style) {\n      case BorderStyle.none:\n        return;\n      case BorderStyle.solid:\n        switch (shape) {\n          case BoxShape.circle:\n            assert(borderRadius == null, 'A borderRadius can only be given for rectangular boxes.');\n            BoxBorder._paintUniformBorderWithCircle(canvas, rect, top);\n            break;\n          case BoxShape.rectangle:\n            if (borderRadius != null) {\n              BoxBorder._paintUniformBorderWithRadius(canvas, rect, top, borderRadius);\n              return;\n            }\n            BoxBorder._paintUniformBorderWithRectangle(canvas, rect, top);\n            break;\n        }\n        return;\n    }\n  }\n\n  assert(borderRadius == null, 'A borderRadius can only be given for uniform borders.');\n  assert(shape == BoxShape.rectangle, 'A border can only be drawn as a circle if it is uniform.');\n\n  BorderSide left, right;\n  assert(textDirection != null, 'Non-uniform BorderDirectional objects require a TextDirection when painting.');\n  switch (textDirection) {\n    case TextDirection.rtl:\n      left = end;\n      right = start;\n      break;\n    case TextDirection.ltr:\n      left = start;\n      right = end;\n      break;\n  }\n  paintBorder(canvas, rect, top: top, left: left, bottom: bottom, right: right);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "scale",
            "type": "painting.BorderDirectional",
            "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/BorderDirectional\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [
                {
                    "name": "t",
                    "type": "dart:core.double",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/scale.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderDirectional scale(double t) {\n  return BorderDirectional(\n    top: top.scale(t),\n    start: start.scale(t),\n    end: end.scale(t),\n    bottom: bottom.scale(t),\n  );\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "toString",
            "type": "dart:core.String",
            "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
            "static": false,
            "memberOf": "painting.BorderDirectional",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "painting\/BorderDirectional\/toString.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  final List&lt;String&gt; arguments = &lt;String&gt;[];\n  if (top != BorderSide.none)\n    arguments.add('top: $top');\n  if (start != BorderSide.none)\n    arguments.add('start: $start');\n  if (end != BorderSide.none)\n    arguments.add('end: $end');\n  if (bottom != BorderSide.none)\n    arguments.add('bottom: $bottom');\n  return '$runtimeType(${arguments.join(\", \")})';\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        }
    ],
    "props": [
        {
            "name": "bottom",
            "type": "painting.BorderSide",
            "types": [],
            "desc": "<p>The bottom side of this border.<\/p>\n        ",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/bottom.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide bottom\n\n<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "dimensions",
            "type": "painting.EdgeInsetsGeometry",
            "types": [],
            "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/BorderDirectional\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/BorderDirectional\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/dimensions.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsetsDirectional.fromSTEB(start.width, top.width, end.width, bottom.width);\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "end",
            "type": "painting.BorderSide",
            "types": [],
            "desc": "<p>The end side of this border.<\/p>\n<p>This is the side on the right in left-to-right text and on the left in\nright-to-left text.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which is used to describe the reading direction.<\/li><\/ul>",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/end.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide end\n\n<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "hashCode",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BorderDirectional\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/hashCode.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(top, start, end, bottom);<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "isUniform",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Whether all four sides of the border are identical. Uniform borders are\ntypically more efficient to paint.<\/p>\n<p>A uniform border by definition has no text direction dependency and\ntherefore could be expressed as a <a href=\"painting\/Border-class.html\">Border<\/a>, even if it is currently a\n<a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. A uniform border can also be expressed as a\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n        ",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/isUniform.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isUniform {\n  final Color topColor = top.color;\n  if (start.color != topColor ||\n      end.color != topColor ||\n      bottom.color != topColor)\n    return false;\n\n  final double topWidth = top.width;\n  if (start.width != topWidth ||\n      end.width != topWidth ||\n      bottom.width != topWidth)\n    return false;\n\n  final BorderStyle topStyle = top.style;\n  if (start.style != topStyle ||\n      end.style != topStyle ||\n      bottom.style != topStyle)\n    return false;\n\n  return true;\n}<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "start",
            "type": "painting.BorderSide",
            "types": [],
            "desc": "<p>The start side of this border.<\/p>\n<p>This is the side on the left in left-to-right text and on the right in\nright-to-left text.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which is used to describe the reading direction.<\/li><\/ul>",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/start.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide start\n\n<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "top",
            "type": "painting.BorderSide",
            "types": [],
            "desc": "<p>The top side of this border.<\/p>\n<p>This getter is available on both <a href=\"painting\/Border-class.html\">Border<\/a> and <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. If\n<a href=\"painting\/BorderDirectional\/isUniform.html\">isUniform<\/a> is true, then this is the same style as all the other sides.<\/p>\n        ",
            "memberOf": "painting.BorderDirectional",
            "isConstant": false,
            "href": "painting\/BorderDirectional\/top.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide top\n\n<\/code><\/pre>\n        ",
            "isDeprecated": false
        }
    ],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": false,
    "implementors": [],
    "realImplementors": [],
    "cn": [],
    "href": "painting\/BorderDirectional-class.html",
    "desc": "<p>A border of a box, comprised of four sides, the lateral sides of which\nflip over based on the reading direction.<\/p>\n<p>The lateral sides are called <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> and <a href=\"painting\/BorderDirectional\/end.html\">end<\/a>. When painted in\nleft-to-right environments, the <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> side will be painted on the left and\nthe <a href=\"painting\/BorderDirectional\/end.html\">end<\/a> side on the right; in right-to-left environments, it is the\nreverse. The other two sides are <a href=\"painting\/BorderDirectional\/top.html\">top<\/a> and <a href=\"painting\/BorderDirectional\/bottom.html\">bottom<\/a>.<\/p>\n<p>The sides are represented by <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects.<\/p>\n<p>If the <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> and <a href=\"painting\/BorderDirectional\/end.html\">end<\/a> sides are the same, then it is slightly more\nefficient to use a <a href=\"painting\/Border-class.html\">Border<\/a> object rather than a <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> object.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which uses this class to describe its edge decoration.<\/li>\n<li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe each side of the box.<\/li>\n<li>\n<a href=\"material\/Theme-class.html\">Theme<\/a>, from the material layer, which can be queried to obtain appropriate colors\nto use for borders in a material app, as shown in the \"divider\" sample above.<\/li>\n<\/ul>",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "BorderDirectional"
}