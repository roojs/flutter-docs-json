{
    "desc": "<p>State for a <a href=\"material\/Scaffold-class.html\">Scaffold<\/a>.<\/p>\n<p>Can display <a href=\"material\/SnackBar-class.html\">SnackBar<\/a>s and <a href=\"material\/BottomSheet-class.html\">BottomSheet<\/a>s. Retrieve a <a href=\"material\/ScaffoldState-class.html\">ScaffoldState<\/a> from\nthe current <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> using <a href=\"material\/Scaffold\/of.html\">Scaffold.of<\/a>.<\/p>\n    ",
    "dtype": "class",
    "example": "",
    "href": "material\/ScaffoldState-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "material",
    "name": "material.ScaffoldState",
    "shortname": "ScaffoldState",
    "extends": [
        "material.Scaffold",
        "widgets.State",
        "foundation.Diagnosticable",
        "dart:core.Object"
    ],
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": null,
            "example": "",
            "href": "material\/ScaffoldState\/ScaffoldState.html",
            "isDeprecated": "0",
            "type": "",
            "name": "ScaffoldState",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Describes the part of the user interface represented by this widget.<\/p>\n<p>The framework calls this method in a number of different situations:<\/p>\n<ul>\n<li>After calling <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>.<\/li>\n<li>After calling <a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a>.<\/li>\n<li>After receiving a call to <a href=\"widgets\/State\/setState.html\">setState<\/a>.<\/li>\n<li>After a dependency of this <a href=\"widgets\/State-class.html\">State<\/a> object changes (e.g., an\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a> referenced by the previous <a href=\"material\/ScaffoldState\/build.html\">build<\/a> changes).<\/li>\n<li>After calling <a href=\"widgets\/State\/deactivate.html\">deactivate<\/a> and then reinserting the <a href=\"widgets\/State-class.html\">State<\/a> object into\nthe tree at another location.<\/li>\n<\/ul>\n<p>The framework replaces the subtree below this widget with the widget\nreturned by this method, either by updating the existing subtree or by\nremoving the subtree and inflating a new subtree, depending on whether the\nwidget returned by this method can update the root of the existing\nsubtree, as determined by calling <a href=\"widgets\/Widget\/canUpdate.html\">Widget.canUpdate<\/a>.<\/p>\n<p>Typically implementations return a newly created constellation of widgets\nthat are configured with information from this widget's constructor, the\ngiven <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>, and the internal state of this <a href=\"widgets\/State-class.html\">State<\/a> object.<\/p>\n<p>The given <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> contains information about the location in the\ntree at which this widget is being built. For example, the context\nprovides the set of inherited widgets for this location in the tree. The\n<a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> argument is always the same as the <code>context<\/code> property of\nthis <a href=\"widgets\/State-class.html\">State<\/a> object and will remain the same for the lifetime of this\nobject. The <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> argument is provided redundantly here so that\nthis method matches the signature for a <a href=\"widgets\/WidgetBuilder.html\">WidgetBuilder<\/a>.<\/p>\n<h2 id=\"design-discussion\">Design discussion<\/h2>\n<h3 id=\"why-is-the-build-method-on-state-and-not-statefulwidget\">Why is the <a href=\"material\/ScaffoldState\/build.html\">build<\/a> method on <a href=\"widgets\/State-class.html\">State<\/a>, and not <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>?<\/h3>\n<p>Putting a <code>Widget build(BuildContext context)<\/code> method on <a href=\"widgets\/State-class.html\">State<\/a> rather\nputting a <code>Widget build(BuildContext context, State state)<\/code> method on\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> gives developers more flexibility when subclassing\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>.<\/p>\n<p>For example, <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a> is a subclass of <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> that\nintroduces an abstract <code>Widget build(BuildContext context)<\/code> method for its\nsubclasses to implement. If <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> already had a <a href=\"material\/ScaffoldState\/build.html\">build<\/a> method\nthat took a <a href=\"widgets\/State-class.html\">State<\/a> argument, <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a> would be forced to provide\nits <a href=\"widgets\/State-class.html\">State<\/a> object to subclasses even though its <a href=\"widgets\/State-class.html\">State<\/a> object is an\ninternal implementation detail of <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a>.<\/p>\n<p>Conceptually, <a href=\"widgets\/StatelessWidget-class.html\">StatelessWidget<\/a> could also be implemented as a subclass of\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> in a similar manner. If the <a href=\"material\/ScaffoldState\/build.html\">build<\/a> method were on\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> rather than <a href=\"widgets\/State-class.html\">State<\/a>, that would not be possible anymore.<\/p>\n<p>Putting the <a href=\"material\/ScaffoldState\/build.html\">build<\/a> function on <a href=\"widgets\/State-class.html\">State<\/a> rather than <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> also\nhelps avoid a category of bugs related to closures implicitly capturing\n<code>this<\/code>. If you defined a closure in a <a href=\"material\/ScaffoldState\/build.html\">build<\/a> function on a\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, that closure would implicitly capture <code>this<\/code>, which is\nthe current widget instance, and would have the (immutable) fields of that\ninstance in scope:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class MyButton extends StatefulWidget {\n  ...\n  final Color color;\n\n  @override\n  Widget build(BuildContext context, MyButtonState state) {\n    ... () { print(\"color: $color\"); } ...\n  }\n}\n<\/code><\/pre>\n<p>For example, suppose the parent builds <code>MyButton<\/code> with <code>color<\/code> being blue,\nthe <code>$color<\/code> in the print function refers to blue, as expected. Now,\nsuppose the parent rebuilds <code>MyButton<\/code> with green. The closure created by\nthe first build still implicitly refers to the original widget and the\n<code>$color<\/code> still prints blue even through the widget has been updated to\ngreen.<\/p>\n<p>In contrast, with the <a href=\"material\/ScaffoldState\/build.html\">build<\/a> function on the <a href=\"widgets\/State-class.html\">State<\/a> object, closures\ncreated during <a href=\"material\/ScaffoldState\/build.html\">build<\/a> implicitly capture the <a href=\"widgets\/State-class.html\">State<\/a> instance instead of\nthe widget instance:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class MyButtonState extends State&lt;MyButton&gt; {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    ... () { print(\"color: ${widget.color}\"); } ...\n  }\n}\n<\/code><\/pre>\n<p>Now when the parent rebuilds <code>MyButton<\/code> with green, the closure created by\nthe first build still refers to <a href=\"widgets\/State-class.html\">State<\/a> object, which is preserved across\nrebuilds, but the framework has updated that <a href=\"widgets\/State-class.html\">State<\/a> object's <a href=\"widgets\/State\/widget.html\">widget<\/a>\nproperty to refer to the new <code>MyButton<\/code> instance and <code>${widget.color}<\/code>\nprints green, as expected.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, which contains the discussion on performance considerations.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nWidget build(BuildContext context) {\n  assert(debugCheckHasMediaQuery(context));\n  assert(debugCheckHasDirectionality(context));\n  final MediaQueryData mediaQuery = MediaQuery.of(context);\n  final ThemeData themeData = Theme.of(context);\n  final TextDirection textDirection = Directionality.of(context);\n  _accessibleNavigation = mediaQuery.accessibleNavigation;\n\n  if (_snackBars.isNotEmpty) {\n    final ModalRoute&lt;dynamic&gt; route = ModalRoute.of(context);\n    if (route == null || route.isCurrent) {\n      if (_snackBarController.isCompleted &amp;&amp; _snackBarTimer == null) {\n        final SnackBar snackBar = _snackBars.first._widget;\n        _snackBarTimer = Timer(snackBar.duration, () {\n          assert(_snackBarController.status == AnimationStatus.forward ||\n                 _snackBarController.status == AnimationStatus.completed);\n          \/\/ Look up MediaQuery again in case the setting changed.\n          final MediaQueryData mediaQuery = MediaQuery.of(context);\n          if (mediaQuery.accessibleNavigation &amp;&amp; snackBar.action != null)\n            return;\n          hideCurrentSnackBar(reason: SnackBarClosedReason.timeout);\n        });\n      }\n    } else {\n      _snackBarTimer?.cancel();\n      _snackBarTimer = null;\n    }\n  }\n\n  final List&lt;LayoutId&gt; children = &lt;LayoutId&gt;[];\n\n  _addIfNonNull(\n    children,\n    widget.body != null &amp;&amp; widget.extendBody ? _BodyBuilder(body: widget.body) : widget.body,\n    _ScaffoldSlot.body,\n    removeLeftPadding: false,\n    removeTopPadding: widget.appBar != null,\n    removeRightPadding: false,\n    removeBottomPadding: widget.bottomNavigationBar != null || widget.persistentFooterButtons != null,\n    removeBottomInset: _resizeToAvoidBottomInset,\n  );\n\n  if (widget.appBar != null) {\n    final double topPadding = widget.primary ? mediaQuery.padding.top : 0.0;\n    final double extent = widget.appBar.preferredSize.height + topPadding;\n    assert(extent &gt;= 0.0 &amp;&amp; extent.isFinite);\n    _addIfNonNull(\n      children,\n      ConstrainedBox(\n        constraints: BoxConstraints(maxHeight: extent),\n        child: FlexibleSpaceBar.createSettings(\n          currentExtent: extent,\n          child: widget.appBar,\n        ),\n      ),\n      _ScaffoldSlot.appBar,\n      removeLeftPadding: false,\n      removeTopPadding: false,\n      removeRightPadding: false,\n      removeBottomPadding: true,\n    );\n  }\n\n  if (_snackBars.isNotEmpty) {\n    _addIfNonNull(\n      children,\n      _snackBars.first._widget,\n      _ScaffoldSlot.snackBar,\n      removeLeftPadding: false,\n      removeTopPadding: true,\n      removeRightPadding: false,\n      removeBottomPadding: widget.bottomNavigationBar != null || widget.persistentFooterButtons != null,\n    );\n  }\n\n  if (widget.persistentFooterButtons != null) {\n    _addIfNonNull(\n      children,\n      Container(\n        decoration: BoxDecoration(\n          border: Border(\n            top: Divider.createBorderSide(context, width: 1.0),\n          ),\n        ),\n        child: SafeArea(\n          child: ButtonTheme.bar(\n            child: SafeArea(\n              top: false,\n              child: ButtonBar(\n                children: widget.persistentFooterButtons,\n              ),\n            ),\n          ),\n        ),\n      ),\n      _ScaffoldSlot.persistentFooter,\n      removeLeftPadding: false,\n      removeTopPadding: true,\n      removeRightPadding: false,\n      removeBottomPadding: false,\n    );\n  }\n\n  if (widget.bottomNavigationBar != null) {\n    _addIfNonNull(\n      children,\n      widget.bottomNavigationBar,\n      _ScaffoldSlot.bottomNavigationBar,\n      removeLeftPadding: false,\n      removeTopPadding: true,\n      removeRightPadding: false,\n      removeBottomPadding: false,\n    );\n  }\n\n  if (_currentBottomSheet != null || _dismissedBottomSheets.isNotEmpty) {\n    final List&lt;Widget&gt; bottomSheets = &lt;Widget&gt;[];\n    if (_dismissedBottomSheets.isNotEmpty)\n      bottomSheets.addAll(_dismissedBottomSheets);\n    if (_currentBottomSheet != null)\n      bottomSheets.add(_currentBottomSheet._widget);\n    final Widget stack = Stack(\n      children: bottomSheets,\n      alignment: Alignment.bottomCenter,\n    );\n    _addIfNonNull(\n      children,\n      stack,\n      _ScaffoldSlot.bottomSheet,\n      removeLeftPadding: false,\n      removeTopPadding: true,\n      removeRightPadding: false,\n      removeBottomPadding: _resizeToAvoidBottomInset,\n    );\n  }\n\n  _addIfNonNull(\n    children,\n    _FloatingActionButtonTransition(\n      child: widget.floatingActionButton,\n      fabMoveAnimation: _floatingActionButtonMoveController,\n      fabMotionAnimator: _floatingActionButtonAnimator,\n      geometryNotifier: _geometryNotifier,\n    ),\n    _ScaffoldSlot.floatingActionButton,\n    removeLeftPadding: true,\n    removeTopPadding: true,\n    removeRightPadding: true,\n    removeBottomPadding: true,\n  );\n\n  switch (themeData.platform) {\n    case TargetPlatform.iOS:\n      _addIfNonNull(\n        children,\n        GestureDetector(\n          behavior: HitTestBehavior.opaque,\n          onTap: _handleStatusBarTap,\n          \/\/ iOS accessibility automatically adds scroll-to-top to the clock in the status bar\n          excludeFromSemantics: true,\n        ),\n        _ScaffoldSlot.statusBar,\n        removeLeftPadding: false,\n        removeTopPadding: true,\n        removeRightPadding: false,\n        removeBottomPadding: true,\n      );\n      break;\n    case TargetPlatform.android:\n    case TargetPlatform.fuchsia:\n      break;\n  }\n\n  if (_endDrawerOpened) {\n    _buildDrawer(children, textDirection);\n    _buildEndDrawer(children, textDirection);\n  } else {\n    _buildEndDrawer(children, textDirection);\n    _buildDrawer(children, textDirection);\n  }\n\n  \/\/ The minimum insets for contents of the Scaffold to keep visible.\n  final EdgeInsets minInsets = mediaQuery.padding.copyWith(\n    bottom: _resizeToAvoidBottomInset ? mediaQuery.viewInsets.bottom : 0.0,\n  );\n\n  \/\/ extendBody locked when keyboard is open\n  final bool _extendBody = minInsets.bottom &gt; 0 ? false : widget.extendBody;\n\n  return _ScaffoldScope(\n    hasDrawer: hasDrawer,\n    geometryNotifier: _geometryNotifier,\n    child: PrimaryScrollController(\n      controller: _primaryScrollController,\n      child: Material(\n        color: widget.backgroundColor ?? themeData.scaffoldBackgroundColor,\n        child: AnimatedBuilder(animation: _floatingActionButtonMoveController, builder: (BuildContext context, Widget child) {\n          return CustomMultiChildLayout(\n            children: children,\n            delegate: _ScaffoldLayout(\n              extendBody: _extendBody,\n              minInsets: minInsets,\n              currentFloatingActionButtonLocation: _floatingActionButtonLocation,\n              floatingActionButtonMoveAnimationProgress: _floatingActionButtonMoveController.value,\n              floatingActionButtonMotionAnimator: _floatingActionButtonAnimator,\n              geometryNotifier: _geometryNotifier,\n              previousFloatingActionButtonLocation: _previousFloatingActionButtonLocation,\n              textDirection: textDirection,\n            ),\n          );\n        }),\n      ),\n    ),\n  );\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/build.html",
            "isDeprecated": "0",
            "type": "widgets.Widget",
            "name": "build",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": [
                {
                    "name": "context",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.BuildContext"
                }
            ]
        },
        {
            "desc": "<p>Called when a dependency of this <a href=\"widgets\/State-class.html\">State<\/a> object changes.<\/p>\n<p>For example, if the previous call to <a href=\"material\/ScaffoldState\/build.html\">build<\/a> referenced an\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a> that later changed, the framework would call this\nmethod to notify this object about the change.<\/p>\n<p>This method is also called immediately after <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>. It is safe to\ncall <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> from this method.<\/p>\n<p>Subclasses rarely override this method because the framework always\ncalls <a href=\"material\/ScaffoldState\/build.html\">build<\/a> after a dependency changes. Some subclasses do override\nthis method because they need to do some expensive work (e.g., network\nfetches) when their dependencies change, and that work would be too\nexpensive to do for every build.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid didChangeDependencies() {\n  final MediaQueryData mediaQuery = MediaQuery.of(context);\n  \/\/ If we transition from accessible navigation to non-accessible navigation\n  \/\/ and there is a SnackBar that would have timed out that has already\n  \/\/ completed its timer, dismiss that SnackBar. If the timer hasn't finished\n  \/\/ yet, let it timeout as normal.\n  if (_accessibleNavigation == true\n    &amp;&amp; !mediaQuery.accessibleNavigation\n    &amp;&amp; _snackBarTimer != null\n    &amp;&amp; !_snackBarTimer.isActive) {\n    hideCurrentSnackBar(reason: SnackBarClosedReason.timeout);\n  }\n  _accessibleNavigation = mediaQuery.accessibleNavigation;\n  super.didChangeDependencies();\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/didChangeDependencies.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "didChangeDependencies",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Called whenever the widget configuration changes.<\/p>\n<p>If the parent widget rebuilds and request that this location in the tree\nupdate to display a new widget with the same <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and\n<a href=\"widgets\/Widget\/key.html\">Widget.key<\/a>, the framework will update the <a href=\"widgets\/State\/widget.html\">widget<\/a> property of this\n<a href=\"widgets\/State-class.html\">State<\/a> object to refer to the new widget and then call this method\nwith the previous widget as an argument.<\/p>\n<p>Override this method to respond when the <a href=\"widgets\/State\/widget.html\">widget<\/a> changes (e.g., to start\nimplicit animations).<\/p>\n<p>The framework always calls <a href=\"material\/ScaffoldState\/build.html\">build<\/a> after calling <a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a>, which\nmeans any calls to <a href=\"widgets\/State\/setState.html\">setState<\/a> in <a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a> are redundant.<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"material\/ScaffoldState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>,\n<a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>, unsubscribe from the object.<\/li>\n<\/ul>\n<p>If you override this, make sure your method starts with a call to\nsuper.didUpdateWidget(oldWidget).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid didUpdateWidget(Scaffold oldWidget) {\n  \/\/ Update the Floating Action Button Animator, and then schedule the Floating Action Button for repositioning.\n  if (widget.floatingActionButtonAnimator != oldWidget.floatingActionButtonAnimator) {\n    _floatingActionButtonAnimator = widget.floatingActionButtonAnimator ?? _kDefaultFloatingActionButtonAnimator;\n  }\n  if (widget.floatingActionButtonLocation != oldWidget.floatingActionButtonLocation) {\n    _moveFloatingActionButton(widget.floatingActionButtonLocation ?? _kDefaultFloatingActionButtonLocation);\n  }\n  if (widget.bottomSheet != oldWidget.bottomSheet) {\n    assert(() {\n      if (widget.bottomSheet != null &amp;&amp; _currentBottomSheet?._isLocalHistoryEntry == true) {\n        throw FlutterError(\n          'Scaffold.bottomSheet cannot be specified while a bottom sheet displayed '\n          'with showBottomSheet() is still visible.\\n Use the PersistentBottomSheetController '\n          'returned by showBottomSheet() to close the old bottom sheet before creating '\n          'a Scaffold with a (non null) bottomSheet.'\n        );\n      }\n      return true;\n    }());\n    _closeCurrentBottomSheet();\n    _maybeBuildCurrentBottomSheet();\n  }\n  super.didUpdateWidget(oldWidget);\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/didUpdateWidget.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "didUpdateWidget",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": [
                {
                    "name": "oldWidget",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "material.Scaffold"
                }
            ]
        },
        {
            "desc": "<p>Called when this object is removed from the tree permanently.<\/p>\n<p>The framework calls this method when this <a href=\"widgets\/State-class.html\">State<\/a> object will never\nbuild again. After the framework calls <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>, the <a href=\"widgets\/State-class.html\">State<\/a> object is\nconsidered unmounted and the <a href=\"widgets\/State\/mounted.html\">mounted<\/a> property is false. It is an error\nto call <a href=\"widgets\/State\/setState.html\">setState<\/a> at this point. This stage of the lifecycle is terminal:\nthere is no way to remount a <a href=\"widgets\/State-class.html\">State<\/a> object that has been disposed.<\/p>\n<p>Subclasses should override this method to release any resources retained\nby this object (e.g., stop any active animations).<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"material\/ScaffoldState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>,\n<a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>, unsubscribe from the object.<\/li>\n<\/ul>\n<p>If you override this, make sure to end your method with a call to\nsuper.dispose().<\/p>\n<p>See also <a href=\"widgets\/State\/deactivate.html\">deactivate<\/a>, which is called prior to <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid dispose() {\n  _snackBarController?.dispose();\n  _snackBarTimer?.cancel();\n  _snackBarTimer = null;\n  _geometryNotifier.dispose();\n  for (_PersistentBottomSheet bottomSheet in _dismissedBottomSheets)\n    bottomSheet.animationController.dispose();\n  if (_currentBottomSheet != null)\n    _currentBottomSheet._widget.animationController.dispose();\n  _floatingActionButtonMoveController.dispose();\n  super.dispose();\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/dispose.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "dispose",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Removes the current <a href=\"material\/SnackBar-class.html\">SnackBar<\/a> by running its normal exit animation.<\/p>\n<p>The closed completer is called after the animation is complete.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void hideCurrentSnackBar({ SnackBarClosedReason reason = SnackBarClosedReason.hide }) {\n  assert(reason != null);\n  if (_snackBars.isEmpty || _snackBarController.status == AnimationStatus.dismissed)\n    return;\n  final MediaQueryData mediaQuery = MediaQuery.of(context);\n  final Completer&lt;SnackBarClosedReason&gt; completer = _snackBars.first._completer;\n  if (mediaQuery.accessibleNavigation) {\n    _snackBarController.value = 0.0;\n    completer.complete(reason);\n  } else {\n    _snackBarController.reverse().then&lt;void&gt;((void value) {\n      assert(mounted);\n      if (!completer.isCompleted)\n        completer.complete(reason);\n    });\n  }\n  _snackBarTimer?.cancel();\n  _snackBarTimer = null;\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/hideCurrentSnackBar.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "hideCurrentSnackBar",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": [
                {
                    "name": "reason",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "material.SnackBarClosedReason"
                }
            ]
        },
        {
            "desc": "<p>Called when this object is inserted into the tree.<\/p>\n<p>The framework will call this method exactly once for each <a href=\"widgets\/State-class.html\">State<\/a> object\nit creates.<\/p>\n<p>Override this method to perform initialization that depends on the\nlocation at which this object was inserted into the tree (i.e., <a href=\"widgets\/State\/context.html\">context<\/a>)\nor on the widget used to configure this object (i.e., <a href=\"widgets\/State\/widget.html\">widget<\/a>).<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"material\/ScaffoldState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>,\n<a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"material\/ScaffoldState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"material\/ScaffoldState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"material\/ScaffoldState\/dispose.html\">dispose<\/a>, unsubscribe from the object.\nYou cannot use <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> from this\nmethod. However, <a href=\"material\/ScaffoldState\/didChangeDependencies.html\">didChangeDependencies<\/a> will be called immediately\nfollowing this method, and <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> can\nbe used there.<\/li>\n<\/ul>\n<p>If you override this, make sure your method starts with a call to\nsuper.initState().<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initState() {\n  super.initState();\n  _geometryNotifier = _ScaffoldGeometryNotifier(const ScaffoldGeometry(), context);\n  _floatingActionButtonLocation = widget.floatingActionButtonLocation ?? _kDefaultFloatingActionButtonLocation;\n  _floatingActionButtonAnimator = widget.floatingActionButtonAnimator ?? _kDefaultFloatingActionButtonAnimator;\n  _previousFloatingActionButtonLocation = _floatingActionButtonLocation;\n  _floatingActionButtonMoveController = AnimationController(\n    vsync: this,\n    lowerBound: 0.0,\n    upperBound: 1.0,\n    value: 1.0,\n    duration: kFloatingActionButtonSegue * 2,\n  );\n  _maybeBuildCurrentBottomSheet();\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/initState.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "initState",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Opens the <a href=\"material\/Drawer-class.html\">Drawer<\/a> (if any).<\/p>\n<p>If the scaffold has a non-null <a href=\"material\/Scaffold\/drawer.html\">Scaffold.drawer<\/a>, this function will cause\nthe drawer to begin its entrance animation.<\/p>\n<p>Normally this is not needed since the <a href=\"material\/Scaffold-class.html\">Scaffold<\/a> automatically shows an\nappropriate <a href=\"material\/IconButton-class.html\">IconButton<\/a>, and handles the edge-swipe gesture, to show the\ndrawer.<\/p>\n<p>To close the drawer once it is open, use <a href=\"widgets\/Navigator\/pop.html\">Navigator.pop<\/a>.<\/p>\n<p>See <a href=\"material\/Scaffold\/of.html\">Scaffold.of<\/a> for information about how to obtain the <a href=\"material\/ScaffoldState-class.html\">ScaffoldState<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void openDrawer() {\n  if (_endDrawerKey.currentState != null &amp;&amp; _endDrawerOpened)\n    _endDrawerKey.currentState.close();\n  _drawerKey.currentState?.open();\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/openDrawer.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "openDrawer",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Opens the end side <a href=\"material\/Drawer-class.html\">Drawer<\/a> (if any).<\/p>\n<p>If the scaffold has a non-null <a href=\"material\/Scaffold\/endDrawer.html\">Scaffold.endDrawer<\/a>, this function will cause\nthe end side drawer to begin its entrance animation.<\/p>\n<p>Normally this is not needed since the <a href=\"material\/Scaffold-class.html\">Scaffold<\/a> automatically shows an\nappropriate <a href=\"material\/IconButton-class.html\">IconButton<\/a>, and handles the edge-swipe gesture, to show the\ndrawer.<\/p>\n<p>To close the end side drawer once it is open, use <a href=\"widgets\/Navigator\/pop.html\">Navigator.pop<\/a>.<\/p>\n<p>See <a href=\"material\/Scaffold\/of.html\">Scaffold.of<\/a> for information about how to obtain the <a href=\"material\/ScaffoldState-class.html\">ScaffoldState<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void openEndDrawer() {\n  if (_drawerKey.currentState != null &amp;&amp; _drawerOpened)\n    _drawerKey.currentState.close();\n  _endDrawerKey.currentState?.open();\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/openEndDrawer.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "openEndDrawer",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Removes the current <a href=\"material\/SnackBar-class.html\">SnackBar<\/a> (if any) immediately.<\/p>\n<p>The removed snack bar does not run its normal exit animation. If there are\nany queued snack bars, they begin their entrance animation immediately.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void removeCurrentSnackBar({ SnackBarClosedReason reason = SnackBarClosedReason.remove }) {\n  assert(reason != null);\n  if (_snackBars.isEmpty)\n    return;\n  final Completer&lt;SnackBarClosedReason&gt; completer = _snackBars.first._completer;\n  if (!completer.isCompleted)\n    completer.complete(reason);\n  _snackBarTimer?.cancel();\n  _snackBarTimer = null;\n  _snackBarController.value = 0.0;\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/removeCurrentSnackBar.html",
            "isDeprecated": "0",
            "type": "<void>",
            "name": "removeCurrentSnackBar",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": [
                {
                    "name": "reason",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "material.SnackBarClosedReason"
                }
            ]
        },
        {
            "desc": "<p>Shows a persistent material design bottom sheet in the nearest <a href=\"material\/Scaffold-class.html\">Scaffold<\/a>.<\/p>\n<p>Returns a controller that can be used to close and otherwise manipulate the\nbottom sheet.<\/p>\n<p>To rebuild the bottom sheet (e.g. if it is stateful), call\n<a href=\"widgets\/State\/setState.html\">PersistentBottomSheetController.setState<\/a> on the controller returned by\nthis method.<\/p>\n<p>The new bottom sheet becomes a <a href=\"widgets\/LocalHistoryEntry-class.html\">LocalHistoryEntry<\/a> for the enclosing\n<a href=\"widgets\/ModalRoute-class.html\">ModalRoute<\/a> and a back button is added to the appbar of the <a href=\"material\/Scaffold-class.html\">Scaffold<\/a>\nthat closes the bottom sheet.<\/p>\n<p>To create a persistent bottom sheet that is not a <a href=\"widgets\/LocalHistoryEntry-class.html\">LocalHistoryEntry<\/a> and\ndoes not add a back button to the enclosing Scaffold's appbar, use the\n<a href=\"material\/Scaffold\/bottomSheet.html\">Scaffold.bottomSheet<\/a> constructor parameter.<\/p>\n<p>A persistent bottom sheet shows information that supplements the primary\ncontent of the app. A persistent bottom sheet remains visible even when\nthe user interacts with other parts of the app.<\/p>\n<p>A closely related widget is a modal bottom sheet, which is an alternative\nto a menu or a dialog and prevents the user from interacting with the rest\nof the app. Modal bottom sheets can be created and displayed with the\n<a href=\"material\/showModalBottomSheet.html\">showModalBottomSheet<\/a> function.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"material\/BottomSheet-class.html\">BottomSheet<\/a>, which is the widget typically returned by the <code>builder<\/code>.<\/li>\n<li>\n<a href=\"material\/ScaffoldState\/showBottomSheet.html\">showBottomSheet<\/a>, which calls this method given a <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>.<\/li>\n<li>\n<a href=\"material\/showModalBottomSheet.html\">showModalBottomSheet<\/a>, which can be used to display a modal bottom\nsheet.<\/li>\n<li>\n<a href=\"material\/Scaffold\/of.html\">Scaffold.of<\/a>, for information about how to obtain the <a href=\"material\/ScaffoldState-class.html\">ScaffoldState<\/a>.<\/li>\n<li><a href=\"https:\/\/material.io\/design\/components\/sheets-bottom.html#standard-bottom-sheet\">material.io\/design\/components\/sheets-bottom.html#standard-bottom-sheet<\/a><\/li>\n<\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">PersistentBottomSheetController&lt;T&gt; showBottomSheet&lt;T&gt;(WidgetBuilder builder) {\n  _closeCurrentBottomSheet();\n  final AnimationController controller = BottomSheet.createAnimationController(this)\n    ..forward();\n  setState(() {\n    _currentBottomSheet = _buildBottomSheet&lt;T&gt;(builder, controller, true);\n  });\n  return _currentBottomSheet;\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/showBottomSheet.html",
            "isDeprecated": "0",
            "type": "material.PersistentBottomSheetController",
            "name": "showBottomSheet",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": [
                {
                    "name": "builder",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.WidgetBuilder"
                }
            ]
        },
        {
            "desc": "<p>Shows a <a href=\"material\/SnackBar-class.html\">SnackBar<\/a> at the bottom of the scaffold.<\/p>\n<p>A scaffold can show at most one snack bar at a time. If this function is\ncalled while another snack bar is already visible, the given snack bar\nwill be added to a queue and displayed after the earlier snack bars have\nclosed.<\/p>\n<p>To control how long a <a href=\"material\/SnackBar-class.html\">SnackBar<\/a> remains visible, use <a href=\"material\/SnackBar\/duration.html\">SnackBar.duration<\/a>.<\/p>\n<p>To remove the <a href=\"material\/SnackBar-class.html\">SnackBar<\/a> with an exit animation, use <a href=\"material\/ScaffoldState\/hideCurrentSnackBar.html\">hideCurrentSnackBar<\/a>\nor call <a href=\"material\/ScaffoldFeatureController\/close.html\">ScaffoldFeatureController.close<\/a> on the returned\n<a href=\"material\/ScaffoldFeatureController-class.html\">ScaffoldFeatureController<\/a>. To remove a <a href=\"material\/SnackBar-class.html\">SnackBar<\/a> suddenly (without an\nanimation), use <a href=\"material\/ScaffoldState\/removeCurrentSnackBar.html\">removeCurrentSnackBar<\/a>.<\/p>\n<p>See <a href=\"material\/Scaffold\/of.html\">Scaffold.of<\/a> for information about how to obtain the <a href=\"material\/ScaffoldState-class.html\">ScaffoldState<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ScaffoldFeatureController&lt;SnackBar, SnackBarClosedReason&gt; showSnackBar(SnackBar snackbar) {\n  _snackBarController ??= SnackBar.createAnimationController(vsync: this)\n    ..addStatusListener(_handleSnackBarStatusChange);\n  if (_snackBars.isEmpty) {\n    assert(_snackBarController.isDismissed);\n    _snackBarController.forward();\n  }\n  ScaffoldFeatureController&lt;SnackBar, SnackBarClosedReason&gt; controller;\n  controller = ScaffoldFeatureController&lt;SnackBar, SnackBarClosedReason&gt;._(\n    \/\/ We provide a fallback key so that if back-to-back snackbars happen to\n    \/\/ match in structure, material ink splashes and highlights don't survive\n    \/\/ from one to the next.\n    snackbar.withAnimation(_snackBarController, fallbackKey: UniqueKey()),\n    Completer&lt;SnackBarClosedReason&gt;(),\n    () {\n      assert(_snackBars.first == controller);\n      hideCurrentSnackBar(reason: SnackBarClosedReason.hide);\n    },\n    null, \/\/ SnackBar doesn't use a builder function so setState() wouldn't rebuild it\n  );\n  setState(() {\n    _snackBars.addLast(controller);\n  });\n  return controller;\n}<\/code><\/pre>\n    ",
            "href": "material\/ScaffoldState\/showSnackBar.html",
            "isDeprecated": "0",
            "type": "material.ScaffoldFeatureController<material.SnackBar<material.SnackBarClosedReason>>",
            "name": "showSnackBar",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "material.ScaffoldState",
            "params": [
                {
                    "name": "snackbar",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "material.SnackBar"
                }
            ]
        }
    ],
    "props": [
        {
            "desc": "<p>Whether this scaffold has a non-null <a href=\"material\/Scaffold\/drawer.html\">Scaffold.drawer<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasDrawer =&gt; widget.drawer != null;<\/code><\/pre>\n        ",
            "href": "material\/ScaffoldState\/hasDrawer.html",
            "name": "hasDrawer",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Whether this scaffold has a non-null <a href=\"material\/Scaffold\/endDrawer.html\">Scaffold.endDrawer<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasEndDrawer =&gt; widget.endDrawer != null;<\/code><\/pre>\n        ",
            "href": "material\/ScaffoldState\/hasEndDrawer.html",
            "name": "hasEndDrawer",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Whether the <a href=\"material\/Scaffold\/drawer.html\">Scaffold.drawer<\/a> is opened.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"material\/ScaffoldState\/openDrawer.html\">ScaffoldState.openDrawer<\/a>, which opens the <a href=\"material\/Scaffold\/drawer.html\">Scaffold.drawer<\/a> of a\n<a href=\"material\/Scaffold-class.html\">Scaffold<\/a>.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isDrawerOpen =&gt; _drawerOpened;<\/code><\/pre>\n        ",
            "href": "material\/ScaffoldState\/isDrawerOpen.html",
            "name": "isDrawerOpen",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "material.ScaffoldState",
            "params": []
        },
        {
            "desc": "<p>Whether the <a href=\"material\/Scaffold\/endDrawer.html\">Scaffold.endDrawer<\/a> is opened.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"material\/ScaffoldState\/openEndDrawer.html\">ScaffoldState.openEndDrawer<\/a>, which opens the <a href=\"material\/Scaffold\/endDrawer.html\">Scaffold.endDrawer<\/a> of\na <a href=\"material\/Scaffold-class.html\">Scaffold<\/a>.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isEndDrawerOpen =&gt; _endDrawerOpened;<\/code><\/pre>\n        ",
            "href": "material\/ScaffoldState\/isEndDrawerOpen.html",
            "name": "isEndDrawerOpen",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "memberOf": "material.ScaffoldState",
            "params": []
        }
    ]
}