{
    "name": "dart:async.Timer",
    "extends": [],
    "memberOf": "dart:async",
    "events": [],
    "methods": [
        {
            "name": "Timer",
            "type": "",
            "desc": "<p>Creates a new timer.<\/p>\n<p>The <code>callback<\/code> function is invoked after the given <code>duration<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.Timer",
            "sig": "",
            "params": [
                {
                    "name": "duration",
                    "type": "dart:core.Duration",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "callback",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": true,
            "href": "dart-async\/Timer\/Timer.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Timer(Duration duration, void callback()) {\n  if (Zone.current == Zone.root) {\n    \/\/ No need to bind the callback. We know that the root's timer will\n    \/\/ be invoked in the root zone.\n    return Zone.current.createTimer(duration, callback);\n  }\n  return Zone.current\n      .createTimer(duration, Zone.current.bindCallbackGuarded(callback));\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "cancel",
            "type": "",
            "desc": "<p>Cancels the timer.<\/p>\n<p>Once a <a href=\"dart-async\/Timer-class.html\">Timer<\/a> has been canceled, the callback function will not be called\nby the timer. Calling <a href=\"dart-async\/Timer\/cancel.html\">cancel<\/a> more than once on a <a href=\"dart-async\/Timer-class.html\">Timer<\/a> is allowed, and\nwill have no further effect.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.Timer",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "dart-async\/Timer\/cancel.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void cancel();<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "Timer.periodic",
            "type": "",
            "desc": "<p>Creates a new repeating timer.<\/p>\n<p>The <code>callback<\/code> is invoked repeatedly with <code>duration<\/code> intervals until\ncanceled with the <a href=\"dart-async\/Timer\/cancel.html\">cancel<\/a> function.<\/p>\n<p>The exact timing depends on the underlying timer implementation.\nNo more than <code>n<\/code> callbacks will be made in <code>duration * n<\/code> time,\nbut the time between two consecutive callbacks\ncan be shorter and longer than <code>duration<\/code>.<\/p>\n<p>In particular, an implementation may schedule the next callback, e.g.,\na <code>duration<\/code> after either when the previous callback ended,\nwhen the previous callback started, or when the previous callback was\nscheduled for - even if the actual callback was delayed.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.Timer",
            "sig": "",
            "params": [
                {
                    "name": "duration",
                    "type": "dart:core.Duration",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "timer",
                    "type": "dart:async.Timer",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "timer",
                    "type": "dart:async.Timer",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": true,
            "href": "dart-async\/Timer\/Timer.periodic.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Timer.periodic(Duration duration, void callback(Timer timer)) {\n  if (Zone.current == Zone.root) {\n    \/\/ No need to bind the callback. We know that the root's timer will\n    \/\/ be invoked in the root zone.\n    return Zone.current.createPeriodicTimer(duration, callback);\n  }\n  var boundCallback = Zone.current.bindUnaryCallbackGuarded&lt;Timer&gt;(callback);\n  return Zone.current.createPeriodicTimer(duration, boundCallback);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "run",
            "type": "",
            "desc": "<p>Runs the given <code>callback<\/code> asynchronously as soon as possible.<\/p>\n<p>This function is equivalent to <code>new Timer(Duration.zero, callback)<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "dart:async.Timer",
            "sig": "",
            "params": [
                {
                    "name": "callback",
                    "type": "",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "isConstructor": false,
            "href": "dart-async\/Timer\/run.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static void run(void callback()) {\n  new Timer(Duration.zero, callback);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        }
    ],
    "props": [
        {
            "name": "isActive",
            "type": "dart:core.bool",
            "types": [],
            "desc": "<p>Returns whether the timer is still active.<\/p>\n<p>A non-periodic timer is active if the callback has not been executed,\nand the timer has not been canceled.<\/p>\n<p>A periodic timer is active if it has not been canceled.<\/p>\n        ",
            "memberOf": "dart:async.Timer",
            "isConstant": false,
            "href": "dart-async\/Timer\/isActive.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isActive;<\/code><\/pre>\n        ",
            "isDeprecated": false
        },
        {
            "name": "tick",
            "type": "dart:core.int",
            "types": [],
            "desc": "<p>The number of durations preceding the most recent timer event.<\/p>\n<p>The value starts at zero and is incremented each time a timer event\noccurs, so each callback will see a larger value than the previous one.<\/p>\n<p>If a periodic timer with a non-zero duration is delayed too much,\nso more than one tick should have happened,\nall but the last tick in the past are considered \"missed\",\nand no callback is invoked for them.\nThe <a href=\"dart-async\/Timer\/tick.html\">tick<\/a> count reflects the number of durations that have passed and\nnot the number of callback invocations that have happened.<\/p>\n        ",
            "memberOf": "dart:async.Timer",
            "isConstant": false,
            "href": "dart-async\/Timer\/tick.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get tick;<\/code><\/pre>\n        ",
            "isDeprecated": false
        }
    ],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": true,
    "implementors": [],
    "realImplementors": [],
    "cn": [],
    "href": "dart-async\/Timer-class.html",
    "desc": "<p>A count-down timer that can be configured to fire once or repeatedly.<\/p>\n<p>The timer counts down from the specified duration to 0.\nWhen the timer reaches 0, the timer invokes the specified callback function.\nUse a periodic timer to repeatedly count down the same interval.<\/p>\n<p>A negative duration is treated the same as a duration of 0.\nIf the duration is statically known to be 0, consider using <a href=\"dart-async\/Timer\/run.html\">run<\/a>.<\/p>\n<p>Frequently the duration is either a constant or computed as in the\nfollowing example (taking advantage of the multiplication operator of\nthe <a href=\"dart-core\/Duration-class.html\">Duration<\/a> class):<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">const timeout = const Duration(seconds: 3);\nconst ms = const Duration(milliseconds: 1);\n\nstartTimeout([int milliseconds]) {\n  var duration = milliseconds == null ? timeout : ms * milliseconds;\n  return new Timer(duration, handleTimeout);\n}\n...\nvoid handleTimeout() {  \/\/ callback function\n  ...\n}\n<\/code><\/pre>\n<p>Note: If Dart code using Timer is compiled to JavaScript, the finest\ngranularity available in the browser is 4 milliseconds.<\/p>\n<p>See <a href=\"dart-core\/Stopwatch-class.html\">Stopwatch<\/a> for measuring elapsed time.<\/p>\n    ",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "Timer"
}