{
    "desc": "<p>State for a <a href=\"widgets\/EditableText-class.html\">EditableText<\/a>.<\/p>\n    ",
    "dtype": "class",
    "example": "",
    "href": "widgets\/EditableTextState-class.html",
    "isAbstract": false,
    "isConstant": "0",
    "isDeprecated": false,
    "memberOf": "widgets",
    "name": "widgets.EditableTextState",
    "shortname": "EditableTextState",
    "extends": [
        "widgets.EditableText",
        "widgets.State",
        "foundation.Diagnosticable",
        "dart:core.Object"
    ],
    "is_enum": false,
    "is_mixin": false,
    "realImplementors": [],
    "events": [],
    "methods": [
        {
            "desc": "",
            "example": "",
            "href": "widgets\/EditableTextState\/EditableTextState.html",
            "isDeprecated": false,
            "type": "",
            "name": "EditableTextState",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Brings the provided <a href=\"dart-ui\/TextPosition-class.html\">TextPosition<\/a> into the visible area of the text\ninput.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid bringIntoView(TextPosition position) {\n  _scrollController.jumpTo(_getScrollOffsetForCaret(renderEditable.getLocalRectForCaret(position)));\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/bringIntoView.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "bringIntoView",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": [
                {
                    "name": "position",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "dart:ui.TextPosition"
                }
            ]
        },
        {
            "desc": "<p>Describes the part of the user interface represented by this widget.<\/p>\n<p>The framework calls this method in a number of different situations:<\/p>\n<ul>\n<li>After calling <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>.<\/li>\n<li>After calling <a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a>.<\/li>\n<li>After receiving a call to <a href=\"widgets\/State\/setState.html\">setState<\/a>.<\/li>\n<li>After a dependency of this <a href=\"widgets\/State-class.html\">State<\/a> object changes (e.g., an\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a> referenced by the previous <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> changes).<\/li>\n<li>After calling <a href=\"widgets\/AutomaticKeepAliveClientMixin\/deactivate.html\">deactivate<\/a> and then reinserting the <a href=\"widgets\/State-class.html\">State<\/a> object into\nthe tree at another location.<\/li>\n<\/ul>\n<p>The framework replaces the subtree below this widget with the widget\nreturned by this method, either by updating the existing subtree or by\nremoving the subtree and inflating a new subtree, depending on whether the\nwidget returned by this method can update the root of the existing\nsubtree, as determined by calling <a href=\"widgets\/Widget\/canUpdate.html\">Widget.canUpdate<\/a>.<\/p>\n<p>Typically implementations return a newly created constellation of widgets\nthat are configured with information from this widget's constructor, the\ngiven <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>, and the internal state of this <a href=\"widgets\/State-class.html\">State<\/a> object.<\/p>\n<p>The given <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> contains information about the location in the\ntree at which this widget is being built. For example, the context\nprovides the set of inherited widgets for this location in the tree. The\n<a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> argument is always the same as the <code>context<\/code> property of\nthis <a href=\"widgets\/State-class.html\">State<\/a> object and will remain the same for the lifetime of this\nobject. The <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> argument is provided redundantly here so that\nthis method matches the signature for a <a href=\"widgets\/WidgetBuilder.html\">WidgetBuilder<\/a>.<\/p>\n<h2 id=\"design-discussion\">Design discussion<\/h2>\n<h3 id=\"why-is-the-build-method-on-state-and-not-statefulwidget\">Why is the <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> method on <a href=\"widgets\/State-class.html\">State<\/a>, and not <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>?<\/h3>\n<p>Putting a <code>Widget build(BuildContext context)<\/code> method on <a href=\"widgets\/State-class.html\">State<\/a> rather\nputting a <code>Widget build(BuildContext context, State state)<\/code> method on\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> gives developers more flexibility when subclassing\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>.<\/p>\n<p>For example, <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a> is a subclass of <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> that\nintroduces an abstract <code>Widget build(BuildContext context)<\/code> method for its\nsubclasses to implement. If <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> already had a <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> method\nthat took a <a href=\"widgets\/State-class.html\">State<\/a> argument, <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a> would be forced to provide\nits <a href=\"widgets\/State-class.html\">State<\/a> object to subclasses even though its <a href=\"widgets\/State-class.html\">State<\/a> object is an\ninternal implementation detail of <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a>.<\/p>\n<p>Conceptually, <a href=\"widgets\/StatelessWidget-class.html\">StatelessWidget<\/a> could also be implemented as a subclass of\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> in a similar manner. If the <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> method were on\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> rather than <a href=\"widgets\/State-class.html\">State<\/a>, that would not be possible anymore.<\/p>\n<p>Putting the <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> function on <a href=\"widgets\/State-class.html\">State<\/a> rather than <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> also\nhelps avoid a category of bugs related to closures implicitly capturing\n<code>this<\/code>. If you defined a closure in a <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> function on a\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, that closure would implicitly capture <code>this<\/code>, which is\nthe current widget instance, and would have the (immutable) fields of that\ninstance in scope:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class MyButton extends StatefulWidget {\n  ...\n  final Color color;\n\n  @override\n  Widget build(BuildContext context, MyButtonState state) {\n    ... () { print(\"color: $color\"); } ...\n  }\n}\n<\/code><\/pre>\n<p>For example, suppose the parent builds <code>MyButton<\/code> with <code>color<\/code> being blue,\nthe <code>$color<\/code> in the print function refers to blue, as expected. Now,\nsuppose the parent rebuilds <code>MyButton<\/code> with green. The closure created by\nthe first build still implicitly refers to the original widget and the\n<code>$color<\/code> still prints blue even through the widget has been updated to\ngreen.<\/p>\n<p>In contrast, with the <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> function on the <a href=\"widgets\/State-class.html\">State<\/a> object, closures\ncreated during <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> implicitly capture the <a href=\"widgets\/State-class.html\">State<\/a> instance instead of\nthe widget instance:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class MyButtonState extends State&lt;MyButton&gt; {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    ... () { print(\"color: ${widget.color}\"); } ...\n  }\n}\n<\/code><\/pre>\n<p>Now when the parent rebuilds <code>MyButton<\/code> with green, the closure created by\nthe first build still refers to <a href=\"widgets\/State-class.html\">State<\/a> object, which is preserved across\nrebuilds, but the framework has updated that <a href=\"widgets\/State-class.html\">State<\/a> object's <a href=\"widgets\/State\/widget.html\">widget<\/a>\nproperty to refer to the new <code>MyButton<\/code> instance and <code>${widget.color}<\/code>\nprints green, as expected.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, which contains the discussion on performance considerations.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nWidget build(BuildContext context) {\n  assert(debugCheckHasMediaQuery(context));\n  FocusScope.of(context).reparentIfNeeded(widget.focusNode);\n  super.build(context); \/\/ See AutomaticKeepAliveClientMixin.\n\n  final TextSelectionControls controls = widget.selectionControls;\n  return Scrollable(\n    excludeFromSemantics: true,\n    axisDirection: _isMultiline ? AxisDirection.down : AxisDirection.right,\n    controller: _scrollController,\n    physics: const ClampingScrollPhysics(),\n    dragStartBehavior: widget.dragStartBehavior,\n    viewportBuilder: (BuildContext context, ViewportOffset offset) {\n      return CompositedTransformTarget(\n        link: _layerLink,\n        child: Semantics(\n          onCopy: _semanticsOnCopy(controls),\n          onCut: _semanticsOnCut(controls),\n          onPaste: _semanticsOnPaste(controls),\n          child: _Editable(\n            key: _editableKey,\n            textSpan: buildTextSpan(),\n            value: _value,\n            cursorColor: _cursorColor,\n            backgroundCursorColor: widget.backgroundCursorColor,\n            showCursor: EditableText.debugDeterministicCursor\n                ? ValueNotifier&lt;bool&gt;(true)\n                : _cursorVisibilityNotifier,\n            hasFocus: _hasFocus,\n            maxLines: widget.maxLines,\n            minLines: widget.minLines,\n            expands: widget.expands,\n            strutStyle: widget.strutStyle,\n            selectionColor: widget.selectionColor,\n            textScaleFactor: widget.textScaleFactor ?? MediaQuery.textScaleFactorOf(context),\n            textAlign: widget.textAlign,\n            textDirection: _textDirection,\n            locale: widget.locale,\n            obscureText: widget.obscureText,\n            autocorrect: widget.autocorrect,\n            offset: offset,\n            onSelectionChanged: _handleSelectionChanged,\n            onCaretChanged: _handleCaretChanged,\n            rendererIgnoresPointer: widget.rendererIgnoresPointer,\n            cursorWidth: widget.cursorWidth,\n            cursorRadius: widget.cursorRadius,\n            cursorOffset: widget.cursorOffset,\n            paintCursorAboveText: widget.paintCursorAboveText,\n            enableInteractiveSelection: widget.enableInteractiveSelection,\n            textSelectionDelegate: this,\n            devicePixelRatio: _devicePixelRatio,\n          ),\n        ),\n      );\n    },\n  );\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/build.html",
            "isDeprecated": false,
            "type": "widgets.Widget",
            "name": "build",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": [
                {
                    "name": "context",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.BuildContext"
                }
            ]
        },
        {
            "desc": "<p>Builds <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> from current editing value.<\/p>\n<p>By default makes text in composing range appear as underlined.\nDescendants can override this method to customize appearance of text.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextSpan buildTextSpan() {\n  if (!widget.obscureText &amp;&amp; _value.composing.isValid) {\n    final TextStyle composingStyle = widget.style.merge(\n      const TextStyle(decoration: TextDecoration.underline),\n    );\n\n    return TextSpan(\n      style: widget.style,\n      children: &lt;TextSpan&gt;[\n        TextSpan(text: _value.composing.textBefore(_value.text)),\n        TextSpan(\n          style: composingStyle,\n          text: _value.composing.textInside(_value.text),\n        ),\n        TextSpan(text: _value.composing.textAfter(_value.text)),\n    ]);\n  }\n\n  String text = _value.text;\n  if (widget.obscureText) {\n    text = RenderEditable.obscuringCharacter * text.length;\n    final int o =\n      _obscureShowCharTicksPending &gt; 0 ? _obscureLatestCharIndex : null;\n    if (o != null &amp;&amp; o &gt;= 0 &amp;&amp; o &lt; text.length)\n      text = text.replaceRange(o, o + 1, _value.text.substring(o, o + 1));\n  }\n  return TextSpan(style: widget.style, text: text);\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/buildTextSpan.html",
            "isDeprecated": false,
            "type": "painting.TextSpan",
            "name": "buildTextSpan",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Called when a dependency of this <a href=\"widgets\/State-class.html\">State<\/a> object changes.<\/p>\n<p>For example, if the previous call to <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> referenced an\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a> that later changed, the framework would call this\nmethod to notify this object about the change.<\/p>\n<p>This method is also called immediately after <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>. It is safe to\ncall <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> from this method.<\/p>\n<p>Subclasses rarely override this method because the framework always\ncalls <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> after a dependency changes. Some subclasses do override\nthis method because they need to do some expensive work (e.g., network\nfetches) when their dependencies change, and that work would be too\nexpensive to do for every build.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid didChangeDependencies() {\n  super.didChangeDependencies();\n  if (!_didAutoFocus &amp;&amp; widget.autofocus) {\n    FocusScope.of(context).autofocus(widget.focusNode);\n    _didAutoFocus = true;\n  }\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/didChangeDependencies.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "didChangeDependencies",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Called when the application's dimensions change. For example,\nwhen a phone is rotated.<\/p>\n<p>This method exposes notifications from <a href=\"dart-ui\/Window\/onMetricsChanged.html\">Window.onMetricsChanged<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> implements the parts of the <a href=\"widgets\/State-class.html\">State<\/a> and\n<a href=\"widgets\/WidgetsBindingObserver-class.html\">WidgetsBindingObserver<\/a> protocols necessary to react when the device is\nrotated (or otherwise changes dimensions).\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class MetricsReactor extends StatefulWidget {\n  const MetricsReactor({ Key key }) : super(key: key);\n\n  @override\n  _MetricsReactorState createState() =&gt; _MetricsReactorState();\n}\n\nclass _MetricsReactorState extends State&lt;MetricsReactor&gt; with WidgetsBindingObserver {\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  Size _lastSize;\n\n  @override\n  void didChangeMetrics() {\n    setState(() { _lastSize = WidgetsBinding.instance.window.physicalSize; });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Current size: $_lastSize');\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>In general, this is unnecessary as the layout system takes care of\nautomatically recomputing the application geometry when the application\nsize changes.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/MediaQuery\/of.html\">MediaQuery.of<\/a>, which provides a similar service with less\nboilerplate.<\/li><\/ul>",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid didChangeMetrics() {\n  if (_lastBottomViewInset &lt; WidgetsBinding.instance.window.viewInsets.bottom) {\n    _showCaretOnScreen();\n  }\n  _lastBottomViewInset = WidgetsBinding.instance.window.viewInsets.bottom;\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/didChangeMetrics.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "didChangeMetrics",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Called whenever the widget configuration changes.<\/p>\n<p>If the parent widget rebuilds and request that this location in the tree\nupdate to display a new widget with the same <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and\n<a href=\"widgets\/Widget\/key.html\">Widget.key<\/a>, the framework will update the <a href=\"widgets\/State\/widget.html\">widget<\/a> property of this\n<a href=\"widgets\/State-class.html\">State<\/a> object to refer to the new widget and then call this method\nwith the previous widget as an argument.<\/p>\n<p>Override this method to respond when the <a href=\"widgets\/State\/widget.html\">widget<\/a> changes (e.g., to start\nimplicit animations).<\/p>\n<p>The framework always calls <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> after calling <a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a>, which\nmeans any calls to <a href=\"widgets\/State\/setState.html\">setState<\/a> in <a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a> are redundant.<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>,\n<a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>, unsubscribe from the object.<\/li>\n<\/ul>\n<p>If you override this, make sure your method starts with a call to\nsuper.didUpdateWidget(oldWidget).<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid didUpdateWidget(EditableText oldWidget) {\n  super.didUpdateWidget(oldWidget);\n  if (widget.controller != oldWidget.controller) {\n    oldWidget.controller.removeListener(_didChangeTextEditingValue);\n    widget.controller.addListener(_didChangeTextEditingValue);\n    _updateRemoteEditingValueIfNeeded();\n  }\n  if (widget.focusNode != oldWidget.focusNode) {\n    oldWidget.focusNode.removeListener(_handleFocusChanged);\n    widget.focusNode.addListener(_handleFocusChanged);\n    updateKeepAlive();\n  }\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/didUpdateWidget.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "didUpdateWidget",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": [
                {
                    "name": "oldWidget",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "widgets.EditableText"
                }
            ]
        },
        {
            "desc": "<p>Called when this object is removed from the tree permanently.<\/p>\n<p>The framework calls this method when this <a href=\"widgets\/State-class.html\">State<\/a> object will never\nbuild again. After the framework calls <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>, the <a href=\"widgets\/State-class.html\">State<\/a> object is\nconsidered unmounted and the <a href=\"widgets\/State\/mounted.html\">mounted<\/a> property is false. It is an error\nto call <a href=\"widgets\/State\/setState.html\">setState<\/a> at this point. This stage of the lifecycle is terminal:\nthere is no way to remount a <a href=\"widgets\/State-class.html\">State<\/a> object that has been disposed.<\/p>\n<p>Subclasses should override this method to release any resources retained\nby this object (e.g., stop any active animations).<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>,\n<a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>, unsubscribe from the object.<\/li>\n<\/ul>\n<p>If you override this, make sure to end your method with a call to\nsuper.dispose().<\/p>\n<p>See also <a href=\"widgets\/AutomaticKeepAliveClientMixin\/deactivate.html\">deactivate<\/a>, which is called prior to <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid dispose() {\n  widget.controller.removeListener(_didChangeTextEditingValue);\n  _cursorBlinkOpacityController.removeListener(_onCursorColorTick);\n  _floatingCursorResetController.removeListener(_onFloatingCursorResetTick);\n  _closeInputConnectionIfNeeded();\n  assert(!_hasInputConnection);\n  _stopCursorTimer();\n  assert(_cursorTimer == null);\n  _selectionOverlay?.dispose();\n  _selectionOverlay = null;\n  widget.focusNode.removeListener(_handleFocusChanged);\n  super.dispose();\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/dispose.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "dispose",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Hides the text selection toolbar.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid hideToolbar() {\n  _selectionOverlay?.hide();\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/hideToolbar.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "hideToolbar",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Called when this object is inserted into the tree.<\/p>\n<p>The framework will call this method exactly once for each <a href=\"widgets\/State-class.html\">State<\/a> object\nit creates.<\/p>\n<p>Override this method to perform initialization that depends on the\nlocation at which this object was inserted into the tree (i.e., <a href=\"widgets\/State\/context.html\">context<\/a>)\nor on the widget used to configure this object (i.e., <a href=\"widgets\/State\/widget.html\">widget<\/a>).<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"widgets\/EditableTextState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>,\n<a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"widgets\/EditableTextState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"widgets\/EditableTextState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"widgets\/EditableTextState\/dispose.html\">dispose<\/a>, unsubscribe from the object.\nYou cannot use <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> from this\nmethod. However, <a href=\"widgets\/EditableTextState\/didChangeDependencies.html\">didChangeDependencies<\/a> will be called immediately\nfollowing this method, and <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> can\nbe used there.<\/li>\n<\/ul>\n<p>If you override this, make sure your method starts with a call to\nsuper.initState().<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initState() {\n  super.initState();\n  widget.controller.addListener(_didChangeTextEditingValue);\n  widget.focusNode.addListener(_handleFocusChanged);\n  _scrollController.addListener(() { _selectionOverlay?.updateForScroll(); });\n  _cursorBlinkOpacityController = AnimationController(vsync: this, duration: _fadeDuration);\n  _cursorBlinkOpacityController.addListener(_onCursorColorTick);\n  _floatingCursorResetController = AnimationController(vsync: this);\n  _floatingCursorResetController.addListener(_onFloatingCursorResetTick);\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/initState.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "initState",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Requests that this client perform the given action.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid performAction(TextInputAction action) {\n  switch (action) {\n    case TextInputAction.newline:\n      \/\/ If this is a multiline EditableText, do nothing for a \"newline\"\n      \/\/ action; The newline is already inserted. Otherwise, finalize\n      \/\/ editing.\n      if (!_isMultiline)\n        _finalizeEditing(true);\n      break;\n    case TextInputAction.done:\n    case TextInputAction.go:\n    case TextInputAction.send:\n    case TextInputAction.search:\n      _finalizeEditing(true);\n      break;\n    default:\n      \/\/ Finalize editing, but don't give up focus because this keyboard\n      \/\/  action does not imply the user is done inputting information.\n      _finalizeEditing(false);\n      break;\n  }\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/performAction.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "performAction",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": [
                {
                    "name": "action",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "services.TextInputAction"
                }
            ]
        },
        {
            "desc": "<p>Express interest in interacting with the keyboard.<\/p>\n<p>If this control is already attached to the keyboard, this function will\nrequest that the keyboard become visible. Otherwise, this function will\nask the focus system that it become focused. If successful in acquiring\nfocus, the control will then attach to the keyboard and request that the\nkeyboard become visible.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void requestKeyboard() {\n  if (_hasFocus) {\n    _openInputConnection();\n  } else {\n    final List&lt;FocusScopeNode&gt; ancestorScopes = FocusScope.ancestorsOf(context);\n    for (int i = ancestorScopes.length - 1; i &gt;= 1; i -= 1)\n      ancestorScopes[i].setFirstFocus(ancestorScopes[i - 1]);\n    FocusScope.of(context).requestFocus(widget.focusNode);\n  }\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/requestKeyboard.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "requestKeyboard",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Shows the selection toolbar at the location of the current cursor.<\/p>\n<p>Returns <code>false<\/code> if a toolbar couldn't be shown such as when no text\nselection currently exists.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool showToolbar() {\n  if (_selectionOverlay == null)\n    return false;\n\n  _selectionOverlay.showToolbar();\n  return true;\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/showToolbar.html",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "name": "showToolbar",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Requests that this client update its editing state to the given value.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid updateEditingValue(TextEditingValue value) {\n  if (value.text != _value.text) {\n    _hideSelectionOverlayIfNeeded();\n    _showCaretOnScreen();\n    if (widget.obscureText &amp;&amp; value.text.length == _value.text.length + 1) {\n      _obscureShowCharTicksPending = _kObscureShowLatestCharCursorTicks;\n      _obscureLatestCharIndex = _value.selection.baseOffset;\n    }\n  }\n  _lastKnownRemoteTextEditingValue = value;\n  _formatAndSetValue(value);\n\n  \/\/ To keep the cursor from blinking while typing, we want to restart the\n  \/\/ cursor timer every time a new character is typed.\n  _stopCursorTimer(resetCharTicks: false);\n  _startCursorTimer();\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/updateEditingValue.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "updateEditingValue",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": [
                {
                    "name": "value",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "services.TextEditingValue"
                }
            ]
        },
        {
            "desc": "<p>Updates the floating cursor position and state.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid updateFloatingCursor(RawFloatingCursorPoint point) {\n  switch(point.state){\n    case FloatingCursorDragState.Start:\n      final TextPosition currentTextPosition = TextPosition(offset: renderEditable.selection.baseOffset);\n      _startCaretRect = renderEditable.getLocalRectForCaret(currentTextPosition);\n      renderEditable.setFloatingCursor(point.state, _startCaretRect.center - _floatingCursorOffset, currentTextPosition);\n      break;\n    case FloatingCursorDragState.Update:\n      \/\/ We want to send in points that are centered around a (0,0) origin, so we cache the\n      \/\/ position on the first update call.\n      if (_pointOffsetOrigin != null) {\n        final Offset centeredPoint = point.offset - _pointOffsetOrigin;\n        final Offset rawCursorOffset = _startCaretRect.center + centeredPoint - _floatingCursorOffset;\n        _lastBoundedOffset = renderEditable.calculateBoundedFloatingCursorOffset(rawCursorOffset);\n        _lastTextPosition = renderEditable.getPositionForPoint(renderEditable.localToGlobal(_lastBoundedOffset + _floatingCursorOffset));\n        renderEditable.setFloatingCursor(point.state, _lastBoundedOffset, _lastTextPosition);\n      } else {\n        _pointOffsetOrigin = point.offset;\n      }\n      break;\n    case FloatingCursorDragState.End:\n      _floatingCursorResetController.value = 0.0;\n      _floatingCursorResetController.animateTo(1.0, duration: _floatingCursorResetTime, curve: Curves.decelerate);\n    break;\n  }\n}<\/code><\/pre>\n    ",
            "href": "widgets\/EditableTextState\/updateFloatingCursor.html",
            "isDeprecated": false,
            "type": "<void>",
            "name": "updateFloatingCursor",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "widgets.EditableTextState",
            "params": [
                {
                    "name": "point",
                    "desc": "",
                    "example": "",
                    "href": "",
                    "isDeprecated": false,
                    "isOptional": false,
                    "type": "services.RawFloatingCursorPoint"
                }
            ]
        }
    ],
    "props": [
        {
            "desc": "<p>The cursor blink interval (the amount of time the cursor is in the \"on\"\nstate or the \"off\" state). A complete cursor blink period is twice this\nvalue (half on, half off).<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@visibleForTesting\nDuration get cursorBlinkInterval =&gt; _kCursorBlinkHalfPeriod;<\/code><\/pre>\n        ",
            "href": "widgets\/EditableTextState\/cursorBlinkInterval.html",
            "name": "cursorBlinkInterval",
            "isDeprecated": false,
            "type": "dart:core.Duration",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Whether the blinking cursor is actually visible at this precise moment\n(it's hidden half the time, since it blinks).<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@visibleForTesting\nbool get cursorCurrentlyVisible =&gt; _cursorBlinkOpacityController.value &gt; 0;<\/code><\/pre>\n        ",
            "href": "widgets\/EditableTextState\/cursorCurrentlyVisible.html",
            "name": "cursorCurrentlyVisible",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>The renderer for this widget's <code>Editable<\/code> descendant.<\/p>\n<p>This property is typically used to notify the renderer of input gestures\nwhen <code>ignorePointer<\/code> is true. See <a href=\"rendering\/RenderEditable\/ignorePointer.html\">RenderEditable.ignorePointer<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RenderEditable get renderEditable =&gt; _editableKey.currentContext.findRenderObject();<\/code><\/pre>\n        ",
            "href": "widgets\/EditableTextState\/renderEditable.html",
            "name": "renderEditable",
            "isDeprecated": false,
            "type": "rendering.RenderEditable",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>The current status of the text selection handles.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@visibleForTesting\nTextSelectionOverlay get selectionOverlay =&gt; _selectionOverlay;<\/code><\/pre>\n        ",
            "href": "widgets\/EditableTextState\/selectionOverlay.html",
            "name": "selectionOverlay",
            "isDeprecated": false,
            "type": "widgets.TextSelectionOverlay",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Gets the current text input.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nTextEditingValue get textEditingValue =&gt; _value;<\/code><\/pre>\n        ",
            "href": "widgets\/EditableTextState\/textEditingValue.html",
            "name": "textEditingValue",
            "isDeprecated": false,
            "type": "services.TextEditingValue",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        },
        {
            "desc": "<p>Whether the current instance should be kept alive.<\/p>\n<p>Call <a href=\"widgets\/AutomaticKeepAliveClientMixin\/updateKeepAlive.html\">updateKeepAlive<\/a> whenever this getter's value changes.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get wantKeepAlive =&gt; widget.focusNode.hasFocus;<\/code><\/pre>\n        ",
            "href": "widgets\/EditableTextState\/wantKeepAlive.html",
            "name": "wantKeepAlive",
            "isDeprecated": false,
            "type": "dart:core.bool",
            "dtype": "property",
            "isStatic": false,
            "isConstant": false,
            "memberOf": "widgets.EditableTextState",
            "params": []
        }
    ]
}