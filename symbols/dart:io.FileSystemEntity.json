{
    "desc": "<p>The common super class for <a href=\"dart-io\/File-class.html\">File<\/a>, <a href=\"dart-io\/Directory-class.html\">Directory<\/a>, and <a href=\"dart-io\/Link-class.html\">Link<\/a> objects.<\/p>\n<p><a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> objects are returned from directory listing\noperations. To determine if a FileSystemEntity is a <a href=\"dart-io\/File-class.html\">File<\/a>, a\n<a href=\"dart-io\/Directory-class.html\">Directory<\/a>, or a <a href=\"dart-io\/Link-class.html\">Link<\/a> perform a type check:<\/p>\n<pre class=\"language-dart\"><code>if (entity is File) (entity as File).readAsStringSync();\n<\/code><\/pre>\n<p>You can also use the <a href=\"dart-io\/FileSystemEntity\/type.html\">type<\/a> or <a href=\"dart-io\/FileSystemEntity\/typeSync.html\">typeSync<\/a> methods to determine\nthe type of a file system object.<\/p>\n<p>Most methods in this class occur in synchronous and asynchronous pairs,\nfor example, <a href=\"dart-io\/FileSystemEntity\/exists.html\">exists<\/a> and <a href=\"dart-io\/FileSystemEntity\/existsSync.html\">existsSync<\/a>.\nUnless you have a specific reason for using the synchronous version\nof a method, prefer the asynchronous version to avoid blocking your program.<\/p>\n<p>Here's the exists method in action:<\/p>\n<pre class=\"language-dart\"><code>entity.exists().then((isThere) {\n  isThere ? print('exists') : print('non-existent');\n});\n<\/code><\/pre>\n<h2 id=\"other-resources\">Other resources<\/h2>\n<ul>\n<li>\n<p><a href=\"https:\/\/www.dartlang.org\/dart-by-example\/#files-directories-and-symlinks\">Dart by\nExample<\/a>\nprovides additional task-oriented code samples that show how to use various\nAPI from the <a href=\"dart-io\/Directory-class.html\">Directory<\/a> class and the <a href=\"dart-io\/File-class.html\">File<\/a> class, both subclasses of\nFileSystemEntity.<\/p>\n<\/li>\n<li>\n<p><a href=\"https:\/\/www.dartlang.org\/docs\/dart-up-and-running\/ch03.html#dartio---io-for-command-line-apps\">I\/O for Command-Line\nApps<\/a>,\na section from <em>A Tour of the Dart Libraries<\/em> covers files and directories.<\/p>\n<\/li>\n<li>\n<p><a href=\"https:\/\/www.dartlang.org\/docs\/tutorials\/cmdline\/\">Write Command-Line Apps<\/a>,\na tutorial about writing command-line apps, includes information about\nfiles and directories.<\/p>\n<\/li>\n<\/ul>",
    "dtype": "class",
    "example": "",
    "href": "dart-io\/FileSystemEntity-class.html",
    "isAbstract": "1",
    "isConstant": "0",
    "isDeprecated": "0",
    "is_enum": 1,
    "is_mixin": 1,
    "is_typedef": 1,
    "memberOf": "dart:io",
    "name": "dart:io.FileSystemEntity",
    "shortname": "FileSystemEntity",
    "extends": [],
    "events": [],
    "methods": [
        {
            "desc": null,
            "example": "",
            "href": "dart-io\/FileSystemEntity\/FileSystemEntity.html",
            "isDeprecated": "0",
            "type": "",
            "dtype": "constructor",
            "isConstructor": true,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Deletes this <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a>.<\/p>\n<p>If the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> is a directory, and if <code>recursive<\/code> is false,\nthe directory must be empty. Otherwise, if <code>recursive<\/code> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.<\/p>\n<p>If <code>recursive<\/code> is true, the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> is deleted even if the type\nof the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> doesn't match the content of the file system.\nThis behavior allows <a href=\"dart-io\/FileSystemEntity\/delete.html\">delete<\/a> to be used to unconditionally delete any file\nsystem object.<\/p>\n<p>Returns a <code>Future&lt;FileSystemEntity&gt;<\/code> that completes with this\n<a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> when the deletion is done. If the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a>\ncannot be deleted, the future completes with an exception.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;FileSystemEntity&gt; delete({bool recursive: false}) =&gt;\n    _delete(recursive: recursive);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/delete.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:io.FileSystemEntity>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "recursive",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.bool"
                }
            ]
        },
        {
            "desc": "<p>Synchronously deletes this <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a>.<\/p>\n<p>If the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> is a directory, and if <code>recursive<\/code> is false,\nthe directory must be empty. Otherwise, if <code>recursive<\/code> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.<\/p>\n<p>If <code>recursive<\/code> is true, the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> is deleted even if the type\nof the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> doesn't match the content of the file system.\nThis behavior allows <a href=\"dart-io\/FileSystemEntity\/deleteSync.html\">deleteSync<\/a> to be used to unconditionally delete any\nfile system object.<\/p>\n<p>Throws an exception if the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> cannot be deleted.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void deleteSync({bool recursive: false}) =&gt; _deleteSync(recursive: recursive);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/deleteSync.html",
            "isDeprecated": "0",
            "type": "<void>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "recursive",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.bool"
                }
            ]
        },
        {
            "desc": "<p>Checks whether the file system entity with this path exists. Returns\na <code>Future&lt;bool&gt;<\/code> that completes with the result.<\/p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a href=\"dart-io\/File-class.html\">File<\/a>,\n<a href=\"dart-io\/Directory-class.html\">Directory<\/a>, and <a href=\"dart-io\/Link-class.html\">Link<\/a>.  Calling <a href=\"dart-io\/FileSystemEntity\/exists.html\">exists<\/a> on an instance of one\nof these subclasses checks whether the object exists in the file\nsystem object exists and is of the correct type (file, directory,\nor link).  To check whether a path points to an object on the\nfile system, regardless of the object's type, use the <a href=\"dart-io\/FileSystemEntity\/type.html\">type<\/a>\nstatic method.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; exists();<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/exists.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.bool>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Synchronously checks whether the file system entity with this path\nexists.<\/p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a href=\"dart-io\/File-class.html\">File<\/a>,\n<a href=\"dart-io\/Directory-class.html\">Directory<\/a>, and <a href=\"dart-io\/Link-class.html\">Link<\/a>.  Calling <a href=\"dart-io\/FileSystemEntity\/existsSync.html\">existsSync<\/a> on an instance of\none of these subclasses checks whether the object exists in the\nfile system object exists and is of the correct type (file,\ndirectory, or link).  To check whether a path points to an object\non the file system, regardless of the object's type, use the\n<a href=\"dart-io\/FileSystemEntity\/typeSync.html\">typeSync<\/a> static method.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool existsSync();<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/existsSync.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Checks whether two paths refer to the same object in the\nfile system.<\/p>\n<p>Returns a <code>Future&lt;bool&gt;<\/code> that completes with the result.<\/p>\n<p>Comparing a link to its target returns false, as does comparing two links\nthat point to the same target.  To check the target of a link, use\nLink.target explicitly to fetch it.  Directory links appearing\ninside a path are followed, though, to find the file system object.<\/p>\n<p>Completes the returned Future with an error if one of the paths points\nto an object that does not exist.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;bool&gt; identical(String path1, String path2) {\n  IOOverrides overrides = IOOverrides.current;\n  if (overrides == null) {\n    return _identical(path1, path2);\n  }\n  return overrides.fseIdentical(path1, path2);\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/identical.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.bool>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path1",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                },
                {
                    "name": "path2",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Synchronously checks whether two paths refer to the same object in the\nfile system.<\/p>\n<p>Comparing a link to its target returns false, as does comparing two links\nthat point to the same target.  To check the target of a link, use\nLink.target explicitly to fetch it.  Directory links appearing\ninside a path are followed, though, to find the file system object.<\/p>\n<p>Throws an error if one of the paths points to an object that does not\nexist.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool identicalSync(String path1, String path2) {\n  IOOverrides overrides = IOOverrides.current;\n  if (overrides == null) {\n    return _identicalSync(path1, path2);\n  }\n  return overrides.fseIdenticalSync(path1, path2);\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/identicalSync.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path1",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                },
                {
                    "name": "path2",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Checks if type(path) returns FileSystemEntityType.directory.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;bool&gt; isDirectory(String path) =&gt;\n    _getType(_toUtf8Array(path), true)\n        .then((type) =&gt; (type == FileSystemEntityType.directory));<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/isDirectory.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.bool>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Synchronously checks if typeSync(path) returns\nFileSystemEntityType.directory.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool isDirectorySync(String path) =&gt;\n    (_getTypeSync(_toUtf8Array(path), true) ==\n        FileSystemEntityType.directory);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/isDirectorySync.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Checks if type(path) returns FileSystemEntityType.file.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;bool&gt; isFile(String path) =&gt; _getType(_toUtf8Array(path), true)\n    .then((type) =&gt; (type == FileSystemEntityType.file));<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/isFile.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.bool>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Synchronously checks if typeSync(path) returns\nFileSystemEntityType.file.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool isFileSync(String path) =&gt;\n    (_getTypeSync(_toUtf8Array(path), true) == FileSystemEntityType.file);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/isFileSync.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Checks if type(path, followLinks: false) returns FileSystemEntityType.link.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;bool&gt; isLink(String path) =&gt; _isLinkRaw(_toUtf8Array(path));<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/isLink.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.bool>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Synchronously checks if typeSync(path, followLinks: false) returns\nFileSystemEntityType.link.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool isLinkSync(String path) =&gt; _isLinkRawSync(_toUtf8Array(path));<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/isLinkSync.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Removes the final path component of a path, using the platform's\npath separator to split the path.<\/p>\n<p>Will not remove the root component of a Windows path, like \"C:\\\" or\n\"\\\\server_name\\\". Ignores trailing path separators, and leaves no\ntrailing path separators.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static String parentOf(String path) {\n  int rootEnd = -1;\n  if (Platform.isWindows) {\n    if (path.startsWith(_absoluteWindowsPathPattern)) {\n      \/\/ Root ends at first \/ or \\ after the first two characters.\n      rootEnd = path.indexOf(new RegExp(r'[\/\\\\]'), 2);\n      if (rootEnd == -1) return path;\n    } else if (path.startsWith('\\\\') || path.startsWith('\/')) {\n      rootEnd = 0;\n    }\n  } else if (path.startsWith('\/')) {\n    rootEnd = 0;\n  }\n  \/\/ Ignore trailing slashes.\n  \/\/ All non-trivial cases have separators between two non-separators.\n  int pos = path.lastIndexOf(_parentRegExp);\n  if (pos &gt; rootEnd) {\n    return path.substring(0, pos + 1);\n  } else if (rootEnd &gt; -1) {\n    return path.substring(0, rootEnd + 1);\n  } else {\n    return '.';\n  }\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/parentOf.html",
            "isDeprecated": "0",
            "type": "dart:core.String",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Renames this file system entity.<\/p>\n<p>Returns a <code>Future&lt;FileSystemEntity&gt;<\/code> that completes with a\n<a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> instance for the renamed file system entity.<\/p>\n<p>If <code>newPath<\/code> identifies an existing entity of the same type, that entity\nis replaced. If <code>newPath<\/code> identifies an existing entity of a different\ntype, the operation fails and the future completes with an exception.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;FileSystemEntity&gt; rename(String newPath);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/rename.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:io.FileSystemEntity>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "newPath",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Synchronously renames this file system entity.<\/p>\n<p>Returns a <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> instance for the renamed entity.<\/p>\n<p>If <code>newPath<\/code> identifies an existing entity of the same type, that entity\nis replaced. If <code>newPath<\/code> identifies an existing entity of a different\ntype, the operation fails and an exception is thrown.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">FileSystemEntity renameSync(String newPath);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/renameSync.html",
            "isDeprecated": "0",
            "type": "dart:io.FileSystemEntity",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "newPath",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Resolves the path of a file system object relative to the\ncurrent working directory.<\/p>\n<p>Resolves all symbolic links on the path and resolves all <code>..<\/code> and <code>.<\/code> path\nsegments.<\/p>\n<p><a href=\"dart-io\/FileSystemEntity\/resolveSymbolicLinks.html\">resolveSymbolicLinks<\/a> uses the operating system's native\nfile system API to resolve the path, using the <code>realpath<\/code> function\non linux and OS X, and the <code>GetFinalPathNameByHandle<\/code> function on\nWindows. If the path does not point to an existing file system object,\n<code>resolveSymbolicLinks<\/code> throws a <code>FileSystemException<\/code>.<\/p>\n<p>On Windows the <code>..<\/code> segments are resolved <em>before<\/em> resolving the symbolic\nlink, and on other platforms the symbolic links are <em>resolved to their\ntarget<\/em> before applying a <code>..<\/code> that follows.<\/p>\n<p>To ensure the same behavior on all platforms resolve <code>..<\/code> segments before\ncalling <code>resolveSymbolicLinks<\/code>. One way of doing this is with the <code>Uri<\/code>\nclass:<\/p>\n<pre class=\"language-dart\"><code>var path = Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();\nif (path == '') path = '.';\nnew File(path).resolveSymbolicLinks().then((resolved) {\n  print(resolved);\n});\n<\/code><\/pre>\n<p>since <code>Uri.resolve<\/code> removes <code>..<\/code> segments. This will result in the Windows\nbehavior.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;String&gt; resolveSymbolicLinks() {\n  return _File._dispatchWithNamespace(\n      _IOService.fileResolveSymbolicLinks, [null, _rawPath]).then((response) {\n    if (_isErrorResponse(response)) {\n      throw _exceptionFromResponse(\n          response, \"Cannot resolve symbolic links\", path);\n    }\n    return response;\n  });\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/resolveSymbolicLinks.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:core.String>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Resolves the path of a file system object relative to the\ncurrent working directory.<\/p>\n<p>Resolves all symbolic links on the path and resolves all <code>..<\/code> and <code>.<\/code> path\nsegments.<\/p>\n<p><a href=\"dart-io\/FileSystemEntity\/resolveSymbolicLinksSync.html\">resolveSymbolicLinksSync<\/a> uses the operating system's native\nfile system API to resolve the path, using the <code>realpath<\/code> function\non linux and OS X, and the <code>GetFinalPathNameByHandle<\/code> function on\nWindows. If the path does not point to an existing file system object,\n<code>resolveSymbolicLinksSync<\/code> throws a <code>FileSystemException<\/code>.<\/p>\n<p>On Windows the <code>..<\/code> segments are resolved <em>before<\/em> resolving the symbolic\nlink, and on other platforms the symbolic links are <em>resolved to their\ntarget<\/em> before applying a <code>..<\/code> that follows.<\/p>\n<p>To ensure the same behavior on all platforms resolve <code>..<\/code> segments before\ncalling <code>resolveSymbolicLinksSync<\/code>. One way of doing this is with the <code>Uri<\/code>\nclass:<\/p>\n<pre class=\"language-dart\"><code>var path = Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();\nif (path == '') path = '.';\nvar resolved = new File(path).resolveSymbolicLinksSync();\nprint(resolved);\n<\/code><\/pre>\n<p>since <code>Uri.resolve<\/code> removes <code>..<\/code> segments. This will result in the Windows\nbehavior.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">String resolveSymbolicLinksSync() {\n  var result = _resolveSymbolicLinks(_Namespace._namespace, _rawPath);\n  _throwIfError(result, \"Cannot resolve symbolic links\", path);\n  return result;\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/resolveSymbolicLinksSync.html",
            "isDeprecated": "0",
            "type": "dart:core.String",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Calls the operating system's stat() function on the <a href=\"dart-io\/FileSystemEntity\/path.html\">path<\/a> of this\n<a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a>.<\/p>\n<p>Identical to <code>FileStat.stat(this.path)<\/code>.<\/p>\n<p>Returns a <code>Future&lt;FileStat&gt;<\/code> object containing the data returned by\nstat().<\/p>\n<p>If the call fails, completes the future with a <a href=\"dart-io\/FileStat-class.html\">FileStat<\/a> object\nwith .type set to\nFileSystemEntityType.notFound and the other fields invalid.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;FileStat&gt; stat() =&gt; FileStat.stat(path);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/stat.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:io.FileStat>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Synchronously calls the operating system's stat() function on the\n<a href=\"dart-io\/FileSystemEntity\/path.html\">path<\/a> of this <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a>.<\/p>\n<p>Identical to <code>FileStat.statSync(this.path)<\/code>.<\/p>\n<p>Returns a <a href=\"dart-io\/FileStat-class.html\">FileStat<\/a> object containing the data returned by stat().<\/p>\n<p>If the call fails, returns a <a href=\"dart-io\/FileStat-class.html\">FileStat<\/a> object with .type set to\nFileSystemEntityType.notFound and the other fields invalid.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">FileStat statSync() =&gt; FileStat.statSync(path);<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/statSync.html",
            "isDeprecated": "0",
            "type": "dart:io.FileStat",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Finds the type of file system object that a path points to.<\/p>\n<p>Returns a <code>Future&lt;FileSystemEntityType&gt;<\/code> that completes with the result.<\/p>\n<p><a href=\"dart-io\/FileSystemEntityType-class.html\">FileSystemEntityType<\/a> has the constant instances file, directory,\nlink, and notFound.  <a href=\"dart-io\/FileSystemEntity\/type.html\">type<\/a> will return link only if the optional\nnamed argument <code>followLinks<\/code> is false, and <code>path<\/code> points to a link.\nIf the path does not point to a file system object, or any other error\noccurs in looking up the path, notFound is returned.  The only\nerror or exception that may be put on the returned future is ArgumentError,\ncaused by passing the wrong type of arguments to the function.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;FileSystemEntityType&gt; type(String path,\n    {bool followLinks: true}) {\n  return _getType(_toUtf8Array(path), followLinks);\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/type.html",
            "isDeprecated": "0",
            "type": "dart:async.Future<dart:io.FileSystemEntityType>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "followLinks",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.bool"
                },
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Synchronously finds the type of file system object that a path points to.<\/p>\n<p>Returns a <a href=\"dart-io\/FileSystemEntityType-class.html\">FileSystemEntityType<\/a>.<\/p>\n<p><a href=\"dart-io\/FileSystemEntityType-class.html\">FileSystemEntityType<\/a> has the constant instances file, directory,\nlink, and notFound.  <a href=\"dart-io\/FileSystemEntity\/type.html\">type<\/a> will return link only if the optional\nnamed argument <code>followLinks<\/code> is false, and <code>path<\/code> points to a link.\nIf the path does not point to a file system object, or any other error\noccurs in looking up the path, notFound is returned.  The only\nerror or exception that may be thrown is ArgumentError,\ncaused by passing the wrong type of arguments to the function.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static FileSystemEntityType typeSync(String path, {bool followLinks: true}) {\n  return _getTypeSync(_toUtf8Array(path), followLinks);\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/typeSync.html",
            "isDeprecated": "0",
            "type": "dart:io.FileSystemEntityType",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "followLinks",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.bool"
                },
                {
                    "name": "path",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.String"
                }
            ]
        },
        {
            "desc": "<p>Start watching the <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> for changes.<\/p>\n<p>The implementation uses platform-dependent event-based APIs for receiving\nfile-system notifications, thus behavior depends on the platform.<\/p>\n<ul>\n<li>\n<code>Windows<\/code>: Uses <code>ReadDirectoryChangesW<\/code>. The implementation only\nsupports watching directories. Recursive watching is supported.<\/li>\n<li>\n<code>Linux<\/code>: Uses <code>inotify<\/code>. The implementation supports watching both\nfiles and directories. Recursive watching is not supported.\nNote: When watching files directly, delete events might not happen\nas expected.<\/li>\n<li>\n<code>OS X<\/code>: Uses <code>FSEvents<\/code>. The implementation supports watching both\nfiles and directories. Recursive watching is supported.<\/li>\n<\/ul>\n<p>The system will start listening for events once the returned <a href=\"dart-async\/Stream-class.html\">Stream<\/a> is\nbeing listened to, not when the call to <a href=\"dart-io\/FileSystemEntity\/watch.html\">watch<\/a> is issued.<\/p>\n<p>The returned value is an endless broadcast <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, that only stops when\none of the following happens:<\/p>\n<ul>\n<li>The <a href=\"dart-async\/Stream-class.html\">Stream<\/a> is canceled, e.g. by calling <code>cancel<\/code> on the\n <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>.<\/li>\n<li>The <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> being watches, is deleted.<\/li>\n<\/ul>\n<p>Use <code>events<\/code> to specify what events to listen for. The constants in\n<a href=\"dart-io\/FileSystemEvent-class.html\">FileSystemEvent<\/a> can be or'ed together to mix events. Default is\n<a class=\"deprecated\" href=\"dart-io\/FileSystemEvent\/ALL-constant.html\">FileSystemEvent.ALL<\/a>.<\/p>\n<p>A move event may be reported as seperate delete and create events.<\/p>\n    ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;FileSystemEvent&gt; watch(\n    {int events: FileSystemEvent.all, bool recursive: false}) {\n  \/\/ FIXME(bkonyi): find a way to do this using the raw path.\n  final String trimmedPath = _trimTrailingPathSeparators(path);\n  final IOOverrides overrides = IOOverrides.current;\n  if (overrides == null) {\n    return _FileSystemWatcher._watch(trimmedPath, events, recursive);\n  }\n  return overrides.fsWatch(trimmedPath, events, recursive);\n}<\/code><\/pre>\n    ",
            "href": "dart-io\/FileSystemEntity\/watch.html",
            "isDeprecated": "0",
            "type": "dart:async.Stream<dart:io.FileSystemEvent>",
            "dtype": "method",
            "isConstructor": false,
            "static": false,
            "memberOf": "dart:io.FileSystemEntity",
            "params": [
                {
                    "name": "events",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.int"
                },
                {
                    "name": "recursive",
                    "desc": null,
                    "example": "",
                    "href": "",
                    "isDeprecated": "0",
                    "isOptional": false,
                    "type": "dart:core.bool"
                }
            ]
        }
    ],
    "props": [
        {
            "desc": "<p>Returns a <a href=\"dart-io\/FileSystemEntity-class.html\">FileSystemEntity<\/a> whose path is the absolute path to <a href=\"dart-io\/FileSystemEntity-class.html\">this<\/a>.<\/p>\n<p>The type of the returned instance is the type of <a href=\"dart-io\/FileSystemEntity-class.html\">this<\/a>.<\/p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">FileSystemEntity get absolute;<\/code><\/pre>\n        ",
            "href": "dart-io\/FileSystemEntity\/absolute.html",
            "isDeprecated": "0",
            "type": "dart:io.FileSystemEntity",
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Returns a <a href=\"dart-core\/bool-class.html\">bool<\/a> indicating whether this object's path is absolute.<\/p>\n<p>On Windows, a path is absolute if it starts with \\\\ or a drive letter\nbetween a and z (upper or lower case) followed by :\\ or :\/.\nOn non-Windows, a path is absolute if it starts with \/.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isAbsolute {\n  if (Platform.isWindows) {\n    return path.startsWith(_absoluteWindowsPathPattern);\n  } else {\n    return path.startsWith('\/');\n  }\n}<\/code><\/pre>\n        ",
            "href": "dart-io\/FileSystemEntity\/isAbsolute.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Test if <a href=\"dart-io\/FileSystemEntity\/watch.html\">watch<\/a> is supported on the current system.<\/p>\n<p>OS X 10.6 and below is not supported.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">static bool get isWatchSupported {\n  final IOOverrides overrides = IOOverrides.current;\n  if (overrides == null) {\n    return _FileSystemWatcher.isSupported;\n  }\n  return overrides.fsWatchIsSupported();\n}<\/code><\/pre>\n        ",
            "href": "dart-io\/FileSystemEntity\/isWatchSupported.html",
            "isDeprecated": "0",
            "type": "dart:core.bool",
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>The directory containing <a href=\"dart-io\/FileSystemEntity-class.html\">this<\/a>.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Directory get parent =&gt; new Directory(parentOf(path));<\/code><\/pre>\n        ",
            "href": "dart-io\/FileSystemEntity\/parent.html",
            "isDeprecated": "0",
            "type": "dart:io.Directory",
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": null,
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get path;<\/code><\/pre>\n        ",
            "href": "dart-io\/FileSystemEntity\/path.html",
            "isDeprecated": "0",
            "type": "dart:core.String",
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        },
        {
            "desc": "<p>Returns a <a href=\"dart-core\/Uri-class.html\">Uri<\/a> representing the file system entity's location.<\/p>\n<p>The returned URI's scheme is always \"file\" if the entity's <a href=\"dart-io\/FileSystemEntity\/path.html\">path<\/a> is\nabsolute, otherwise the scheme will be empty.<\/p>\n        ",
            "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Uri get uri =&gt; new Uri.file(path);<\/code><\/pre>\n        ",
            "href": "dart-io\/FileSystemEntity\/uri.html",
            "isDeprecated": "0",
            "type": "dart:core.Uri",
            "memberOf": "dart:io.FileSystemEntity",
            "params": []
        }
    ]
}