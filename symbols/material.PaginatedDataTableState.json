{
    "name": "material.PaginatedDataTableState",
    "extends": [
        "material.PaginatedDataTable",
        "widgets.State",
        "foundation.Diagnosticable",
        "dart:core.Object"
    ],
    "memberOf": "material",
    "events": [],
    "methods": [
        {
            "name": "PaginatedDataTableState",
            "type": "",
            "desc": "",
            "static": false,
            "memberOf": "material.PaginatedDataTableState",
            "sig": "",
            "params": [],
            "isConstructor": true,
            "href": "material\/PaginatedDataTableState\/PaginatedDataTableState.html",
            "example": "",
            "isDeprecated": false
        },
        {
            "name": "build",
            "type": "widgets.Widget",
            "desc": "<p>Describes the part of the user interface represented by this widget.<\/p>\n<p>The framework calls this method in a number of different situations:<\/p>\n<ul>\n<li>After calling <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>.<\/li>\n<li>After calling <a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a>.<\/li>\n<li>After receiving a call to <a href=\"widgets\/State\/setState.html\">setState<\/a>.<\/li>\n<li>After a dependency of this <a href=\"widgets\/State-class.html\">State<\/a> object changes (e.g., an\n<a href=\"widgets\/InheritedWidget-class.html\">InheritedWidget<\/a> referenced by the previous <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> changes).<\/li>\n<li>After calling <a href=\"widgets\/State\/deactivate.html\">deactivate<\/a> and then reinserting the <a href=\"widgets\/State-class.html\">State<\/a> object into\nthe tree at another location.<\/li>\n<\/ul>\n<p>The framework replaces the subtree below this widget with the widget\nreturned by this method, either by updating the existing subtree or by\nremoving the subtree and inflating a new subtree, depending on whether the\nwidget returned by this method can update the root of the existing\nsubtree, as determined by calling <a href=\"widgets\/Widget\/canUpdate.html\">Widget.canUpdate<\/a>.<\/p>\n<p>Typically implementations return a newly created constellation of widgets\nthat are configured with information from this widget's constructor, the\ngiven <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>, and the internal state of this <a href=\"widgets\/State-class.html\">State<\/a> object.<\/p>\n<p>The given <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> contains information about the location in the\ntree at which this widget is being built. For example, the context\nprovides the set of inherited widgets for this location in the tree. The\n<a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> argument is always the same as the <code>context<\/code> property of\nthis <a href=\"widgets\/State-class.html\">State<\/a> object and will remain the same for the lifetime of this\nobject. The <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a> argument is provided redundantly here so that\nthis method matches the signature for a <a href=\"widgets\/WidgetBuilder.html\">WidgetBuilder<\/a>.<\/p>\n<h2 id=\"design-discussion\">Design discussion<\/h2>\n<h3 id=\"why-is-the-build-method-on-state-and-not-statefulwidget\">Why is the <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> method on <a href=\"widgets\/State-class.html\">State<\/a>, and not <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>?<\/h3>\n<p>Putting a <code>Widget build(BuildContext context)<\/code> method on <a href=\"widgets\/State-class.html\">State<\/a> rather\nputting a <code>Widget build(BuildContext context, State state)<\/code> method on\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> gives developers more flexibility when subclassing\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>.<\/p>\n<p>For example, <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a> is a subclass of <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> that\nintroduces an abstract <code>Widget build(BuildContext context)<\/code> method for its\nsubclasses to implement. If <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> already had a <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> method\nthat took a <a href=\"widgets\/State-class.html\">State<\/a> argument, <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a> would be forced to provide\nits <a href=\"widgets\/State-class.html\">State<\/a> object to subclasses even though its <a href=\"widgets\/State-class.html\">State<\/a> object is an\ninternal implementation detail of <a href=\"widgets\/AnimatedWidget-class.html\">AnimatedWidget<\/a>.<\/p>\n<p>Conceptually, <a href=\"widgets\/StatelessWidget-class.html\">StatelessWidget<\/a> could also be implemented as a subclass of\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> in a similar manner. If the <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> method were on\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> rather than <a href=\"widgets\/State-class.html\">State<\/a>, that would not be possible anymore.<\/p>\n<p>Putting the <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> function on <a href=\"widgets\/State-class.html\">State<\/a> rather than <a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a> also\nhelps avoid a category of bugs related to closures implicitly capturing\n<code>this<\/code>. If you defined a closure in a <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> function on a\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, that closure would implicitly capture <code>this<\/code>, which is\nthe current widget instance, and would have the (immutable) fields of that\ninstance in scope:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class MyButton extends StatefulWidget {\n  ...\n  final Color color;\n\n  @override\n  Widget build(BuildContext context, MyButtonState state) {\n    ... () { print(\"color: $color\"); } ...\n  }\n}\n<\/code><\/pre>\n<p>For example, suppose the parent builds <code>MyButton<\/code> with <code>color<\/code> being blue,\nthe <code>$color<\/code> in the print function refers to blue, as expected. Now,\nsuppose the parent rebuilds <code>MyButton<\/code> with green. The closure created by\nthe first build still implicitly refers to the original widget and the\n<code>$color<\/code> still prints blue even through the widget has been updated to\ngreen.<\/p>\n<p>In contrast, with the <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> function on the <a href=\"widgets\/State-class.html\">State<\/a> object, closures\ncreated during <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> implicitly capture the <a href=\"widgets\/State-class.html\">State<\/a> instance instead of\nthe widget instance:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class MyButtonState extends State&lt;MyButton&gt; {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    ... () { print(\"color: ${widget.color}\"); } ...\n  }\n}\n<\/code><\/pre>\n<p>Now when the parent rebuilds <code>MyButton<\/code> with green, the closure created by\nthe first build still refers to <a href=\"widgets\/State-class.html\">State<\/a> object, which is preserved across\nrebuilds, but the framework has updated that <a href=\"widgets\/State-class.html\">State<\/a> object's <a href=\"widgets\/State\/widget.html\">widget<\/a>\nproperty to refer to the new <code>MyButton<\/code> instance and <code>${widget.color}<\/code>\nprints green, as expected.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/StatefulWidget-class.html\">StatefulWidget<\/a>, which contains the discussion on performance considerations.<\/li><\/ul>",
            "static": false,
            "memberOf": "material.PaginatedDataTableState",
            "sig": "",
            "params": [
                {
                    "name": "context",
                    "type": "widgets.BuildContext",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "material\/PaginatedDataTableState\/build.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nWidget build(BuildContext context) {\n  \/\/ TODO(ianh): This whole build function doesn't handle RTL yet.\n  assert(debugCheckHasMaterialLocalizations(context));\n  final ThemeData themeData = Theme.of(context);\n  final MaterialLocalizations localizations = MaterialLocalizations.of(context);\n  \/\/ HEADER\n  final List&lt;Widget&gt; headerWidgets = &lt;Widget&gt;[];\n  double startPadding = 24.0;\n  if (_selectedRowCount == 0) {\n    headerWidgets.add(Expanded(child: widget.header));\n    if (widget.header is ButtonBar) {\n      \/\/ We adjust the padding when a button bar is present, because the\n      \/\/ ButtonBar introduces 2 pixels of outside padding, plus 2 pixels\n      \/\/ around each button on each side, and the button itself will have 8\n      \/\/ pixels internally on each side, yet we want the left edge of the\n      \/\/ inside of the button to line up with the 24.0 left inset.\n      \/\/ TODO(ianh): Better magic. See https:\/\/github.com\/flutter\/flutter\/issues\/4460\n      startPadding = 12.0;\n    }\n  } else {\n    headerWidgets.add(Expanded(\n      child: Text(localizations.selectedRowCountTitle(_selectedRowCount)),\n    ));\n  }\n  if (widget.actions != null) {\n    headerWidgets.addAll(\n      widget.actions.map&lt;Widget&gt;((Widget action) {\n        return Padding(\n          \/\/ 8.0 is the default padding of an icon button\n          padding: const EdgeInsetsDirectional.only(start: 24.0 - 8.0 * 2.0),\n          child: action,\n        );\n      }).toList()\n    );\n  }\n\n  \/\/ FOOTER\n  final TextStyle footerTextStyle = themeData.textTheme.caption;\n  final List&lt;Widget&gt; footerWidgets = &lt;Widget&gt;[];\n  if (widget.onRowsPerPageChanged != null) {\n    final List&lt;Widget&gt; availableRowsPerPage = widget.availableRowsPerPage\n      .where((int value) =&gt; value &lt;= _rowCount || value == widget.rowsPerPage)\n      .map&lt;DropdownMenuItem&lt;int&gt;&gt;((int value) {\n        return DropdownMenuItem&lt;int&gt;(\n          value: value,\n          child: Text('$value'),\n        );\n      })\n      .toList();\n    footerWidgets.addAll(&lt;Widget&gt;[\n      Container(width: 14.0), \/\/ to match trailing padding in case we overflow and end up scrolling\n      Text(localizations.rowsPerPageTitle),\n      ConstrainedBox(\n        constraints: const BoxConstraints(minWidth: 64.0), \/\/ 40.0 for the text, 24.0 for the icon\n        child: Align(\n          alignment: AlignmentDirectional.centerEnd,\n          child: DropdownButtonHideUnderline(\n            child: DropdownButton&lt;int&gt;(\n              items: availableRowsPerPage,\n              value: widget.rowsPerPage,\n              onChanged: widget.onRowsPerPageChanged,\n              style: footerTextStyle,\n              iconSize: 24.0,\n            ),\n          ),\n        ),\n      ),\n    ]);\n  }\n  footerWidgets.addAll(&lt;Widget&gt;[\n    Container(width: 32.0),\n    Text(\n      localizations.pageRowsInfoTitle(\n        _firstRowIndex + 1,\n        _firstRowIndex + widget.rowsPerPage,\n        _rowCount,\n        _rowCountApproximate,\n      )\n    ),\n    Container(width: 32.0),\n    IconButton(\n      icon: const Icon(Icons.chevron_left),\n      padding: EdgeInsets.zero,\n      tooltip: localizations.previousPageTooltip,\n      onPressed: _firstRowIndex &lt;= 0 ? null : _handlePrevious,\n    ),\n    Container(width: 24.0),\n    IconButton(\n      icon: const Icon(Icons.chevron_right),\n      padding: EdgeInsets.zero,\n      tooltip: localizations.nextPageTooltip,\n      onPressed: (!_rowCountApproximate &amp;&amp; (_firstRowIndex + widget.rowsPerPage &gt;= _rowCount)) ? null : _handleNext,\n    ),\n    Container(width: 14.0),\n  ]);\n\n  \/\/ CARD\n  return Card(\n    semanticContainer: false,\n    child: Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: &lt;Widget&gt;[\n        Semantics(\n          container: true,\n          child: DefaultTextStyle(\n            \/\/ These typographic styles aren't quite the regular ones. We pick the closest ones from the regular\n            \/\/ list and then tweak them appropriately.\n            \/\/ See https:\/\/material.io\/design\/components\/data-tables.html#tables-within-cards\n            style: _selectedRowCount &gt; 0 ? themeData.textTheme.subhead.copyWith(color: themeData.accentColor)\n                                         : themeData.textTheme.title.copyWith(fontWeight: FontWeight.w400),\n            child: IconTheme.merge(\n              data: const IconThemeData(\n                opacity: 0.54\n              ),\n              child: ButtonTheme.bar(\n                child: Ink(\n                  height: 64.0,\n                  color: _selectedRowCount &gt; 0 ? themeData.secondaryHeaderColor : null,\n                  child: Padding(\n                    padding: EdgeInsetsDirectional.only(start: startPadding, end: 14.0),\n                    child: Row(\n                      mainAxisAlignment: MainAxisAlignment.end,\n                      children: headerWidgets,\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n        SingleChildScrollView(\n          scrollDirection: Axis.horizontal,\n          dragStartBehavior: widget.dragStartBehavior,\n          child: DataTable(\n            key: _tableKey,\n            columns: widget.columns,\n            sortColumnIndex: widget.sortColumnIndex,\n            sortAscending: widget.sortAscending,\n            onSelectAll: widget.onSelectAll,\n            rows: _getRows(_firstRowIndex, widget.rowsPerPage),\n          ),\n        ),\n        DefaultTextStyle(\n          style: footerTextStyle,\n          child: IconTheme.merge(\n            data: const IconThemeData(\n              opacity: 0.54\n            ),\n            child: Container(\n              height: 56.0,\n              child: SingleChildScrollView(\n                dragStartBehavior: widget.dragStartBehavior,\n                scrollDirection: Axis.horizontal,\n                reverse: true,\n                child: Row(\n                  children: footerWidgets,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ],\n    ),\n  );\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "didUpdateWidget",
            "type": "",
            "desc": "<p>Called whenever the widget configuration changes.<\/p>\n<p>If the parent widget rebuilds and request that this location in the tree\nupdate to display a new widget with the same <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and\n<a href=\"widgets\/Widget\/key.html\">Widget.key<\/a>, the framework will update the <a href=\"widgets\/State\/widget.html\">widget<\/a> property of this\n<a href=\"widgets\/State-class.html\">State<\/a> object to refer to the new widget and then call this method\nwith the previous widget as an argument.<\/p>\n<p>Override this method to respond when the <a href=\"widgets\/State\/widget.html\">widget<\/a> changes (e.g., to start\nimplicit animations).<\/p>\n<p>The framework always calls <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> after calling <a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a>, which\nmeans any calls to <a href=\"widgets\/State\/setState.html\">setState<\/a> in <a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a> are redundant.<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>,\n<a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>, unsubscribe from the object.<\/li>\n<\/ul>\n<p>If you override this, make sure your method starts with a call to\nsuper.didUpdateWidget(oldWidget).<\/p>\n    ",
            "static": false,
            "memberOf": "material.PaginatedDataTableState",
            "sig": "",
            "params": [
                {
                    "name": "oldWidget",
                    "type": "material.PaginatedDataTable",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "material\/PaginatedDataTableState\/didUpdateWidget.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid didUpdateWidget(PaginatedDataTable oldWidget) {\n  super.didUpdateWidget(oldWidget);\n  if (oldWidget.source != widget.source) {\n    oldWidget.source.removeListener(_handleDataSourceChanged);\n    widget.source.addListener(_handleDataSourceChanged);\n    _handleDataSourceChanged();\n  }\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "dispose",
            "type": "",
            "desc": "<p>Called when this object is removed from the tree permanently.<\/p>\n<p>The framework calls this method when this <a href=\"widgets\/State-class.html\">State<\/a> object will never\nbuild again. After the framework calls <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>, the <a href=\"widgets\/State-class.html\">State<\/a> object is\nconsidered unmounted and the <a href=\"widgets\/State\/mounted.html\">mounted<\/a> property is false. It is an error\nto call <a href=\"widgets\/State\/setState.html\">setState<\/a> at this point. This stage of the lifecycle is terminal:\nthere is no way to remount a <a href=\"widgets\/State-class.html\">State<\/a> object that has been disposed.<\/p>\n<p>Subclasses should override this method to release any resources retained\nby this object (e.g., stop any active animations).<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>,\n<a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>, unsubscribe from the object.<\/li>\n<\/ul>\n<p>If you override this, make sure to end your method with a call to\nsuper.dispose().<\/p>\n<p>See also <a href=\"widgets\/State\/deactivate.html\">deactivate<\/a>, which is called prior to <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "material.PaginatedDataTableState",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "material\/PaginatedDataTableState\/dispose.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid dispose() {\n  widget.source.removeListener(_handleDataSourceChanged);\n  super.dispose();\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "initState",
            "type": "",
            "desc": "<p>Called when this object is inserted into the tree.<\/p>\n<p>The framework will call this method exactly once for each <a href=\"widgets\/State-class.html\">State<\/a> object\nit creates.<\/p>\n<p>Override this method to perform initialization that depends on the\nlocation at which this object was inserted into the tree (i.e., <a href=\"widgets\/State\/context.html\">context<\/a>)\nor on the widget used to configure this object (i.e., <a href=\"widgets\/State\/widget.html\">widget<\/a>).<\/p>\n<p>If a <a href=\"widgets\/State-class.html\">State<\/a>'s <a href=\"material\/PaginatedDataTableState\/build.html\">build<\/a> method depends on an object that can itself\nchange state, for example a <a href=\"foundation\/ChangeNotifier-class.html\">ChangeNotifier<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, or some\nother object to which one can subscribe to receive notifications, then\nbe sure to subscribe and unsubscribe properly in <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>,\n<a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a>, and <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>:<\/p>\n<ul>\n<li>In <a href=\"material\/PaginatedDataTableState\/initState.html\">initState<\/a>, subscribe to the object.<\/li>\n<li>In <a href=\"material\/PaginatedDataTableState\/didUpdateWidget.html\">didUpdateWidget<\/a> unsubscribe from the old object and subscribe\nto the new one if the updated widget configuration requires\nreplacing the object.<\/li>\n<li>In <a href=\"material\/PaginatedDataTableState\/dispose.html\">dispose<\/a>, unsubscribe from the object.\nYou cannot use <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> from this\nmethod. However, <a href=\"widgets\/State\/didChangeDependencies.html\">didChangeDependencies<\/a> will be called immediately\nfollowing this method, and <a href=\"widgets\/BuildContext\/inheritFromWidgetOfExactType.html\">BuildContext.inheritFromWidgetOfExactType<\/a> can\nbe used there.<\/li>\n<\/ul>\n<p>If you override this, make sure your method starts with a call to\nsuper.initState().<\/p>\n    ",
            "static": false,
            "memberOf": "material.PaginatedDataTableState",
            "sig": "",
            "params": [],
            "isConstructor": false,
            "href": "material\/PaginatedDataTableState\/initState.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid initState() {\n  super.initState();\n  _firstRowIndex = PageStorage.of(context)?.readState(context) ?? widget.initialFirstRowIndex ?? 0;\n  widget.source.addListener(_handleDataSourceChanged);\n  _handleDataSourceChanged();\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        },
        {
            "name": "pageTo",
            "type": "",
            "desc": "<p>Ensures that the given row is visible.<\/p>\n    ",
            "static": false,
            "memberOf": "material.PaginatedDataTableState",
            "sig": "",
            "params": [
                {
                    "name": "rowIndex",
                    "type": "dart:core.int",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "material\/PaginatedDataTableState\/pageTo.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void pageTo(int rowIndex) {\n  final int oldFirstRowIndex = _firstRowIndex;\n  setState(() {\n    final int rowsPerPage = widget.rowsPerPage;\n    _firstRowIndex = (rowIndex ~\/ rowsPerPage) * rowsPerPage;\n  });\n  if ((widget.onPageChanged != null) &amp;&amp;\n      (oldFirstRowIndex != _firstRowIndex))\n    widget.onPageChanged(_firstRowIndex);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": []
        }
    ],
    "props": [],
    "isMixin": false,
    "isEnum": false,
    "isTypedef": false,
    "isConstant": false,
    "isAbstract": false,
    "implementors": [],
    "realImplementors": [],
    "cn": [],
    "href": "material\/PaginatedDataTableState-class.html",
    "desc": "<p>Holds the state of a <a href=\"material\/PaginatedDataTable-class.html\">PaginatedDataTable<\/a>.<\/p>\n<p>The table can be programmatically paged using the <a href=\"material\/PaginatedDataTableState\/pageTo.html\">pageTo<\/a> method.<\/p>\n    ",
    "example": "",
    "isDeprecated": false,
    "dtype": "class",
    "shortname": "PaginatedDataTableState"
}