{
    "name": "stream_channel",
    "href": "package-stream_channel_stream_channel\/package-stream_channel_stream_channel-library.html",
    "cn": [
        {
            "name": "stream_channel.DelegatingStreamChannel",
            "extends": [
                "stream_channel.StreamChannelMixin",
                "dart:core.Object"
            ],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingStreamChannel",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "stream_channel.DelegatingStreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "_inner",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/DelegatingStreamChannel\/DelegatingStreamChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingStreamChannel(this._inner);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "sink",
                    "type": "dart:async.StreamSink",
                    "types": [],
                    "desc": "<p>The sink for sending values to the other endpoint.<\/p>\n        ",
                    "memberOf": "stream_channel.DelegatingStreamChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/DelegatingStreamChannel\/sink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;T&gt; get sink =&gt; _inner.sink;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The single-subscription stream that emits values from the other endpoint.<\/p>\n        ",
                    "memberOf": "stream_channel.DelegatingStreamChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/DelegatingStreamChannel\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream =&gt; _inner.stream;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/DelegatingStreamChannel-class.html",
            "desc": "<p>A simple delegating wrapper around <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a>.<\/p>\n<p>Subclasses can override individual methods, or use this to expose only\n<a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> methods.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingStreamChannel"
        },
        {
            "name": "stream_channel.Disconnector",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "Disconnector",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "stream_channel.Disconnector",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/Disconnector\/Disconnector.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "bind",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms the events sent to and emitted by <code>channel<\/code>.<\/p>\n<p>Creates a new channel. When events are passed to the returned channel's\nsink, the transformer will transform them and pass the transformed\nversions to <code>channel.sink<\/code>. When events are emitted from the\n<code>channel.straem<\/code>, the transformer will transform them and pass the\ntransformed versions to the returned channel's stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.Disconnector",
                    "sig": "",
                    "params": [
                        {
                            "name": "channel",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/Disconnector\/bind.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; bind(StreamChannel&lt;T&gt; channel) {\n  return channel.changeSink((innerSink) {\n    var sink = new _DisconnectorSink&lt;T&gt;(innerSink);\n\n    if (isDisconnected) {\n      \/\/ Ignore errors here, because otherwise there would be no way for the\n      \/\/ user to handle them gracefully.\n      sink._disconnect().catchError((_) {});\n    } else {\n      _sinks.add(sink);\n    }\n\n    return sink;\n  });\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "disconnect",
                    "type": "dart:async.Future",
                    "desc": "<p>Disconnects all channels that have been transformed.<\/p>\n<p>Returns a future that completes when all inner sinks' <a href=\"dart-async\/StreamSink\/close.html\">StreamSink.close<\/a>\nfutures have completed. Note that a <a href=\"dart-async\/StreamController-class.html\">StreamController<\/a>'s sink won't close\nuntil the corresponding stream has a listener.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.Disconnector",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/Disconnector\/disconnect.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future disconnect() =&gt; _disconnectMemo.runOnce(() {\n      var futures = _sinks.map((sink) =&gt; sink._disconnect()).toList();\n      _sinks.clear();\n      return Future.wait(futures, eagerError: true);\n    });<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "isDisconnected",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether <a href=\"package-stream_channel_stream_channel\/Disconnector\/disconnect.html\">disconnect<\/a> has been called.<\/p>\n        ",
                    "memberOf": "stream_channel.Disconnector",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/Disconnector\/isDisconnected.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isDisconnected =&gt; _disconnectMemo.hasRun;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/Disconnector-class.html",
            "desc": "<p>Allows the caller to force a channel to disconnect.<\/p>\n<p>When <a href=\"package-stream_channel_stream_channel\/Disconnector\/disconnect.html\">disconnect<\/a> is called, the channel (or channels) transformed by this\ntransformer will act as though the remote end had disconnected\u2014the stream\nwill emit a done event, and the sink will ignore future inputs. The inner\nsink will also be closed to notify the remote end of the disconnection.<\/p>\n<p>If a channel is transformed after the <a href=\"package-stream_channel_stream_channel\/Disconnector\/disconnect.html\">disconnect<\/a> has been called, it will\nbe disconnected immediately.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "Disconnector"
        },
        {
            "name": "stream_channel.IsolateChannel",
            "extends": [
                "stream_channel.StreamChannelMixin",
                "dart:core.Object"
            ],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "IsolateChannel",
                    "type": "",
                    "desc": "<p>Creates a stream channel that receives messages from <code>receivePort<\/code> and\nsends them over <code>sendPort<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.IsolateChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "receivePort",
                            "type": "dart:isolate.ReceivePort",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sendPort",
                            "type": "dart:isolate.SendPort",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/IsolateChannel\/IsolateChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory IsolateChannel(ReceivePort receivePort, SendPort sendPort) {\n  var controller =\n      new StreamChannelController&lt;T&gt;(allowForeignErrors: false, sync: true);\n  receivePort.cast&lt;T&gt;().pipe(controller.local.sink);\n  controller.local.stream\n      .listen((data) =&gt; sendPort.send(data), onDone: receivePort.close);\n  return new IsolateChannel._(\n      controller.foreign.stream, controller.foreign.sink);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "IsolateChannel.connectReceive",
                    "type": "",
                    "desc": "<p>Connects to a remote channel that was created with\n<a href=\"package-stream_channel_stream_channel\/IsolateChannel\/IsolateChannel.connectSend.html\">IsolateChannel.connectSend<\/a>.<\/p>\n<p>These constructors establish a connection using only a single\n<a href=\"dart-isolate\/SendPort-class.html\">SendPort<\/a>\/<a href=\"dart-isolate\/ReceivePort-class.html\">ReceivePort<\/a> pair, as long as each side uses one of the\nconnect constructors.<\/p>\n<p>The connection protocol is guaranteed to remain compatible across versions\nat least until the next major version release. If the protocol is\nviolated, the resulting channel will emit a single value on its stream and\nthen close.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.IsolateChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "receivePort",
                            "type": "dart:isolate.ReceivePort",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/IsolateChannel\/IsolateChannel.connectReceive.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory IsolateChannel.connectReceive(ReceivePort receivePort) {\n  \/\/ We can't use a [StreamChannelCompleter] here because we need the return\n  \/\/ value to be an [IsolateChannel].\n  var streamCompleter = new StreamCompleter&lt;T&gt;();\n  var sinkCompleter = new StreamSinkCompleter&lt;T&gt;();\n  var channel =\n      new IsolateChannel&lt;T&gt;._(streamCompleter.stream, sinkCompleter.sink);\n\n  \/\/ The first message across the ReceivePort should be a SendPort pointing to\n  \/\/ the remote end. If it's not, we'll make the stream emit an error\n  \/\/ complaining.\n  StreamSubscription&lt;dynamic&gt; subscription;\n  subscription = receivePort.listen((message) {\n    if (message is SendPort) {\n      var controller = new StreamChannelController&lt;T&gt;(\n          allowForeignErrors: false, sync: true);\n      new SubscriptionStream(subscription)\n          .cast&lt;T&gt;()\n          .pipe(controller.local.sink);\n      controller.local.stream\n          .listen((data) =&gt; message.send(data), onDone: receivePort.close);\n\n      streamCompleter.setSourceStream(controller.foreign.stream);\n      sinkCompleter.setDestinationSink(controller.foreign.sink);\n      return;\n    }\n\n    streamCompleter.setError(\n        new StateError('Unexpected Isolate response \"$message\".'),\n        StackTrace.current);\n    sinkCompleter.setDestinationSink(new NullStreamSink&lt;T&gt;());\n    subscription.cancel();\n  });\n\n  return channel;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "IsolateChannel.connectSend",
                    "type": "",
                    "desc": "<p>Connects to a remote channel that was created with\n<a href=\"package-stream_channel_stream_channel\/IsolateChannel\/IsolateChannel.connectReceive.html\">IsolateChannel.connectReceive<\/a>.<\/p>\n<p>These constructors establish a connection using only a single\n<a href=\"dart-isolate\/SendPort-class.html\">SendPort<\/a>\/<a href=\"dart-isolate\/ReceivePort-class.html\">ReceivePort<\/a> pair, as long as each side uses one of the\nconnect constructors.<\/p>\n<p>The connection protocol is guaranteed to remain compatible across versions\nat least until the next major version release.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.IsolateChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "sendPort",
                            "type": "dart:isolate.SendPort",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/IsolateChannel\/IsolateChannel.connectSend.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory IsolateChannel.connectSend(SendPort sendPort) {\n  var receivePort = new ReceivePort();\n  sendPort.send(receivePort.sendPort);\n  return new IsolateChannel(receivePort, sendPort);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "sink",
                    "type": "dart:async.StreamSink",
                    "types": [],
                    "desc": "<p>The sink for sending values to the other endpoint.<\/p>\n        ",
                    "memberOf": "stream_channel.IsolateChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/IsolateChannel\/sink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final StreamSink&lt;T&gt; sink\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The single-subscription stream that emits values from the other endpoint.<\/p>\n        ",
                    "memberOf": "stream_channel.IsolateChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/IsolateChannel\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Stream&lt;T&gt; stream\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/IsolateChannel-class.html",
            "desc": "<p>A <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> that communicates over a <a href=\"dart-isolate\/ReceivePort-class.html\">ReceivePort<\/a>\/<a href=\"dart-isolate\/SendPort-class.html\">SendPort<\/a> pair,\npresumably with another isolate.<\/p>\n<p>The remote endpoint doesn't necessarily need to be running an\n<a href=\"package-stream_channel_stream_channel\/IsolateChannel-class.html\">IsolateChannel<\/a>. This can be used with any two ports, although the\n<a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> semantics mean that this class will treat them as being\npaired (for example, closing the <a href=\"package-stream_channel_stream_channel\/IsolateChannel\/sink.html\">sink<\/a> will cause the <a href=\"package-stream_channel_stream_channel\/IsolateChannel\/stream.html\">stream<\/a> to stop\nemitting events).<\/p>\n<p>The underlying isolate ports have no notion of closing connections. This\nmeans that <a href=\"package-stream_channel_stream_channel\/IsolateChannel\/stream.html\">stream<\/a> won't close unless <a href=\"package-stream_channel_stream_channel\/IsolateChannel\/sink.html\">sink<\/a> is closed, and that closing\n<a href=\"package-stream_channel_stream_channel\/IsolateChannel\/sink.html\">sink<\/a> won't cause the remote endpoint to close. Users should take care to\nensure that they always close the <a href=\"package-stream_channel_stream_channel\/IsolateChannel\/sink.html\">sink<\/a> of every <a href=\"package-stream_channel_stream_channel\/IsolateChannel-class.html\">IsolateChannel<\/a> they use\nto avoid leaving dangling <a href=\"dart-isolate\/ReceivePort-class.html\">ReceivePort<\/a>s.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "IsolateChannel"
        },
        {
            "name": "stream_channel.JsonDocumentTransformer",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "JsonDocumentTransformer",
                    "type": "",
                    "desc": "<p>Creates a new transformer.<\/p>\n<p>The <code>reviver<\/code> and <code>toEncodable<\/code> arguments work the same way as the\ncorresponding arguments to <a href=\"dart-convert\/JsonCodec\/JsonCodec.html\">new JsonCodec<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.JsonDocumentTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "key",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "object",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "object",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/JsonDocumentTransformer\/JsonDocumentTransformer.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">JsonDocumentTransformer({reviver(key, value), toEncodable(object)})\n    : _codec = new JsonCodec(reviver: reviver, toEncodable: toEncodable);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "bind",
                    "type": "stream_channel.StreamChannel<dart:core.Object>",
                    "desc": "<p>Transforms the events sent to and emitted by <code>channel<\/code>.<\/p>\n<p>Creates a new channel. When events are passed to the returned channel's\nsink, the transformer will transform them and pass the transformed\nversions to <code>channel.sink<\/code>. When events are emitted from the\n<code>channel.straem<\/code>, the transformer will transform them and pass the\ntransformed versions to the returned channel's stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.JsonDocumentTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "channel",
                            "type": "stream_channel.StreamChannel<dart:core.String>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "stream_channel.StreamChannel",
                                "dart:core.String"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/JsonDocumentTransformer\/bind.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;Object&gt; bind(StreamChannel&lt;String&gt; channel) {\n  var stream = channel.stream.map(_codec.decode);\n  var sink = new StreamSinkTransformer&lt;Object, String&gt;.fromHandlers(\n      handleData: (data, sink) {\n    sink.add(_codec.encode(data));\n  }).bind(channel.sink);\n  return new StreamChannel.withCloseGuarantee(stream, sink);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "stream_channel.StreamChannel",
                        "dart:core.Object"
                    ]
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/JsonDocumentTransformer-class.html",
            "desc": "<p>A <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer-class.html\">StreamChannelTransformer<\/a> that transforms JSON documents\u2014strings that\ncontain individual objects encoded as JSON\u2014into decoded Dart objects.<\/p>\n<p>This decodes JSON that's emitted by the transformed channel's stream, and\nencodes objects so that JSON is passed to the transformed channel's sink.<\/p>\n<p>If the transformed channel emits invalid JSON, this emits a\n<a href=\"dart-core\/FormatException-class.html\">FormatException<\/a>. If an unencodable object is added to the sink, it\nsynchronously throws a <a href=\"dart-convert\/JsonUnsupportedObjectError-class.html\">JsonUnsupportedObjectError<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "JsonDocumentTransformer"
        },
        {
            "name": "stream_channel.MultiChannel",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "MultiChannel",
                    "type": "",
                    "desc": "<p>Creates a new <a href=\"package-stream_channel_stream_channel\/MultiChannel-class.html\">MultiChannel<\/a> that sends and receives messages over\n<code>inner<\/code>.<\/p>\n<p>The inner channel must take JSON-like objects.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.MultiChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "inner",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/MultiChannel\/MultiChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory MultiChannel(StreamChannel&lt;dynamic&gt; inner) =&gt;\n    new _MultiChannel&lt;T&gt;(inner);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "virtualChannel",
                    "type": "stream_channel.VirtualChannel",
                    "desc": "<p>Creates a new virtual channel.<\/p>\n<p>If <code>id<\/code> is not passed, this creates a virtual channel from scratch. Before\nit's used, its <a href=\"package-stream_channel_stream_channel\/VirtualChannel\/id.html\">VirtualChannel.id<\/a> must be sent to the remote endpoint\nwhere <a href=\"package-stream_channel_stream_channel\/MultiChannel\/virtualChannel.html\">virtualChannel<\/a> should be called with that id.<\/p>\n<p>If <code>id<\/code> is passed, this creates a virtual channel corresponding to the\nchannel with that id on the remote channel.<\/p>\n<p>Throws an <a href=\"dart-core\/ArgumentError-class.html\">ArgumentError<\/a> if a virtual channel already exists for <code>id<\/code>.\nThrows a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if the underlying channel is closed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.MultiChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "id",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/MultiChannel\/virtualChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">VirtualChannel&lt;T&gt; virtualChannel([int id]);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "sink",
                    "type": "dart:async.StreamSink",
                    "types": [],
                    "desc": "<p>The default output stream.<\/p>\n<p>This connects to the remote <a href=\"package-stream_channel_stream_channel\/MultiChannel\/stream.html\">stream<\/a>. If this is closed, the remote\n<a href=\"package-stream_channel_stream_channel\/MultiChannel\/stream.html\">stream<\/a> will close, but other virtual channels will remain open and new\nvirtual channels may be opened.<\/p>\n        ",
                    "memberOf": "stream_channel.MultiChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/MultiChannel\/sink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;T&gt; get sink;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The default input stream.<\/p>\n<p>This connects to the remote <a href=\"package-stream_channel_stream_channel\/MultiChannel\/sink.html\">sink<\/a>.<\/p>\n        ",
                    "memberOf": "stream_channel.MultiChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/MultiChannel\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/MultiChannel-class.html",
            "desc": "<p>A class that multiplexes multiple virtual channels across a single\nunderlying transport layer.<\/p>\n<p>This should be connected to another <a href=\"package-stream_channel_stream_channel\/MultiChannel-class.html\">MultiChannel<\/a> on the other end of the\nunderlying channel. It starts with a single default virtual channel,\naccessible via <a href=\"package-stream_channel_stream_channel\/MultiChannel\/stream.html\">stream<\/a> and <a href=\"package-stream_channel_stream_channel\/MultiChannel\/sink.html\">sink<\/a>. Additional virtual channels can be\ncreated with <a href=\"package-stream_channel_stream_channel\/MultiChannel\/virtualChannel.html\">virtualChannel<\/a>.<\/p>\n<p>When a virtual channel is created by one endpoint, the other must connect to\nit before messages may be sent through it. The first endpoint passes its\n<a href=\"package-stream_channel_stream_channel\/VirtualChannel\/id.html\">VirtualChannel.id<\/a> to the second, which then creates a channel from that id\nalso using <a href=\"package-stream_channel_stream_channel\/MultiChannel\/virtualChannel.html\">virtualChannel<\/a>. For example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">\/\/ First endpoint\nvar virtual = multiChannel.virtualChannel();\nmultiChannel.sink.add({\n  \"channel\": virtual.id\n});\n\n\/\/ Second endpoint\nmultiChannel.stream.listen((message) {\n  var virtual = multiChannel.virtualChannel(message[\"channel\"]);\n  \/\/ ...\n});\n<\/code><\/pre>\n<p>Sending errors across a <a href=\"package-stream_channel_stream_channel\/MultiChannel-class.html\">MultiChannel<\/a> is not supported. Any errors from the\nunderlying stream will be reported only via the default\n<a href=\"package-stream_channel_stream_channel\/MultiChannel\/stream.html\">MultiChannel.stream<\/a>.<\/p>\n<p>Each virtual channel may be closed individually. When all of them are\nclosed, the underlying <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> is closed automatically.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "MultiChannel"
        },
        {
            "name": "stream_channel.StreamChannel",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "StreamChannel",
                    "type": "",
                    "desc": "<p>Creates a new <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> that communicates over <code>stream<\/code> and <code>sink<\/code>.<\/p>\n<p>Note that this stream\/sink pair must provide the guarantees listed in the\n<a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> documentation. If they don't do so natively,\n<a href=\"package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.withGuarantees.html\">StreamChannel.withGuarantees<\/a> should be used instead.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamChannel(Stream&lt;T&gt; stream, StreamSink&lt;T&gt; sink) =&gt;\n    new _StreamChannel&lt;T&gt;(stream, sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "cast",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Returns a copy of this with the generic type coerced to <code>S<\/code>.<\/p>\n<p>If any events emitted by <a href=\"package-stream_channel_stream_channel\/StreamChannel\/stream.html\">stream<\/a> aren't of type <code>S<\/code>, they're converted\ninto <a href=\"dart-core\/CastError-class.html\">CastError<\/a> events. Similarly, if any events are added to <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a> that\naren't of type <code>S<\/code>, a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> is thrown.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/cast.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;S&gt; cast&lt;S&gt;();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "changeSink",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Returns a copy of this with <code>sink<\/code> replaced by <code>change<\/code>'s return\nvalue.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/changeSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; changeSink(StreamSink&lt;T&gt; change(StreamSink&lt;T&gt; sink));<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "changeStream",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Returns a copy of this with <code>stream<\/code> replaced by <code>change<\/code>'s return\nvalue.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/changeStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; changeStream(Stream&lt;T&gt; change(Stream&lt;T&gt; stream));<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "pipe",
                    "type": "",
                    "desc": "<p>Connects this to <code>other<\/code>, so that any values emitted by either are sent\ndirectly to the other.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "other",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/pipe.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void pipe(StreamChannel&lt;T&gt; other);<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "transform",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms this using <code>transformer<\/code>.<\/p>\n<p>This is identical to calling <code>transformer.bind(channel)<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "stream_channel.StreamChannelTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/transform.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;S&gt; transform&lt;S&gt;(StreamChannelTransformer&lt;S, T&gt; transformer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "transformSink",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms only the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a> component of this using <code>transformer<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "async.StreamSinkTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/transformSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; transformSink(StreamSinkTransformer&lt;T, T&gt; transformer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "transformStream",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms only the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/stream.html\">stream<\/a> component of this using <code>transformer<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "dart:async.StreamTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/transformStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; transformStream(StreamTransformer&lt;T, T&gt; transformer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "StreamChannel.withCloseGuarantee",
                    "type": "",
                    "desc": "<p>Creates a new <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> that communicates over <code>stream<\/code> and <code>sink<\/code>.<\/p>\n<p>This specifically enforces the second guarantee: closing the sink causes\nthe stream to close before it emits any more events. This guarantee is\ninvalidated when an asynchronous gap is added between the original\nstream's event dispatch and the returned stream's, for example by\ntransforming it with a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a>. This is a lighter-weight way\nof preserving that guarantee in particular than\n<a href=\"package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.withGuarantees.html\">StreamChannel.withGuarantees<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.withCloseGuarantee.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamChannel.withCloseGuarantee(\n        Stream&lt;T&gt; stream, StreamSink&lt;T&gt; sink) =&gt;\n    new CloseGuaranteeChannel(stream, sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "StreamChannel.withGuarantees",
                    "type": "",
                    "desc": "<p>Creates a new <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> that communicates over <code>stream<\/code> and <code>sink<\/code>.<\/p>\n<p>Unlike <a href=\"package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.html\">new StreamChannel<\/a>, this enforces the guarantees listed in the\n<a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> documentation. This makes it somewhat less efficient than\njust wrapping a stream and a sink directly, so <a href=\"package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.html\">new StreamChannel<\/a> should\nbe used when the guarantees are provided natively.<\/p>\n<p>If <code>allowSinkErrors<\/code> is <code>false<\/code>, errors are not allowed to be passed to\n<code>sink<\/code>. If any are, the connection will close and the error will be\nforwarded to <code>sink<\/code>.done.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "allowSinkErrors",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.withGuarantees.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamChannel.withGuarantees(Stream&lt;T&gt; stream, StreamSink&lt;T&gt; sink,\n        {bool allowSinkErrors: true}) =&gt;\n    new GuaranteeChannel(stream, sink, allowSinkErrors: allowSinkErrors);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "sink",
                    "type": "dart:async.StreamSink",
                    "types": [],
                    "desc": "<p>The sink for sending values to the other endpoint.<\/p>\n        ",
                    "memberOf": "stream_channel.StreamChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/sink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;T&gt; get sink;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The single-subscription stream that emits values from the other endpoint.<\/p>\n        ",
                    "memberOf": "stream_channel.StreamChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannel\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/StreamChannel-class.html",
            "desc": "<p>An abstract class representing a two-way communication channel.<\/p>\n<p>Users should consider the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/stream.html\">stream<\/a> emitting a \"done\" event to be the\ncanonical indicator that the channel has closed. If they wish to close the\nchannel, they should close the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a>\u2014canceling the stream subscription is\nnot sufficient. Protocol errors may be emitted through the stream or through\n<a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a>.done, depending on their underlying cause. Note that the sink may\nsilently drop events if the channel closes before <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a>.close is called.<\/p>\n<p>Implementations are strongly encouraged to mix in or extend\n<a href=\"package-stream_channel_stream_channel\/StreamChannelMixin-class.html\">StreamChannelMixin<\/a> to get default implementations of the various instance\nmethods. Adding new methods to this interface will not be considered a\nbreaking change if implementations are also added to <a href=\"package-stream_channel_stream_channel\/StreamChannelMixin-class.html\">StreamChannelMixin<\/a>.<\/p>\n<p>Implementations must provide the following guarantees:<\/p>\n<ul>\n<li>\n<p>The stream is single-subscription, and must follow all the guarantees of\nsingle-subscription streams.<\/p>\n<\/li>\n<li>\n<p>Closing the sink causes the stream to close before it emits any more\nevents.<\/p>\n<\/li>\n<li>\n<p>After the stream closes, the sink is automatically closed. If this\nhappens, sink methods should silently drop their arguments until\n<a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a>.close is called.<\/p>\n<\/li>\n<li>\n<p>If the stream closes before it has a listener, the sink should silently\ndrop events if possible.<\/p>\n<\/li>\n<li>\n<p>Canceling the stream's subscription has no effect on the sink. The channel\nmust still be able to respond to the other endpoint closing the channel\neven after the subscription has been canceled.<\/p>\n<\/li>\n<li>\n<p>The sink <em>either<\/em> forwards errors to the other endpoint <em>or<\/em> closes as\nsoon as an error is added and forwards that error to the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a>.done\nfuture.<\/p>\n<\/li>\n<\/ul>\n<p>These guarantees allow users to interact uniformly with all implementations,\nand ensure that either endpoint closing the stream produces consistent\nbehavior.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamChannel"
        },
        {
            "name": "stream_channel.StreamChannelCompleter",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "StreamChannelCompleter",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelCompleter",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannelCompleter\/StreamChannelCompleter.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannelCompleter() {\n  _channel =\n      new StreamChannel&lt;T&gt;(_streamCompleter.stream, _sinkCompleter.sink);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "fromFuture",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Convert a <code>Future&lt;StreamChannel&gt;<\/code> to a <code>StreamChannel<\/code>.<\/p>\n<p>This creates a channel using a channel completer, and sets the source\nchannel to the result of the future when the future completes.<\/p>\n<p>If the future completes with an error, the returned channel's stream will\ninstead contain just that error. The sink will silently discard all\nevents.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "channelFuture",
                            "type": "dart:async.Future<stream_channel.StreamChannel>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.Future",
                                "stream_channel.StreamChannel"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelCompleter\/fromFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamChannel fromFuture(Future&lt;StreamChannel&gt; channelFuture) {\n  var completer = new StreamChannelCompleter();\n  channelFuture.then(completer.setChannel, onError: completer.setError);\n  return completer.channel;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "setChannel",
                    "type": "",
                    "desc": "<p>Set a channel as the source and destination for <code>channel<\/code>.<\/p>\n<p>A channel may be set at most once.<\/p>\n<p>Either <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/setChannel.html\">setChannel<\/a> or <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/setError.html\">setError<\/a> may be called at most once. Trying to\ncall either of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "channel",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelCompleter\/setChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setChannel(StreamChannel&lt;T&gt; channel) {\n  if (_set) throw new StateError(\"The channel has already been set.\");\n  _set = true;\n\n  _streamCompleter.setSourceStream(channel.stream);\n  _sinkCompleter.setDestinationSink(channel.sink);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "setError",
                    "type": "",
                    "desc": "<p>Indicates that there was an error connecting the channel.<\/p>\n<p>This makes the stream emit <code>error<\/code> and close. It makes the sink discard\nall its events.<\/p>\n<p>Either <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/setChannel.html\">setChannel<\/a> or <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/setError.html\">setError<\/a> may be called at most once. Trying to\ncall either of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelCompleter\/setError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setError(error, [StackTrace stackTrace]) {\n  if (_set) throw new StateError(\"The channel has already been set.\");\n  _set = true;\n\n  _streamCompleter.setError(error, stackTrace);\n  _sinkCompleter.setDestinationSink(new NullStreamSink());\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "channel",
                    "type": "stream_channel.StreamChannel",
                    "types": [],
                    "desc": "<p>The channel for this completer.<\/p>\n        ",
                    "memberOf": "stream_channel.StreamChannelCompleter",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelCompleter\/channel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; get channel =&gt; _channel;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/StreamChannelCompleter-class.html",
            "desc": "<p>A <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/channel.html\">channel<\/a> where the source and destination are provided later.<\/p>\n<p>The <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/channel.html\">channel<\/a> is a normal channel that can be listened to and that events\ncan be added to immediately, but until <a href=\"package-stream_channel_stream_channel\/StreamChannelCompleter\/setChannel.html\">setChannel<\/a> is called it won't emit\nany events and all events added to it will be buffered.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamChannelCompleter"
        },
        {
            "name": "stream_channel.StreamChannelController",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "StreamChannelController",
                    "type": "",
                    "desc": "<p>Creates a <a href=\"package-stream_channel_stream_channel\/StreamChannelController-class.html\">StreamChannelController<\/a>.<\/p>\n<p>If <code>sync<\/code> is true, events added to either channel's sink are synchronously\ndispatched to the other channel's stream. This should only be done if the\nsource of those events is already asynchronous.<\/p>\n<p>If <code>allowForeignErrors<\/code> is <code>false<\/code>, errors are not allowed to be passed to\nthe foreign channel's sink. If any are, the connection will close and the\nerror will be forwarded to the foreign channel's <a href=\"dart-async\/StreamSink\/done.html\">StreamSink.done<\/a> future.\nThis guarantees that the local stream will never emit errors.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelController",
                    "sig": "",
                    "params": [
                        {
                            "name": "allowForeignErrors",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sync",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannelController\/StreamChannelController.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannelController({bool allowForeignErrors: true, bool sync: false}) {\n  var localToForeignController = new StreamController&lt;T&gt;(sync: sync);\n  var foreignToLocalController = new StreamController&lt;T&gt;(sync: sync);\n  _local = new StreamChannel&lt;T&gt;.withGuarantees(\n      foreignToLocalController.stream, localToForeignController.sink);\n  _foreign = new StreamChannel&lt;T&gt;.withGuarantees(\n      localToForeignController.stream, foreignToLocalController.sink,\n      allowSinkErrors: allowForeignErrors);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "foreign",
                    "type": "stream_channel.StreamChannel",
                    "types": [],
                    "desc": "<p>The foreign channel.<\/p>\n<p>This channel should be returned to external users so they can communicate\nwith <a href=\"package-stream_channel_stream_channel\/StreamChannelController\/local.html\">local<\/a>.<\/p>\n        ",
                    "memberOf": "stream_channel.StreamChannelController",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelController\/foreign.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; get foreign =&gt; _foreign;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "local",
                    "type": "stream_channel.StreamChannel",
                    "types": [],
                    "desc": "<p>The local channel.<\/p>\n<p>This channel should be used directly by the creator of this\n<a href=\"package-stream_channel_stream_channel\/StreamChannelController-class.html\">StreamChannelController<\/a> to send and receive events.<\/p>\n        ",
                    "memberOf": "stream_channel.StreamChannelController",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelController\/local.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; get local =&gt; _local;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/StreamChannelController-class.html",
            "desc": "<p>A controller for exposing a new <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a>.<\/p>\n<p>This exposes two connected <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a>s, <a href=\"package-stream_channel_stream_channel\/StreamChannelController\/local.html\">local<\/a> and <a href=\"package-stream_channel_stream_channel\/StreamChannelController\/foreign.html\">foreign<\/a>. The\nuser's code should use <a href=\"package-stream_channel_stream_channel\/StreamChannelController\/local.html\">local<\/a> to emit and receive events. Then <a href=\"package-stream_channel_stream_channel\/StreamChannelController\/foreign.html\">foreign<\/a>\ncan be returned for others to use. For example, here's a simplified version\nof the implementation of <a href=\"package-stream_channel_stream_channel\/IsolateChannel\/IsolateChannel.html\">new IsolateChannel<\/a>:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel isolateChannel(ReceivePort receivePort, SendPort sendPort) {\n  var controller = new StreamChannelController(allowForeignErrors: false);\n\n  \/\/ Pipe all events from the receive port into the local sink...\n  receivePort.pipe(controller.local.sink);\n\n  \/\/ ...and all events from the local stream into the send port.\n  controller.local.stream.listen(sendPort.send, onDone: receivePort.close);\n\n  \/\/ Then return the foreign controller for your users to use.\n  return controller.foreign;\n}\n<\/code><\/pre>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamChannelController"
        },
        {
            "name": "stream_channel.StreamChannelMixin",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "StreamChannelMixin",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/StreamChannelMixin.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "cast",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Returns a copy of this with the generic type coerced to <code>S<\/code>.<\/p>\n<p>If any events emitted by <a href=\"package-stream_channel_stream_channel\/StreamChannel\/stream.html\">stream<\/a> aren't of type <code>S<\/code>, they're converted\ninto <a href=\"dart-core\/CastError-class.html\">CastError<\/a> events. Similarly, if any events are added to <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a> that\naren't of type <code>S<\/code>, a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> is thrown.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/cast.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;S&gt; cast&lt;S&gt;() =&gt; new StreamChannel(\n    DelegatingStream.typed(stream), DelegatingStreamSink.typed(sink));<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "changeSink",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Returns a copy of this with <code>sink<\/code> replaced by <code>change<\/code>'s return\nvalue.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/changeSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; changeSink(StreamSink&lt;T&gt; change(StreamSink&lt;T&gt; sink)) =&gt;\n    new StreamChannel.withCloseGuarantee(stream, change(sink));<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "changeStream",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Returns a copy of this with <code>stream<\/code> replaced by <code>change<\/code>'s return\nvalue.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/changeStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; changeStream(Stream&lt;T&gt; change(Stream&lt;T&gt; stream)) =&gt;\n    new StreamChannel.withCloseGuarantee(change(stream), sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "pipe",
                    "type": "",
                    "desc": "<p>Connects this to <code>other<\/code>, so that any values emitted by either are sent\ndirectly to the other.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [
                        {
                            "name": "other",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/pipe.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void pipe(StreamChannel&lt;T&gt; other) {\n  stream.pipe(other.sink);\n  other.stream.pipe(sink);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "transform",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms this using <code>transformer<\/code>.<\/p>\n<p>This is identical to calling <code>transformer.bind(channel)<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "stream_channel.StreamChannelTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/transform.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;S&gt; transform&lt;S&gt;(StreamChannelTransformer&lt;S, T&gt; transformer) =&gt;\n    transformer.bind(this);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "transformSink",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms only the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a> component of this using <code>transformer<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "async.StreamSinkTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/transformSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; transformSink(StreamSinkTransformer&lt;T, T&gt; transformer) =&gt;\n    changeSink(transformer.bind);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "transformStream",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms only the <a href=\"package-stream_channel_stream_channel\/StreamChannel\/stream.html\">stream<\/a> component of this using <code>transformer<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelMixin",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "dart:async.StreamTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelMixin\/transformStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;T&gt; transformStream(StreamTransformer&lt;T, T&gt; transformer) =&gt;\n    changeStream(transformer.bind);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [
                "stream_channel.DelegatingStreamChannel",
                "stream_channel.IsolateChannel",
                "stream_channel.VirtualChannel",
                "web_socket_channel.WebSocketChannel",
                "web_socket_channel.io.IOWebSocketChannel"
            ],
            "realImplementors": [
                "stream_channel.DelegatingStreamChannel",
                "stream_channel.IsolateChannel",
                "stream_channel.VirtualChannel",
                "web_socket_channel.WebSocketChannel",
                "web_socket_channel.io.IOWebSocketChannel"
            ],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/StreamChannelMixin-class.html",
            "desc": "<p>A mixin that implements the instance methods of <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> in terms of\n<a href=\"package-stream_channel_stream_channel\/StreamChannel\/stream.html\">stream<\/a> and <a href=\"package-stream_channel_stream_channel\/StreamChannel\/sink.html\">sink<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamChannelMixin"
        },
        {
            "name": "stream_channel.StreamChannelTransformer",
            "extends": [],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "StreamChannelTransformer",
                    "type": "",
                    "desc": "<p>Creates a <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer-class.html\">StreamChannelTransformer<\/a> from existing stream and sink\ntransformers.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "_streamTransformer",
                            "type": "dart:async.StreamTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "_sinkTransformer",
                            "type": "async.StreamSinkTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannelTransformer\/StreamChannelTransformer.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const StreamChannelTransformer(\n    this._streamTransformer, this._sinkTransformer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "bind",
                    "type": "stream_channel.StreamChannel",
                    "desc": "<p>Transforms the events sent to and emitted by <code>channel<\/code>.<\/p>\n<p>Creates a new channel. When events are passed to the returned channel's\nsink, the transformer will transform them and pass the transformed\nversions to <code>channel.sink<\/code>. When events are emitted from the\n<code>channel.straem<\/code>, the transformer will transform them and pass the\ntransformed versions to the returned channel's stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "channel",
                            "type": "stream_channel.StreamChannel",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelTransformer\/bind.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannel&lt;S&gt; bind(StreamChannel&lt;T&gt; channel) =&gt;\n    new StreamChannel&lt;S&gt;.withCloseGuarantee(\n        channel.stream.transform(_streamTransformer),\n        _sinkTransformer.bind(channel.sink));<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "StreamChannelTransformer.fromCodec",
                    "type": "",
                    "desc": "<p>Creates a <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer-class.html\">StreamChannelTransformer<\/a> from a codec's encoder and decoder.<\/p>\n<p>All input to the inner channel's sink is encoded using <a href=\"dart-convert\/Codec\/encoder.html\">Codec.encoder<\/a>,\nand all output from its stream is decoded using <a href=\"dart-convert\/Codec\/decoder.html\">Codec.decoder<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "codec",
                            "type": "dart:convert.Codec",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-stream_channel_stream_channel\/StreamChannelTransformer\/StreamChannelTransformer.fromCodec.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamChannelTransformer.fromCodec(Codec&lt;S, T&gt; codec)\n    : this(codec.decoder,\n          new StreamSinkTransformer.fromStreamTransformer(codec.encoder));<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "typed",
                    "type": "stream_channel.StreamChannelTransformer",
                    "desc": "<p>Creates a wrapper that coerces the type of <code>transformer<\/code>.<\/p>\n<p>This soundly converts a <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer-class.html\">StreamChannelTransformer<\/a> to a\n<code>StreamChannelTransformer&lt;S, T&gt;<\/code>, regardless of its original generic type,\nby asserting that the events emitted by the transformed channel's stream\nare instances of <code>T<\/code> whenever they're provided. If they're not, the stream\nthrows a <a href=\"dart-core\/CastError-class.html\">CastError<\/a>. This also means that calls to <a href=\"dart-async\/EventSink\/add.html\">StreamSink.add<\/a> on\nthe transformed channel's sink may throw a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> if the argument\ntype doesn't match the reified type of the sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.StreamChannelTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "stream_channel.StreamChannelTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/StreamChannelTransformer\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamChannelTransformer&lt;S, T&gt; typed&lt;S, T&gt;(\n        StreamChannelTransformer transformer) =&gt;\n    transformer is StreamChannelTransformer&lt;S, T&gt;\n        ? transformer\n        : new TypeSafeStreamChannelTransformer(transformer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/StreamChannelTransformer-class.html",
            "desc": "<p>A <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer-class.html\">StreamChannelTransformer<\/a> transforms the events being passed to and\nemitted by a <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a>.<\/p>\n<p>This works on the same principle as <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> and\n<a href=\"package-async_async\/StreamSinkTransformer-class.html\">StreamSinkTransformer<\/a>. Each transformer defines a <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer\/bind.html\">bind<\/a> method that takes\nin the original <a href=\"package-stream_channel_stream_channel\/StreamChannel-class.html\">StreamChannel<\/a> and returns the transformed version.<\/p>\n<p>Transformers must be able to have <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer\/bind.html\">bind<\/a> called multiple times. If a\nsubclass implements <a href=\"package-stream_channel_stream_channel\/StreamChannelTransformer\/bind.html\">bind<\/a> explicitly, it should be sure that the returned\nstream follows the second stream channel guarantee: closing the sink causes\nthe stream to close before it emits any more events. This guarantee is\ninvalidated when an asynchronous gap is added between the original stream's\nevent dispatch and the returned stream's, for example by transforming it\nwith a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a>. The guarantee can be easily preserved using\n<a href=\"package-stream_channel_stream_channel\/StreamChannel\/StreamChannel.withCloseGuarantee.html\">StreamChannel.withCloseGuarantee<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamChannelTransformer"
        },
        {
            "name": "stream_channel.VirtualChannel",
            "extends": [
                "stream_channel.StreamChannelMixin",
                "dart:core.Object"
            ],
            "memberOf": "stream_channel",
            "events": [],
            "methods": [
                {
                    "name": "virtualChannel",
                    "type": "stream_channel.VirtualChannel",
                    "desc": "<p>Creates a new virtual channel.<\/p>\n<p>If <code>id<\/code> is not passed, this creates a virtual channel from scratch. Before\nit's used, its <a href=\"package-stream_channel_stream_channel\/VirtualChannel\/id.html\">VirtualChannel.id<\/a> must be sent to the remote endpoint\nwhere <a href=\"package-stream_channel_stream_channel\/VirtualChannel\/virtualChannel.html\">virtualChannel<\/a> should be called with that id.<\/p>\n<p>If <code>id<\/code> is passed, this creates a virtual channel corresponding to the\nchannel with that id on the remote channel.<\/p>\n<p>Throws an <a href=\"dart-core\/ArgumentError-class.html\">ArgumentError<\/a> if a virtual channel already exists for <code>id<\/code>.\nThrows a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if the underlying channel is closed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "stream_channel.VirtualChannel",
                    "sig": "",
                    "params": [
                        {
                            "name": "id",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-stream_channel_stream_channel\/VirtualChannel\/virtualChannel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">VirtualChannel&lt;T&gt; virtualChannel([id]) =&gt; _parent.virtualChannel(id);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "id",
                    "type": "dart:core.int",
                    "types": [],
                    "desc": "<p>The identifier for this channel.<\/p>\n<p>This can be sent across the <a href=\"package-stream_channel_stream_channel\/MultiChannel-class.html\">MultiChannel<\/a> to provide the remote endpoint\na means to connect to this channel. Nothing about this is guaranteed\nexcept that it will be JSON-serializable.<\/p>\n        ",
                    "memberOf": "stream_channel.VirtualChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/VirtualChannel\/id.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final int id\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "sink",
                    "type": "dart:async.StreamSink",
                    "types": [],
                    "desc": "<p>The default output stream.<\/p>\n<p>This connects to the remote <a href=\"package-stream_channel_stream_channel\/VirtualChannel\/stream.html\">stream<\/a>. If this is closed, the remote\n<a href=\"package-stream_channel_stream_channel\/VirtualChannel\/stream.html\">stream<\/a> will close, but other virtual channels will remain open and new\nvirtual channels may be opened.<\/p>\n        ",
                    "memberOf": "stream_channel.VirtualChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/VirtualChannel\/sink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final StreamSink&lt;T&gt; sink\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The default input stream.<\/p>\n<p>This connects to the remote <a href=\"package-stream_channel_stream_channel\/VirtualChannel\/sink.html\">sink<\/a>.<\/p>\n        ",
                    "memberOf": "stream_channel.VirtualChannel",
                    "isConstant": false,
                    "href": "package-stream_channel_stream_channel\/VirtualChannel\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Stream&lt;T&gt; stream\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-stream_channel_stream_channel\/VirtualChannel-class.html",
            "desc": "<p>A virtual channel created by <a href=\"package-stream_channel_stream_channel\/MultiChannel-class.html\">MultiChannel<\/a>.<\/p>\n<p>This implements <a href=\"package-stream_channel_stream_channel\/MultiChannel-class.html\">MultiChannel<\/a> for convenience.\n<a href=\"package-stream_channel_stream_channel\/VirtualChannel\/virtualChannel.html\">VirtualChannel.virtualChannel<\/a> is semantically identical to the parent's\n<a href=\"package-stream_channel_stream_channel\/VirtualChannel\/virtualChannel.html\">MultiChannel.virtualChannel<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "VirtualChannel"
        }
    ],
    "isFakeNamespace": false,
    "desc": "",
    "example": "",
    "isDeprecated": false
}