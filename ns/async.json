{
    "name": "async",
    "href": "package-async_async\/package-async_async-library.html",
    "cn": [
        {
            "name": "async.AsyncCache",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "AsyncCache",
                    "type": "",
                    "desc": "<p>Creates a cache that invalidates its contents after <code>duration<\/code> has passed.<\/p>\n<p>The <code>duration<\/code> starts counting after the Future returned by <a href=\"package-async_async\/AsyncCache\/fetch.html\">fetch<\/a>\ncompletes, or after the Stream returned by <a href=\"package-async_async\/AsyncCache\/fetchStream.html\">fetchStream<\/a> emits a done\nevent.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.AsyncCache",
                    "sig": "",
                    "params": [
                        {
                            "name": "_duration",
                            "type": "dart:core.Duration",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/AsyncCache\/AsyncCache.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">AsyncCache(this._duration);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "AsyncCache.ephemeral",
                    "type": "",
                    "desc": "<p>Creates a cache that invalidates after an in-flight request is complete.<\/p>\n<p>An ephemeral cache guarantees that a callback function will only be\nexecuted at most once concurrently. This is useful for requests for which\ndata is updated frequently but stale data is acceptable.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.AsyncCache",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/AsyncCache\/AsyncCache.ephemeral.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory AsyncCache.ephemeral() =&gt; new AsyncCache(Duration.zero);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "fetch",
                    "type": "dart:async.Future",
                    "desc": "<p>Returns a cached value from a previous call to <a href=\"package-async_async\/AsyncCache\/fetch.html\">fetch<\/a>, or runs <code>callback<\/code>\nto compute a new one.<\/p>\n<p>If <a href=\"package-async_async\/AsyncCache\/fetch.html\">fetch<\/a> has been called recently enough, returns its previous return\nvalue. Otherwise, runs <code>callback<\/code> and returns its new return value.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.AsyncCache",
                    "sig": "",
                    "params": [
                        {
                            "name": "callback",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/AsyncCache\/fetch.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; fetch(Future&lt;T&gt; callback()) async {\n  if (_cachedStreamSplitter != null) {\n    throw new StateError('Previously used to cache via `fetchStream`');\n  }\n  if (_cachedValueFuture == null) {\n    _cachedValueFuture = callback();\n    await _cachedValueFuture;\n    _startStaleTimer();\n  }\n  return _cachedValueFuture;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "fetchStream",
                    "type": "dart:async.Stream",
                    "desc": "<p>Returns a cached stream from a previous call to <a href=\"package-async_async\/AsyncCache\/fetchStream.html\">fetchStream<\/a>, or runs\n<code>callback<\/code> to compute a new stream.<\/p>\n<p>If <a href=\"package-async_async\/AsyncCache\/fetchStream.html\">fetchStream<\/a> has been called recently enough, returns a copy of its\nprevious return value. Otherwise, runs <code>callback<\/code> and returns its new\nreturn value.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.AsyncCache",
                    "sig": "",
                    "params": [
                        {
                            "name": "callback",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/AsyncCache\/fetchStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; fetchStream(Stream&lt;T&gt; callback()) {\n  if (_cachedValueFuture != null) {\n    throw new StateError('Previously used to cache via `fetch`');\n  }\n  if (_cachedStreamSplitter == null) {\n    _cachedStreamSplitter = new StreamSplitter(callback()\n        .transform(new StreamTransformer.fromHandlers(handleDone: (sink) {\n      _startStaleTimer();\n      sink.close();\n    })));\n  }\n  return _cachedStreamSplitter.split();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "invalidate",
                    "type": "",
                    "desc": "<p>Removes any cached value.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.AsyncCache",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/AsyncCache\/invalidate.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void invalidate() {\n  \/\/ TODO: This does not return a future, but probably should.\n  _cachedValueFuture = null;\n  \/\/ TODO: This does not await, but probably should.\n  _cachedStreamSplitter?.close();\n  _cachedStreamSplitter = null;\n  _stale?.cancel();\n  _stale = null;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/AsyncCache-class.html",
            "desc": "<p>Runs asynchronous functions and caches the result for a period of time.<\/p>\n<p>This class exists to cover the pattern of having potentially expensive code\nsuch as file I\/O, network access, or isolate computation that's unlikely to\nchange quickly run fewer times. For example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">final _usersCache = new AsyncCache&lt;List&lt;String&gt;&gt;(const Duration(hours: 1));\n\n\/\/\/ Uses the cache if it exists, otherwise calls the closure:\nFuture&lt;List&lt;String&gt;&gt; get onlineUsers =&gt; _usersCache.fetch(() {\n  \/\/ Actually fetch online users here.\n});\n<\/code><\/pre>\n<p>This class's timing can be mocked using <a href=\"https:\/\/pub.dartlang.org\/packages\/fake_async\"><code>fake_async<\/code><\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "AsyncCache"
        },
        {
            "name": "async.AsyncMemoizer",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "AsyncMemoizer",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.AsyncMemoizer",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/AsyncMemoizer\/AsyncMemoizer.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "runOnce",
                    "type": "dart:async.Future",
                    "desc": "<p>Runs the function, <code>computation<\/code>, if it hasn't been run before.<\/p>\n<p>If <a href=\"package-async_async\/AsyncMemoizer\/runOnce.html\">runOnce<\/a> has already been called, this returns the original result.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.AsyncMemoizer",
                    "sig": "",
                    "params": [
                        {
                            "name": "computation",
                            "type": "dart:async.FutureOr",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/AsyncMemoizer\/runOnce.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; runOnce(FutureOr&lt;T&gt; computation()) {\n  if (!hasRun) _completer.complete(new Future.sync(computation));\n  return future;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "future",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>The future containing the method's result.<\/p>\n<p>This can be accessed at any time, and will fire once <a href=\"package-async_async\/AsyncMemoizer\/runOnce.html\">runOnce<\/a> is called.<\/p>\n        ",
                    "memberOf": "async.AsyncMemoizer",
                    "isConstant": false,
                    "href": "package-async_async\/AsyncMemoizer\/future.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get future =&gt; _completer.future;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "hasRun",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether <a href=\"package-async_async\/AsyncMemoizer\/runOnce.html\">runOnce<\/a> has been called yet.<\/p>\n        ",
                    "memberOf": "async.AsyncMemoizer",
                    "isConstant": false,
                    "href": "package-async_async\/AsyncMemoizer\/hasRun.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasRun =&gt; _completer.isCompleted;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/AsyncMemoizer-class.html",
            "desc": "<p>A class for running an asynchronous function exactly once and caching its\nresult.<\/p>\n<p>An <code>AsyncMemoizer<\/code> is used when some function may be run multiple times in\norder to get its result, but it only actually needs to be run once for its\neffect. To memoize the result of an async function, you can create a\nmemoizer outside the function (for example as an instance field if you want\nto memoize the result of a method), and then wrap the function's body in a\ncall to <a href=\"package-async_async\/AsyncMemoizer\/runOnce.html\">runOnce<\/a>.<\/p>\n<p>This is useful for methods like <code>close()<\/code> and getters that need to do\nasynchronous work. For example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">class SomeResource {\n  final _closeMemo = new AsyncMemoizer();\n\n  Future close() =&gt; _closeMemo.runOnce(() {\n    \/\/ ...\n  });\n}\n<\/code><\/pre>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "AsyncMemoizer"
        },
        {
            "name": "async.CancelableCompleter",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "CancelableCompleter",
                    "type": "",
                    "desc": "<p>Creates a new completer for a <a href=\"package-async_async\/CancelableOperation-class.html\">CancelableOperation<\/a>.<\/p>\n<p>When the future operation canceled, as long as the completer hasn't yet\ncompleted, <code>onCancel<\/code> is called. If <code>onCancel<\/code> returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>, it's\nforwarded to <a href=\"package-async_async\/CancelableOperation\/cancel.html\">CancelableOperation.cancel<\/a>.<\/p>\n<p><code>onCancel<\/code> will be called synchronously when the operation is canceled.\nIt's guaranteed to only be called once.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "onCancel",
                            "type": "dart:async.FutureOr",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/CancelableCompleter\/CancelableCompleter.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">CancelableCompleter({FutureOr onCancel()})\n    : _onCancel = onCancel,\n      _inner = new Completer&lt;T&gt;() {\n  _operation = new CancelableOperation&lt;T&gt;._(this);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "complete",
                    "type": "",
                    "desc": "<p>Completes <a href=\"package-async_async\/CancelableCompleter\/operation.html\">operation<\/a> to <code>value<\/code>.<\/p>\n<p>If <code>value<\/code> is a <a href=\"dart-async\/Future-class.html\">Future<\/a>, this will complete to the result of that\n<a href=\"dart-async\/Future-class.html\">Future<\/a> once it completes.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/CancelableCompleter\/complete.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void complete([value]) {\n  if (_isCompleted) throw new StateError(\"Operation already completed\");\n  _isCompleted = true;\n\n  if (value is! Future) {\n    if (_isCanceled) return;\n    _inner.complete(value);\n    return;\n  }\n\n  if (_isCanceled) {\n    \/\/ Make sure errors from [value] aren't top-leveled.\n    value.catchError((_) {});\n    return;\n  }\n\n  value.then((result) {\n    if (_isCanceled) return;\n    _inner.complete(result);\n  }, onError: (error, stackTrace) {\n    if (_isCanceled) return;\n    _inner.completeError(error, stackTrace);\n  });\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "completeError",
                    "type": "",
                    "desc": "<p>Completes <a href=\"package-async_async\/CancelableCompleter\/operation.html\">operation<\/a> to <code>error<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/CancelableCompleter\/completeError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void completeError(Object error, [StackTrace stackTrace]) {\n  if (_isCompleted) throw new StateError(\"Operation already completed\");\n  _isCompleted = true;\n\n  if (_isCanceled) return;\n  _inner.completeError(error, stackTrace);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "isCanceled",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether the completer was canceled before being completed.<\/p>\n        ",
                    "memberOf": "async.CancelableCompleter",
                    "isConstant": false,
                    "href": "package-async_async\/CancelableCompleter\/isCanceled.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isCanceled =&gt; _isCanceled;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isCompleted",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether the completer has completed.<\/p>\n        ",
                    "memberOf": "async.CancelableCompleter",
                    "isConstant": false,
                    "href": "package-async_async\/CancelableCompleter\/isCompleted.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isCompleted =&gt; _isCompleted;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "operation",
                    "type": "async.CancelableOperation",
                    "types": [],
                    "desc": "<p>The operation controlled by this completer.<\/p>\n        ",
                    "memberOf": "async.CancelableCompleter",
                    "isConstant": false,
                    "href": "package-async_async\/CancelableCompleter\/operation.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">CancelableOperation&lt;T&gt; get operation =&gt; _operation;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/CancelableCompleter-class.html",
            "desc": "<p>A completer for a <a href=\"package-async_async\/CancelableOperation-class.html\">CancelableOperation<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "CancelableCompleter"
        },
        {
            "name": "async.CancelableOperation",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "asStream",
                    "type": "dart:async.Stream",
                    "desc": "<p>Creates a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> containing the result of this operation.<\/p>\n<p>This is like <code>value.asStream()<\/code>, but if a subscription to the stream is\ncanceled, this is as well.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableOperation",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/CancelableOperation\/asStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; asStream() {\n  var controller =\n      new StreamController&lt;T&gt;(sync: true, onCancel: _completer._cancel);\n\n  value.then((value) {\n    controller.add(value);\n    controller.close();\n  }, onError: (error, stackTrace) {\n    controller.addError(error, stackTrace);\n    controller.close();\n  });\n  return controller.stream;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "cancel",
                    "type": "dart:async.Future",
                    "desc": "<p>Cancels this operation.<\/p>\n<p>This returns the <a href=\"dart-async\/Future-class.html\">Future<\/a> returned by the <a href=\"package-async_async\/CancelableCompleter-class.html\">CancelableCompleter<\/a>'s\n<code>onCancel<\/code> callback. Unlike <a href=\"package-async_async\/CancelableOperation\/cancel.html\">Stream.cancel<\/a>, it never returns <code>null<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableOperation",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/CancelableOperation\/cancel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future cancel() =&gt; _completer._cancel();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "CancelableOperation.fromFuture",
                    "type": "",
                    "desc": "<p>Creates a <a href=\"package-async_async\/CancelableOperation-class.html\">CancelableOperation<\/a> wrapping <code>inner<\/code>.<\/p>\n<p>When this operation is canceled, <code>onCancel<\/code> will be called and any value\nor error produced by <code>inner<\/code> will be discarded. If <code>onCancel<\/code> returns a\n<a href=\"dart-async\/Future-class.html\">Future<\/a>, it will be forwarded to <a href=\"package-async_async\/CancelableOperation\/cancel.html\">cancel<\/a>.<\/p>\n<p><code>onCancel<\/code> will be called synchronously when the operation is canceled.\nIt's guaranteed to only be called once.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableOperation",
                    "sig": "",
                    "params": [
                        {
                            "name": "inner",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "onCancel",
                            "type": "dart:async.FutureOr",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/CancelableOperation\/CancelableOperation.fromFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory CancelableOperation.fromFuture(Future&lt;T&gt; inner,\n    {FutureOr onCancel()}) {\n  var completer = new CancelableCompleter&lt;T&gt;(onCancel: onCancel);\n  completer.complete(inner);\n  return completer.operation;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "valueOrCancellation",
                    "type": "dart:async.Future",
                    "desc": "<p>Creates a <a href=\"dart-async\/Future-class.html\">Future<\/a> that completes when this operation completes <em>or<\/em> when\nit's cancelled.<\/p>\n<p>If this operation completes, this completes to the same result as <a href=\"package-async_async\/CancelableOperation\/value.html\">value<\/a>.\nIf this operation is cancelled, the returned future waits for the future\nreturned by <a href=\"package-async_async\/CancelableOperation\/cancel.html\">cancel<\/a>, then completes to <code>cancellationValue<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.CancelableOperation",
                    "sig": "",
                    "params": [
                        {
                            "name": "cancellationValue",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/CancelableOperation\/valueOrCancellation.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future valueOrCancellation([T cancellationValue]) {\n  var completer = new Completer&lt;T&gt;.sync();\n  value.then((result) =&gt; completer.complete(result),\n      onError: completer.completeError);\n\n  _completer._cancelMemo.future.then((_) {\n    completer.complete(cancellationValue);\n  }, onError: completer.completeError);\n\n  return completer.future;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "value",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>The value returned by the operation.<\/p>\n        ",
                    "memberOf": "async.CancelableOperation",
                    "isConstant": false,
                    "href": "package-async_async\/CancelableOperation\/value.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get value =&gt; _completer._inner.future;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/CancelableOperation-class.html",
            "desc": "<p>An asynchronous operation that can be cancelled.<\/p>\n<p>The value of this operation is exposed as <a href=\"package-async_async\/CancelableOperation\/value.html\">value<\/a>. When this operation is\ncancelled, <a href=\"package-async_async\/CancelableOperation\/value.html\">value<\/a> won't complete either successfully or with an error. If\n<a href=\"package-async_async\/CancelableOperation\/value.html\">value<\/a> has already completed, cancelling the operation does nothing.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "CancelableOperation"
        },
        {
            "name": "async.DelegatingEventSink",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingEventSink",
                    "type": "",
                    "desc": "<p>Create a delegating sink forwarding calls to <code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingEventSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingEventSink\/DelegatingEventSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingEventSink(EventSink&lt;T&gt; sink) : _sink = sink;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "add",
                    "type": "",
                    "desc": "<p>Adds a data <code>event<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingEventSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingEventSink\/add.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T data) {\n  _sink.add(data);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "addError",
                    "type": "",
                    "desc": "<p>Adds an <code>error<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingEventSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingEventSink\/addError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(error, [StackTrace stackTrace]) {\n  _sink.addError(error, stackTrace);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "close",
                    "type": "",
                    "desc": "<p>Closes the sink.<\/p>\n<p>Calling this method more than once is allowed, but does nothing.<\/p>\n<p>Neither <a href=\"package-async_async\/DelegatingEventSink\/add.html\">add<\/a> nor <a href=\"package-async_async\/DelegatingEventSink\/addError.html\">addError<\/a> must be called after this method.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingEventSink",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingEventSink\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void close() {\n  _sink.close();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "typed",
                    "type": "dart:async.EventSink",
                    "desc": "<p>Creates a wrapper that coerces the type of <code>sink<\/code>.<\/p>\n<p>Unlike <a href=\"package-async_async\/DelegatingEventSink\/DelegatingEventSink.html\">new DelegatingEventSink<\/a>, this only requires its argument to be an\ninstance of <code>EventSink<\/code>, not <code>EventSink&lt;T&gt;<\/code>. This means that calls to\n<a href=\"package-async_async\/DelegatingEventSink\/add.html\">add<\/a> may throw a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> if the argument type doesn't match the\nreified type of <code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingEventSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingEventSink\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static EventSink&lt;T&gt; typed&lt;T&gt;(EventSink sink) =&gt;\n    sink is EventSink&lt;T&gt; ? sink : new DelegatingEventSink._(sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/DelegatingEventSink-class.html",
            "desc": "<p>Simple delegating wrapper around an <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a>.<\/p>\n<p>Subclasses can override individual methods, or use this to expose only the\n<a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> methods of a subclass.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingEventSink"
        },
        {
            "name": "async.DelegatingFuture",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingFuture",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "_future",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingFuture\/DelegatingFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingFuture(this._future);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "asStream",
                    "type": "dart:async.Stream",
                    "desc": "<p>Creates a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> containing the result of this future.<\/p>\n<p>The stream will produce single data or error event containing the\ncompletion result of this future, and then it will close with a\ndone event.<\/p>\n<p>If the future never completes, the stream will not produce any events.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingFuture\/asStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; asStream() =&gt; _future.asStream();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "catchError",
                    "type": "dart:async.Future",
                    "desc": "<p>Handles errors emitted by this <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n<p>This is the asynchronous equivalent of a \"catch\" block.<\/p>\n<p>Returns a new <a href=\"dart-async\/Future-class.html\">Future<\/a> that will be completed with either the result of\nthis future or the result of calling the <code>onError<\/code> callback.<\/p>\n<p>If this future completes with a value,\nthe returned future completes with the same value.<\/p>\n<p>If this future completes with an error,\nthen <code>test<\/code> is first called with the error value.<\/p>\n<p>If <code>test<\/code> returns false, the exception is not handled by this <code>catchError<\/code>,\nand the returned future completes with the same error and stack trace\nas this future.<\/p>\n<p>If <code>test<\/code> returns <code>true<\/code>,\n<code>onError<\/code> is called with the error and possibly stack trace,\nand the returned future is completed with the result of this call\nin exactly the same way as for <a href=\"package-async_async\/DelegatingFuture\/then.html\">then<\/a>'s <code>onError<\/code>.<\/p>\n<p>If <code>test<\/code> is omitted, it defaults to a function that always returns true.\nThe <code>test<\/code> function should not throw, but if it does, it is handled as\nif the <code>onError<\/code> function had thrown.<\/p>\n<p>Note that futures don't delay reporting of errors until listeners are\nadded. If the first <code>catchError<\/code> (or <code>then<\/code>) call happens after this future\nhas completed with an error then the error is reported as unhandled error.\nSee the description on <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "onError",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingFuture\/catchError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; catchError(Function onError, {bool test(Object error)}) =&gt;\n    _future.catchError(onError, test: test);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "then",
                    "type": "dart:async.Future",
                    "desc": "<p>Register callbacks to be called when this future completes.<\/p>\n<p>When this future completes with a value,\nthe <code>onValue<\/code> callback will be called with that value.\nIf this future is already completed, the callback will not be called\nimmediately, but will be scheduled in a later microtask.<\/p>\n<p>If <code>onError<\/code> is provided, and this future completes with an error,\nthe <code>onError<\/code> callback is called with that error and its stack trace.\nThe <code>onError<\/code> callback must accept either one argument or two arguments\nwhere the latter is a <a href=\"dart-core\/StackTrace-class.html\">StackTrace<\/a>.\nIf <code>onError<\/code> accepts two arguments,\nit is called with both the error and the stack trace,\notherwise it is called with just the error object.\nThe <code>onError<\/code> callback must return a value or future that can be used\nto complete the returned future, so it must be something assignable to\n<code>FutureOr&lt;R&gt;<\/code>.<\/p>\n<p>Returns a new <a href=\"dart-async\/Future-class.html\">Future<\/a>\nwhich is completed with the result of the call to <code>onValue<\/code>\n(if this future completes with a value)\nor to <code>onError<\/code> (if this future completes with an error).<\/p>\n<p>If the invoked callback throws,\nthe returned future is completed with the thrown error\nand a stack trace for the error.\nIn the case of <code>onError<\/code>,\nif the exception thrown is <code>identical<\/code> to the error argument to <code>onError<\/code>,\nthe throw is considered a rethrow,\nand the original stack trace is used instead.<\/p>\n<p>If the callback returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>,\nthe future returned by <code>then<\/code> will be completed with\nthe same result as the future returned by the callback.<\/p>\n<p>If <code>onError<\/code> is not given, and this future completes with an error,\nthe error is forwarded directly to the returned future.<\/p>\n<p>In most cases, it is more readable to use <a href=\"package-async_async\/DelegatingFuture\/catchError.html\">catchError<\/a> separately, possibly\nwith a <code>test<\/code> parameter, instead of handling both value and error in a\nsingle <a href=\"package-async_async\/DelegatingFuture\/then.html\">then<\/a> call.<\/p>\n<p>Note that futures don't delay reporting of errors until listeners are\nadded. If the first <code>then<\/code> or <code>catchError<\/code> call happens after this future\nhas completed with an error then the error is reported as unhandled error.\nSee the description on <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "onError",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingFuture\/then.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;S&gt; then&lt;S&gt;(FutureOr&lt;S&gt; onValue(T value), {Function onError}) =&gt;\n    _future.then(onValue, onError: onError);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "timeout",
                    "type": "dart:async.Future",
                    "desc": "<p>Time-out the future computation after <code>timeLimit<\/code> has passed.<\/p>\n<p>Returns a new future that completes with the same value as this future,\nif this future completes in time.<\/p>\n<p>If this future does not complete before <code>timeLimit<\/code> has passed,\nthe <code>onTimeout<\/code> action is executed instead, and its result (whether it\nreturns or throws) is used as the result of the returned future.\nThe <code>onTimeout<\/code> function must return a <code>T<\/code> or a <code>Future&lt;T&gt;<\/code>.<\/p>\n<p>If <code>onTimeout<\/code> is omitted, a timeout will cause the returned future to\ncomplete with a <a href=\"dart-async\/TimeoutException-class.html\">TimeoutException<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "timeLimit",
                            "type": "dart:core.Duration",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "onTimeout",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingFuture\/timeout.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; timeout(Duration timeLimit, {onTimeout()}) =&gt;\n    _future.timeout(timeLimit, onTimeout: onTimeout);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "typed",
                    "type": "dart:async.Future",
                    "desc": "<p>Creates a wrapper which throws if <code>future<\/code>'s value isn't an instance of\n<code>T<\/code>.<\/p>\n<p>This soundly converts a <a href=\"dart-async\/Future-class.html\">Future<\/a> to a <code>Future&lt;T&gt;<\/code>, regardless of its\noriginal generic type, by asserting that its value is an instance of <code>T<\/code>\nwhenever it's provided. If it's not, the future throws a <a href=\"dart-core\/CastError-class.html\">CastError<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "future",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingFuture\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@Deprecated('Use future.then((v) =&gt; v as T) instead.')\nstatic Future&lt;T&gt; typed&lt;T&gt;(Future future) =&gt;\n    future is Future&lt;T&gt; ? future : future.then((v) =&gt; v as T);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "whenComplete",
                    "type": "dart:async.Future",
                    "desc": "<p>Registers a function to be called when this future completes.<\/p>\n<p>The <code>action<\/code> function is called when this future completes, whether it\ndoes so with a value or with an error.<\/p>\n<p>This is the asynchronous equivalent of a \"finally\" block.<\/p>\n<p>The future returned by this call, <code>f<\/code>, will complete the same way\nas this future unless an error occurs in the <code>action<\/code> call, or in\na <a href=\"dart-async\/Future-class.html\">Future<\/a> returned by the <code>action<\/code> call. If the call to <code>action<\/code>\ndoes not return a future, its return value is ignored.<\/p>\n<p>If the call to <code>action<\/code> throws, then <code>f<\/code> is completed with the\nthrown error.<\/p>\n<p>If the call to <code>action<\/code> returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>, <code>f2<\/code>, then completion of\n<code>f<\/code> is delayed until <code>f2<\/code> completes. If <code>f2<\/code> completes with\nan error, that will be the result of <code>f<\/code> too. The value of <code>f2<\/code> is always\nignored.<\/p>\n<p>This method is equivalent to:<\/p>\n<pre class=\"language-dart\"><code>Future&lt;T&gt; whenComplete(action()) {\n  return this.then((v) {\n    var f2 = action();\n    if (f2 is Future) return f2.then((_) =&gt; v);\n    return v\n  }, onError: (e) {\n    var f2 = action();\n    if (f2 is Future) return f2.then((_) { throw e; });\n    throw e;\n  });\n}\n<\/code><\/pre>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "action",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingFuture\/whenComplete.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; whenComplete(action()) =&gt; _future.whenComplete(action);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [
                "async.ResultFuture"
            ],
            "realImplementors": [
                "async.ResultFuture"
            ],
            "cn": [],
            "href": "package-async_async\/DelegatingFuture-class.html",
            "desc": "<p>A wrapper that forwards calls to a <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingFuture"
        },
        {
            "name": "async.DelegatingSink",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingSink",
                    "type": "",
                    "desc": "<p>Create a delegating sink forwarding calls to <code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:core.Sink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingSink\/DelegatingSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingSink(Sink&lt;T&gt; sink) : _sink = sink;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "add",
                    "type": "",
                    "desc": "<p>Adds <code>data<\/code> to the sink.<\/p>\n<p>Must not be called after a call to <a href=\"package-async_async\/DelegatingSink\/close.html\">close<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingSink\/add.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T data) {\n  _sink.add(data);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "close",
                    "type": "",
                    "desc": "<p>Closes the sink.<\/p>\n<p>The <a href=\"package-async_async\/DelegatingSink\/add.html\">add<\/a> method must not be called after this method.<\/p>\n<p>Calling this method more than once is allowed, but does nothing.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingSink",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingSink\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void close() {\n  _sink.close();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "typed",
                    "type": "dart:core.Sink",
                    "desc": "<p>Creates a wrapper that coerces the type of <code>sink<\/code>.<\/p>\n<p>Unlike <a href=\"package-async_async\/DelegatingSink\/DelegatingSink.html\">new DelegatingSink<\/a>, this only requires its argument to be an\ninstance of <code>Sink<\/code>, not <code>Sink&lt;T&gt;<\/code>. This means that calls to <a href=\"package-async_async\/DelegatingSink\/add.html\">add<\/a> may\nthrow a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> if the argument type doesn't match the reified type of\n<code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:core.Sink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingSink\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Sink&lt;T&gt; typed&lt;T&gt;(Sink sink) =&gt;\n    sink is Sink&lt;T&gt; ? sink : new DelegatingSink._(sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/DelegatingSink-class.html",
            "desc": "<p>Simple delegating wrapper around a <a href=\"dart-core\/Sink-class.html\">Sink<\/a>.<\/p>\n<p>Subclasses can override individual methods, or use this to expose only the\n<a href=\"dart-core\/Sink-class.html\">Sink<\/a> methods of a subclass.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingSink"
        },
        {
            "name": "async.DelegatingStream",
            "extends": [
                "dart:async.StreamView",
                "dart:async.Stream",
                "dart:core.Object"
            ],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingStream",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.DelegatingStream",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingStream\/DelegatingStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingStream(Stream&lt;T&gt; stream) : super(stream);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "typed",
                    "type": "dart:async.Stream",
                    "desc": "<p>Creates a wrapper which throws if <code>stream<\/code>'s events aren't instances of\n<code>T<\/code>.<\/p>\n<p>This soundly converts a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> to a <code>Stream&lt;T&gt;<\/code>, regardless of its\noriginal generic type, by asserting that its events are instances of <code>T<\/code>\nwhenever they're provided. If they're not, the stream throws a\n<a href=\"dart-core\/CastError-class.html\">CastError<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStream",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStream\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Stream&lt;T&gt; typed&lt;T&gt;(Stream stream) =&gt; stream.cast();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/DelegatingStream-class.html",
            "desc": "<p>Simple delegating wrapper around a <a href=\"dart-async\/Stream-class.html\">Stream<\/a>.<\/p>\n<p>Subclasses can override individual methods, or use this to expose only the\n<a href=\"dart-async\/Stream-class.html\">Stream<\/a> methods of a subclass.<\/p>\n<p>Note that this is identical to <a href=\"dart-async\/StreamView-class.html\">StreamView<\/a> in <code>dart:async<\/code>. It's provided\nunder this name for consistency with other <code>Delegating*<\/code> classes.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingStream"
        },
        {
            "name": "async.DelegatingStreamConsumer",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingStreamConsumer",
                    "type": "",
                    "desc": "<p>Create a delegating consumer forwarding calls to <code>consumer<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamConsumer",
                    "sig": "",
                    "params": [
                        {
                            "name": "consumer",
                            "type": "dart:async.StreamConsumer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingStreamConsumer\/DelegatingStreamConsumer.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingStreamConsumer(StreamConsumer&lt;T&gt; consumer) : _consumer = consumer;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "addStream",
                    "type": "dart:async.Future",
                    "desc": "<p>Consumes the elements of <code>stream<\/code>.<\/p>\n<p>Listens on <code>stream<\/code> and does something for each event.<\/p>\n<p>Returns a future which is completed when the stream is done being added,\nand the consumer is ready to accept a new stream.\nNo further calls to <a href=\"package-async_async\/DelegatingStreamConsumer\/addStream.html\">addStream<\/a> or <a href=\"package-async_async\/DelegatingStreamConsumer\/close.html\">close<\/a> should happen before the\nreturned future has completed.<\/p>\n<p>The consumer may stop listening to the stream after an error,\nit may consume all the errors and only stop at a done event,\nor it may be canceled early if the receiver don't want any further events.<\/p>\n<p>If the consumer stops listening because of some error preventing it\nfrom continuing, it may report this error in the returned future,\notherwise it will just complete the future with <code>null<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamConsumer",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamConsumer\/addStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future addStream(Stream&lt;T&gt; stream) =&gt; _consumer.addStream(stream);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "close",
                    "type": "dart:async.Future",
                    "desc": "<p>Tells the consumer that no further streams will be added.<\/p>\n<p>This allows the consumer to complete any remaining work and release\nresources that are no longer needed<\/p>\n<p>Returns a future which is completed when the consumer has shut down.\nIf cleaning up can fail, the error may be reported in the returned future,\notherwise it completes with <code>null<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamConsumer",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamConsumer\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close() =&gt; _consumer.close();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "typed",
                    "type": "dart:async.StreamConsumer",
                    "desc": "<p>Creates a wrapper that coerces the type of <code>consumer<\/code>.<\/p>\n<p>Unlike <a href=\"dart-async\/StreamConsumer\/StreamConsumer.html\">new StreamConsumer<\/a>, this only requires its argument to be an\ninstance of <code>StreamConsumer<\/code>, not <code>StreamConsumer&lt;T&gt;<\/code>. This means that\ncalls to <a href=\"package-async_async\/DelegatingStreamConsumer\/addStream.html\">addStream<\/a> may throw a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> if the argument type doesn't\nmatch the reified type of <code>consumer<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamConsumer",
                    "sig": "",
                    "params": [
                        {
                            "name": "consumer",
                            "type": "dart:async.StreamConsumer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamConsumer\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamConsumer&lt;T&gt; typed&lt;T&gt;(StreamConsumer consumer) =&gt;\n    consumer is StreamConsumer&lt;T&gt;\n        ? consumer\n        : new DelegatingStreamConsumer._(consumer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/DelegatingStreamConsumer-class.html",
            "desc": "<p>Simple delegating wrapper around a <a href=\"dart-async\/StreamConsumer-class.html\">StreamConsumer<\/a>.<\/p>\n<p>Subclasses can override individual methods, or use this to expose only the\n<a href=\"dart-async\/StreamConsumer-class.html\">StreamConsumer<\/a> methods of a subclass.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingStreamConsumer"
        },
        {
            "name": "async.DelegatingStreamSink",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingStreamSink",
                    "type": "",
                    "desc": "<p>Create delegating sink forwarding calls to <code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingStreamSink\/DelegatingStreamSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingStreamSink(StreamSink&lt;T&gt; sink) : _sink = sink;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "add",
                    "type": "",
                    "desc": "<p>Adds a data <code>event<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSink\/add.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T data) {\n  _sink.add(data);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "addError",
                    "type": "",
                    "desc": "<p>Adds an <code>error<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSink\/addError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(error, [StackTrace stackTrace]) {\n  _sink.addError(error, stackTrace);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "addStream",
                    "type": "dart:async.Future",
                    "desc": "<p>Consumes the elements of <code>stream<\/code>.<\/p>\n<p>Listens on <code>stream<\/code> and does something for each event.<\/p>\n<p>Returns a future which is completed when the stream is done being added,\nand the consumer is ready to accept a new stream.\nNo further calls to <a href=\"package-async_async\/DelegatingStreamSink\/addStream.html\">addStream<\/a> or <a href=\"package-async_async\/DelegatingStreamSink\/close.html\">close<\/a> should happen before the\nreturned future has completed.<\/p>\n<p>The consumer may stop listening to the stream after an error,\nit may consume all the errors and only stop at a done event,\nor it may be canceled early if the receiver don't want any further events.<\/p>\n<p>If the consumer stops listening because of some error preventing it\nfrom continuing, it may report this error in the returned future,\notherwise it will just complete the future with <code>null<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSink\/addStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future addStream(Stream&lt;T&gt; stream) =&gt; _sink.addStream(stream);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "close",
                    "type": "dart:async.Future",
                    "desc": "<p>Tells the stream sink that no further streams will be added.<\/p>\n<p>This allows the stream sink to complete any remaining work and release\nresources that are no longer needed<\/p>\n<p>Returns a future which is completed when the stream sink has shut down.\nIf cleaning up can fail, the error may be reported in the returned future,\notherwise it completes with <code>null<\/code>.<\/p>\n<p>Returns the same future as <a href=\"package-async_async\/DelegatingStreamSink\/done.html\">done<\/a>.<\/p>\n<p>The stream sink may close before the <a href=\"package-async_async\/DelegatingStreamSink\/close.html\">close<\/a> method is called, either due\nto an error or because it is itself providing events to someone who has\nstopped listening. In that case, the <a href=\"package-async_async\/DelegatingStreamSink\/done.html\">done<\/a> future is completed first,\nand the <code>close<\/code> method will return the <code>done<\/code> future when called.<\/p>\n<p>Unifies <a href=\"package-async_async\/DelegatingStreamSink\/close.html\">StreamConsumer.close<\/a> and <a href=\"package-async_async\/DelegatingStreamSink\/close.html\">EventSink.close<\/a> which both mark their\nobject as not expecting any further events.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSink",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSink\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close() =&gt; _sink.close();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "typed",
                    "type": "dart:async.StreamSink",
                    "desc": "<p>Creates a wrapper that coerces the type of <code>sink<\/code>.<\/p>\n<p>Unlike <a href=\"dart-async\/StreamSink\/StreamSink.html\">new StreamSink<\/a>, this only requires its argument to be an instance\nof <code>StreamSink<\/code>, not <code>StreamSink&lt;T&gt;<\/code>. This means that calls to <a href=\"package-async_async\/DelegatingStreamSink\/add.html\">add<\/a> may\nthrow a <a href=\"dart-core\/CastError-class.html\">CastError<\/a> if the argument type doesn't match the reified type of\n<code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSink\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamSink&lt;T&gt; typed&lt;T&gt;(StreamSink sink) =&gt;\n    sink is StreamSink&lt;T&gt; ? sink : new DelegatingStreamSink._(sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "done",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>Return a future which is completed when the <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> is finished.<\/p>\n<p>If the <code>StreamSink<\/code> fails with an error,\nperhaps in response to adding events using <a href=\"package-async_async\/DelegatingStreamSink\/add.html\">add<\/a>, <a href=\"package-async_async\/DelegatingStreamSink\/addError.html\">addError<\/a> or <a href=\"package-async_async\/DelegatingStreamSink\/close.html\">close<\/a>,\nthe <a href=\"package-async_async\/DelegatingStreamSink\/done.html\">done<\/a> future will complete with that error.<\/p>\n<p>Otherwise, the returned future will complete when either:<\/p>\n<ul>\n<li>all events have been processed and the sink has been closed, or<\/li>\n<li>the sink has otherwise been stopped from handling more events\n(for example by canceling a stream subscription).<\/li>\n<\/ul>",
                    "memberOf": "async.DelegatingStreamSink",
                    "isConstant": false,
                    "href": "package-async_async\/DelegatingStreamSink\/done.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future get done =&gt; _sink.done;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [
                "web_socket_channel.WebSocketSink"
            ],
            "realImplementors": [
                "web_socket_channel.WebSocketSink"
            ],
            "cn": [],
            "href": "package-async_async\/DelegatingStreamSink-class.html",
            "desc": "<p>Simple delegating wrapper around a <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a>.<\/p>\n<p>Subclasses can override individual methods, or use this to expose only the\n<a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> methods of a subclass.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingStreamSink"
        },
        {
            "name": "async.DelegatingStreamSubscription",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "DelegatingStreamSubscription",
                    "type": "",
                    "desc": "<p>Create delegating subscription forwarding calls to <code>sourceSubscription<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "sourceSubscription",
                            "type": "dart:async.StreamSubscription",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/DelegatingStreamSubscription\/DelegatingStreamSubscription.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DelegatingStreamSubscription(StreamSubscription&lt;T&gt; sourceSubscription)\n    : _source = sourceSubscription;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "asFuture",
                    "type": "dart:async.Future",
                    "desc": "<p>Returns a future that handles the <a href=\"package-async_async\/DelegatingStreamSubscription\/onDone.html\">onDone<\/a> and <a href=\"package-async_async\/DelegatingStreamSubscription\/onError.html\">onError<\/a> callbacks.<\/p>\n<p>This method <em>overwrites<\/em> the existing <a href=\"package-async_async\/DelegatingStreamSubscription\/onDone.html\">onDone<\/a> and <a href=\"package-async_async\/DelegatingStreamSubscription\/onError.html\">onError<\/a> callbacks\nwith new ones that complete the returned future.<\/p>\n<p>In case of an error the subscription will automatically cancel (even\nwhen it was listening with <code>cancelOnError<\/code> set to <code>false<\/code>).<\/p>\n<p>In case of a <code>done<\/code> event the future completes with the given\n<code>futureValue<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "futureValue",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/asFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;E&gt; asFuture&lt;E&gt;([E futureValue]) =&gt; _source.asFuture(futureValue);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "cancel",
                    "type": "dart:async.Future",
                    "desc": "<p>Cancels this subscription.<\/p>\n<p>After this call, the subscription no longer receives events.<\/p>\n<p>The stream may need to shut down the source of events and clean up after\nthe subscription is canceled.<\/p>\n<p>Returns a future that is completed once the stream has finished\nits cleanup.<\/p>\n<p>For historical reasons, may also return <code>null<\/code> if no cleanup was necessary.\nReturning <code>null<\/code> is deprecated and should be avoided.<\/p>\n<p>Typically, futures are returned when the stream needs to release resources.\nFor example, a stream might need to close an open file (as an asynchronous\noperation). If the listener wants to delete the file after having\ncanceled the subscription, it must wait for the cleanup future to complete.<\/p>\n<p>A returned future completes with a <code>null<\/code> value.\nIf the cleanup throws, which it really shouldn't, the returned future\ncompletes with that error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/cancel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future cancel() =&gt; _source.cancel();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "onData",
                    "type": "",
                    "desc": "<p>Replaces the data event handler of this subscription.<\/p>\n<p>The <code>handleData<\/code> function is called for each element of the stream\nafter this function is called.\nIf <code>handleData<\/code> is <code>null<\/code>, further elements are ignored.<\/p>\n<p>This method replaces the current handler set by the invocation of\n<a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a> or by a previous call to <a href=\"package-async_async\/DelegatingStreamSubscription\/onData.html\">onData<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/onData.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void onData(void handleData(T data)) {\n  _source.onData(handleData);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "onDone",
                    "type": "",
                    "desc": "<p>Replaces the done event handler of this subscription.<\/p>\n<p>The <code>handleDone<\/code> function is called when the stream closes.\nThe value may be <code>null<\/code>, in which case no function is called.<\/p>\n<p>This method replaces the current handler set by the invocation of\n<a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>, by calling <a href=\"package-async_async\/DelegatingStreamSubscription\/asFuture.html\">asFuture<\/a>, or by a previous call to <a href=\"package-async_async\/DelegatingStreamSubscription\/onDone.html\">onDone<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "handleDone",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/onDone.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void onDone(void handleDone()) {\n  _source.onDone(handleDone);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "onError",
                    "type": "",
                    "desc": "<p>Replaces the error event handler of this subscription.<\/p>\n<p>The <code>handleError<\/code> function must be able to be called with either\none positional argument, or with two positional arguments\nwhere the seconds is always a <a href=\"dart-core\/StackTrace-class.html\">StackTrace<\/a>.<\/p>\n<p>The <code>handleError<\/code> argument may be <code>null<\/code>, in which case further\nerror events are considered unhandled, and will be reported to\n<a href=\"dart-async\/Zone\/handleUncaughtError.html\">Zone.handleUncaughtError<\/a>.<\/p>\n<p>The provided function is called for all error events from the\nstream subscription.<\/p>\n<p>This method replaces the current handler set by the invocation of\n<a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>, by calling <a href=\"package-async_async\/DelegatingStreamSubscription\/asFuture.html\">asFuture<\/a>, or by a previous call to <a href=\"package-async_async\/DelegatingStreamSubscription\/onError.html\">onError<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "handleError",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/onError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void onError(Function handleError) {\n  _source.onError(handleError);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "pause",
                    "type": "",
                    "desc": "<p>Request that the stream pauses events until further notice.<\/p>\n<p>While paused, the subscription will not fire any events.\nIf it receives events from its source, they will be buffered until\nthe subscription is resumed.\nFor non-broadcast streams, the underlying source is usually informed\nabout the pause,\nso it can stop generating events until the subscription is resumed.<\/p>\n<p>To avoid buffering events on a broadcast stream, it is better to\ncancel this subscription, and start to listen again when events\nare needed, if the intermediate events are not important.<\/p>\n<p>If <code>resumeSignal<\/code> is provided, the stream subscription will undo the pause\nwhen the future completes, as if by a call to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a>.\nIf the future completes with an error,\nthe stream will still resume, but the error will be considered unhandled\nand is passed to <a href=\"dart-async\/Zone\/handleUncaughtError.html\">Zone.handleUncaughtError<\/a>.<\/p>\n<p>A call to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a> will also undo a pause.<\/p>\n<p>If the subscription is paused more than once, an equal number\nof resumes must be performed to resume the stream.\nCalls to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a> and the completion of a <code>resumeSignal<\/code> are\ninterchangeable - the <a href=\"package-async_async\/DelegatingStreamSubscription\/pause.html\">pause<\/a> which was passed a <code>resumeSignal<\/code> may be\nended by a call to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a>, and completing the <code>resumeSignal<\/code> may end a\ndifferent <a href=\"package-async_async\/DelegatingStreamSubscription\/pause.html\">pause<\/a>.<\/p>\n<p>It is safe to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a> or complete a <code>resumeSignal<\/code> even when the\nsubscription is not paused, and the resume will have no effect.<\/p>\n<p>Currently DOM streams silently drop events when the stream is paused. This\nis a bug and will be fixed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "resumeFuture",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/pause.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void pause([Future resumeFuture]) {\n  _source.pause(resumeFuture);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "resume",
                    "type": "",
                    "desc": "<p>Resume after a pause.<\/p>\n<p>This undoes one previous call to <a href=\"package-async_async\/DelegatingStreamSubscription\/pause.html\">pause<\/a>.\nWhen all previously calls to <a href=\"package-async_async\/DelegatingStreamSubscription\/pause.html\">pause<\/a> have been matched by a calls to\n<a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a>, possibly through a <code>resumeSignal<\/code> passed to <a href=\"package-async_async\/DelegatingStreamSubscription\/pause.html\">pause<\/a>,\nthe stream subscription may emit events again.<\/p>\n<p>It is safe to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a> even when the subscription is not paused, and the\nresume will have no effect.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/resume.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void resume() {\n  _source.resume();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "typed",
                    "type": "dart:async.StreamSubscription",
                    "desc": "<p>Creates a wrapper which throws if <code>subscription<\/code>'s events aren't instances\nof <code>T<\/code>.<\/p>\n<p>This soundly converts a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> to a <code>StreamSubscription&lt;T&gt;<\/code>,\nregardless of its original generic type, by asserting that its events are\ninstances of <code>T<\/code> whenever they're provided. If they're not, the\nsubscription throws a <a href=\"dart-core\/CastError-class.html\">CastError<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.DelegatingStreamSubscription",
                    "sig": "",
                    "params": [
                        {
                            "name": "subscription",
                            "type": "dart:async.StreamSubscription",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamSubscription&lt;T&gt; typed&lt;T&gt;(StreamSubscription subscription) =&gt;\n    subscription is StreamSubscription&lt;T&gt;\n        ? subscription\n        : new TypeSafeStreamSubscription&lt;T&gt;(subscription);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "isPaused",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether the <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> is currently paused.<\/p>\n<p>If there have been more calls to <a href=\"package-async_async\/DelegatingStreamSubscription\/pause.html\">pause<\/a> than to <a href=\"package-async_async\/DelegatingStreamSubscription\/resume.html\">resume<\/a> on this\nstream subscription, the subscription is paused, and this getter\nreturns <code>true<\/code>.<\/p>\n<p>Returns <code>false<\/code> if the stream can currently emit events, or if\nthe subscription has completed or been cancelled.<\/p>\n        ",
                    "memberOf": "async.DelegatingStreamSubscription",
                    "isConstant": false,
                    "href": "package-async_async\/DelegatingStreamSubscription\/isPaused.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isPaused =&gt; _source.isPaused;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/DelegatingStreamSubscription-class.html",
            "desc": "<p>Simple delegating wrapper around a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>.<\/p>\n<p>Subclasses can override individual methods.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "DelegatingStreamSubscription"
        },
        {
            "name": "async.ErrorResult",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "operator ==",
                    "type": "dart:core.bool",
                    "desc": "<p>This is equal only to an error result with equal <a href=\"package-async_async\/ErrorResult\/error.html\">error<\/a> and <a href=\"package-async_async\/ErrorResult\/stackTrace.html\">stackTrace<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ErrorResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "other",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ErrorResult\/operator_equals.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool operator ==(Object other) =&gt;\n    other is ErrorResult &amp;&amp;\n    error == other.error &amp;&amp;\n    stackTrace == other.stackTrace;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "ErrorResult",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.ErrorResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/ErrorResult\/ErrorResult.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ErrorResult(this.error, this.stackTrace);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "addTo",
                    "type": "",
                    "desc": "<p>Adds this result to an <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a>.<\/p>\n<p>Calls the sink's <code>add<\/code> or <code>addError<\/code> method as appropriate.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ErrorResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ErrorResult\/addTo.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addTo(EventSink sink) {\n  sink.addError(error, stackTrace);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "complete",
                    "type": "",
                    "desc": "<p>Completes a completer with this result.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ErrorResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "completer",
                            "type": "dart:async.Completer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ErrorResult\/complete.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void complete(Completer completer) {\n  completer.completeError(error, stackTrace);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "handle",
                    "type": "",
                    "desc": "<p>Calls an error handler with the error and stacktrace.<\/p>\n<p>An async error handler function is either a function expecting two\narguments, which will be called with the error and the stack trace, or it\nhas to be a function expecting only one argument, which will be called\nwith only the error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ErrorResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "errorHandler",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ErrorResult\/handle.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void handle(Function errorHandler) {\n  if (errorHandler is ZoneBinaryCallback) {\n    errorHandler(error, stackTrace);\n  } else {\n    errorHandler(error);\n  }\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "asError",
                    "type": "async.ErrorResult",
                    "types": [],
                    "desc": "<p>If this is an error result, returns itself.<\/p>\n<p>Otherwise returns <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/asError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ErrorResult get asError =&gt; this;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "asFuture",
                    "type": "dart:async.Future<dart:core.Null>",
                    "types": [
                        "dart:async.Future",
                        "dart:core.Null"
                    ],
                    "desc": "<p>A future that has been completed with this result as a value or an error.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/asFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;Null&gt; get asFuture =&gt; new Future&lt;Null&gt;.error(error, stackTrace);<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "asValue",
                    "type": "async.ValueResult<dart:core.Null>",
                    "types": [
                        "async.ValueResult",
                        "dart:core.Null"
                    ],
                    "desc": "<p>If this is a value result, returns itself.<\/p>\n<p>Otherwise returns <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/asValue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ValueResult&lt;Null&gt; get asValue =&gt; null;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "error",
                    "type": "dart:core.Object",
                    "types": [],
                    "desc": "<p>The error object that was thrown.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/error.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Object error\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "hashCode",
                    "type": "dart:core.int",
                    "types": [],
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"package-async_async\/ErrorResult\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"package-async_async\/ErrorResult\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"package-async_async\/ErrorResult\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"package-async_async\/ErrorResult\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"package-async_async\/ErrorResult\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"package-async_async\/ErrorResult\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/hashCode.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get hashCode =&gt; error.hashCode ^ stackTrace.hashCode ^ 0x1d61823f;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isError",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this result is an error result.<\/p>\n<p>Always the opposite of <a href=\"package-async_async\/ErrorResult\/isValue.html\">isValue<\/a>.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/isError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isError =&gt; true;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isValue",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this result is a value result.<\/p>\n<p>Always the opposite of <a href=\"package-async_async\/ErrorResult\/isError.html\">isError<\/a>.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/isValue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isValue =&gt; false;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stackTrace",
                    "type": "dart:core.StackTrace",
                    "types": [],
                    "desc": "<p>The stack trace corresponding to where <a href=\"package-async_async\/ErrorResult\/error.html\">error<\/a> was thrown.<\/p>\n        ",
                    "memberOf": "async.ErrorResult",
                    "isConstant": false,
                    "href": "package-async_async\/ErrorResult\/stackTrace.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final StackTrace stackTrace\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/ErrorResult-class.html",
            "desc": "<p>A result representing a thrown error.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "ErrorResult"
        },
        {
            "name": "async.FutureGroup",
            "extends": [],
            "memberOf": "async",
            "events": [
                {
                    "name": "onIdle",
                    "type": "dart:async.Stream",
                    "desc": "<p>A broadcast stream that emits a <code>null<\/code> event whenever the last pending\nfuture in this group completes.<\/p>\n<p>Once this group isn't waiting on any futures <em>and<\/em> <a href=\"package-async_async\/FutureGroup\/close.html\">close<\/a> has been\ncalled, this stream will close.<\/p>\n        ",
                    "static": false,
                    "memberOf": "",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/FutureGroup\/onIdle.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream get onIdle {\n  if (_onIdleController == null) {\n    _onIdleController = new StreamController.broadcast(sync: true);\n  }\n  return _onIdleController.stream;\n}<\/code><\/pre>\n        ",
                    "isDeprecated": false,
                    "isConstant": false
                }
            ],
            "methods": [
                {
                    "name": "FutureGroup",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.FutureGroup",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/FutureGroup\/FutureGroup.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "add",
                    "type": "",
                    "desc": "<p>Wait for <code>task<\/code> to complete.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.FutureGroup",
                    "sig": "",
                    "params": [
                        {
                            "name": "task",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/FutureGroup\/add.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(Future&lt;T&gt; task) {\n  if (_closed) throw new StateError(\"The FutureGroup is closed.\");\n\n  \/\/ Ensure that future values are put into [values] in the same order they're\n  \/\/ added to the group by pre-allocating a slot for them and recording its\n  \/\/ index.\n  var index = _values.length;\n  _values.add(null);\n\n  _pending++;\n  task.then((value) {\n    if (_completer.isCompleted) return null;\n\n    _pending--;\n    _values[index] = value;\n\n    if (_pending != 0) return null;\n    if (_onIdleController != null) _onIdleController.add(null);\n\n    if (!_closed) return null;\n    if (_onIdleController != null) _onIdleController.close();\n    _completer.complete(_values);\n  }).catchError((error, stackTrace) {\n    if (_completer.isCompleted) return null;\n    _completer.completeError(error, stackTrace);\n  });\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "close",
                    "type": "",
                    "desc": "<p>Signals to the group that the caller is done adding futures, and so\n<a href=\"package-async_async\/FutureGroup\/future.html\">future<\/a> should fire once all added futures have completed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.FutureGroup",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/FutureGroup\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void close() {\n  _closed = true;\n  if (_pending != 0) return;\n  if (_completer.isCompleted) return;\n  _completer.complete(_values);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "future",
                    "type": "dart:async.Future<dart:core.List>",
                    "types": [
                        "dart:async.Future",
                        "dart:core.List"
                    ],
                    "desc": "<p>The future that fires once <a href=\"package-async_async\/FutureGroup\/close.html\">close<\/a> has been called and all futures in the\ngroup have completed.<\/p>\n<p>This will also complete with an error if any of the futures in the group\nfails, regardless of whether <a href=\"package-async_async\/FutureGroup\/close.html\">close<\/a> was called.<\/p>\n        ",
                    "memberOf": "async.FutureGroup",
                    "isConstant": false,
                    "href": "package-async_async\/FutureGroup\/future.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;List&lt;T&gt;&gt; get future =&gt; _completer.future;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isIdle",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this group has no pending futures.<\/p>\n        ",
                    "memberOf": "async.FutureGroup",
                    "isConstant": false,
                    "href": "package-async_async\/FutureGroup\/isIdle.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isIdle =&gt; _pending == 0;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/FutureGroup-class.html",
            "desc": "<p>A collection of futures waits until all added <a href=\"dart-async\/Future-class.html\">Future<\/a>s complete.<\/p>\n<p>Futures are added to the group with <a href=\"package-async_async\/FutureGroup\/add.html\">add<\/a>. Once you're finished adding\nfutures, signal that by calling <a href=\"package-async_async\/FutureGroup\/close.html\">close<\/a>. Then, once all added futures have\ncompleted, <a href=\"package-async_async\/FutureGroup\/future.html\">future<\/a> will complete with a list of values from the futures in\nthe group, in the order they were added.<\/p>\n<p>If any added future completes with an error, <a href=\"package-async_async\/FutureGroup\/future.html\">future<\/a> will emit that error\nand the group will be closed, regardless of the state of other futures in\nthe group.<\/p>\n<p>This is similar to <a href=\"dart-async\/Future\/wait.html\">Future.wait<\/a> with <code>eagerError<\/code> set to <code>true<\/code>, except\nthat a <a href=\"package-async_async\/FutureGroup-class.html\">FutureGroup<\/a> can have futures added gradually over time rather than\nneeding them all at once.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "FutureGroup"
        },
        {
            "name": "async.LazyStream",
            "extends": [
                "dart:async.Stream",
                "dart:core.Object"
            ],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "LazyStream",
                    "type": "",
                    "desc": "<p>Creates a single-subscription <code>Stream<\/code> that calls <code>callback<\/code> when it gets\na listener and forwards to the returned stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.LazyStream",
                    "sig": "",
                    "params": [
                        {
                            "name": "callback",
                            "type": "dart:async.FutureOr<dart:async.Stream>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.FutureOr",
                                "dart:async.Stream"
                            ]
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/LazyStream\/LazyStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">LazyStream(FutureOr&lt;Stream&lt;T&gt;&gt; callback()) : _callback = callback {\n  \/\/ Explicitly check for null because we null out [_callback] internally.\n  if (_callback == null) throw new ArgumentError.notNull('callback');\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "listen",
                    "type": "dart:async.StreamSubscription",
                    "desc": "<p>Adds a subscription to this stream.<\/p>\n<p>Returns a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> which handles events from this stream using\nthe provided <code>onData<\/code>, <code>onError<\/code> and <code>onDone<\/code> handlers.\nThe handlers can be changed on the subscription, but they start out\nas the provided functions.<\/p>\n<p>On each data event from this stream, the subscriber's <code>onData<\/code> handler\nis called. If <code>onData<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>On errors from this stream, the <code>onError<\/code> handler is called with the\nerror object and possibly a stack trace.<\/p>\n<p>The <code>onError<\/code> callback must be of type <code>void onError(error)<\/code> or\n<code>void onError(error, StackTrace stackTrace)<\/code>. If <code>onError<\/code> accepts\ntwo arguments it is called with the error object and the stack trace\n(which could be <code>null<\/code> if this stream itself received an error without\nstack trace).\nOtherwise it is called with just the error object.\nIf <code>onError<\/code> is omitted, any errors on this stream are considered unhandled,\nand will be passed to the current <a href=\"dart-async\/Zone-class.html\">Zone<\/a>'s error handler.\nBy default unhandled async errors are treated\nas if they were uncaught top-level errors.<\/p>\n<p>If this stream closes and sends a done event, the <code>onDone<\/code> handler is\ncalled. If <code>onDone<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>If <code>cancelOnError<\/code> is true, the subscription is automatically canceled\nwhen the first error event is delivered. The default is <code>false<\/code>.<\/p>\n<p>While a subscription is paused, or when it has been canceled,\nthe subscription doesn't receive events and none of the\nevent handler functions are called.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.LazyStream",
                    "sig": "",
                    "params": [
                        {
                            "name": "event",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "event",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "onError",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "onDone",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "cancelOnError",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/LazyStream\/listen.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSubscription&lt;T&gt; listen(void onData(T event),\n    {Function onError, void onDone(), bool cancelOnError}) {\n  if (_callback == null) {\n    throw new StateError(\"Stream has already been listened to.\");\n  }\n\n  \/\/ Null out the callback before we invoke it to ensure that even while\n  \/\/ running it, this can't be called twice.\n  var callback = _callback;\n  _callback = null;\n  var result = callback();\n\n  Stream&lt;T&gt; stream;\n  if (result is Future&lt;Stream&lt;T&gt;&gt;) {\n    stream = StreamCompleter.fromFuture(result.then((stream) {\n      return DelegatingStream.typed&lt;T&gt;(stream);\n    }));\n  } else {\n    stream = DelegatingStream.typed&lt;T&gt;(result as Stream);\n  }\n\n  return stream.listen(onData,\n      onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/LazyStream-class.html",
            "desc": "<p>A <a href=\"dart-async\/Stream-class.html\">Stream<\/a> wrapper that forwards to another <a href=\"dart-async\/Stream-class.html\">Stream<\/a> that's initialized\nlazily.<\/p>\n<p>This class allows a concrete <code>Stream<\/code> to be created only once it has a\nlistener. It's useful to wrapping APIs that do expensive computation to\nproduce a <code>Stream<\/code>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "LazyStream"
        },
        {
            "name": "async.NullStreamSink",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "NullStreamSink",
                    "type": "",
                    "desc": "<p>Creates a null sink.<\/p>\n<p>If <code>done<\/code> is passed, it's used as the <a href=\"package-async_async\/NullStreamSink\/done.html\">Sink.done<\/a> future. Otherwise, a\ncompleted future is used.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.NullStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "done",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/NullStreamSink\/NullStreamSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">NullStreamSink({Future done}) : done = done ?? new Future.value();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "add",
                    "type": "",
                    "desc": "<p>Adds a data <code>event<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.NullStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/NullStreamSink\/add.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T data) {\n  _checkEventAllowed();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "addError",
                    "type": "",
                    "desc": "<p>Adds an <code>error<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.NullStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/NullStreamSink\/addError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(error, [StackTrace stackTrace]) {\n  _checkEventAllowed();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "addStream",
                    "type": "dart:async.Future",
                    "desc": "<p>Consumes the elements of <code>stream<\/code>.<\/p>\n<p>Listens on <code>stream<\/code> and does something for each event.<\/p>\n<p>Returns a future which is completed when the stream is done being added,\nand the consumer is ready to accept a new stream.\nNo further calls to <a href=\"package-async_async\/NullStreamSink\/addStream.html\">addStream<\/a> or <a href=\"package-async_async\/NullStreamSink\/close.html\">close<\/a> should happen before the\nreturned future has completed.<\/p>\n<p>The consumer may stop listening to the stream after an error,\nit may consume all the errors and only stop at a done event,\nor it may be canceled early if the receiver don't want any further events.<\/p>\n<p>If the consumer stops listening because of some error preventing it\nfrom continuing, it may report this error in the returned future,\notherwise it will just complete the future with <code>null<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.NullStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/NullStreamSink\/addStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future addStream(Stream&lt;T&gt; stream) {\n  _checkEventAllowed();\n\n  _addingStream = true;\n  var future = stream.listen(null).cancel() ?? new Future.value();\n  return future.whenComplete(() {\n    _addingStream = false;\n  });\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "close",
                    "type": "dart:async.Future",
                    "desc": "<p>Tells the stream sink that no further streams will be added.<\/p>\n<p>This allows the stream sink to complete any remaining work and release\nresources that are no longer needed<\/p>\n<p>Returns a future which is completed when the stream sink has shut down.\nIf cleaning up can fail, the error may be reported in the returned future,\notherwise it completes with <code>null<\/code>.<\/p>\n<p>Returns the same future as <a href=\"package-async_async\/NullStreamSink\/done.html\">done<\/a>.<\/p>\n<p>The stream sink may close before the <a href=\"package-async_async\/NullStreamSink\/close.html\">close<\/a> method is called, either due\nto an error or because it is itself providing events to someone who has\nstopped listening. In that case, the <a href=\"package-async_async\/NullStreamSink\/done.html\">done<\/a> future is completed first,\nand the <code>close<\/code> method will return the <code>done<\/code> future when called.<\/p>\n<p>Unifies <a href=\"package-async_async\/NullStreamSink\/close.html\">StreamConsumer.close<\/a> and <a href=\"package-async_async\/NullStreamSink\/close.html\">EventSink.close<\/a> which both mark their\nobject as not expecting any further events.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.NullStreamSink",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/NullStreamSink\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close() {\n  _closed = true;\n  return done;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "NullStreamSink.error",
                    "type": "",
                    "desc": "<p>Creates a null sink whose <a href=\"package-async_async\/NullStreamSink\/done.html\">done<\/a> future emits <code>error<\/code>.<\/p>\n<p>Note that this error will not be considered uncaught.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.NullStreamSink",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/NullStreamSink\/NullStreamSink.error.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">NullStreamSink.error(error, [StackTrace stackTrace])\n    : done = new Future.error(error, stackTrace)\n        \/\/ Don't top-level the error. This gives the user a change to call\n        \/\/ [close] or [done], and matches the behavior of a remote endpoint\n        \/\/ experiencing an error.\n        ..catchError((_) {});<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "done",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>Return a future which is completed when the <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> is finished.<\/p>\n<p>If the <code>StreamSink<\/code> fails with an error,\nperhaps in response to adding events using <a href=\"package-async_async\/NullStreamSink\/add.html\">add<\/a>, <a href=\"package-async_async\/NullStreamSink\/addError.html\">addError<\/a> or <a href=\"package-async_async\/NullStreamSink\/close.html\">close<\/a>,\nthe <a href=\"package-async_async\/NullStreamSink\/done.html\">done<\/a> future will complete with that error.<\/p>\n<p>Otherwise, the returned future will complete when either:<\/p>\n<ul>\n<li>all events have been processed and the sink has been closed, or<\/li>\n<li>the sink has otherwise been stopped from handling more events\n(for example by canceling a stream subscription).<\/li>\n<\/ul>",
                    "memberOf": "async.NullStreamSink",
                    "isConstant": false,
                    "href": "package-async_async\/NullStreamSink\/done.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Future done\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/NullStreamSink-class.html",
            "desc": "<p>A <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> that discards all events.<\/p>\n<p>The sink silently drops events until <a href=\"package-async_async\/NullStreamSink\/close.html\">close<\/a> is called, at which point it\nthrows <a href=\"dart-core\/StateError-class.html\">StateError<\/a>s when events are added. This is the same behavior as a\nsink whose remote end has closed, such as when a <a href=\"dart-io\/WebSocket-class.html\">WebSocket<\/a> connection has\nbeen closed.<\/p>\n<p>This can be used when a sink is needed but no events are actually intended\nto be added. The <a href=\"package-async_async\/NullStreamSink\/NullStreamSink.error.html\">new NullStreamSink.error<\/a> constructor can be used to\nrepresent errors when creating a sink, since <a href=\"package-async_async\/NullStreamSink\/done.html\">StreamSink.done<\/a> exposes sink\nerrors. For example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;List&lt;int&gt;&gt; openForWrite(String filename) {\n  try {\n    return new RandomAccessSink(new File(filename).openSync());\n  } on IOException catch (error, stackTrace) {\n    return new NullStreamSink.error(error, stackTrace);\n  }\n}\n<\/code><\/pre>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "NullStreamSink"
        },
        {
            "name": "async.RestartableTimer",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "RestartableTimer",
                    "type": "",
                    "desc": "<p>Creates a new timer.<\/p>\n<p>The <code>callback<\/code> function is invoked after the given <code>duration<\/code>. Unlike a\nnormal non-periodic <a href=\"dart-async\/Timer-class.html\">Timer<\/a>, <code>callback<\/code> may be called more than once.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.RestartableTimer",
                    "sig": "",
                    "params": [
                        {
                            "name": "_duration",
                            "type": "dart:core.Duration",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "_callback",
                            "type": "dart:async.ZoneCallback",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/RestartableTimer\/RestartableTimer.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RestartableTimer(this._duration, this._callback) {\n  _timer = new Timer(_duration, _callback);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "cancel",
                    "type": "",
                    "desc": "<p>Cancels the timer.<\/p>\n<p>Once a <a href=\"dart-async\/Timer-class.html\">Timer<\/a> has been canceled, the callback function will not be called\nby the timer. Calling <a href=\"package-async_async\/RestartableTimer\/cancel.html\">cancel<\/a> more than once on a <a href=\"dart-async\/Timer-class.html\">Timer<\/a> is allowed, and\nwill have no further effect.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.RestartableTimer",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/RestartableTimer\/cancel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void cancel() {\n  _timer.cancel();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "reset",
                    "type": "",
                    "desc": "<p>Restarts the timer so that it counts down from its original duration\nagain.<\/p>\n<p>This restarts the timer even if it has already fired or has been canceled.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.RestartableTimer",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/RestartableTimer\/reset.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void reset() {\n  _timer.cancel();\n  _timer = new Timer(_duration, _callback);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "isActive",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Returns whether the timer is still active.<\/p>\n<p>A non-periodic timer is active if the callback has not been executed,\nand the timer has not been canceled.<\/p>\n<p>A periodic timer is active if it has not been canceled.<\/p>\n        ",
                    "memberOf": "async.RestartableTimer",
                    "isConstant": false,
                    "href": "package-async_async\/RestartableTimer\/isActive.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isActive =&gt; _timer.isActive;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "tick",
                    "type": "dart:core.int",
                    "types": [],
                    "desc": "<p>The number of durations preceding the most recent timer event.<\/p>\n<p>The value starts at zero and is incremented each time a timer event\noccurs, so each callback will see a larger value than the previous one.<\/p>\n<p>If a periodic timer with a non-zero duration is delayed too much,\nso more than one tick should have happened,\nall but the last tick in the past are considered \"missed\",\nand no callback is invoked for them.\nThe <a href=\"package-async_async\/RestartableTimer\/tick.html\">tick<\/a> count reflects the number of durations that have passed and\nnot the number of callback invocations that have happened.<\/p>\n        ",
                    "memberOf": "async.RestartableTimer",
                    "isConstant": false,
                    "href": "package-async_async\/RestartableTimer\/tick.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\n\/\/ TODO: Dart 2.0 requires this method to be implemented.\n\/\/ See https:\/\/github.com\/dart-lang\/sdk\/issues\/31664\n\/\/ ignore: override_on_non_overriding_getter\nint get tick {\n  throw new UnimplementedError(\"tick\");\n}<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/RestartableTimer-class.html",
            "desc": "<p>A non-periodic timer that can be restarted any number of times.<\/p>\n<p>Once restarted (via <a href=\"package-async_async\/RestartableTimer\/reset.html\">reset<\/a>), the timer counts down from its original\nduration again.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "RestartableTimer"
        },
        {
            "name": "async.Result",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "Result",
                    "type": "",
                    "desc": "<p>Creates a <code>Result<\/code> with the result of calling <code>computation<\/code>.<\/p>\n<p>This generates either a <a href=\"package-async_async\/ValueResult-class.html\">ValueResult<\/a> with the value returned by\ncalling <code>computation<\/code>, or an <a href=\"package-async_async\/ErrorResult-class.html\">ErrorResult<\/a> with an error thrown by\nthe call.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "computation",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/Result\/Result.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Result(T computation()) {\n  try {\n    return new ValueResult&lt;T&gt;(computation());\n  } catch (e, s) {\n    return new ErrorResult(e, s);\n  }\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "addTo",
                    "type": "",
                    "desc": "<p>Adds this result to an <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a>.<\/p>\n<p>Calls the sink's <code>add<\/code> or <code>addError<\/code> method as appropriate.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/addTo.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addTo(EventSink&lt;T&gt; sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "capture",
                    "type": "dart:async.Future<async.Result>",
                    "desc": "<p>Captures the result of a future into a <code>Result<\/code> future.<\/p>\n<p>The resulting future will never have an error.\nErrors have been converted to an <a href=\"package-async_async\/ErrorResult-class.html\">ErrorResult<\/a> value.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "future",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/capture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;Result&lt;T&gt;&gt; capture&lt;T&gt;(Future&lt;T&gt; future) {\n  return future.then((value) =&gt; new ValueResult(value),\n      onError: (error, stackTrace) =&gt; new ErrorResult(error, stackTrace));\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "async.Result"
                    ]
                },
                {
                    "name": "captureAll",
                    "type": "dart:async.Future<dart:core.List<async.Result>>",
                    "desc": "<p>Captures each future in <code>elements<\/code>,<\/p>\n<p>Returns a (future of) a list of results for each element in <code>elements<\/code>,\nin iteration order.\nEach future in <code>elements<\/code> is <a href=\"package-async_async\/Result\/capture.html\">capture<\/a>d and each non-future is\nwrapped as a <a href=\"package-async_async\/Result\/Result.value.html\">Result.value<\/a>.\nThe returned future will never have an error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "elements",
                            "type": "dart:core.Iterable<dart:async.FutureOr>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Iterable",
                                "dart:async.FutureOr"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/captureAll.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;List&lt;Result&lt;T&gt;&gt;&gt; captureAll&lt;T&gt;(Iterable&lt;FutureOr&lt;T&gt;&gt; elements) {\n  var results = &lt;Result&lt;T&gt;&gt;[];\n  int pending = 0;\n  Completer&lt;List&lt;Result&lt;T&gt;&gt;&gt; completer;\n  for (var element in elements) {\n    if (element is Future&lt;T&gt;) {\n      int i = results.length;\n      results.add(null);\n      pending++;\n      Result.capture&lt;T&gt;(element).then((result) {\n        results[i] = result;\n        if (--pending == 0) {\n          completer.complete(results);\n        }\n      });\n    } else {\n      results.add(new Result&lt;T&gt;.value(element));\n    }\n  }\n  if (pending == 0) {\n    return new Future&lt;List&lt;Result&lt;T&gt;&gt;&gt;.value(results);\n  }\n  completer = new Completer&lt;List&lt;Result&lt;T&gt;&gt;&gt;();\n  return completer.future;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.List",
                        "async.Result"
                    ]
                },
                {
                    "name": "captureSink",
                    "type": "dart:async.EventSink",
                    "desc": "<p>Captures the events of the returned sink into results on <code>sink<\/code>.<\/p>\n<p>Data and error events added to the returned sink are captured into\n<a href=\"package-async_async\/Result-class.html\">Result<\/a> values and added as data events on the provided <code>sink<\/code>.\nNo error events are ever added to <code>sink<\/code>.<\/p>\n<p>When the returned sink is closed, so is <code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink<async.Result>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.EventSink",
                                "async.Result"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/captureSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static EventSink&lt;T&gt; captureSink&lt;T&gt;(EventSink&lt;Result&lt;T&gt;&gt; sink) =&gt;\n    new CaptureSink&lt;T&gt;(sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "captureStream",
                    "type": "dart:async.Stream<async.Result>",
                    "desc": "<p>Captures the results of a stream into a stream of <a href=\"package-async_async\/Result-class.html\">Result<\/a> values.<\/p>\n<p>The returned stream will not have any error events.\nErrors from the source stream have been converted to <a href=\"package-async_async\/ErrorResult-class.html\">ErrorResult<\/a>s.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "source",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/captureStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Stream&lt;Result&lt;T&gt;&gt; captureStream&lt;T&gt;(Stream&lt;T&gt; source) =&gt;\n    source.transform(new CaptureStreamTransformer&lt;T&gt;());<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Stream",
                        "async.Result"
                    ]
                },
                {
                    "name": "complete",
                    "type": "",
                    "desc": "<p>Completes a completer with this result.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "completer",
                            "type": "dart:async.Completer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/complete.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void complete(Completer&lt;T&gt; completer);<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "Result.error",
                    "type": "",
                    "desc": "<p>Creates a <code>Result<\/code> holding an error.<\/p>\n<p>Alias for <a href=\"package-async_async\/ErrorResult\/ErrorResult.html\">ErrorResult.ErrorResult<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/Result\/Result.error.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Result.error(Object error, [StackTrace stackTrace]) =&gt;\n    new ErrorResult(error, stackTrace);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "flatten",
                    "type": "async.Result",
                    "desc": "<p>Converts a result of a result to a single result.<\/p>\n<p>If the result is an error, or it is a <code>Result<\/code> value\nwhich is then an error, then a result with that error is returned.\nOtherwise both levels of results are value results, and a single\nresult with the value is returned.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "result",
                            "type": "async.Result<async.Result>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "async.Result",
                                "async.Result"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/flatten.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Result&lt;T&gt; flatten&lt;T&gt;(Result&lt;Result&lt;T&gt;&gt; result) {\n  if (result.isValue) return result.asValue.value;\n  return result.asError;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "flattenAll",
                    "type": "async.Result<dart:core.List>",
                    "desc": "<p>Converts a sequence of results to a result of a list.<\/p>\n<p>Returns either a list of values if <code>results<\/code> doesn't contain any errors,\nor the first error result in <code>results<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "results",
                            "type": "dart:core.Iterable<async.Result>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Iterable",
                                "async.Result"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/flattenAll.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Result&lt;List&lt;T&gt;&gt; flattenAll&lt;T&gt;(Iterable&lt;Result&lt;T&gt;&gt; results) {\n  var values = &lt;T&gt;[];\n  for (var result in results) {\n    if (result.isValue) {\n      values.add(result.asValue.value);\n    } else {\n      return result.asError;\n    }\n  }\n  return new Result&lt;List&lt;T&gt;&gt;.value(values);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "async.Result",
                        "dart:core.List"
                    ]
                },
                {
                    "name": "release",
                    "type": "dart:async.Future",
                    "desc": "<p>Releases the result of a captured future.<\/p>\n<p>Converts the <a href=\"package-async_async\/Result-class.html\">Result<\/a> value of the given <code>future<\/code> to a value or error\ncompletion of the returned future.<\/p>\n<p>If <code>future<\/code> completes with an error, the returned future completes with\nthe same error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "future",
                            "type": "dart:async.Future<async.Result>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.Future",
                                "async.Result"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/release.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;T&gt; release&lt;T&gt;(Future&lt;Result&lt;T&gt;&gt; future) =&gt;\n    future.then&lt;T&gt;((result) =&gt; result.asFuture);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "releaseSink",
                    "type": "dart:async.EventSink<async.Result>",
                    "desc": "<p>Releases results added to the returned sink as data and errors on <code>sink<\/code>.<\/p>\n<p>A <a href=\"package-async_async\/Result-class.html\">Result<\/a> added to the returned sink is added as a data or error event\non <code>sink<\/code>. Errors added to the returned sink are forwarded directly to\n<code>sink<\/code> and so is the <a href=\"dart-async\/EventSink\/close.html\">EventSink.close<\/a> calls.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/releaseSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static EventSink&lt;Result&lt;T&gt;&gt; releaseSink&lt;T&gt;(EventSink&lt;T&gt; sink) =&gt;\n    new ReleaseSink&lt;T&gt;(sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.EventSink",
                        "async.Result"
                    ]
                },
                {
                    "name": "releaseStream",
                    "type": "dart:async.Stream",
                    "desc": "<p>Releases a stream of <code>result<\/code> values into a stream of the results.<\/p>\n<p><code>Result<\/code> values of the source stream become value or error events in\nthe returned stream as appropriate.\nErrors from the source stream become errors in the returned stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "source",
                            "type": "dart:async.Stream<async.Result>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.Stream",
                                "async.Result"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/Result\/releaseStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Stream&lt;T&gt; releaseStream&lt;T&gt;(Stream&lt;Result&lt;T&gt;&gt; source) =&gt;\n    source.transform(new ReleaseStreamTransformer&lt;T&gt;());<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "Result.value",
                    "type": "",
                    "desc": "<p>Creates a <code>Result<\/code> holding a value.<\/p>\n<p>Alias for <a href=\"package-async_async\/ValueResult\/ValueResult.html\">ValueResult.ValueResult<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.Result",
                    "sig": "",
                    "params": [
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/Result\/Result.value.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Result.value(T value) = ValueResult&lt;T&gt;;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "asError",
                    "type": "async.ErrorResult",
                    "types": [],
                    "desc": "<p>If this is an error result, returns itself.<\/p>\n<p>Otherwise returns <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.Result",
                    "isConstant": false,
                    "href": "package-async_async\/Result\/asError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ErrorResult get asError;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "asFuture",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>A future that has been completed with this result as a value or an error.<\/p>\n        ",
                    "memberOf": "async.Result",
                    "isConstant": false,
                    "href": "package-async_async\/Result\/asFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get asFuture;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "asValue",
                    "type": "async.ValueResult",
                    "types": [],
                    "desc": "<p>If this is a value result, returns itself.<\/p>\n<p>Otherwise returns <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.Result",
                    "isConstant": false,
                    "href": "package-async_async\/Result\/asValue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ValueResult&lt;T&gt; get asValue;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "type": "",
                    "href": "package-async_async\/Result\/captureSinkTransformer-constant.html",
                    "desc": "<p>A sink transformer that captures events into <a href=\"package-async_async\/Result-class.html\">Result<\/a>s.<\/p>\n<p>The result of the transformation is a sink that only forwards <a href=\"package-async_async\/Result-class.html\">Result<\/a>\nvalues and no error events.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">captureSinkTransformer =\nconst StreamSinkTransformer&lt;Object, Result&lt;Object&gt;&gt;.fromStreamTransformer(\n    const CaptureStreamTransformer&lt;Object&gt;())\n\n<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "name": "captureSinkTransformer",
                    "memberOf": "async.Result"
                },
                {
                    "type": "",
                    "href": "package-async_async\/Result\/captureStreamTransformer-constant.html",
                    "desc": "<p>A stream transformer that captures a stream of events into <a href=\"package-async_async\/Result-class.html\">Result<\/a>s.<\/p>\n<p>The result of the transformation is a stream of <a href=\"package-async_async\/Result-class.html\">Result<\/a> values and no\nerror events. This is the transformer used by <a href=\"package-async_async\/Result\/captureStream.html\">captureStream<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">captureStreamTransformer = const CaptureStreamTransformer&lt;Object&gt;()\n\n<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "name": "captureStreamTransformer",
                    "memberOf": "async.Result"
                },
                {
                    "name": "isError",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this result is an error result.<\/p>\n<p>Always the opposite of <a href=\"package-async_async\/Result\/isValue.html\">isValue<\/a>.<\/p>\n        ",
                    "memberOf": "async.Result",
                    "isConstant": false,
                    "href": "package-async_async\/Result\/isError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isError;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isValue",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this result is a value result.<\/p>\n<p>Always the opposite of <a href=\"package-async_async\/Result\/isError.html\">isError<\/a>.<\/p>\n        ",
                    "memberOf": "async.Result",
                    "isConstant": false,
                    "href": "package-async_async\/Result\/isValue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isValue;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "type": "",
                    "href": "package-async_async\/Result\/releaseSinkTransformer-constant.html",
                    "desc": "<p>A sink transformer that releases result events.<\/p>\n<p>The result of the transformation is a sink that forwards of values and\nerror events.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">releaseSinkTransformer =\nconst StreamSinkTransformer&lt;Result&lt;Object&gt;, Object&gt;.fromStreamTransformer(\n    const ReleaseStreamTransformer&lt;Object&gt;())\n\n<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "name": "releaseSinkTransformer",
                    "memberOf": "async.Result"
                },
                {
                    "type": "",
                    "href": "package-async_async\/Result\/releaseStreamTransformer-constant.html",
                    "desc": "<p>A stream transformer that releases a stream of result events.<\/p>\n<p>The result of the transformation is a stream of values and error events.\nThis is the transformer used by <a href=\"package-async_async\/Result\/releaseStream.html\">releaseStream<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">releaseStreamTransformer = const ReleaseStreamTransformer&lt;Object&gt;()\n\n<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "name": "releaseStreamTransformer",
                    "memberOf": "async.Result"
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/Result-class.html",
            "desc": "<p>The result of a computation.<\/p>\n<p>Capturing a result (either a returned value or a thrown error) means\nconverting it into a <a href=\"package-async_async\/Result-class.html\">Result<\/a> - either a <a href=\"package-async_async\/ValueResult-class.html\">ValueResult<\/a> or an <a href=\"package-async_async\/ErrorResult-class.html\">ErrorResult<\/a>.<\/p>\n<p>This value can release itself by writing itself either to a <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> or a\n<a href=\"dart-async\/Completer-class.html\">Completer<\/a>, or by becoming a <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n<p>A <a href=\"dart-async\/Future-class.html\">Future<\/a> represents a potential result, one that might not have been\ncomputed yet, and a <a href=\"package-async_async\/Result-class.html\">Result<\/a> is always a completed and available result.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "Result"
        },
        {
            "name": "async.ResultFuture",
            "extends": [
                "async.DelegatingFuture",
                "dart:core.Object"
            ],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "ResultFuture",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.ResultFuture",
                    "sig": "",
                    "params": [
                        {
                            "name": "future",
                            "type": "dart:async.Future",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/ResultFuture\/ResultFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ResultFuture(Future&lt;T&gt; future) : super(future) {\n  Result.capture(future).then((result) {\n    _result = result;\n  });\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "isComplete",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether the future has fired and <a href=\"package-async_async\/ResultFuture\/result.html\">result<\/a> is available.<\/p>\n        ",
                    "memberOf": "async.ResultFuture",
                    "isConstant": false,
                    "href": "package-async_async\/ResultFuture\/isComplete.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isComplete =&gt; result != null;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "result",
                    "type": "async.Result",
                    "types": [],
                    "desc": "<p>The result of the wrapped <a href=\"dart-async\/Future-class.html\">Future<\/a>, if it's completed.<\/p>\n<p>If it hasn't completed yet, this will be <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.ResultFuture",
                    "isConstant": false,
                    "href": "package-async_async\/ResultFuture\/result.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Result&lt;T&gt; get result =&gt; _result;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/ResultFuture-class.html",
            "desc": "<p>A <a href=\"dart-async\/Future-class.html\">Future<\/a> wrapper that provides synchronous access to the result of the\nwrapped <a href=\"dart-async\/Future-class.html\">Future<\/a> once it's completed.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "ResultFuture"
        },
        {
            "name": "async.SingleSubscriptionTransformer",
            "extends": [
                "dart:async.StreamTransformerBase",
                "dart:core.Object"
            ],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "SingleSubscriptionTransformer",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.SingleSubscriptionTransformer",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/SingleSubscriptionTransformer\/SingleSubscriptionTransformer.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const SingleSubscriptionTransformer();<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "bind",
                    "type": "dart:async.Stream",
                    "desc": "<p>Transforms the provided <code>stream<\/code>.<\/p>\n<p>Returns a new stream with events that are computed from events of the\nprovided <code>stream<\/code>.<\/p>\n<p>The <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> interface is completely generic,\nso it cannot say what subclasses do.\nEach <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> should document clearly how it transforms the\nstream (on the class or variable used to access the transformer),\nas well as any differences from the following typical behavior:<\/p>\n<ul>\n<li>When the returned stream is listened to, it starts listening to the\ninput <code>stream<\/code>.<\/li>\n<li>Subscriptions of the returned stream forward (in a reasonable time)\na <a href=\"dart-async\/StreamSubscription\/pause.html\">StreamSubscription.pause<\/a> call to the subscription of the input\n<code>stream<\/code>.<\/li>\n<li>Similarly, canceling a subscription of the returned stream eventually\n(in reasonable time) cancels the subscription of the input <code>stream<\/code>.<\/li>\n<\/ul>\n<p>\"Reasonable time\" depends on the transformer and stream. Some transformers,\nlike a \"timeout\" transformer, might make these operations depend on a\nduration. Others might not delay them at all, or just by a microtask.<\/p>\n<p>Transformers are free to handle errors in any way.\nA transformer implementation may choose to propagate errors,\nor convert them to other events, or ignore them completely,\nbut if errors are ignored, it should be documented explicitly.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.SingleSubscriptionTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/SingleSubscriptionTransformer\/bind.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; bind(Stream&lt;S&gt; stream) {\n  StreamSubscription&lt;S&gt; subscription;\n  var controller = new StreamController&lt;T&gt;(\n      sync: true, onCancel: () =&gt; subscription.cancel());\n  subscription = stream.listen((value) {\n    \/\/ TODO(nweiz): When we release a new major version, get rid of the second\n    \/\/ type parameter and avoid this conversion.\n    try {\n      controller.add(value as T);\n    } on CastError catch (error, stackTrace) {\n      controller.addError(error, stackTrace);\n    }\n  }, onError: controller.addError, onDone: controller.close);\n  return controller.stream;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/SingleSubscriptionTransformer-class.html",
            "desc": "<p>A transformer that converts a broadcast stream into a single-subscription\nstream.<\/p>\n<p>This buffers the broadcast stream's events, which means that it starts\nlistening to a stream as soon as it's bound.<\/p>\n<p>This also casts the source stream's events to type <code>T<\/code>. If the cast fails,\nthe result stream will emit a <a href=\"dart-core\/CastError-class.html\">CastError<\/a>. This behavior is deprecated, and\nshould not be relied upon.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "SingleSubscriptionTransformer"
        },
        {
            "name": "async.StreamCompleter",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "StreamCompleter",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.StreamCompleter",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamCompleter\/StreamCompleter.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "fromFuture",
                    "type": "dart:async.Stream",
                    "desc": "<p>Convert a <code>Future&lt;Stream&gt;<\/code> to a <code>Stream<\/code>.<\/p>\n<p>This creates a stream using a stream completer,\nand sets the source stream to the result of the future when the\nfuture completes.<\/p>\n<p>If the future completes with an error, the returned stream will\ninstead contain just that error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "streamFuture",
                            "type": "dart:async.Future<dart:async.Stream>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.Future",
                                "dart:async.Stream"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamCompleter\/fromFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Stream&lt;T&gt; fromFuture&lt;T&gt;(Future&lt;Stream&lt;T&gt;&gt; streamFuture) {\n  var completer = new StreamCompleter&lt;T&gt;();\n  streamFuture.then(completer.setSourceStream, onError: completer.setError);\n  return completer.stream;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "setEmpty",
                    "type": "",
                    "desc": "<p>Equivalent to setting an empty stream using <a href=\"package-async_async\/StreamCompleter\/setSourceStream.html\">setSourceStream<\/a>.<\/p>\n<p>Any one of <a href=\"package-async_async\/StreamCompleter\/setSourceStream.html\">setSourceStream<\/a>, <a href=\"package-async_async\/StreamCompleter\/setEmpty.html\">setEmpty<\/a>, and <a href=\"package-async_async\/StreamCompleter\/setError.html\">setError<\/a> may be called at\nmost once. Trying to call any of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamCompleter",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamCompleter\/setEmpty.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setEmpty() {\n  if (_stream._isSourceStreamSet) {\n    throw new StateError(\"Source stream already set\");\n  }\n  _stream._setEmpty();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "setError",
                    "type": "",
                    "desc": "<p>Completes this to a stream that emits <code>error<\/code> and then closes.<\/p>\n<p>This is useful when the process of creating the data for the stream fails.<\/p>\n<p>Any one of <a href=\"package-async_async\/StreamCompleter\/setSourceStream.html\">setSourceStream<\/a>, <a href=\"package-async_async\/StreamCompleter\/setEmpty.html\">setEmpty<\/a>, and <a href=\"package-async_async\/StreamCompleter\/setError.html\">setError<\/a> may be called at\nmost once. Trying to call any of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamCompleter\/setError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setError(error, [StackTrace stackTrace]) {\n  setSourceStream(new Stream.fromFuture(new Future.error(error, stackTrace)));\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "setSourceStream",
                    "type": "",
                    "desc": "<p>Set a stream as the source of events for the <a href=\"package-async_async\/StreamCompleter-class.html\">StreamCompleter<\/a>'s\n<a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a>.<\/p>\n<p>The completer's <code>stream<\/code> will act exactly as <code>sourceStream<\/code>.<\/p>\n<p>If the source stream is set before <a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a> is listened to,\nthe listen call on <a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a> is forwarded directly to <code>sourceStream<\/code>.<\/p>\n<p>If <a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a> is listened to before setting the source stream,\nan intermediate subscription is created. It looks like a completely\nnormal subscription, and can be paused or canceled, but it won't\nproduce any events until a source stream is provided.<\/p>\n<p>If the <code>stream<\/code> subscription is canceled before a source stream is set,\nthe source stream will be listened to and immediately canceled again.<\/p>\n<p>Otherwise, when the source stream is then set,\nit is immediately listened to, and its events are forwarded to the\nexisting subscription.<\/p>\n<p>Any one of <a href=\"package-async_async\/StreamCompleter\/setSourceStream.html\">setSourceStream<\/a>, <a href=\"package-async_async\/StreamCompleter\/setEmpty.html\">setEmpty<\/a>, and <a href=\"package-async_async\/StreamCompleter\/setError.html\">setError<\/a> may be called at\nmost once. Trying to call any of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "sourceStream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamCompleter\/setSourceStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setSourceStream(Stream&lt;T&gt; sourceStream) {\n  if (_stream._isSourceStreamSet) {\n    throw new StateError(\"Source stream already set\");\n  }\n  _stream._setSourceStream(sourceStream);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The stream of this completer.<\/p>\n<p>This stream is always a single-subscription stream.<\/p>\n<p>When a source stream is provided, its events will be forwarded to\nlisteners on this stream.<\/p>\n<p>The stream can be listened either before or after a source stream\nis set.<\/p>\n        ",
                    "memberOf": "async.StreamCompleter",
                    "isConstant": false,
                    "href": "package-async_async\/StreamCompleter\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream =&gt; _stream;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamCompleter-class.html",
            "desc": "<p>A single-subscription <a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a> where the contents are provided later.<\/p>\n<p>It is generally recommended that you never create a <code>Future&lt;Stream&gt;<\/code>\nbecause you can just directly create a stream that doesn't do anything\nuntil it's ready to do so.\nThis class can be used to create such a stream.<\/p>\n<p>The <a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a> is a normal stream that you can listen to immediately,\nbut until either <a href=\"package-async_async\/StreamCompleter\/setSourceStream.html\">setSourceStream<\/a> or <a href=\"package-async_async\/StreamCompleter\/setEmpty.html\">setEmpty<\/a> is called,\nthe stream won't produce any events.<\/p>\n<p>The same effect can be achieved by using a <a href=\"dart-async\/StreamController-class.html\">StreamController<\/a>\nand adding the stream using <code>addStream<\/code> when both\nthe controller's stream is listened to and the source stream is ready.\nThis class attempts to shortcut some of the overhead when possible.\nFor example, if the <a href=\"package-async_async\/StreamCompleter\/stream.html\">stream<\/a> is only listened to\nafter the source stream has been set,\nthe listen is performed directly on the source stream.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamCompleter"
        },
        {
            "name": "async.StreamGroup",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "StreamGroup",
                    "type": "",
                    "desc": "<p>Creates a new stream group where <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> is single-subscriber.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamGroup",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamGroup\/StreamGroup.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamGroup() {\n  _controller = new StreamController&lt;T&gt;(\n      onListen: _onListen,\n      onPause: _onPause,\n      onResume: _onResume,\n      onCancel: _onCancel,\n      sync: true);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "add",
                    "type": "dart:async.Future",
                    "desc": "<p>Adds <code>stream<\/code> as a member of this group.<\/p>\n<p>Any events from <code>stream<\/code> will be emitted through <a href=\"package-async_async\/StreamGroup\/stream.html\">this.stream<\/a>. If this\ngroup has a listener, <code>stream<\/code> will be listened to immediately; otherwise\nit will only be listened to once this group gets a listener.<\/p>\n<p>If this is a single-subscription group and its subscription has been\ncanceled, <code>stream<\/code> will be canceled as soon as its added. If this returns\na <a href=\"dart-async\/Future-class.html\">Future<\/a>, it will be returned from <a href=\"package-async_async\/StreamGroup\/add.html\">add<\/a>. Otherwise, <a href=\"package-async_async\/StreamGroup\/add.html\">add<\/a> returns\n<code>null<\/code>.<\/p>\n<p>Throws a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if this group is closed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamGroup",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamGroup\/add.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future add(Stream&lt;T&gt; stream) {\n  if (_closed) {\n    throw new StateError(\"Can't add a Stream to a closed StreamGroup.\");\n  }\n\n  if (_state == _StreamGroupState.dormant) {\n    _subscriptions.putIfAbsent(stream, () =&gt; null);\n  } else if (_state == _StreamGroupState.canceled) {\n    \/\/ Listen to the stream and cancel it immediately so that no one else can\n    \/\/ listen, for consistency. If the stream has an onCancel listener this\n    \/\/ will also fire that, which may help it clean up resources.\n    return stream.listen(null).cancel();\n  } else {\n    _subscriptions.putIfAbsent(stream, () =&gt; _listenToStream(stream));\n  }\n\n  return null;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "StreamGroup.broadcast",
                    "type": "",
                    "desc": "<p>Creates a new stream group where <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> is a broadcast stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamGroup",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamGroup\/StreamGroup.broadcast.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamGroup.broadcast() {\n  _controller = new StreamController&lt;T&gt;.broadcast(\n      onListen: _onListen, onCancel: _onCancelBroadcast, sync: true);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "close",
                    "type": "dart:async.Future",
                    "desc": "<p>Closes the group, indicating that no more streams will be added.<\/p>\n<p>If there are no streams in the group, <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> is closed immediately.\nOtherwise, <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> will close once all streams in the group close.<\/p>\n<p>Returns a <a href=\"dart-async\/Future-class.html\">Future<\/a> that completes once <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> has actually been closed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamGroup",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamGroup\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close() {\n  if (_closed) return _controller.done;\n\n  _closed = true;\n  if (_subscriptions.isEmpty) _controller.close();\n\n  return _controller.done;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "merge",
                    "type": "dart:async.Stream",
                    "desc": "<p>Merges the events from <code>streams<\/code> into a single (single-subscriber) stream.<\/p>\n<p>This is equivalent to adding <code>streams<\/code> to a group, closing that group, and\nreturning its stream.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamGroup",
                    "sig": "",
                    "params": [
                        {
                            "name": "streams",
                            "type": "dart:core.Iterable<dart:async.Stream>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Iterable",
                                "dart:async.Stream"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamGroup\/merge.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Stream&lt;T&gt; merge&lt;T&gt;(Iterable&lt;Stream&lt;T&gt;&gt; streams) {\n  var group = new StreamGroup&lt;T&gt;();\n  streams.forEach(group.add);\n  group.close();\n  return group.stream;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "remove",
                    "type": "dart:async.Future",
                    "desc": "<p>Removes <code>stream<\/code> as a member of this group.<\/p>\n<p>No further events from <code>stream<\/code> will be emitted through this group. If\n<code>stream<\/code> has been listened to, its subscription will be canceled.<\/p>\n<p>If <code>stream<\/code> has been listened to, this <em>synchronously<\/em> cancels its\nsubscription. This means that any events from <code>stream<\/code> that haven't yet\nbeen emitted through this group will not be.<\/p>\n<p>If <code>stream<\/code>'s subscription is canceled, this returns\n<a href=\"dart-async\/StreamSubscription\/cancel.html\">StreamSubscription.cancel<\/a>'s return value. Otherwise, it returns <code>null<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamGroup",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamGroup\/remove.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future remove(Stream&lt;T&gt; stream) {\n  var subscription = _subscriptions.remove(stream);\n  var future = subscription == null ? null : subscription.cancel();\n  if (_closed &amp;&amp; _subscriptions.isEmpty) _controller.close();\n  return future;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "stream",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>The stream through which all events from streams in the group are emitted.<\/p>\n        ",
                    "memberOf": "async.StreamGroup",
                    "isConstant": false,
                    "href": "package-async_async\/StreamGroup\/stream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream =&gt; _controller.stream;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamGroup-class.html",
            "desc": "<p>A collection of streams whose events are unified and sent through a central\nstream.<\/p>\n<p>Both errors and data events are forwarded through <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a>. The streams in\nthe group won't be listened to until <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> has a listener. <strong>Note that\nthis means that events emitted by broadcast streams will be dropped until\n<a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> has a listener.<\/strong><\/p>\n<p>If the <code>StreamGroup<\/code> is constructed using <a href=\"package-async_async\/StreamGroup\/StreamGroup.html\">new StreamGroup<\/a>, <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> will\nbe single-subscription. In this case, if <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> is paused or canceled, all\nstreams in the group will likewise be paused or canceled, respectively.<\/p>\n<p>If the <code>StreamGroup<\/code> is constructed using <a href=\"package-async_async\/StreamGroup\/StreamGroup.broadcast.html\">new StreamGroup.broadcast<\/a>,\n<a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> will be a broadcast stream. In this case, the streams in the group\nwill never be paused and single-subscription streams in the group will never\nbe canceled. <strong>Note that single-subscription streams in a broadcast group\nmay drop events if a listener is added and later removed.<\/strong> Broadcast\nstreams in the group will be canceled once <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> has no listeners, and\nwill be listened to again once <a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> has listeners.<\/p>\n<p><a href=\"package-async_async\/StreamGroup\/stream.html\">stream<\/a> won't close until <a href=\"package-async_async\/StreamGroup\/close.html\">close<\/a> is called on the group <em>and<\/em> every stream\nin the group closes.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamGroup"
        },
        {
            "name": "async.StreamQueue",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "StreamQueue",
                    "type": "",
                    "desc": "<p>Create a <code>StreamQueue<\/code> of the events of <code>source<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "source",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamQueue\/StreamQueue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamQueue(Stream&lt;T&gt; source) = _StreamQueue&lt;T&gt;;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "cancel",
                    "type": "dart:async.Future",
                    "desc": "<p>Cancels the underlying event source.<\/p>\n<p>If <code>immediate<\/code> is <code>false<\/code> (the default), the cancel operation waits until\nall previously requested events have been processed, then it cancels the\nsubscription providing the events.<\/p>\n<p>If <code>immediate<\/code> is <code>true<\/code>, the source is instead canceled\nimmediately. Any pending events are completed as though the underlying\nstream had closed.<\/p>\n<p>The returned future completes with the result of calling\n<code>cancel<\/code>.<\/p>\n<p>After calling <code>cancel<\/code>, no further events can be requested.\nNone of <a href=\"package-async_async\/StreamQueue\/lookAhead.html\">lookAhead<\/a>, <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a>, <a href=\"package-async_async\/StreamQueue\/peek.html\">peek<\/a>, <a href=\"package-async_async\/StreamQueue\/rest.html\">rest<\/a>, <a href=\"package-async_async\/StreamQueue\/skip.html\">skip<\/a>, <a href=\"package-async_async\/StreamQueue\/take.html\">take<\/a> or <a href=\"package-async_async\/StreamQueue\/cancel.html\">cancel<\/a>\nmay be called again.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "immediate",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/cancel.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future cancel({bool immediate: false}) {\n  if (_isClosed) throw _failClosed();\n  _isClosed = true;\n\n  if (!immediate) {\n    var request = new _CancelRequest&lt;T&gt;(this);\n    _addRequest(request);\n    return request.future;\n  }\n\n  if (_isDone &amp;&amp; _eventQueue.isEmpty) return new Future.value();\n  return _cancel();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "cancelable",
                    "type": "async.CancelableOperation",
                    "desc": "<p>Passes a copy of this queue to <code>callback<\/code>, and updates this queue to match\nthe copy's position once <code>callback<\/code> completes.<\/p>\n<p>If the returned <a href=\"package-async_async\/CancelableOperation-class.html\">CancelableOperation<\/a> is canceled, this queue instead\ncontinues as though <a href=\"package-async_async\/StreamQueue\/cancelable.html\">cancelable<\/a> hadn't been called. Otherwise, it emits\nthe same value or error as <code>callback<\/code>.<\/p>\n<p>See also <a href=\"package-async_async\/StreamQueue\/startTransaction.html\">startTransaction<\/a> and <a href=\"package-async_async\/StreamQueue\/withTransaction.html\">withTransaction<\/a>.<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">final _stdinQueue = new StreamQueue(stdin);\n\n\/\/\/ Returns an operation that completes when the user sends a line to\n\/\/\/ standard input.\n\/\/\/\n\/\/\/ If the operation is canceled, stops waiting for user input.\nCancelableOperation&lt;String&gt; nextStdinLine() =&gt;\n    _stdinQueue.cancelable((queue) =&gt; queue.next);\n<\/code><\/pre>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "queue",
                            "type": "async.StreamQueue",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "queue",
                            "type": "async.StreamQueue",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/cancelable.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">CancelableOperation&lt;S&gt; cancelable&lt;S&gt;(\n    Future&lt;S&gt; callback(StreamQueue&lt;T&gt; queue)) {\n  var transaction = startTransaction();\n  var completer = new CancelableCompleter&lt;S&gt;(onCancel: () {\n    transaction.reject();\n  });\n\n  var queue = transaction.newQueue();\n  completer.complete(callback(queue).whenComplete(() {\n    if (!completer.isCanceled) transaction.commit(queue);\n  }));\n\n  return completer.operation;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "lookAhead",
                    "type": "dart:async.Future<dart:core.List>",
                    "desc": "<p>Look at the next <code>count<\/code> data events without consuming them.<\/p>\n<p>Works like <a href=\"package-async_async\/StreamQueue\/take.html\">take<\/a> except that the events are left in the queue.\nIf one of the next <code>count<\/code> events is an error, the returned future\ncompletes with this error, and the error is still left in the queue.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "count",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/lookAhead.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;List&lt;T&gt;&gt; lookAhead(int count) {\n  if (count &lt; 0) throw new RangeError.range(count, 0, null, \"count\");\n  if (!_isClosed) {\n    var request = new _LookAheadRequest&lt;T&gt;(count);\n    _addRequest(request);\n    return request.future;\n  }\n  throw _failClosed();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.List"
                    ]
                },
                {
                    "name": "skip",
                    "type": "dart:async.Future<dart:core.int>",
                    "desc": "<p>Skips the next <code>count<\/code> <em>data<\/em> events.<\/p>\n<p>The <code>count<\/code> must be non-negative.<\/p>\n<p>When successful, this is equivalent to using <a href=\"package-async_async\/StreamQueue\/take.html\">take<\/a>\nand ignoring the result.<\/p>\n<p>If an error occurs before <code>count<\/code> data events have been skipped,\nthe returned future completes with that error instead.<\/p>\n<p>If the stream closes before <code>count<\/code> data events,\nthe remaining unskipped event count is returned.\nIf the returned future completes with the integer <code>0<\/code>,\nthen all events were succssfully skipped. If the value\nis greater than zero then the stream ended early.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "count",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/skip.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;int&gt; skip(int count) {\n  if (count &lt; 0) throw new RangeError.range(count, 0, null, \"count\");\n  if (!_isClosed) {\n    var request = new _SkipRequest&lt;T&gt;(count);\n    _addRequest(request);\n    return request.future;\n  }\n  throw _failClosed();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.int"
                    ]
                },
                {
                    "name": "startTransaction",
                    "type": "async.StreamQueueTransaction",
                    "desc": "<p>Requests a transaction that can conditionally consume events.<\/p>\n<p>The transaction can create copies of this queue at the current position\nusing <a href=\"package-async_async\/StreamQueueTransaction\/newQueue.html\">StreamQueueTransaction.newQueue<\/a>. Each of these queues is\nindependent of one another and of the parent queue. The transaction\nfinishes when one of two methods is called:<\/p>\n<ul>\n<li>\n<p><a href=\"package-async_async\/StreamQueueTransaction\/commit.html\">StreamQueueTransaction.commit<\/a> updates the parent queue's position to\nmatch that of one of the copies.<\/p>\n<\/li>\n<li>\n<p><a href=\"package-async_async\/StreamQueueTransaction\/reject.html\">StreamQueueTransaction.reject<\/a> causes the parent queue to continue as\nthough <a href=\"package-async_async\/StreamQueue\/startTransaction.html\">startTransaction<\/a> hadn't been called.<\/p>\n<\/li>\n<\/ul>\n<p>Until the transaction finishes, this queue won't emit any events.<\/p>\n<p>See also <a href=\"package-async_async\/StreamQueue\/withTransaction.html\">withTransaction<\/a> and <a href=\"package-async_async\/StreamQueue\/cancelable.html\">cancelable<\/a>.<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">\/\/\/ Consumes all empty lines from the beginning of [lines].\nFuture consumeEmptyLines(StreamQueue&lt;String&gt; lines) async {\n  while (await lines.hasNext) {\n    var transaction = lines.startTransaction();\n    var queue = transaction.newQueue();\n    if ((await queue.next).isNotEmpty) {\n      transaction.reject();\n      return;\n    } else {\n      transaction.commit(queue);\n    }\n  }\n}\n<\/code><\/pre>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/startTransaction.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamQueueTransaction&lt;T&gt; startTransaction() {\n  if (_isClosed) throw _failClosed();\n\n  var request = new _TransactionRequest(this);\n  _addRequest(request);\n  return request.transaction;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "take",
                    "type": "dart:async.Future<dart:core.List>",
                    "desc": "<p>Requests the next <code>count<\/code> data events as a list.<\/p>\n<p>The <code>count<\/code> must be non-negative.<\/p>\n<p>Equivalent to calling <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a> <code>count<\/code> times and\nstoring the data values in a list.<\/p>\n<p>If an error occurs before <code>count<\/code> data events has\nbeen collected, the returned future completes with\nthat error instead.<\/p>\n<p>If the stream closes before <code>count<\/code> data events,\nthe returned future completes with the list\nof data collected so far. That is, the returned\nlist may have fewer than <code>count<\/code> elements.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "count",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/take.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;List&lt;T&gt;&gt; take(int count) {\n  if (count &lt; 0) throw new RangeError.range(count, 0, null, \"count\");\n  if (!_isClosed) {\n    var request = new _TakeRequest&lt;T&gt;(count);\n    _addRequest(request);\n    return request.future;\n  }\n  throw _failClosed();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.List"
                    ]
                },
                {
                    "name": "withTransaction",
                    "type": "dart:async.Future<dart:core.bool>",
                    "desc": "<p>Passes a copy of this queue to <code>callback<\/code>, and updates this queue to match\nthe copy's position if <code>callback<\/code> returns <code>true<\/code>.<\/p>\n<p>This queue won't emit any events until <code>callback<\/code> returns. If it returns\n<code>false<\/code>, this queue continues as though <a href=\"package-async_async\/StreamQueue\/withTransaction.html\">withTransaction<\/a> hadn't been\ncalled. If it throws an error, this updates this queue to match the copy's\nposition and throws the error from the returned <code>Future<\/code>.<\/p>\n<p>Returns the same value as <code>callback<\/code>.<\/p>\n<p>See also <a href=\"package-async_async\/StreamQueue\/startTransaction.html\">startTransaction<\/a> and <a href=\"package-async_async\/StreamQueue\/cancelable.html\">cancelable<\/a>.<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">\/\/\/ Consumes all empty lines from the beginning of [lines].\nFuture consumeEmptyLines(StreamQueue&lt;String&gt; lines) async {\n  while (await lines.hasNext) {\n    \/\/ Consume a line if it's empty, otherwise return.\n    if (!await lines.withTransaction(\n        (queue) async =&gt; (await queue.next).isEmpty)) {\n      return;\n    }\n  }\n}\n<\/code><\/pre>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueue",
                    "sig": "",
                    "params": [
                        {
                            "name": "queue",
                            "type": "async.StreamQueue",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.Future",
                                "dart:core.bool"
                            ]
                        },
                        {
                            "name": "queue",
                            "type": "async.StreamQueue",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueue\/withTransaction.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; withTransaction(Future&lt;bool&gt; callback(StreamQueue&lt;T&gt; queue)) {\n  var transaction = startTransaction();\n\n  \/\/\/ Avoid async\/await to ensure that [startTransaction] is called\n  \/\/\/ synchronously and so ends up in the right place in the request queue.\n  var queue = transaction.newQueue();\n  return callback(queue).then((result) {\n    if (result) {\n      transaction.commit(queue);\n    } else {\n      transaction.reject();\n    }\n    return result;\n  }, onError: (error) {\n    transaction.commit(queue);\n    throw error;\n  });\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.bool"
                    ]
                }
            ],
            "props": [
                {
                    "name": "eventsDispatched",
                    "type": "dart:core.int",
                    "types": [],
                    "desc": "<p>The number of events dispatched by this queue.<\/p>\n<p>This counts error events. It doesn't count done events, or events\ndispatched to a stream returned by <a href=\"package-async_async\/StreamQueue\/rest.html\">rest<\/a>.<\/p>\n        ",
                    "memberOf": "async.StreamQueue",
                    "isConstant": false,
                    "href": "package-async_async\/StreamQueue\/eventsDispatched.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get eventsDispatched =&gt; _eventsReceived - _eventQueue.length;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "hasNext",
                    "type": "dart:async.Future<dart:core.bool>",
                    "types": [
                        "dart:async.Future",
                        "dart:core.bool"
                    ],
                    "desc": "<p>Asks if the stream has any more events.<\/p>\n<p>Returns a future that completes with <code>true<\/code> if the stream has any\nmore events, whether data or error.\nIf the stream closes without producing any more events, the returned\nfuture completes with <code>false<\/code>.<\/p>\n<p>Can be used before using <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a> to avoid getting an error in the\nfuture returned by <code>next<\/code> in the case where there are no more events.\nAnother alternative is to use <code>take(1)<\/code> which returns either zero or\none events.<\/p>\n        ",
                    "memberOf": "async.StreamQueue",
                    "isConstant": false,
                    "href": "package-async_async\/StreamQueue\/hasNext.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; get hasNext {\n  if (!_isClosed) {\n    var hasNextRequest = new _HasNextRequest&lt;T&gt;();\n    _addRequest(hasNextRequest);\n    return hasNextRequest.future;\n  }\n  throw _failClosed();\n}<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "next",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>Requests the next (yet unrequested) event from the stream.<\/p>\n<p>When the requested event arrives, the returned future is completed with\nthe event.\nIf the event is a data event, the returned future completes\nwith its value.\nIf the event is an error event, the returned future completes with\nits error and stack trace.\nIf the stream closes before an event arrives, the returned future\ncompletes with a <a href=\"dart-core\/StateError-class.html\">StateError<\/a>.<\/p>\n<p>It's possible to have several pending <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a> calls (or other requests),\nand they will be completed in the order they were requested, by the\nfirst events that were not consumed by previous requeusts.<\/p>\n        ",
                    "memberOf": "async.StreamQueue",
                    "isConstant": false,
                    "href": "package-async_async\/StreamQueue\/next.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get next {\n  if (!_isClosed) {\n    var nextRequest = new _NextRequest&lt;T&gt;();\n    _addRequest(nextRequest);\n    return nextRequest.future;\n  }\n  throw _failClosed();\n}<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "peek",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>Looks at the next (yet unrequested) event from the stream.<\/p>\n<p>Like <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a> except that the event is not consumed.\nIf the next event is an error event, it stays in the queue.<\/p>\n        ",
                    "memberOf": "async.StreamQueue",
                    "isConstant": false,
                    "href": "package-async_async\/StreamQueue\/peek.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get peek {\n  if (!_isClosed) {\n    var nextRequest = new _PeekRequest&lt;T&gt;();\n    _addRequest(nextRequest);\n    return nextRequest.future;\n  }\n  throw _failClosed();\n}<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "rest",
                    "type": "dart:async.Stream",
                    "types": [],
                    "desc": "<p>Returns a stream of all the remaning events of the source stream.<\/p>\n<p>All requested <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a>, <a href=\"package-async_async\/StreamQueue\/skip.html\">skip<\/a> or <a href=\"package-async_async\/StreamQueue\/take.html\">take<\/a> operations are completed\nfirst, and then any remaining events are provided as events of\nthe returned stream.<\/p>\n<p>Using <code>rest<\/code> closes this stream queue. After getting the\n<code>rest<\/code> the caller may no longer request other events, like\nafter calling <a href=\"package-async_async\/StreamQueue\/cancel.html\">cancel<\/a>.<\/p>\n        ",
                    "memberOf": "async.StreamQueue",
                    "isConstant": false,
                    "href": "package-async_async\/StreamQueue\/rest.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get rest {\n  if (_isClosed) {\n    throw _failClosed();\n  }\n  var request = new _RestRequest&lt;T&gt;(this);\n  _isClosed = true;\n  _addRequest(request);\n  return request.stream;\n}<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamQueue-class.html",
            "desc": "<p>An asynchronous pull-based interface for accessing stream events.<\/p>\n<p>Wraps a stream and makes individual events available on request.<\/p>\n<p>You can request (and reserve) one or more events from the stream,\nand after all previous requests have been fulfilled, stream events\ngo towards fulfilling your request.<\/p>\n<p>For example, if you ask for <a href=\"package-async_async\/StreamQueue\/next.html\">next<\/a> two times, the returned futures\nwill be completed by the next two unrequested events from the stream.<\/p>\n<p>The stream subscription is paused when there are no active\nrequests.<\/p>\n<p>Some streams, including broadcast streams, will buffer\nevents while paused, so waiting too long between requests may\ncause memory bloat somewhere else.<\/p>\n<p>This is similar to, but more convenient than, a <a href=\"dart-async\/StreamIterator-class.html\">StreamIterator<\/a>.\nA <code>StreamIterator<\/code> requires you to manually check when a new event is\navailable and you can only access the value of that event until you\ncheck for the next one. A <code>StreamQueue<\/code> allows you to request, for example,\nthree events at a time, either individually, as a group using <a href=\"package-async_async\/StreamQueue\/take.html\">take<\/a>\nor <a href=\"package-async_async\/StreamQueue\/skip.html\">skip<\/a>, or in any combination.<\/p>\n<p>You can also ask to have the <a href=\"package-async_async\/StreamQueue\/rest.html\">rest<\/a> of the stream provided as\na new stream. This allows, for example, taking the first event\nout of a stream and continuing to use the rest of the stream as a stream.<\/p>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code>var events = new StreamQueue&lt;String&gt;(someStreamOfLines);\nvar first = await events.next;\nwhile (first.startsWith('#')) {\n  \/\/ Skip comments.\n  first = await events.next;\n}\n\nif (first.startsWith(MAGIC_MARKER)) {\n  var headerCount =\n      first.parseInt(first.substring(MAGIC_MARKER.length + 1));\n  handleMessage(headers: await events.take(headerCount),\n                body: events.rest);\n  return;\n}\n\/\/ Error handling.\n<\/code><\/pre>\n<p>When you need no further events the <code>StreamQueue<\/code> should be closed\nusing <a href=\"package-async_async\/StreamQueue\/cancel.html\">cancel<\/a>. This releases the underlying stream subscription.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamQueue"
        },
        {
            "name": "async.StreamQueueTransaction",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "commit",
                    "type": "",
                    "desc": "<p>Commits a queue created using <a href=\"package-async_async\/StreamQueueTransaction\/newQueue.html\">newQueue<\/a>.<\/p>\n<p>The parent queue's position is updated to be the same as <code>queue<\/code>'s.\nFurther requests on all queues created by this transaction, including\n<code>queue<\/code>, will complete as though <code>cancel<\/code> were called with <code>immediate:\ntrue<\/code>.<\/p>\n<p>Throws a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if <a href=\"package-async_async\/StreamQueueTransaction\/commit.html\">commit<\/a> or <a href=\"package-async_async\/StreamQueueTransaction\/reject.html\">reject<\/a> have already been called, or\nif there are pending requests on <code>queue<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueueTransaction",
                    "sig": "",
                    "params": [
                        {
                            "name": "queue",
                            "type": "async.StreamQueue",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueueTransaction\/commit.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void commit(StreamQueue&lt;T&gt; queue) {\n  _assertActive();\n  if (!_queues.contains(queue)) {\n    throw new ArgumentError(\"Queue doesn't belong to this transaction.\");\n  } else if (queue._requestQueue.isNotEmpty) {\n    throw new StateError(\"A queue with pending requests can't be committed.\");\n  }\n  _committed = true;\n\n  \/\/ Remove all events from the parent queue that were consumed by the\n  \/\/ child queue.\n  for (var j = 0; j &lt; queue.eventsDispatched; j++) {\n    _parent._eventQueue.removeFirst();\n  }\n\n  _done();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "newQueue",
                    "type": "async.StreamQueue",
                    "desc": "<p>Creates a new copy of the parent queue.<\/p>\n<p>This copy starts at the parent queue's position when\n<a href=\"package-async_async\/StreamQueue\/startTransaction.html\">StreamQueue.startTransaction<\/a> was called. Its position can be committed\nto the parent queue using <a href=\"package-async_async\/StreamQueueTransaction\/commit.html\">commit<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueueTransaction",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueueTransaction\/newQueue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamQueue&lt;T&gt; newQueue() {\n  var queue = new StreamQueue(_splitter.split());\n  _queues.add(queue);\n  return queue;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "reject",
                    "type": "",
                    "desc": "<p>Rejects this transaction without updating the parent queue.<\/p>\n<p>The parent will continue as though <a href=\"package-async_async\/StreamQueue\/startTransaction.html\">StreamQueue.startTransaction<\/a> hadn't\nbeen called. Further requests on all queues created by this transaction\nwill complete as though <code>cancel<\/code> were called with <code>immediate: true<\/code>.<\/p>\n<p>Throws a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if <a href=\"package-async_async\/StreamQueueTransaction\/commit.html\">commit<\/a> or <a href=\"package-async_async\/StreamQueueTransaction\/reject.html\">reject<\/a> have already been called.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamQueueTransaction",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamQueueTransaction\/reject.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void reject() {\n  _assertActive();\n  _rejected = true;\n  _done();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamQueueTransaction-class.html",
            "desc": "<p>A transaction on a <a href=\"package-async_async\/StreamQueue-class.html\">StreamQueue<\/a>, created by <a href=\"package-async_async\/StreamQueue\/startTransaction.html\">StreamQueue.startTransaction<\/a>.<\/p>\n<p>Copies of the parent queue may be created using <a href=\"package-async_async\/StreamQueueTransaction\/newQueue.html\">newQueue<\/a>. Calling <a href=\"package-async_async\/StreamQueueTransaction\/commit.html\">commit<\/a>\nmoves the parent queue to a copy's position, and calling <a href=\"package-async_async\/StreamQueueTransaction\/reject.html\">reject<\/a> causes it\nto continue as though <a href=\"package-async_async\/StreamQueue\/startTransaction.html\">StreamQueue.startTransaction<\/a> was never called.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamQueueTransaction"
        },
        {
            "name": "async.StreamSinkCompleter",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "StreamSinkCompleter",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.StreamSinkCompleter",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamSinkCompleter\/StreamSinkCompleter.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "fromFuture",
                    "type": "dart:async.StreamSink",
                    "desc": "<p>Convert a <code>Future&lt;StreamSink&gt;<\/code> to a <code>StreamSink<\/code>.<\/p>\n<p>This creates a sink using a sink completer, and sets the destination sink\nto the result of the future when the future completes.<\/p>\n<p>If the future completes with an error, the returned sink will instead\nbe closed. Its <code>Sink.done<\/code> future will contain the error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "sinkFuture",
                            "type": "dart:async.Future<dart:async.StreamSink>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:async.Future",
                                "dart:async.StreamSink"
                            ]
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSinkCompleter\/fromFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamSink&lt;T&gt; fromFuture&lt;T&gt;(Future&lt;StreamSink&lt;T&gt;&gt; sinkFuture) {\n  var completer = new StreamSinkCompleter&lt;T&gt;();\n  sinkFuture.then(completer.setDestinationSink, onError: completer.setError);\n  return completer.sink;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "setDestinationSink",
                    "type": "",
                    "desc": "<p>Sets a sink as the destination for events from the <a href=\"package-async_async\/StreamSinkCompleter-class.html\">StreamSinkCompleter<\/a>'s\n<a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a>.<\/p>\n<p>The completer's <a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a> will act exactly as <code>destinationSink<\/code>.<\/p>\n<p>If the destination sink is set before events are added to <a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a>, further\nevents are forwarded directly to <code>destinationSink<\/code>.<\/p>\n<p>If events are added to <a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a> before setting the destination sink, they're\nbuffered until the destination is available.<\/p>\n<p>A destination sink may be set at most once.<\/p>\n<p>Either of <a href=\"package-async_async\/StreamSinkCompleter\/setDestinationSink.html\">setDestinationSink<\/a> or <a href=\"package-async_async\/StreamSinkCompleter\/setError.html\">setError<\/a> may be called at most once.\nTrying to call either of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "destinationSink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSinkCompleter\/setDestinationSink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setDestinationSink(StreamSink&lt;T&gt; destinationSink) {\n  if (_sink._destinationSink != null) {\n    throw new StateError(\"Destination sink already set\");\n  }\n  _sink._setDestinationSink(destinationSink);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "setError",
                    "type": "",
                    "desc": "<p>Completes this to a closed sink whose <code>Sink.done<\/code> future emits <code>error<\/code>.<\/p>\n<p>This is useful when the process of loading the sink fails.<\/p>\n<p>Either of <a href=\"package-async_async\/StreamSinkCompleter\/setDestinationSink.html\">setDestinationSink<\/a> or <a href=\"package-async_async\/StreamSinkCompleter\/setError.html\">setError<\/a> may be called at most once.\nTrying to call either of them again will fail.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkCompleter",
                    "sig": "",
                    "params": [
                        {
                            "name": "error",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSinkCompleter\/setError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setError(error, [StackTrace stackTrace]) {\n  setDestinationSink(new NullStreamSink.error(error, stackTrace));\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "sink",
                    "type": "dart:async.StreamSink",
                    "types": [],
                    "desc": "<p>The sink for this completer.<\/p>\n<p>When a destination sink is provided, events that have been passed to the\nsink will be forwarded to the destination.<\/p>\n<p>Events can be added to the sink either before or after a destination sink\nis set.<\/p>\n        ",
                    "memberOf": "async.StreamSinkCompleter",
                    "isConstant": false,
                    "href": "package-async_async\/StreamSinkCompleter\/sink.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final StreamSink&lt;T&gt; sink = new _CompleterSink&lt;T&gt;()\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamSinkCompleter-class.html",
            "desc": "<p>A <a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a> where the destination is provided later.<\/p>\n<p>The <a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a> is a normal sink that you can add events to to immediately, but\nuntil <a href=\"package-async_async\/StreamSinkCompleter\/setDestinationSink.html\">setDestinationSink<\/a> is called, the events will be buffered.<\/p>\n<p>The same effect can be achieved by using a <a href=\"dart-async\/StreamController-class.html\">StreamController<\/a> and adding it\nto the sink using <code>Sink.addStream<\/code> when the destination sink is ready. This\nclass attempts to shortcut some of the overhead when possible. For example,\nif the <a href=\"package-async_async\/StreamSinkCompleter\/sink.html\">sink<\/a> only has events added after the destination sink has been set,\nthose events are added directly to the sink.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamSinkCompleter"
        },
        {
            "name": "async.StreamSinkTransformer",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "bind",
                    "type": "dart:async.StreamSink",
                    "desc": "<p>Transforms the events passed to <code>sink<\/code>.<\/p>\n<p>Creates a new sink. When events are passed to the returned sink, it will\ntransform them and pass the transformed versions to <code>sink<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.StreamSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSinkTransformer\/bind.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;S&gt; bind(StreamSink&lt;T&gt; sink);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "StreamSinkTransformer.fromHandlers",
                    "type": "",
                    "desc": "<p>Creates a <a href=\"package-async_async\/StreamSinkTransformer-class.html\">StreamSinkTransformer<\/a> that delegates events to the given\nhandlers.<\/p>\n<p>The handlers work exactly as they do for <a href=\"package-async_async\/StreamSinkTransformer\/StreamSinkTransformer.fromHandlers.html\">StreamTransformer.fromHandlers<\/a>.\nThey're called for each incoming event, and any actions on the sink\nthey're passed are forwarded to the inner sink. If a handler is omitted,\nthe event is passed through unaltered.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "data",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "error",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stackTrace",
                            "type": "dart:core.StackTrace",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamSinkTransformer\/StreamSinkTransformer.fromHandlers.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamSinkTransformer.fromHandlers(\n    {void handleData(S data, EventSink&lt;T&gt; sink),\n    void handleError(Object error, StackTrace stackTrace, EventSink&lt;T&gt; sink),\n    void handleDone(EventSink&lt;T&gt; sink)}) {\n  return new HandlerTransformer&lt;S, T&gt;(handleData, handleError, handleDone);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "StreamSinkTransformer.fromStreamTransformer",
                    "type": "",
                    "desc": "<p>Creates a <a href=\"package-async_async\/StreamSinkTransformer-class.html\">StreamSinkTransformer<\/a> that transforms events and errors\nusing <code>transformer<\/code>.<\/p>\n<p>This is equivalent to piping all events from the outer sink through a\nstream transformed by <code>transformer<\/code> and from there into the inner sink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "dart:async.StreamTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamSinkTransformer\/StreamSinkTransformer.fromStreamTransformer.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const factory StreamSinkTransformer.fromStreamTransformer(\n    StreamTransformer&lt;S, T&gt; transformer) = StreamTransformerWrapper&lt;S, T&gt;;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "typed",
                    "type": "async.StreamSinkTransformer",
                    "desc": "<p>Creates a wrapper that coerces the type of <code>transformer<\/code>.<\/p>\n<p>This soundly converts a <a href=\"package-async_async\/StreamSinkTransformer-class.html\">StreamSinkTransformer<\/a> to a\n<code>StreamSinkTransformer&lt;S, T&gt;<\/code>, regardless of its original generic type.\nThis means that calls to <a href=\"dart-async\/EventSink\/add.html\">StreamSink.add<\/a> on the returned sink may throw a\n<a href=\"dart-core\/CastError-class.html\">CastError<\/a> if the argument type doesn't match the reified type of the\nsink.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSinkTransformer",
                    "sig": "",
                    "params": [
                        {
                            "name": "transformer",
                            "type": "async.StreamSinkTransformer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSinkTransformer\/typed.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamSinkTransformer&lt;S, T&gt; typed&lt;S, T&gt;(\n        StreamSinkTransformer transformer) =&gt;\n    transformer is StreamSinkTransformer&lt;S, T&gt;\n        ? transformer\n        : new TypeSafeStreamSinkTransformer(transformer);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamSinkTransformer-class.html",
            "desc": "<p>A <a href=\"package-async_async\/StreamSinkTransformer-class.html\">StreamSinkTransformer<\/a> transforms the events being passed to a sink.<\/p>\n<p>This works on the same principle as a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a>. Each transformer\ndefines a <a href=\"package-async_async\/StreamSinkTransformer\/bind.html\">bind<\/a> method that takes in the original <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> and returns\nthe transformed version. However, where a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> transforms\nevents after they leave the stream, this transforms them before they enter\nthe sink.<\/p>\n<p>Transformers must be able to have <code>bind<\/code> called used multiple times.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamSinkTransformer"
        },
        {
            "name": "async.StreamSplitter",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "StreamSplitter",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.StreamSplitter",
                    "sig": "",
                    "params": [
                        {
                            "name": "_stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamSplitter\/StreamSplitter.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSplitter(this._stream);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "close",
                    "type": "dart:async.Future",
                    "desc": "<p>Indicates that no more branches will be requested via <a href=\"package-async_async\/StreamSplitter\/split.html\">split<\/a>.<\/p>\n<p>This clears the internal buffer of events. If there are no branches or all\nbranches have been canceled, this cancels the subscription to the input\nstream.<\/p>\n<p>Returns a <a href=\"dart-async\/Future-class.html\">Future<\/a> that completes once all events have been processed by\nall branches and (if applicable) the subscription to the input stream has\nbeen canceled.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSplitter",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSplitter\/close.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close() {\n  if (_isClosed) return _closeGroup.future;\n  _isClosed = true;\n\n  _buffer.clear();\n  if (_controllers.isEmpty) _cancelSubscription();\n\n  return _closeGroup.future;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "split",
                    "type": "dart:async.Stream",
                    "desc": "<p>Returns a single-subscription stream that's a copy of the input stream.<\/p>\n<p>This will throw a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if <a href=\"package-async_async\/StreamSplitter\/close.html\">close<\/a> has been called.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSplitter",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSplitter\/split.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; split() {\n  if (_isClosed) {\n    throw new StateError(\"Can't call split() on a closed StreamSplitter.\");\n  }\n\n  var controller = new StreamController&lt;T&gt;(\n      onListen: _onListen, onPause: _onPause, onResume: _onResume);\n  controller.onCancel = () =&gt; _onCancel(controller);\n\n  for (var result in _buffer) {\n    result.addTo(controller);\n  }\n\n  if (_isDone) {\n    _closeGroup.add(controller.close());\n  } else {\n    _controllers.add(controller);\n  }\n\n  return controller.stream;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "splitFrom",
                    "type": "dart:core.List<dart:async.Stream>",
                    "desc": "<p>Splits <code>stream<\/code> into <code>count<\/code> identical streams.<\/p>\n<p><code>count<\/code> defaults to 2. This is the same as creating <code>count<\/code> branches and\nthen closing the <a href=\"package-async_async\/StreamSplitter-class.html\">StreamSplitter<\/a>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamSplitter",
                    "sig": "",
                    "params": [
                        {
                            "name": "stream",
                            "type": "dart:async.Stream",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "count",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamSplitter\/splitFrom.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static List&lt;Stream&lt;T&gt;&gt; splitFrom&lt;T&gt;(Stream&lt;T&gt; stream, [int count]) {\n  if (count == null) count = 2;\n  var splitter = new StreamSplitter&lt;T&gt;(stream);\n  var streams = new List&lt;Stream&lt;T&gt;&gt;.generate(count, (_) =&gt; splitter.split());\n  splitter.close();\n  return streams;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:core.List",
                        "dart:async.Stream"
                    ]
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamSplitter-class.html",
            "desc": "<p>A class that splits a single source stream into an arbitrary number of\n(single-subscription) streams (called \"branch\") that emit the same events.<\/p>\n<p>Each branch will emit all the same values and errors as the source stream,\nregardless of which values have been emitted on other branches. This means\nthat the splitter stores every event that has been emitted so far, which may\nconsume a lot of memory. The user can call <a href=\"package-async_async\/StreamSplitter\/close.html\">close<\/a> to indicate that no more\nbranches will be created, and this memory will be released.<\/p>\n<p>The source stream is only listened to once a branch is created <em>and listened\nto<\/em>. It's paused when all branches are paused <em>or when all branches are\ncanceled<\/em>, and resumed once there's at least one branch that's listening and\nunpaused. It's not canceled unless no branches are listening and <a href=\"package-async_async\/StreamSplitter\/close.html\">close<\/a> has\nbeen called.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamSplitter"
        },
        {
            "name": "async.StreamZip",
            "extends": [
                "dart:core.List",
                "dart:async.Stream",
                "dart:core.Object"
            ],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "StreamZip",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.StreamZip",
                    "sig": "",
                    "params": [
                        {
                            "name": "streams",
                            "type": "dart:core.Iterable<dart:async.Stream>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Iterable",
                                "dart:async.Stream"
                            ]
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/StreamZip\/StreamZip.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamZip(Iterable&lt;Stream&lt;T&gt;&gt; streams) : _streams = streams;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "listen",
                    "type": "dart:async.StreamSubscription<dart:core.List>",
                    "desc": "<p>Adds a subscription to this stream.<\/p>\n<p>Returns a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> which handles events from this stream using\nthe provided <code>onData<\/code>, <code>onError<\/code> and <code>onDone<\/code> handlers.\nThe handlers can be changed on the subscription, but they start out\nas the provided functions.<\/p>\n<p>On each data event from this stream, the subscriber's <code>onData<\/code> handler\nis called. If <code>onData<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>On errors from this stream, the <code>onError<\/code> handler is called with the\nerror object and possibly a stack trace.<\/p>\n<p>The <code>onError<\/code> callback must be of type <code>void onError(error)<\/code> or\n<code>void onError(error, StackTrace stackTrace)<\/code>. If <code>onError<\/code> accepts\ntwo arguments it is called with the error object and the stack trace\n(which could be <code>null<\/code> if this stream itself received an error without\nstack trace).\nOtherwise it is called with just the error object.\nIf <code>onError<\/code> is omitted, any errors on this stream are considered unhandled,\nand will be passed to the current <a href=\"dart-async\/Zone-class.html\">Zone<\/a>'s error handler.\nBy default unhandled async errors are treated\nas if they were uncaught top-level errors.<\/p>\n<p>If this stream closes and sends a done event, the <code>onDone<\/code> handler is\ncalled. If <code>onDone<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>If <code>cancelOnError<\/code> is true, the subscription is automatically canceled\nwhen the first error event is delivered. The default is <code>false<\/code>.<\/p>\n<p>While a subscription is paused, or when it has been canceled,\nthe subscription doesn't receive events and none of the\nevent handler functions are called.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.StreamZip",
                    "sig": "",
                    "params": [
                        {
                            "name": "data",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "data",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "onError",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "onDone",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "cancelOnError",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/StreamZip\/listen.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSubscription&lt;List&lt;T&gt;&gt; listen(void onData(List&lt;T&gt; data),\n    {Function onError, void onDone(), bool cancelOnError}) {\n  cancelOnError = identical(true, cancelOnError);\n  var subscriptions = &lt;StreamSubscription&lt;T&gt;&gt;[];\n  StreamController&lt;List&lt;T&gt;&gt; controller;\n  List&lt;T&gt; current;\n  int dataCount = 0;\n\n  \/\/\/ Called for each data from a subscription in [subscriptions].\n  void handleData(int index, T data) {\n    current[index] = data;\n    dataCount++;\n    if (dataCount == subscriptions.length) {\n      var data = current;\n      current = new List(subscriptions.length);\n      dataCount = 0;\n      for (int i = 0; i &lt; subscriptions.length; i++) {\n        if (i != index) subscriptions[i].resume();\n      }\n      controller.add(data);\n    } else {\n      subscriptions[index].pause();\n    }\n  }\n\n  \/\/\/ Called for each error from a subscription in [subscriptions].\n  \/\/\/ Except if [cancelOnError] is true, in which case the function below\n  \/\/\/ is used instead.\n  void handleError(Object error, StackTrace stackTrace) {\n    controller.addError(error, stackTrace);\n  }\n\n  \/\/\/ Called when a subscription has an error and [cancelOnError] is true.\n  \/\/\/\n  \/\/\/ Prematurely cancels all subscriptions since we know that we won't\n  \/\/\/ be needing any more values.\n  void handleErrorCancel(Object error, StackTrace stackTrace) {\n    for (int i = 0; i &lt; subscriptions.length; i++) {\n      subscriptions[i].cancel();\n    }\n    controller.addError(error, stackTrace);\n  }\n\n  void handleDone() {\n    for (int i = 0; i &lt; subscriptions.length; i++) {\n      subscriptions[i].cancel();\n    }\n    controller.close();\n  }\n\n  try {\n    for (var stream in _streams) {\n      int index = subscriptions.length;\n      subscriptions.add(stream.listen((data) {\n        handleData(index, data);\n      },\n          onError: cancelOnError ? handleError : handleErrorCancel,\n          onDone: handleDone,\n          cancelOnError: cancelOnError));\n    }\n  } catch (e) {\n    for (int i = subscriptions.length - 1; i &gt;= 0; i--) {\n      subscriptions[i].cancel();\n    }\n    rethrow;\n  }\n\n  current = new List(subscriptions.length);\n\n  controller = new StreamController&lt;List&lt;T&gt;&gt;(onPause: () {\n    for (int i = 0; i &lt; subscriptions.length; i++) {\n      \/\/ This may pause some subscriptions more than once.\n      \/\/ These will not be resumed by onResume below, but must wait for the\n      \/\/ next round.\n      subscriptions[i].pause();\n    }\n  }, onResume: () {\n    for (int i = 0; i &lt; subscriptions.length; i++) {\n      subscriptions[i].resume();\n    }\n  }, onCancel: () {\n    for (int i = 0; i &lt; subscriptions.length; i++) {\n      \/\/ Canceling more than once is safe.\n      subscriptions[i].cancel();\n    }\n  });\n\n  if (subscriptions.isEmpty) {\n    controller.close();\n  }\n  return controller.stream.listen(onData,\n      onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.StreamSubscription",
                        "dart:core.List"
                    ]
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/StreamZip-class.html",
            "desc": "<p>A stream that combines the values of other streams.<\/p>\n<p>This emits lists of collected values from each input stream. The first list\ncontains the first value emitted by each stream, the second contains the\nsecond value, and so on. The lists have the same ordering as the iterable\npassed to <a href=\"package-async_async\/StreamZip\/StreamZip.html\">new StreamZip<\/a>.<\/p>\n<p>Any errors from any of the streams are forwarded directly to this stream.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "StreamZip"
        },
        {
            "name": "async.SubscriptionStream",
            "extends": [
                "dart:async.Stream",
                "dart:core.Object"
            ],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "SubscriptionStream",
                    "type": "",
                    "desc": "<p>Create a single-subscription <code>Stream<\/code> from <code>subscription<\/code>.<\/p>\n<p>The <code>subscription<\/code> should not be paused. This class will not resume prior\npauses, so being paused is indistinguishable from not providing any\nevents.<\/p>\n<p>If the <code>subscription<\/code> doesn't send any <code>done<\/code> events, neither will this\nstream. That may be an issue if <code>subscription<\/code> was made to cancel on\nan error.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.SubscriptionStream",
                    "sig": "",
                    "params": [
                        {
                            "name": "subscription",
                            "type": "dart:async.StreamSubscription",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/SubscriptionStream\/SubscriptionStream.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">SubscriptionStream(StreamSubscription&lt;T&gt; subscription)\n    : _source = subscription {\n  _source.pause();\n  \/\/ Clear callbacks to avoid keeping them alive unnecessarily.\n  _source.onData(null);\n  _source.onError(null);\n  _source.onDone(null);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "listen",
                    "type": "dart:async.StreamSubscription",
                    "desc": "<p>Adds a subscription to this stream.<\/p>\n<p>Returns a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> which handles events from this stream using\nthe provided <code>onData<\/code>, <code>onError<\/code> and <code>onDone<\/code> handlers.\nThe handlers can be changed on the subscription, but they start out\nas the provided functions.<\/p>\n<p>On each data event from this stream, the subscriber's <code>onData<\/code> handler\nis called. If <code>onData<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>On errors from this stream, the <code>onError<\/code> handler is called with the\nerror object and possibly a stack trace.<\/p>\n<p>The <code>onError<\/code> callback must be of type <code>void onError(error)<\/code> or\n<code>void onError(error, StackTrace stackTrace)<\/code>. If <code>onError<\/code> accepts\ntwo arguments it is called with the error object and the stack trace\n(which could be <code>null<\/code> if this stream itself received an error without\nstack trace).\nOtherwise it is called with just the error object.\nIf <code>onError<\/code> is omitted, any errors on this stream are considered unhandled,\nand will be passed to the current <a href=\"dart-async\/Zone-class.html\">Zone<\/a>'s error handler.\nBy default unhandled async errors are treated\nas if they were uncaught top-level errors.<\/p>\n<p>If this stream closes and sends a done event, the <code>onDone<\/code> handler is\ncalled. If <code>onDone<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>If <code>cancelOnError<\/code> is true, the subscription is automatically canceled\nwhen the first error event is delivered. The default is <code>false<\/code>.<\/p>\n<p>While a subscription is paused, or when it has been canceled,\nthe subscription doesn't receive events and none of the\nevent handler functions are called.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.SubscriptionStream",
                    "sig": "",
                    "params": [
                        {
                            "name": "event",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "event",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "onError",
                            "type": "dart:core.Function",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "onDone",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "cancelOnError",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/SubscriptionStream\/listen.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSubscription&lt;T&gt; listen(void onData(T event),\n    {Function onError, void onDone(), bool cancelOnError}) {\n  if (_source == null) {\n    throw new StateError(\"Stream has already been listened to.\");\n  }\n  cancelOnError = (true == cancelOnError);\n  var subscription = _source;\n  _source = null;\n\n  var result = cancelOnError\n      ? new _CancelOnErrorSubscriptionWrapper&lt;T&gt;(subscription)\n      : subscription;\n  result.onData(onData);\n  result.onError(onError);\n  result.onDone(onDone);\n  subscription.resume();\n  return result;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/SubscriptionStream-class.html",
            "desc": "<p>A <a href=\"dart-async\/Stream-class.html\">Stream<\/a> adapter for a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>.<\/p>\n<p>This class allows a <code>StreamSubscription<\/code> to be treated as a <code>Stream<\/code>.<\/p>\n<p>The subscription is paused until the stream is listened to,\nthen it is resumed and the events are passed on to the\nstream's new subscription.<\/p>\n<p>This class assumes that is has control over the original subscription.\nIf other code is accessing the subscription, results may be unpredictable.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "SubscriptionStream"
        },
        {
            "name": "async.ValueResult",
            "extends": [],
            "memberOf": "async",
            "events": [],
            "methods": [
                {
                    "name": "operator ==",
                    "type": "dart:core.bool",
                    "desc": "<p>The equality operator.<\/p>\n<p>The default behavior for all <a href=\"dart-core\/Object-class.html\">Object<\/a>s is to return true if and\nonly if <code>this<\/code> and <code>other<\/code> are the same object.<\/p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:<\/p>\n<ul>\n<li>\n<p>Total: It must return a boolean for all arguments. It should never throw\nor return <code>null<\/code>.<\/p>\n<\/li>\n<li>\n<p>Reflexive: For all objects <code>o<\/code>, <code>o == o<\/code> must be true.<\/p>\n<\/li>\n<li>\n<p>Symmetric: For all objects <code>o1<\/code> and <code>o2<\/code>, <code>o1 == o2<\/code> and <code>o2 == o1<\/code> must\neither both be true, or both be false.<\/p>\n<\/li>\n<li>\n<p>Transitive: For all objects <code>o1<\/code>, <code>o2<\/code>, and <code>o3<\/code>, if <code>o1 == o2<\/code> and\n<code>o2 == o3<\/code> are true, then <code>o1 == o3<\/code> must be true.<\/p>\n<\/li>\n<\/ul>\n<p>The method should also be consistent over time,\nso whether two objects are equal should only change\nif at least one of the objects was modified.<\/p>\n<p>If a subclass overrides the equality operator it should override\nthe <a href=\"package-async_async\/ValueResult\/hashCode.html\">hashCode<\/a> method as well to maintain consistency.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ValueResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "other",
                            "type": "dart:core.Object",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ValueResult\/operator_equals.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool operator ==(Object other) =&gt;\n    other is ValueResult &amp;&amp; value == other.value;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "ValueResult",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "async.ValueResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "value",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-async_async\/ValueResult\/ValueResult.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ValueResult(this.value);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "addTo",
                    "type": "",
                    "desc": "<p>Adds this result to an <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a>.<\/p>\n<p>Calls the sink's <code>add<\/code> or <code>addError<\/code> method as appropriate.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ValueResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "sink",
                            "type": "dart:async.EventSink",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ValueResult\/addTo.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addTo(EventSink&lt;T&gt; sink) {\n  sink.add(value);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "complete",
                    "type": "",
                    "desc": "<p>Completes a completer with this result.<\/p>\n    ",
                    "static": false,
                    "memberOf": "async.ValueResult",
                    "sig": "",
                    "params": [
                        {
                            "name": "completer",
                            "type": "dart:async.Completer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-async_async\/ValueResult\/complete.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void complete(Completer&lt;T&gt; completer) {\n  completer.complete(value);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": []
                }
            ],
            "props": [
                {
                    "name": "asError",
                    "type": "async.ErrorResult",
                    "types": [],
                    "desc": "<p>If this is an error result, returns itself.<\/p>\n<p>Otherwise returns <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/asError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ErrorResult get asError =&gt; null;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "asFuture",
                    "type": "dart:async.Future",
                    "types": [],
                    "desc": "<p>A future that has been completed with this result as a value or an error.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/asFuture.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get asFuture =&gt; new Future.value(value);<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "asValue",
                    "type": "async.ValueResult",
                    "types": [],
                    "desc": "<p>If this is a value result, returns itself.<\/p>\n<p>Otherwise returns <code>null<\/code>.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/asValue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ValueResult&lt;T&gt; get asValue =&gt; this;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "hashCode",
                    "type": "dart:core.int",
                    "types": [],
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"package-async_async\/ValueResult\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"package-async_async\/ValueResult\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"package-async_async\/ValueResult\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"package-async_async\/ValueResult\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"package-async_async\/ValueResult\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"package-async_async\/ValueResult\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/hashCode.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get hashCode =&gt; value.hashCode ^ 0x323f1d61;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isError",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this result is an error result.<\/p>\n<p>Always the opposite of <a href=\"package-async_async\/ValueResult\/isValue.html\">isValue<\/a>.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/isError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isError =&gt; false;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "isValue",
                    "type": "dart:core.bool",
                    "types": [],
                    "desc": "<p>Whether this result is a value result.<\/p>\n<p>Always the opposite of <a href=\"package-async_async\/ValueResult\/isError.html\">isError<\/a>.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/isValue.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isValue =&gt; true;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "value",
                    "type": "",
                    "types": [],
                    "desc": "<p>The result of a successful computation.<\/p>\n        ",
                    "memberOf": "async.ValueResult",
                    "isConstant": false,
                    "href": "package-async_async\/ValueResult\/value.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final T value\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-async_async\/ValueResult-class.html",
            "desc": "<p>A result representing a returned value.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "ValueResult"
        },
        {
            "name": "collectBytes",
            "type": "dart:async.Future<dart:typed_data.Uint8List>",
            "desc": "<p>Collects an asynchronous sequence of byte lists into a single list of bytes.<\/p>\n<p>If the <code>source<\/code> stream emits an error event,\nthe collection fails and the returned future completes with the same error.<\/p>\n<p>If any of the input data are not valid bytes, they will be truncated to\nan eight-bit unsigned value in the resulting list.<\/p>\n    ",
            "static": false,
            "memberOf": "async",
            "sig": "",
            "params": [
                {
                    "name": "source",
                    "type": "dart:async.Stream<dart:core.List<dart:core.int>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Stream",
                        "dart:core.List",
                        "dart:core.int"
                    ]
                },
                {
                    "name": "source",
                    "type": "dart:async.Stream<dart:core.List<dart:core.int>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Stream",
                        "dart:core.List",
                        "dart:core.int"
                    ]
                }
            ],
            "isConstructor": false,
            "href": "package-async_async\/collectBytes.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;Uint8List&gt; collectBytes(Stream&lt;List&lt;int&gt;&gt; source) {\n  return _collectBytes(source, (_, result) =&gt; result);\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": [
                "dart:async.Future",
                "dart:typed_data.Uint8List"
            ]
        },
        {
            "name": "collectBytesCancelable",
            "type": "async.CancelableOperation<dart:typed_data.Uint8List>",
            "desc": "<p>Collects an asynchronous sequence of byte lists into a single list of bytes.<\/p>\n<p>Returns a <a href=\"package-async_async\/CancelableOperation-class.html\">CancelableOperation<\/a> that provides the result future and a way\nto cancel the collection early.<\/p>\n<p>If the <code>source<\/code> stream emits an error event,\nthe collection fails and the returned future completes with the same error.<\/p>\n<p>If any of the input data are not valid bytes, they will be truncated to\nan eight-bit unsigned value in the resulting list.<\/p>\n    ",
            "static": false,
            "memberOf": "async",
            "sig": "",
            "params": [
                {
                    "name": "source",
                    "type": "dart:async.Stream<dart:core.List<dart:core.int>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Stream",
                        "dart:core.List",
                        "dart:core.int"
                    ]
                },
                {
                    "name": "source",
                    "type": "dart:async.Stream<dart:core.List<dart:core.int>>",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Stream",
                        "dart:core.List",
                        "dart:core.int"
                    ]
                }
            ],
            "isConstructor": false,
            "href": "package-async_async\/collectBytesCancelable.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">CancelableOperation&lt;Uint8List&gt; collectBytesCancelable(\n    Stream&lt;List&lt;int&gt;&gt; source) {\n  return _collectBytes(\n      source,\n      (subscription, result) =&gt; new CancelableOperation.fromFuture(result,\n          onCancel: subscription.cancel));\n}<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "types": [
                "async.CancelableOperation",
                "dart:typed_data.Uint8List"
            ]
        },
        {
            "name": "subscriptionTransformer",
            "type": "dart:async.StreamTransformer",
            "desc": "<p>Creates a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> that modifies the behavior of subscriptions to\na stream.<\/p>\n<p>When <a href=\"dart-async\/StreamSubscription\/cancel.html\">StreamSubscription.cancel<\/a>, <a href=\"dart-async\/StreamSubscription\/pause.html\">StreamSubscription.pause<\/a>, or\n<a href=\"dart-async\/StreamSubscription\/resume.html\">StreamSubscription.resume<\/a> is called, the corresponding handler is invoked.\nBy default, handlers just forward to the underlying subscription.<\/p>\n<p>Guarantees that none of the <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> callbacks and none of the\ncallbacks passed to <code>subscriptionTransformer()<\/code> will be invoked once the\ntransformed <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> has been canceled and <code>handleCancel()<\/code> has\nrun. The <code>handlePause<\/code> and <code>handleResume<\/code> are invoked regardless of whether\nthe subscription is paused already or not.<\/p>\n<p>In order to preserve <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> guarantees, <strong>all callbacks must\nsynchronously call the corresponding method<\/strong> on the inner\n<a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>: <code>handleCancel<\/code> must call <code>cancel()<\/code>, <code>handlePause<\/code>\nmust call <code>pause()<\/code>, and <code>handleResume<\/code> must call <code>resume()<\/code>.<\/p>\n    ",
            "static": false,
            "memberOf": "async",
            "sig": "",
            "params": [
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false,
                    "types": []
                },
                {
                    "name": "inner",
                    "type": "dart:async.StreamSubscription",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "package-async_async\/subscriptionTransformer.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamTransformer&lt;T, T&gt; subscriptionTransformer&lt;T&gt;(\n    {Future handleCancel(StreamSubscription&lt;T&gt; inner),\n    void handlePause(StreamSubscription&lt;T&gt; inner),\n    void handleResume(StreamSubscription&lt;T&gt; inner)}) {\n  return new StreamTransformer((stream, cancelOnError) {\n    return new _TransformedSubscription(\n        stream.listen(null, cancelOnError: cancelOnError),\n        handleCancel ?? (inner) =&gt; inner.cancel(),\n        handlePause ??\n            (inner) {\n              inner.pause();\n            },\n        handleResume ??\n            (inner) {\n              inner.resume();\n            });\n  });\n}<\/code><\/pre>\n    ",
            "isDeprecated": false
        },
        {
            "name": "typedStreamTransformer",
            "type": "dart:async.StreamTransformer",
            "desc": "<p>Creates a wrapper that coerces the type of <code>transformer<\/code>.<\/p>\n<p>This soundly converts a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> to a <code>StreamTransformer&lt;S, T&gt;<\/code>,\nregardless of its original generic type, by asserting that the events\nemitted by the transformed stream are instances of <code>T<\/code> whenever they're\nprovided. If they're not, the stream throws a <a href=\"dart-core\/CastError-class.html\">CastError<\/a>.<\/p>\n    ",
            "static": false,
            "memberOf": "async",
            "sig": "",
            "params": [
                {
                    "name": "transformer",
                    "type": "dart:async.StreamTransformer",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "transformer",
                    "type": "dart:async.StreamTransformer",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "package-async_async\/typedStreamTransformer.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamTransformer&lt;S, T&gt; typedStreamTransformer&lt;S, T&gt;(\n        StreamTransformer transformer) =&gt;\n    transformer is StreamTransformer&lt;S, T&gt;\n        ? transformer\n        : new _TypeSafeStreamTransformer(transformer);<\/code><\/pre>\n    ",
            "isDeprecated": false
        }
    ],
    "isFakeNamespace": false,
    "desc": "",
    "example": "",
    "isDeprecated": false
}