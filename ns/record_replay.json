{
    "name": "record_replay",
    "href": "package-process_record_replay\/package-process_record_replay-library.html",
    "cn": [
        {
            "name": "record_replay.CommandElement",
            "extends": [],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "CommandElement",
                    "type": "",
                    "desc": "<p>Creates a new command element with the specified <code>raw<\/code> value.<\/p>\n<p>If a <code>sanitizer<\/code> is specified, it will be used to generate this command\nelement's <a href=\"package-process_record_replay\/CommandElement\/sanitized.html\">sanitized<\/a> value. If it is unspecified, the raw value will be\nused as the sanitized value.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.CommandElement",
                    "sig": "",
                    "params": [
                        {
                            "name": "raw",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "sanitizer",
                            "type": "record_replay.CommandSanitizer",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-process_record_replay\/CommandElement\/CommandElement.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">CommandElement(this.raw, {CommandSanitizer sanitizer})\n    : _sanitizer = sanitizer;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "toString",
                    "type": "dart:core.String",
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.CommandElement",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/CommandElement\/toString.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; raw;<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "raw",
                    "type": "dart:core.String",
                    "types": [],
                    "desc": "<p>This command element's raw, unsanitized, value.<\/p>\n<p>This value is liable to contain non-deterministic segments, such as\nOS-generated temporary file names. It is suitable for passing to the\noperating system to invoke a process, but it is not suitable for\nrecord\/replay.<\/p>\n        ",
                    "memberOf": "record_replay.CommandElement",
                    "isConstant": false,
                    "href": "package-process_record_replay\/CommandElement\/raw.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String raw\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "sanitized",
                    "type": "dart:core.String",
                    "types": [],
                    "desc": "<p>This command element's sanitized value.<\/p>\n<p>This value has been stripped of any non-deterministic segments, such as\nOS-generated temporary file names or user-specific values. It is suitable\nfor record\/replay, but it is not suitable for passing to the operating\nsystem to invoke a process.<\/p>\n        ",
                    "memberOf": "record_replay.CommandElement",
                    "isConstant": false,
                    "href": "package-process_record_replay\/CommandElement\/sanitized.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get sanitized =&gt; _sanitizer == null ? raw : _sanitizer(raw);<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-process_record_replay\/CommandElement-class.html",
            "desc": "<p>A command element capable of holding both a raw and sanitized value.<\/p>\n<p>Instances of this type can be used in the <code>command<\/code> list of the\n<a href=\"package-process_process\/ProcessManager\/start.html\">ProcessManager.start<\/a>, <a href=\"package-process_process\/ProcessManager\/run.html\">ProcessManager.run<\/a>, and <a href=\"package-process_process\/ProcessManager\/runSync.html\">ProcessManager.runSync<\/a>\nmethods.<\/p>\n<p>Each command element has:<\/p>\n<ul>\n<li>A raw value, which is the value that should passed to the underlying\noperating system to invoke the process.<\/li>\n<li>A sanitized value, which is the value that's serialized when used with\n<a href=\"package-process_record_replay\/RecordingProcessManager-class.html\">RecordingProcessManager<\/a> and looked up in the replay log when used\nwith <a href=\"package-process_record_replay\/ReplayProcessManager-class.html\">ReplayProcessManager<\/a>. Sanitized values typically will remove\nuser-specific segments (such as the user's home directory) or random\nsegments (such as temporary file names). Sanitizing values allows you\nto guarantee determinism in your process invocation lookups, thus\nremoving flakiness in tests.<\/li>\n<\/ul>\n<p>This class implements <a href=\"package-process_record_replay\/CommandElement\/toString.html\">toString<\/a> to return the element's raw value, meaning\ninstances of this class can be passed directly to <a href=\"package-process_process\/LocalProcessManager-class.html\">LocalProcessManager<\/a>\nand will work as intended.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "CommandElement"
        },
        {
            "name": "record_replay.CommandSanitizer",
            "type": "dart:core.String",
            "desc": "<p>Callback used to <a href=\"CommandElement.sanitized\">sanitize<\/a> a <a href=\"package-process_record_replay\/CommandElement-class.html\">CommandElement<\/a>\nfor the purpose of recording.<\/p>\n    ",
            "static": false,
            "memberOf": "record_replay",
            "sig": "",
            "params": [
                {
                    "name": "rawValue",
                    "type": "dart:core.String",
                    "desc": "",
                    "isOptional": true,
                    "href": "",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "isConstructor": false,
            "href": "package-process_record_replay\/CommandSanitizer.html",
            "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">typedef String CommandSanitizer(String rawValue);<\/code><\/pre>\n    ",
            "isDeprecated": false,
            "isMixin": false,
            "isEnum": false,
            "isTypedef": true,
            "isConstant": false,
            "dtype": "typedef"
        },
        {
            "name": "record_replay.InvocationEvent",
            "extends": [],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "InvocationEvent",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.InvocationEvent",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/InvocationEvent\/InvocationEvent.html",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "error",
                    "type": "",
                    "types": [],
                    "desc": "<p>The error that was thrown by the invocation if the invocation completed\nwith an error.<\/p>\n<p>If the invocation completed successfully, this value will be <code>null<\/code>, and\n<a href=\"package-file_record_replay\/InvocationEvent\/result.html\">result<\/a> will hold the result of the invocation (which may also be\n<code>null<\/code>).<\/p>\n<p>This field being non-null can be used as an indication that the invocation\ncompleted with an error.<\/p>\n        ",
                    "memberOf": "record_replay.InvocationEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/InvocationEvent\/error.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">dynamic get error;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "object",
                    "type": "dart:core.Object",
                    "types": [],
                    "desc": "<p>The object on which the invocation occurred. Will always be non-null.<\/p>\n        ",
                    "memberOf": "record_replay.InvocationEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/InvocationEvent\/object.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Object get object;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "result",
                    "type": "",
                    "types": [],
                    "desc": "<p>The return value of the invocation if the invocation completed\nsuccessfully.<\/p>\n<p>This may be null (and will always be <code>null<\/code> for setters).<\/p>\n<p>If the invocation completed with an error, this value will be <code>null<\/code>,\nand <a href=\"package-file_record_replay\/InvocationEvent\/error.html\">error<\/a> will be set.<\/p>\n        ",
                    "memberOf": "record_replay.InvocationEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/InvocationEvent\/result.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">T get result;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "timestamp",
                    "type": "dart:core.int",
                    "types": [],
                    "desc": "<p>The stopwatch value (in milliseconds) when the invocation occurred.<\/p>\n<p>This value is recorded when the invocation first occurs, not when the\ndelegate returns.<\/p>\n        ",
                    "memberOf": "record_replay.InvocationEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/InvocationEvent\/timestamp.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get timestamp;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [
                "record_replay.MethodEvent",
                "record_replay.PropertyGetEvent",
                "record_replay.PropertySetEvent"
            ],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/InvocationEvent-class.html",
            "desc": "<p>Base class for recordable file system invocation events.<\/p>\n<p>Instances of this class will be aggregated in a <a href=\"package-file_record_replay\/Recording-class.html\">Recording<\/a><\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "InvocationEvent"
        },
        {
            "name": "record_replay.InvocationException",
            "extends": [],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "InvocationException",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.InvocationException",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/InvocationException\/InvocationException.html",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/InvocationException-class.html",
            "desc": "<p>Exception thrown during replay when an invocation recorded error, but we\nwere unable to find a type-specific converter to deserialize the recorded\nerror into a more specific exception type.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "InvocationException"
        },
        {
            "name": "record_replay.LiveRecording",
            "extends": [
                "record_replay.Recording",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "LiveRecording",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.LiveRecording",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/LiveRecording\/LiveRecording.html",
                    "example": "",
                    "isDeprecated": false
                },
                {
                    "name": "flush",
                    "type": "dart:async.Future<dart:core.Null>",
                    "desc": "<p>Writes this recording to disk.<\/p>\n<p>Live recordings will <em>not<\/em> call <code>flush<\/code> on themselves, so it is up to\ncallers to call this method when they wish to write the recording to\ndisk.<\/p>\n<p>If <code>pendingResultTimeout<\/code> is specified, this will wait the specified\nduration for any results that are <code>Future<\/code>s or <code>Stream<\/code>s to complete\nbefore serializing the recording to disk. Futures that don't complete\nwithin the specified duration will have their results recorded as <code>null<\/code>,\nand streams that don't send a \"done\" event within the specified duration\nwill have their results recorded as the list of events the stream has\nfired thus far.<\/p>\n<p>If <code>pendingResultTimeout<\/code> is not specified (or is <code>null<\/code>), this will wait\nindefinitely for for any results that are <code>Future<\/code>s or <code>Stream<\/code>s to\ncomplete before serializing the recording to disk.<\/p>\n<p>Throws a <a href=\"dart-core\/StateError-class.html\">StateError<\/a> if a flush is already in progress.<\/p>\n<p>Returns a future that completes once the recording has been fully written\nto disk.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.LiveRecording",
                    "sig": "",
                    "params": [
                        {
                            "name": "pendingResultTimeout",
                            "type": "dart:core.Duration",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-file_record_replay\/LiveRecording\/flush.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;Null&gt; flush({Duration pendingResultTimeout});<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.Null"
                    ]
                }
            ],
            "props": [
                {
                    "name": "destination",
                    "type": "file.Directory",
                    "types": [],
                    "desc": "<p>The directory in which recording files will be stored.<\/p>\n<p>These contents of these files, while human readable, do not constitute an\nAPI or contract. Their makeup and structure is subject to change from\none version of <code>package:file<\/code> to the next.<\/p>\n        ",
                    "memberOf": "record_replay.LiveRecording",
                    "isConstant": false,
                    "href": "package-file_record_replay\/LiveRecording\/destination.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Directory get destination;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/LiveRecording-class.html",
            "desc": "<p>An <a href=\"package-file_record_replay\/Recording-class.html\">Recording<\/a> in progress that can be serialized to disk for later use\nin <a href=\"package-file_record_replay\/ReplayFileSystem-class.html\">ReplayFileSystem<\/a>.<\/p>\n<p>Live recordings exist only in memory until <a href=\"package-file_record_replay\/LiveRecording\/flush.html\">flush<\/a> is called.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "LiveRecording"
        },
        {
            "name": "record_replay.MethodEvent",
            "extends": [
                "record_replay.InvocationEvent",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "MethodEvent",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.MethodEvent",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/MethodEvent\/MethodEvent.html",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "method",
                    "type": "dart:core.Symbol",
                    "types": [],
                    "desc": "<p>The method that was invoked.<\/p>\n        ",
                    "memberOf": "record_replay.MethodEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/MethodEvent\/method.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Symbol get method;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "namedArguments",
                    "type": "dart:core.Map<dart:core.Symbol>",
                    "types": [
                        "dart:core.Map",
                        "dart:core.Symbol"
                    ],
                    "desc": "<p>The named arguments that were passed to the method.<\/p>\n        ",
                    "memberOf": "record_replay.MethodEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/MethodEvent\/namedArguments.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Map&lt;Symbol, dynamic&gt; get namedArguments;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "positionalArguments",
                    "type": "dart:core.List",
                    "types": [],
                    "desc": "<p>The positional arguments that were passed to the method.<\/p>\n        ",
                    "memberOf": "record_replay.MethodEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/MethodEvent\/positionalArguments.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">List&lt;dynamic&gt; get positionalArguments;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/MethodEvent-class.html",
            "desc": "<p>A recordable invocation of a method on a file system object.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "MethodEvent"
        },
        {
            "name": "record_replay.NoMatchingInvocationError",
            "extends": [
                "dart:core.Error",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "NoMatchingInvocationError",
                    "type": "",
                    "desc": "<p>Creates a new <code>NoMatchingInvocationError<\/code> caused by the failure to replay\nthe specified <code>invocation<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.NoMatchingInvocationError",
                    "sig": "",
                    "params": [
                        {
                            "name": "invocation",
                            "type": "dart:core.Invocation",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/NoMatchingInvocationError\/NoMatchingInvocationError.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">NoMatchingInvocationError(this.invocation);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "toString",
                    "type": "dart:core.String",
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.NoMatchingInvocationError",
                    "sig": "",
                    "params": [],
                    "isConstructor": false,
                    "href": "package-file_record_replay\/NoMatchingInvocationError\/toString.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  StringBuffer buf = new StringBuffer();\n  buf.write('No matching invocation found: ');\n  buf.write(getSymbolName(invocation.memberName));\n  if (invocation.isMethod) {\n    buf.write('(');\n    int i = 0;\n    for (dynamic arg in invocation.positionalArguments) {\n      buf.write(Error.safeToString(encode(arg)));\n      if (i++ &gt; 0) {\n        buf.write(', ');\n      }\n    }\n    invocation.namedArguments.forEach((Symbol name, dynamic value) {\n      if (i++ &gt; 0) {\n        buf.write(', ');\n      }\n      buf.write('${getSymbolName(name)}: ${encode(value)}');\n    });\n    buf.write(')');\n  } else if (invocation.isSetter) {\n    buf.write(Error.safeToString(encode(invocation.positionalArguments[0])));\n  }\n  return buf.toString();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "invocation",
                    "type": "dart:core.Invocation",
                    "types": [],
                    "desc": "<p>The invocation that was unable to be replayed.<\/p>\n        ",
                    "memberOf": "record_replay.NoMatchingInvocationError",
                    "isConstant": false,
                    "href": "package-file_record_replay\/NoMatchingInvocationError\/invocation.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Invocation invocation\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/NoMatchingInvocationError-class.html",
            "desc": "<p>Error thrown during replay when there is no matching invocation in the\nrecording.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "NoMatchingInvocationError"
        },
        {
            "name": "record_replay.PropertyGetEvent",
            "extends": [
                "record_replay.InvocationEvent",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "PropertyGetEvent",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.PropertyGetEvent",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/PropertyGetEvent\/PropertyGetEvent.html",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "property",
                    "type": "dart:core.Symbol",
                    "types": [],
                    "desc": "<p>The property that was retrieved.<\/p>\n        ",
                    "memberOf": "record_replay.PropertyGetEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/PropertyGetEvent\/property.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Symbol get property;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/PropertyGetEvent-class.html",
            "desc": "<p>A recordable invocation of a property getter on a file system object.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "PropertyGetEvent"
        },
        {
            "name": "record_replay.PropertySetEvent",
            "extends": [
                "dart:core.Null",
                "record_replay.InvocationEvent",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "PropertySetEvent",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.PropertySetEvent",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/PropertySetEvent\/PropertySetEvent.html",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "property",
                    "type": "dart:core.Symbol",
                    "types": [],
                    "desc": "<p>The property that was set.<\/p>\n<p>All setter property symbols will have a trailing equals sign. For example,\nif the <code>foo<\/code> property was set, this value will be a symbol of <code>foo=<\/code>.<\/p>\n        ",
                    "memberOf": "record_replay.PropertySetEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/PropertySetEvent\/property.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Symbol get property;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "value",
                    "type": "",
                    "types": [],
                    "desc": "<p>The value to which <a href=\"package-file_record_replay\/PropertySetEvent\/property.html\">property<\/a> was set. This is distinct from <a href=\"package-file_record_replay\/InvocationEvent\/result.html\">result<\/a>,\nwhich is always <code>null<\/code> for setters.<\/p>\n        ",
                    "memberOf": "record_replay.PropertySetEvent",
                    "isConstant": false,
                    "href": "package-file_record_replay\/PropertySetEvent\/value.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">T get value;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/PropertySetEvent-class.html",
            "desc": "<p>A recordable invocation of a property setter on a file system object.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "PropertySetEvent"
        },
        {
            "name": "record_replay.Recording",
            "extends": [],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "Recording",
                    "type": "",
                    "desc": "",
                    "static": false,
                    "memberOf": "record_replay.Recording",
                    "sig": "",
                    "params": [],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/Recording\/Recording.html",
                    "example": "",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "events",
                    "type": "dart:core.List<record_replay.InvocationEvent>",
                    "types": [
                        "dart:core.List",
                        "record_replay.InvocationEvent"
                    ],
                    "desc": "<p>The invocation events that have been captured by this recording.<\/p>\n        ",
                    "memberOf": "record_replay.Recording",
                    "isConstant": false,
                    "href": "package-file_record_replay\/Recording\/events.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">List&lt;InvocationEvent&lt;dynamic&gt;&gt; get events;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [
                "record_replay.LiveRecording"
            ],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/Recording-class.html",
            "desc": "<p>A recording of a series of invocations on a <a href=\"package-file_file\/FileSystem-class.html\">FileSystem<\/a> and its associated\nobjects (<code>File<\/code>, <code>Directory<\/code>, <code>IOSink<\/code>, etc).<\/p>\n<p>Recorded invocations include property getters, property setters, and\nstandard method invocations. A recording exists as an ordered series of\n\"invocation events\".<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "Recording"
        },
        {
            "name": "record_replay.RecordingFileSystem",
            "extends": [
                "file.FileSystem",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "RecordingFileSystem",
                    "type": "",
                    "desc": "<p>Creates a new <code>RecordingFileSystem<\/code>.<\/p>\n<p>Invocations will be recorded and forwarded to the specified <code>delegate<\/code>\nfile system.<\/p>\n<p>The recording will be serialized to the specified <code>destination<\/code> directory\n(only when <code>flush<\/code> is called on this file system's <a href=\"package-file_record_replay\/RecordingFileSystem\/recording.html\">recording<\/a>).<\/p>\n<p>If <code>stopwatch<\/code> is specified, it will be assumed to have already been\nstarted by the caller, and it will be used to record timestamps on each\nrecorded invocation. If <code>stopwatch<\/code> is unspecified (or <code>null<\/code>), a new\nstopwatch will be created and started immediately to record these\ntimestamps.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingFileSystem",
                    "sig": "",
                    "params": [
                        {
                            "name": "delegate",
                            "type": "file.FileSystem",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "destination",
                            "type": "file.Directory",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stopwatch",
                            "type": "dart:core.Stopwatch",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/RecordingFileSystem\/RecordingFileSystem.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory RecordingFileSystem({\n  @required FileSystem delegate,\n  @required Directory destination,\n  Stopwatch stopwatch,\n}) =&gt;\n    new RecordingFileSystemImpl(delegate, destination, stopwatch);<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [
                {
                    "name": "delegate",
                    "type": "file.FileSystem",
                    "types": [],
                    "desc": "<p>The file system to which invocations will be forwarded upon recording.<\/p>\n        ",
                    "memberOf": "record_replay.RecordingFileSystem",
                    "isConstant": false,
                    "href": "package-file_record_replay\/RecordingFileSystem\/delegate.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">FileSystem get delegate;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "recording",
                    "type": "record_replay.LiveRecording",
                    "types": [],
                    "desc": "<p>The recording generated by invocations on this file system.<\/p>\n<p>The recording provides access to the invocation events that have been\nrecorded thus far, as well as the ability to flush them to disk.<\/p>\n        ",
                    "memberOf": "record_replay.RecordingFileSystem",
                    "isConstant": false,
                    "href": "package-file_record_replay\/RecordingFileSystem\/recording.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">LiveRecording get recording;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "stopwatch",
                    "type": "dart:core.Stopwatch",
                    "types": [],
                    "desc": "<p>The stopwatch used to record timestamps on invocation events.<\/p>\n<p>Timestamps will be recorded before the delegate is invoked (not after\nthe delegate returns).<\/p>\n        ",
                    "memberOf": "record_replay.RecordingFileSystem",
                    "isConstant": false,
                    "href": "package-file_record_replay\/RecordingFileSystem\/stopwatch.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stopwatch get stopwatch;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/RecordingFileSystem-class.html",
            "desc": "<p>File system that records invocations for later playback in tests.<\/p>\n<p>This will record all invocations (methods, property getters, and property\nsetters) that occur on it, in an opaque format that can later be used in\n<a href=\"package-file_record_replay\/ReplayFileSystem-class.html\">ReplayFileSystem<\/a>. All activity in the <a href=\"package-file_file\/File-class.html\">File<\/a>, <a href=\"package-file_file\/Directory-class.html\">Directory<\/a>, <a href=\"package-file_file\/Link-class.html\">Link<\/a>,\n<a href=\"dart-io\/IOSink-class.html\">IOSink<\/a>, and <a href=\"dart-io\/RandomAccessFile-class.html\">RandomAccessFile<\/a> instances returned from this API will also\nbe recorded.<\/p>\n<p>This class is intended for use in tests, where you would otherwise have to\nset up complex mocks or fake file systems. With this class, the process is\nas follows:<\/p>\n<ul>\n<li>You record the file system activity during a real run of your program\nby injecting a <code>RecordingFileSystem<\/code> that delegates to your real file\nsystem.<\/li>\n<li>You serialize that recording to disk as your program finishes.<\/li>\n<li>You use that recording in tests to create a mock file system that knows\nhow to respond to the exact invocations your program makes. Any\ninvocations that aren't in the recording will throw, and you can make\nassertions in your tests about which methods were invoked and in what\norder.<\/li>\n<\/ul>\n<p><em>Implementation note<\/em>: this class uses <a href=\"dart-core\/Object\/noSuchMethod.html\">noSuchMethod<\/a> to dynamically handle\ninvocations. As a result, method references on objects herein will not pass\n<code>is<\/code> checks or checked-mode checks on type. For example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">typedef FileStat StatSync(String path);\nFileSystem fs = new RecordingFileSystem(delegate: delegate, destination: dir);\n\nStatSync method = fs.statSync;     \/\/ Will fail in checked-mode\nfs.statSync is StatSync            \/\/ Will return false\nfs.statSync is Function            \/\/ Will return false\n\ndynamic method2 = fs.statSync;     \/\/ OK\nFileStat stat = method2('\/path');  \/\/ OK\n<\/code><\/pre>\n<p>See also:<\/p>\n<ul><li><a href=\"package-file_record_replay\/ReplayFileSystem-class.html\">ReplayFileSystem<\/a><\/li><\/ul>",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "RecordingFileSystem"
        },
        {
            "name": "record_replay.RecordingProcessManager",
            "extends": [],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "RecordingProcessManager",
                    "type": "",
                    "desc": "<p>Constructs a new <code>RecordingProcessManager<\/code>.<\/p>\n<p>This manager will record all process invocations and serialize them to\nthe specified <code>destination<\/code>. The underlying <code>ProcessManager<\/code> functionality\nwill be delegated to <code>delegate<\/code>.<\/p>\n<p>If <code>destination<\/code> does not already exist, or if it exists and is not empty,\na <a href=\"dart-core\/StateError-class.html\">StateError<\/a> will be thrown.<\/p>\n<p><code>destination<\/code> should be treated as opaque. Its contents are intended to\nbe consumed only by <a href=\"package-process_record_replay\/ReplayProcessManager-class.html\">ReplayProcessManager<\/a> and are subject to change\nbetween versions of <code>package:process<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "delegate",
                            "type": "process.ProcessManager",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "destination",
                            "type": "file.Directory",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-process_record_replay\/RecordingProcessManager\/RecordingProcessManager.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RecordingProcessManager(this.delegate, this.destination) {\n  if (!destination.existsSync() || destination.listSync().isNotEmpty) {\n    throw new StateError('Cannot record to ${destination.path}');\n  }\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "canRun",
                    "type": "dart:core.bool",
                    "desc": "<p>Returns <code>true<\/code> if the <code>executable<\/code> exists and if it can be executed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "executable",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/canRun.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool canRun(dynamic executable, {String workingDirectory}) {\n  bool result =\n      delegate.canRun(executable, workingDirectory: workingDirectory);\n  _manifest.add(new CanRunManifestEntry(\n      executable: executable.toString(), result: result));\n  return result;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "flush",
                    "type": "dart:async.Future<dart:core.Null>",
                    "desc": "<p>Flushes pending data to <a href=\"package-process_record_replay\/RecordingProcessManager\/destination.html\">destination<\/a>.<\/p>\n<p>This manager may buffer invocation metadata in memory as it sees fit.\nCalling <code>flush<\/code> will force the manager to write any pending data to disk.\nThis returns a future that completes when all pending data has been\nwritten to disk.<\/p>\n<p>Failure to call this method before the current process exits will likely\ncause invocation data to be lost.<\/p>\n<p>If <code>finishRunningProcesses<\/code> is true, the returned future will only\ncomplete after all running processes have exited, thus guaranteeing that\nno new invocation data will be generated until new processes are invoked.\nAny processes that don't exit on their own within the specified <code>timeout<\/code>\nwill be marked as daemon processes in the serialized metadata and will be\nsignalled with <code>SIGTERM<\/code>. If such processes <em>still<\/em> don't exit within the\nspecified <code>timeout<\/code> after being signalled, they'll be marked as not\nresponding in the serialized metadata.<\/p>\n<p>If <code>finishRunningProcesses<\/code> is false (the default), then <code>timeout<\/code> is\nignored.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "finishRunningProcesses",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "timeout",
                            "type": "dart:core.Duration",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/flush.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;Null&gt; flush({\n  bool finishRunningProcesses: false,\n  Duration timeout: const Duration(milliseconds: 20),\n}) async {\n  if (finishRunningProcesses) {\n    await _waitForRunningProcessesToExit(timeout);\n  }\n  await _writeManifestToDisk();\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:core.Null"
                    ]
                },
                {
                    "name": "killPid",
                    "type": "dart:core.bool",
                    "desc": "<p>Kills the process with id <code>pid<\/code>.<\/p>\n<p>Where possible, sends the <code>signal<\/code> to the process with id\n<code>pid<\/code>. This includes Linux and OS X. The default signal is\n<a href=\"dart-io\/ProcessSignal\/sigterm-constant.html\">ProcessSignal.sigterm<\/a> which will normally terminate the\nprocess.<\/p>\n<p>On platforms without signal support, including Windows, the call\njust terminates the process with id <code>pid<\/code> in a platform specific\nway, and the <code>signal<\/code> parameter is ignored.<\/p>\n<p>Returns <code>true<\/code> if the signal is successfully delivered to the\nprocess. Otherwise the signal could not be sent, usually meaning\nthat the process is already dead.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "pid",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "signal",
                            "type": "dart:io.ProcessSignal",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/killPid.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool killPid(int pid, [io.ProcessSignal signal = io.ProcessSignal.sigterm]) {\n  return delegate.killPid(pid, signal);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "run",
                    "type": "dart:async.Future<dart:io.ProcessResult>",
                    "desc": "<p>Starts a process and runs it non-interactively to completion.<\/p>\n<p>The first element in <code>command<\/code> will be treated as the executable to run,\nwith subsequent elements being passed as arguments to the executable. It\nis left to implementations to decide what element types they support in\nthe <code>command<\/code> list.<\/p>\n<p>Use <code>workingDirectory<\/code> to set the working directory for the process. Note\nthat the change of directory occurs before executing the process on some\nplatforms, which may have impact when using relative paths for the\nexecutable and the arguments.<\/p>\n<p>Use <code>environment<\/code> to set the environment variables for the process. If not\nset the environment of the parent process is inherited. Currently, only\nUS-ASCII environment variables are supported and errors are likely to occur\nif an environment variable with code-points outside the US-ASCII range is\npassed in.<\/p>\n<p>If <code>includeParentEnvironment<\/code> is <code>true<\/code>, the process's environment will\ninclude the parent process's environment, with <code>environment<\/code> taking\nprecedence. Default is <code>true<\/code>.<\/p>\n<p>If <code>runInShell<\/code> is true, the process will be spawned through a system\nshell. On Linux and OS X, <code>\/bin\/sh<\/code> is used, while\n<code>%WINDIR%\\system32\\cmd.exe<\/code> is used on Windows.<\/p>\n<p>The encoding used for decoding <code>stdout<\/code> and <code>stderr<\/code> into text is\ncontrolled through <code>stdoutEncoding<\/code> and <code>stderrEncoding<\/code>. The\ndefault encoding is <a href=\"dart-io\/systemEncoding-constant.html\">systemEncoding<\/a>. If <code>null<\/code> is used no\ndecoding will happen and the <a href=\"dart-io\/ProcessResult-class.html\">ProcessResult<\/a> will hold binary\ndata.<\/p>\n<p>Returns a <code>Future&lt;ProcessResult&gt;<\/code> that completes with the\nresult of running the process, i.e., exit code, standard out and\nstandard in.<\/p>\n<p>The following code uses <code>run<\/code> to grep for <code>main<\/code> in the\nfile <code>test.dart<\/code> on Linux.<\/p>\n<pre class=\"language-dart\"><code>ProcessManager mgr = new LocalProcessManager();\nmgr.run('grep', ['-i', 'main', 'test.dart']).then((result) {\n  stdout.write(result.stdout);\n  stderr.write(result.stderr);\n});\n<\/code><\/pre>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "command",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "environment",
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Map",
                                "dart:core.String",
                                "dart:core.String"
                            ]
                        },
                        {
                            "name": "includeParentEnvironment",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "runInShell",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stdoutEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stderrEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/run.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;io.ProcessResult&gt; run(\n  List&lt;dynamic&gt; command, {\n  String workingDirectory,\n  Map&lt;String, String&gt; environment,\n  bool includeParentEnvironment: true,\n  bool runInShell: false,\n  Encoding stdoutEncoding: io.systemEncoding,\n  Encoding stderrEncoding: io.systemEncoding,\n}) async {\n  io.ProcessResult result = await delegate.run(\n    command,\n    workingDirectory: workingDirectory,\n    environment: environment,\n    includeParentEnvironment: includeParentEnvironment,\n    runInShell: runInShell,\n    stdoutEncoding: stdoutEncoding,\n    stderrEncoding: stderrEncoding,\n  );\n\n  List&lt;String&gt; sanitizedCommand = sanitize(command);\n  String basename = _getBasename(result.pid, sanitizedCommand);\n  _manifest.add(new RunManifestEntry(\n    pid: result.pid,\n    basename: basename,\n    command: sanitizedCommand,\n    workingDirectory: workingDirectory,\n    environment: environment,\n    includeParentEnvironment: includeParentEnvironment,\n    runInShell: runInShell,\n    stdoutEncoding: stdoutEncoding,\n    stderrEncoding: stderrEncoding,\n    exitCode: result.exitCode,\n  ));\n\n  await _recordData(result.stdout, stdoutEncoding, '$basename.stdout');\n  await _recordData(result.stderr, stderrEncoding, '$basename.stderr');\n\n  return result;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:io.ProcessResult"
                    ]
                },
                {
                    "name": "runSync",
                    "type": "dart:io.ProcessResult",
                    "desc": "<p>Starts a process and runs it to completion. This is a synchronous\ncall and will block until the child process terminates.<\/p>\n<p>The arguments are the same as for <a href=\"package-process_record_replay\/RecordingProcessManager\/run.html\">run<\/a>`.<\/p>\n<p>Returns a <code>ProcessResult<\/code> with the result of running the process,\ni.e., exit code, standard out and standard in.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "command",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "environment",
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Map",
                                "dart:core.String",
                                "dart:core.String"
                            ]
                        },
                        {
                            "name": "includeParentEnvironment",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "runInShell",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stdoutEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stderrEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/runSync.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nio.ProcessResult runSync(\n  List&lt;dynamic&gt; command, {\n  String workingDirectory,\n  Map&lt;String, String&gt; environment,\n  bool includeParentEnvironment: true,\n  bool runInShell: false,\n  Encoding stdoutEncoding: io.systemEncoding,\n  Encoding stderrEncoding: io.systemEncoding,\n}) {\n  io.ProcessResult result = delegate.runSync(\n    command,\n    workingDirectory: workingDirectory,\n    environment: environment,\n    includeParentEnvironment: includeParentEnvironment,\n    runInShell: runInShell,\n    stdoutEncoding: stdoutEncoding,\n    stderrEncoding: stderrEncoding,\n  );\n\n  List&lt;String&gt; sanitizedCommand = sanitize(command);\n  String basename = _getBasename(result.pid, sanitizedCommand);\n  _manifest.add(new RunManifestEntry(\n    pid: result.pid,\n    basename: basename,\n    command: sanitizedCommand,\n    workingDirectory: workingDirectory,\n    environment: environment,\n    includeParentEnvironment: includeParentEnvironment,\n    runInShell: runInShell,\n    stdoutEncoding: stdoutEncoding,\n    stderrEncoding: stderrEncoding,\n    exitCode: result.exitCode,\n  ));\n\n  _recordDataSync(result.stdout, stdoutEncoding, '$basename.stdout');\n  _recordDataSync(result.stderr, stderrEncoding, '$basename.stderr');\n\n  return result;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "start",
                    "type": "dart:async.Future<dart:io.Process>",
                    "desc": "<p>Starts a process by running the specified <code>command<\/code>.<\/p>\n<p>The first element in <code>command<\/code> will be treated as the executable to run,\nwith subsequent elements being passed as arguments to the executable. It\nis left to implementations to decide what element types they support in\nthe <code>command<\/code> list.<\/p>\n<p>Returns a <code>Future&lt;Process&gt;<\/code> that completes with a Process instance when\nthe process has been successfully started. That <a href=\"dart-io\/Process-class.html\">Process<\/a> object can be\nused to interact with the process. If the process cannot be started, the\nreturned <a href=\"dart-async\/Future-class.html\">Future<\/a> completes with an exception.<\/p>\n<p>Use <code>workingDirectory<\/code> to set the working directory for the process. Note\nthat the change of directory occurs before executing the process on some\nplatforms, which may have impact when using relative paths for the\nexecutable and the arguments.<\/p>\n<p>Use <code>environment<\/code> to set the environment variables for the process. If not\nset, the environment of the parent process is inherited. Currently, only\nUS-ASCII environment variables are supported and errors are likely to occur\nif an environment variable with code-points outside the US-ASCII range is\npassed in.<\/p>\n<p>If <code>includeParentEnvironment<\/code> is <code>true<\/code>, the process's environment will\ninclude the parent process's environment, with <code>environment<\/code> taking\nprecedence. Default is <code>true<\/code>.<\/p>\n<p>If <code>runInShell<\/code> is <code>true<\/code>, the process will be spawned through a system\nshell. On Linux and OS X, <code>\/bin\/sh<\/code> is used, while\n<code>%WINDIR%\\system32\\cmd.exe<\/code> is used on Windows.<\/p>\n<p>Users must read all data coming on the <code>stdout<\/code> and <code>stderr<\/code>\nstreams of processes started with <a href=\"package-process_record_replay\/RecordingProcessManager\/start.html\">start<\/a>. If the user\ndoes not read all data on the streams the underlying system\nresources will not be released since there is still pending data.<\/p>\n<p>The following code uses <code>start<\/code> to grep for <code>main<\/code> in the\nfile <code>test.dart<\/code> on Linux.<\/p>\n<pre class=\"language-dart\"><code>ProcessManager mgr = new LocalProcessManager();\nmgr.start('grep', ['-i', 'main', 'test.dart']).then((process) {\n  stdout.addStream(process.stdout);\n  stderr.addStream(process.stderr);\n});\n<\/code><\/pre>\n<p>If <code>mode<\/code> is <a href=\"dart-io\/ProcessStartMode\/normal-constant.html\">ProcessStartMode.normal<\/a> (the default) a child\nprocess will be started with <code>stdin<\/code>, <code>stdout<\/code> and <code>stderr<\/code>\nconnected.<\/p>\n<p>If <code>mode<\/code> is <a href=\"dart-io\/ProcessStartMode\/detached-constant.html\">ProcessStartMode.detached<\/a> a detached process will\nbe created. A detached process has no connection to its parent,\nand can keep running on its own when the parent dies. The only\ninformation available from a detached process is its <code>pid<\/code>. There\nis no connection to its <code>stdin<\/code>, <code>stdout<\/code> or <code>stderr<\/code>, nor will\nthe process' exit code become available when it terminates.<\/p>\n<p>If <code>mode<\/code> is <a href=\"dart-io\/ProcessStartMode\/detachedWithStdio-constant.html\">ProcessStartMode.detachedWithStdio<\/a> a detached\nprocess will be created where the <code>stdin<\/code>, <code>stdout<\/code> and <code>stderr<\/code>\nare connected. The creator can communicate with the child through\nthese. The detached process will keep running even if these\ncommunication channels are closed. The process' exit code will\nnot become available when it terminated.<\/p>\n<p>The default value for <code>mode<\/code> is <code>ProcessStartMode.NORMAL<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.RecordingProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "command",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "environment",
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Map",
                                "dart:core.String",
                                "dart:core.String"
                            ]
                        },
                        {
                            "name": "includeParentEnvironment",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "runInShell",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "mode",
                            "type": "dart:io.ProcessStartMode",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/start.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;io.Process&gt; start(\n  List&lt;dynamic&gt; command, {\n  String workingDirectory,\n  Map&lt;String, String&gt; environment,\n  bool includeParentEnvironment: true,\n  bool runInShell: false,\n  io.ProcessStartMode mode: io.ProcessStartMode.normal,\n}) async {\n  io.Process process = await delegate.start(\n    command,\n    workingDirectory: workingDirectory,\n    environment: environment,\n    includeParentEnvironment: includeParentEnvironment,\n    runInShell: runInShell,\n    mode: mode,\n  );\n\n  List&lt;String&gt; sanitizedCommand = sanitize(command);\n  String basename = _getBasename(process.pid, sanitizedCommand);\n  RunManifestEntry entry = new RunManifestEntry(\n    pid: process.pid,\n    basename: basename,\n    command: sanitizedCommand,\n    workingDirectory: workingDirectory,\n    environment: environment,\n    includeParentEnvironment: includeParentEnvironment,\n    runInShell: runInShell,\n    mode: mode,\n  );\n  _manifest.add(entry);\n\n  _RecordingProcess result = new _RecordingProcess(\n    manager: this,\n    basename: basename,\n    delegate: process,\n  );\n  await result.startRecording();\n  _runningProcesses[process.pid] = result.exitCode.then((int exitCode) {\n    _runningProcesses.remove(process.pid);\n    entry.exitCode = exitCode;\n    return exitCode;\n  });\n\n  return result;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:io.Process"
                    ]
                }
            ],
            "props": [
                {
                    "name": "delegate",
                    "type": "process.ProcessManager",
                    "types": [],
                    "desc": "<p>The manager to which this manager delegates.<\/p>\n        ",
                    "memberOf": "record_replay.RecordingProcessManager",
                    "isConstant": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/delegate.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ProcessManager delegate\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "destination",
                    "type": "file.Directory",
                    "types": [],
                    "desc": "<p>The directory to which serialized invocation metadata will be written.<\/p>\n        ",
                    "memberOf": "record_replay.RecordingProcessManager",
                    "isConstant": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/destination.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Directory destination\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "fs",
                    "type": "file.FileSystem",
                    "types": [],
                    "desc": "<p>The file system in which this manager will create recording files.<\/p>\n        ",
                    "memberOf": "record_replay.RecordingProcessManager",
                    "isConstant": false,
                    "href": "package-process_record_replay\/RecordingProcessManager\/fs.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">FileSystem get fs =&gt; destination.fileSystem;<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-process_record_replay\/RecordingProcessManager-class.html",
            "desc": "<p>Records process invocation activity and serializes it to disk.<\/p>\n<p>A <code>RecordingProcessManager<\/code> decorates another <code>ProcessManager<\/code> instance by\nrecording all process invocation activity (including the stdout and stderr\nof the associated processes) before delegating to the underlying manager.<\/p>\n<p>This class enables \"record \/ replay\" tests, where you record the process\ninvocation activity during a real program run, serialize the activity to\ndisk, then fake all invocation activity during tests by replaying the\nserialized recording.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"package-process_record_replay\/ReplayProcessManager-class.html\">ReplayProcessManager<\/a>.<\/li><\/ul>",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "RecordingProcessManager"
        },
        {
            "name": "record_replay.ReplayFileSystem",
            "extends": [
                "file.FileSystem",
                "dart:core.Object"
            ],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "ReplayFileSystem",
                    "type": "",
                    "desc": "<p>Creates a new <code>ReplayFileSystem<\/code>.<\/p>\n<p>Recording data will be loaded from the specified <code>recording<\/code> location.\nThis location must have been created by <a href=\"package-file_record_replay\/RecordingFileSystem-class.html\">RecordingFileSystem<\/a>, or an\n<a href=\"dart-core\/ArgumentError-class.html\">ArgumentError<\/a> will be thrown.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayFileSystem",
                    "sig": "",
                    "params": [
                        {
                            "name": "recording",
                            "type": "file.Directory",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": true,
                    "href": "package-file_record_replay\/ReplayFileSystem\/ReplayFileSystem.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory ReplayFileSystem({\n  @required Directory recording,\n}) {\n  String dirname = recording.path;\n  String path = recording.fileSystem.path.join(dirname, kManifestName);\n  File manifestFile = recording.fileSystem.file(path);\n  if (!manifestFile.existsSync()) {\n    throw new ArgumentError('Not a valid recording directory: $dirname');\n  }\n  List&lt;Map&lt;String, dynamic&gt;&gt; manifest = new JsonDecoder()\n      .convert(manifestFile.readAsStringSync())\n      .cast&lt;Map&lt;String, dynamic&gt;&gt;();\n  return new ReplayFileSystemImpl(recording, manifest);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                }
            ],
            "props": [],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": true,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-file_record_replay\/ReplayFileSystem-class.html",
            "desc": "<p>A file system that replays invocations from a prior recording for use\nin tests.<\/p>\n<p>This will replay all invocations (methods, property getters, and property\nsetters) that occur on it, based on an opaque recording that was generated\nin <a href=\"package-file_record_replay\/RecordingFileSystem-class.html\">RecordingFileSystem<\/a>. All activity in the <a href=\"package-file_file\/File-class.html\">File<\/a>, <a href=\"package-file_file\/Directory-class.html\">Directory<\/a>, <a href=\"package-file_file\/Link-class.html\">Link<\/a>,\n<a href=\"dart-io\/IOSink-class.html\">IOSink<\/a>, and <a href=\"dart-io\/RandomAccessFile-class.html\">RandomAccessFile<\/a> instances returned from this API will also\nbe replayed from the same recording.<\/p>\n<p>Once an invocation has been replayed once, it is marked as such and will\nnot be eligible for further replay. If an eligible invocation cannot be\nfound that matches an incoming invocation, a <a href=\"package-file_record_replay\/NoMatchingInvocationError-class.html\">NoMatchingInvocationError<\/a>\nwill be thrown.<\/p>\n<p>This class is intended for use in tests, where you would otherwise have to\nset up complex mocks or fake file systems. With this class, the process is\nas follows:<\/p>\n<ul>\n<li>You record the file system activity during a real run of your program\nby injecting a <code>RecordingFileSystem<\/code> that delegates to your real file\nsystem.<\/li>\n<li>You serialize that recording to disk as your program finishes.<\/li>\n<li>You use that recording in tests to create a mock file system that knows\nhow to respond to the exact invocations your program makes. Any\ninvocations that aren't in the recording will throw, and you can make\nassertions in your tests about which methods were invoked and in what\norder.<\/li>\n<\/ul>\n<p><em>Implementation note<\/em>: this class uses <a href=\"dart-core\/Object\/noSuchMethod.html\">noSuchMethod<\/a> to dynamically handle\ninvocations. As a result, method references on objects herein will not pass\n<code>is<\/code> checks or checked-mode checks on type. For example:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">typedef FileStat StatSync(String path);\nFileSystem fs = new ReplayFileSystem(directory);\n\nStatSync method = fs.statSync;     \/\/ Will fail in checked-mode\nfs.statSync is StatSync            \/\/ Will return false\nfs.statSync is Function            \/\/ Will return false\n\ndynamic method2 = fs.statSync;     \/\/ OK\nFileStat stat = method2('\/path');  \/\/ OK\n<\/code><\/pre>\n<p>See also:<\/p>\n<ul><li><a href=\"package-file_record_replay\/RecordingFileSystem-class.html\">RecordingFileSystem<\/a><\/li><\/ul>",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "ReplayFileSystem"
        },
        {
            "name": "record_replay.ReplayProcessManager",
            "extends": [],
            "memberOf": "record_replay",
            "events": [],
            "methods": [
                {
                    "name": "canRun",
                    "type": "dart:core.bool",
                    "desc": "<p>Returns <code>true<\/code> if the <code>executable<\/code> exists and if it can be executed.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "executable",
                            "type": "",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": []
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/canRun.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool canRun(dynamic executable, {String workingDirectory}) {\n  CanRunManifestEntry entry = _manifest.findPendingCanRunEntry(\n    executable: executable.toString(),\n  );\n  if (entry == null) {\n    throw new ArgumentError('No matching invocation found for $executable');\n  }\n  entry.setInvoked();\n  return entry.result;\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "create",
                    "type": "dart:async.Future<record_replay.ReplayProcessManager>",
                    "desc": "<p>Creates a new <code>ReplayProcessManager<\/code> capable of replaying a recording that\nwas serialized to the specified <code>location<\/code> by <a href=\"package-process_record_replay\/RecordingProcessManager-class.html\">RecordingProcessManager<\/a>.<\/p>\n<p>If <code>location<\/code> does not exist, or if it does not represent a valid\nrecording (as determined by <a href=\"package-process_record_replay\/RecordingProcessManager-class.html\">RecordingProcessManager<\/a>), an <a href=\"dart-core\/ArgumentError-class.html\">ArgumentError<\/a>\nwill be thrown.<\/p>\n<p>If <code>streamDelay<\/code> is specified, processes spawned by this manager will\ndelay their <code>stdout<\/code> and <code>stderr<\/code> stream production by the specified\namount. This is useful in cases where the real process invocation had\na necessary delay in stream production, and you need to mirror that\nbehavior. e.g. you spawn a <code>tail<\/code> process to tail a log file, then in a\nfollow-on event loop, you invoke a <code>startServer<\/code> process, which starts\nproducing log output. In this case, you may need to delay the <code>tail<\/code>\noutput to prevent its stream from flushing all its content before you\nstart listening.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "location",
                            "type": "file.Directory",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "streamDelay",
                            "type": "dart:core.Duration",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/create.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;ReplayProcessManager&gt; create(\n  Directory location, {\n  Duration streamDelay: Duration.zero,\n}) async {\n  assert(streamDelay != null);\n\n  if (!location.existsSync()) {\n    throw new ArgumentError.value(location.path, 'location', \"Doesn't exist\");\n  }\n\n  FileSystem fs = location.fileSystem;\n  File manifestFile = fs.file(path.join(location.path, kManifestName));\n  if (!manifestFile.existsSync()) {\n    throw new ArgumentError.value(\n        location, 'location', 'Does not represent a valid recording');\n  }\n\n  String content = await manifestFile.readAsString();\n  try {\n    \/\/ We don't validate the existence of all stdout and stderr files\n    \/\/ referenced in the manifest.\n    Manifest manifest = new Manifest.fromJson(content);\n    return new ReplayProcessManager._(manifest, location, streamDelay);\n  } on FormatException catch (e) {\n    throw new ArgumentError('$kManifestName is not a valid JSON file: $e');\n  }\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "record_replay.ReplayProcessManager"
                    ]
                },
                {
                    "name": "killPid",
                    "type": "dart:core.bool",
                    "desc": "<p>Kills the process with id <code>pid<\/code>.<\/p>\n<p>Where possible, sends the <code>signal<\/code> to the process with id\n<code>pid<\/code>. This includes Linux and OS X. The default signal is\n<a href=\"dart-io\/ProcessSignal\/sigterm-constant.html\">ProcessSignal.sigterm<\/a> which will normally terminate the\nprocess.<\/p>\n<p>On platforms without signal support, including Windows, the call\njust terminates the process with id <code>pid<\/code> in a platform specific\nway, and the <code>signal<\/code> parameter is ignored.<\/p>\n<p>Returns <code>true<\/code> if the signal is successfully delivered to the\nprocess. Otherwise the signal could not be sent, usually meaning\nthat the process is already dead.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "pid",
                            "type": "dart:core.int",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "signal",
                            "type": "dart:io.ProcessSignal",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/killPid.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool killPid(int pid, [io.ProcessSignal signal = io.ProcessSignal.sigterm]) {\n  throw new UnsupportedError(\n      \"$runtimeType.killPid() has not been implemented because at the time \"\n      \"of its writing, it wasn't needed. If you're hitting this error, you \"\n      \"should implement it.\");\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "run",
                    "type": "dart:async.Future<dart:io.ProcessResult>",
                    "desc": "<p>Starts a process and runs it non-interactively to completion.<\/p>\n<p>The first element in <code>command<\/code> will be treated as the executable to run,\nwith subsequent elements being passed as arguments to the executable. It\nis left to implementations to decide what element types they support in\nthe <code>command<\/code> list.<\/p>\n<p>Use <code>workingDirectory<\/code> to set the working directory for the process. Note\nthat the change of directory occurs before executing the process on some\nplatforms, which may have impact when using relative paths for the\nexecutable and the arguments.<\/p>\n<p>Use <code>environment<\/code> to set the environment variables for the process. If not\nset the environment of the parent process is inherited. Currently, only\nUS-ASCII environment variables are supported and errors are likely to occur\nif an environment variable with code-points outside the US-ASCII range is\npassed in.<\/p>\n<p>If <code>includeParentEnvironment<\/code> is <code>true<\/code>, the process's environment will\ninclude the parent process's environment, with <code>environment<\/code> taking\nprecedence. Default is <code>true<\/code>.<\/p>\n<p>If <code>runInShell<\/code> is true, the process will be spawned through a system\nshell. On Linux and OS X, <code>\/bin\/sh<\/code> is used, while\n<code>%WINDIR%\\system32\\cmd.exe<\/code> is used on Windows.<\/p>\n<p>The encoding used for decoding <code>stdout<\/code> and <code>stderr<\/code> into text is\ncontrolled through <code>stdoutEncoding<\/code> and <code>stderrEncoding<\/code>. The\ndefault encoding is <a href=\"dart-io\/systemEncoding-constant.html\">systemEncoding<\/a>. If <code>null<\/code> is used no\ndecoding will happen and the <a href=\"dart-io\/ProcessResult-class.html\">ProcessResult<\/a> will hold binary\ndata.<\/p>\n<p>Returns a <code>Future&lt;ProcessResult&gt;<\/code> that completes with the\nresult of running the process, i.e., exit code, standard out and\nstandard in.<\/p>\n<p>The following code uses <code>run<\/code> to grep for <code>main<\/code> in the\nfile <code>test.dart<\/code> on Linux.<\/p>\n<pre class=\"language-dart\"><code>ProcessManager mgr = new LocalProcessManager();\nmgr.run('grep', ['-i', 'main', 'test.dart']).then((result) {\n  stdout.write(result.stdout);\n  stderr.write(result.stderr);\n});\n<\/code><\/pre>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "command",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "environment",
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Map",
                                "dart:core.String",
                                "dart:core.String"
                            ]
                        },
                        {
                            "name": "includeParentEnvironment",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "runInShell",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stdoutEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stderrEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/run.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;io.ProcessResult&gt; run(\n  List&lt;dynamic&gt; command, {\n  String workingDirectory,\n  Map&lt;String, String&gt; environment,\n  bool includeParentEnvironment: true,\n  bool runInShell: false,\n  Encoding stdoutEncoding: io.systemEncoding,\n  Encoding stderrEncoding: io.systemEncoding,\n}) async {\n  RunManifestEntry entry = _popRunEntry(command,\n      stdoutEncoding: stdoutEncoding, stderrEncoding: stderrEncoding);\n  return await _ReplayResult.create(this, entry);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:io.ProcessResult"
                    ]
                },
                {
                    "name": "runSync",
                    "type": "dart:io.ProcessResult",
                    "desc": "<p>Starts a process and runs it to completion. This is a synchronous\ncall and will block until the child process terminates.<\/p>\n<p>The arguments are the same as for <a href=\"package-process_record_replay\/ReplayProcessManager\/run.html\">run<\/a>`.<\/p>\n<p>Returns a <code>ProcessResult<\/code> with the result of running the process,\ni.e., exit code, standard out and standard in.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "command",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "environment",
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Map",
                                "dart:core.String",
                                "dart:core.String"
                            ]
                        },
                        {
                            "name": "includeParentEnvironment",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "runInShell",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stdoutEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "stderrEncoding",
                            "type": "dart:convert.Encoding",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/runSync.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nio.ProcessResult runSync(\n  List&lt;dynamic&gt; command, {\n  String workingDirectory,\n  Map&lt;String, String&gt; environment,\n  bool includeParentEnvironment: true,\n  bool runInShell: false,\n  Encoding stdoutEncoding: io.systemEncoding,\n  Encoding stderrEncoding: io.systemEncoding,\n}) {\n  RunManifestEntry entry = _popRunEntry(command,\n      stdoutEncoding: stdoutEncoding, stderrEncoding: stderrEncoding);\n  return _ReplayResult.createSync(this, entry);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false
                },
                {
                    "name": "start",
                    "type": "dart:async.Future<dart:io.Process>",
                    "desc": "<p>Starts a process by running the specified <code>command<\/code>.<\/p>\n<p>The first element in <code>command<\/code> will be treated as the executable to run,\nwith subsequent elements being passed as arguments to the executable. It\nis left to implementations to decide what element types they support in\nthe <code>command<\/code> list.<\/p>\n<p>Returns a <code>Future&lt;Process&gt;<\/code> that completes with a Process instance when\nthe process has been successfully started. That <a href=\"dart-io\/Process-class.html\">Process<\/a> object can be\nused to interact with the process. If the process cannot be started, the\nreturned <a href=\"dart-async\/Future-class.html\">Future<\/a> completes with an exception.<\/p>\n<p>Use <code>workingDirectory<\/code> to set the working directory for the process. Note\nthat the change of directory occurs before executing the process on some\nplatforms, which may have impact when using relative paths for the\nexecutable and the arguments.<\/p>\n<p>Use <code>environment<\/code> to set the environment variables for the process. If not\nset, the environment of the parent process is inherited. Currently, only\nUS-ASCII environment variables are supported and errors are likely to occur\nif an environment variable with code-points outside the US-ASCII range is\npassed in.<\/p>\n<p>If <code>includeParentEnvironment<\/code> is <code>true<\/code>, the process's environment will\ninclude the parent process's environment, with <code>environment<\/code> taking\nprecedence. Default is <code>true<\/code>.<\/p>\n<p>If <code>runInShell<\/code> is <code>true<\/code>, the process will be spawned through a system\nshell. On Linux and OS X, <code>\/bin\/sh<\/code> is used, while\n<code>%WINDIR%\\system32\\cmd.exe<\/code> is used on Windows.<\/p>\n<p>Users must read all data coming on the <code>stdout<\/code> and <code>stderr<\/code>\nstreams of processes started with <a href=\"package-process_record_replay\/ReplayProcessManager\/start.html\">start<\/a>. If the user\ndoes not read all data on the streams the underlying system\nresources will not be released since there is still pending data.<\/p>\n<p>The following code uses <code>start<\/code> to grep for <code>main<\/code> in the\nfile <code>test.dart<\/code> on Linux.<\/p>\n<pre class=\"language-dart\"><code>ProcessManager mgr = new LocalProcessManager();\nmgr.start('grep', ['-i', 'main', 'test.dart']).then((process) {\n  stdout.addStream(process.stdout);\n  stderr.addStream(process.stderr);\n});\n<\/code><\/pre>\n<p>If <code>mode<\/code> is <a href=\"dart-io\/ProcessStartMode\/normal-constant.html\">ProcessStartMode.normal<\/a> (the default) a child\nprocess will be started with <code>stdin<\/code>, <code>stdout<\/code> and <code>stderr<\/code>\nconnected.<\/p>\n<p>If <code>mode<\/code> is <a href=\"dart-io\/ProcessStartMode\/detached-constant.html\">ProcessStartMode.detached<\/a> a detached process will\nbe created. A detached process has no connection to its parent,\nand can keep running on its own when the parent dies. The only\ninformation available from a detached process is its <code>pid<\/code>. There\nis no connection to its <code>stdin<\/code>, <code>stdout<\/code> or <code>stderr<\/code>, nor will\nthe process' exit code become available when it terminates.<\/p>\n<p>If <code>mode<\/code> is <a href=\"dart-io\/ProcessStartMode\/detachedWithStdio-constant.html\">ProcessStartMode.detachedWithStdio<\/a> a detached\nprocess will be created where the <code>stdin<\/code>, <code>stdout<\/code> and <code>stderr<\/code>\nare connected. The creator can communicate with the child through\nthese. The detached process will keep running even if these\ncommunication channels are closed. The process' exit code will\nnot become available when it terminated.<\/p>\n<p>The default value for <code>mode<\/code> is <code>ProcessStartMode.NORMAL<\/code>.<\/p>\n    ",
                    "static": false,
                    "memberOf": "record_replay.ReplayProcessManager",
                    "sig": "",
                    "params": [
                        {
                            "name": "command",
                            "type": "dart:core.List",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "workingDirectory",
                            "type": "dart:core.String",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "environment",
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false,
                            "types": [
                                "dart:core.Map",
                                "dart:core.String",
                                "dart:core.String"
                            ]
                        },
                        {
                            "name": "includeParentEnvironment",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "runInShell",
                            "type": "dart:core.bool",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        },
                        {
                            "name": "mode",
                            "type": "dart:io.ProcessStartMode",
                            "desc": "",
                            "isOptional": true,
                            "href": "",
                            "example": "",
                            "isDeprecated": false
                        }
                    ],
                    "isConstructor": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/start.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;io.Process&gt; start(\n  List&lt;dynamic&gt; command, {\n  String workingDirectory,\n  Map&lt;String, String&gt; environment,\n  bool includeParentEnvironment: true,\n  bool runInShell: false,\n  io.ProcessStartMode mode: io.ProcessStartMode.normal,\n}) async {\n  RunManifestEntry entry = _popRunEntry(command, mode: mode);\n  _ReplayResult result = await _ReplayResult.create(this, entry);\n  return result.asProcess(entry.daemon);\n}<\/code><\/pre>\n    ",
                    "isDeprecated": false,
                    "types": [
                        "dart:async.Future",
                        "dart:io.Process"
                    ]
                }
            ],
            "props": [
                {
                    "name": "location",
                    "type": "file.Directory",
                    "types": [],
                    "desc": "<p>The location of the serialized recording that's driving this manager.<\/p>\n        ",
                    "memberOf": "record_replay.ReplayProcessManager",
                    "isConstant": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/location.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Directory location\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                },
                {
                    "name": "streamDelay",
                    "type": "dart:core.Duration",
                    "types": [],
                    "desc": "<p>If non-null, processes spawned by this manager will delay their\n<code>stdout<\/code> and <code>stderr<\/code> stream production by the this amount. See\ndescription of the associated parameter in <a href=\"package-process_record_replay\/ReplayProcessManager\/create.html\">create<\/a>.<\/p>\n        ",
                    "memberOf": "record_replay.ReplayProcessManager",
                    "isConstant": false,
                    "href": "package-process_record_replay\/ReplayProcessManager\/streamDelay.html",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Duration streamDelay\n\n<\/code><\/pre>\n        ",
                    "isDeprecated": false
                }
            ],
            "isMixin": false,
            "isEnum": false,
            "isTypedef": false,
            "isConstant": false,
            "isAbstract": false,
            "implementors": [],
            "realImplementors": [],
            "cn": [],
            "href": "package-process_record_replay\/ReplayProcessManager-class.html",
            "desc": "<p>Fakes all process invocations by replaying a previously-recorded series\nof invocations.<\/p>\n<p>Recordings exist as opaque directories that are produced by\n<a href=\"package-process_record_replay\/RecordingProcessManager-class.html\">RecordingProcessManager<\/a>.<\/p>\n    ",
            "example": "",
            "isDeprecated": false,
            "dtype": "class",
            "shortname": "ReplayProcessManager"
        }
    ],
    "isFakeNamespace": false,
    "desc": "",
    "example": "",
    "isDeprecated": false
}