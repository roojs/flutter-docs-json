{
    "class": [
        {
            "desc": "<p>Pair of error and stack trace. Returned by <a href=\"dart-async\/Zone\/errorCallback.html\">Zone.errorCallback<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/AsyncError-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.AsyncError",
            "shortname": "AsyncError",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">AsyncError(this.error, this.stackTrace);<\/code><\/pre>\n    ",
                    "href": "dart-async\/AsyncError\/AsyncError.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AsyncError",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.AsyncError",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">String toString() =&gt; '$error';<\/code><\/pre>\n    ",
                    "href": "dart-async\/AsyncError\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.AsyncError",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Object error\n\n<\/code><\/pre>\n        ",
                    "href": "dart-async\/AsyncError\/error.html",
                    "name": "error",
                    "isDeprecated": false,
                    "type": "dart:core.Object",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.AsyncError",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final StackTrace stackTrace\n\n<\/code><\/pre>\n        ",
                    "href": "dart-async\/AsyncError\/stackTrace.html",
                    "name": "stackTrace",
                    "isDeprecated": false,
                    "type": "dart:core.StackTrace",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.AsyncError",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A way to produce Future objects and to complete them later\nwith a value or error.<\/p>\n<p>Most of the time, the simplest way to create a future is to just use\none of the <a href=\"dart-async\/Future-class.html\">Future<\/a> constructors to capture the result of a single\nasynchronous computation:<\/p>\n<pre class=\"language-dart\"><code>new Future(() { doSomething(); return result; });\n<\/code><\/pre>\n<p>or, if the future represents the result of a sequence of asynchronous\ncomputations, they can be chained using <a href=\"dart-async\/Future\/then.html\">Future.then<\/a> or similar functions\non <a href=\"dart-async\/Future-class.html\">Future<\/a>:<\/p>\n<pre class=\"language-dart\"><code>Future doStuff(){\n  return someAsyncOperation().then((result) {\n    return someOtherAsyncOperation(result);\n  });\n}\n<\/code><\/pre>\n<p>If you do need to create a Future from scratch \u2014 for example,\nwhen you're converting a callback-based API into a Future-based\none \u2014 you can use a Completer as follows:<\/p>\n<pre class=\"language-dart\"><code>class AsyncOperation {\n  Completer _completer = new Completer();\n\n  Future&lt;T&gt; doOperation() {\n    _startOperation();\n    return _completer.future; \/\/ Send future object back to client.\n  }\n\n  \/\/ Something calls this when the value is ready.\n  void _finishOperation(T result) {\n    _completer.complete(result);\n  }\n\n  \/\/ If something goes wrong, call this.\n  void _errorHappened(error) {\n    _completer.completeError(error);\n  }\n}\n<\/code><\/pre>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/Completer-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.Completer",
            "shortname": "Completer",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a new completer.<\/p>\n<p>The general workflow for creating a new future is to 1) create a\nnew completer, 2) hand out its future, and, at a later point, 3) invoke\neither <a href=\"dart-async\/Completer\/complete.html\">complete<\/a> or <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a>.<\/p>\n<p>The completer completes the future asynchronously. That means that\ncallbacks registered on the future are not called immediately when\n<a href=\"dart-async\/Completer\/complete.html\">complete<\/a> or <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a> is called. Instead the callbacks are\ndelayed until a later microtask.<\/p>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code>var completer = new Completer();\nhandOut(completer.future);\nlater: {\n  completer.complete('completion value');\n}\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Completer() =&gt; new _AsyncCompleter&lt;T&gt;();<\/code><\/pre>\n    ",
                    "href": "dart-async\/Completer\/Completer.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Completer",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.Completer",
                    "params": []
                },
                {
                    "desc": "<p>Completes <a href=\"dart-async\/Completer\/future.html\">future<\/a> with the supplied values.<\/p>\n<p>The value must be either a value of type <code>T<\/code>\nor a future of type <code>Future&lt;T&gt;<\/code>.<\/p>\n<p>If the value is itself a future, the completer will wait for that future\nto complete, and complete with the same result, whether it is a success\nor an error.<\/p>\n<p>Calling <a href=\"dart-async\/Completer\/complete.html\">complete<\/a> or <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a> must be done at most once.<\/p>\n<p>All listeners on the future are informed about the value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void complete([FutureOr&lt;T&gt; value]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Completer\/complete.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "complete",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Completer",
                    "params": [
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.FutureOr"
                        }
                    ]
                },
                {
                    "desc": "<p>Complete <a href=\"dart-async\/Completer\/future.html\">future<\/a> with an error.<\/p>\n<p>Calling <a href=\"dart-async\/Completer\/complete.html\">complete<\/a> or <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a> must be done at most once.<\/p>\n<p>Completing a future with an error indicates that an exception was thrown\nwhile trying to produce a value.<\/p>\n<p>If <code>error<\/code> is <code>null<\/code>, it is replaced by a <a href=\"dart-core\/NullThrownError-class.html\">NullThrownError<\/a>.<\/p>\n<p>If <code>error<\/code> is a <code>Future<\/code>, the future itself is used as the error value.\nIf you want to complete with the result of the future, you can use:<\/p>\n<pre class=\"language-dart\"><code>thisCompleter.complete(theFuture)\n<\/code><\/pre>\n<p>or if you only want to handle an error from the future:<\/p>\n<pre class=\"language-dart\"><code>theFuture.catchError(thisCompleter.completeError);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void completeError(Object error, [StackTrace stackTrace]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Completer\/completeError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "completeError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Completer",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The future that is completed by this completer.<\/p>\n<p>The future that is completed when <a href=\"dart-async\/Completer\/complete.html\">complete<\/a> or <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a> is called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get future;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Completer\/future.html",
                    "name": "future",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Completer",
                    "params": []
                },
                {
                    "desc": "<p>Whether the <a href=\"dart-async\/Completer\/future.html\">future<\/a> has been completed.<\/p>\n<p>Reflects whether <a href=\"dart-async\/Completer\/complete.html\">complete<\/a> or <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a> has been called.\nA <code>true<\/code> value doesn't necessarily mean that listeners of this future\nhave been invoked yet, either because the completer usually waits until\na later microtask to propagate the result, or because <a href=\"dart-async\/Completer\/complete.html\">complete<\/a>\nwas called with a future that hasn't completed yet.<\/p>\n<p>When this value is <code>true<\/code>, <a href=\"dart-async\/Completer\/complete.html\">complete<\/a> and <a href=\"dart-async\/Completer\/completeError.html\">completeError<\/a> must not be\ncalled again.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isCompleted;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Completer\/isCompleted.html",
                    "name": "isCompleted",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Completer",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Indicates that loading of <a href=\"dart-async\/DeferredLibrary\/libraryName.html\">libraryName<\/a> is deferred.<\/p>\n<p>This class is obsolete. Instead use the syntax:\nimport \"library.dart\" deferred as prefix;<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/DeferredLibrary-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.DeferredLibrary",
            "shortname": "DeferredLibrary",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const DeferredLibrary(this.libraryName, {this.uri});<\/code><\/pre>\n    ",
                    "href": "dart-async\/DeferredLibrary\/DeferredLibrary.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "DeferredLibrary",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.DeferredLibrary",
                    "params": [
                        {
                            "name": "libraryName",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "uri",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Ensure that <a href=\"dart-async\/DeferredLibrary\/libraryName.html\">libraryName<\/a> has been loaded.<\/p>\n<p>If the library fails to load, the Future will complete with a\nDeferredLoadException.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">external Future&lt;Null&gt; load();<\/code><\/pre>\n    ",
                    "href": "dart-async\/DeferredLibrary\/load.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.Null>",
                    "name": "load",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.DeferredLibrary",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String libraryName\n\n<\/code><\/pre>\n        ",
                    "href": "dart-async\/DeferredLibrary\/libraryName.html",
                    "name": "libraryName",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.DeferredLibrary",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String uri\n\n<\/code><\/pre>\n        ",
                    "href": "dart-async\/DeferredLibrary\/uri.html",
                    "name": "uri",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.DeferredLibrary",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Thrown when a deferred library fails to load.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/DeferredLoadException-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.DeferredLoadException",
            "shortname": "DeferredLoadException",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DeferredLoadException(this._s);<\/code><\/pre>\n    ",
                    "href": "dart-async\/DeferredLoadException\/DeferredLoadException.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "DeferredLoadException",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.DeferredLoadException",
                    "params": [
                        {
                            "name": "_s",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">String toString() =&gt; \"DeferredLoadException: '$_s'\";<\/code><\/pre>\n    ",
                    "href": "dart-async\/DeferredLoadException\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.DeferredLoadException",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A <a href=\"dart-core\/Sink-class.html\">Sink<\/a> that supports adding errors.<\/p>\n<p>This makes it suitable for capturing the results of asynchronous\ncomputations, which can complete with a value or an error.<\/p>\n<p>The <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> has been designed to handle asynchronous events from\n<a href=\"dart-async\/Stream-class.html\">Stream<\/a>s. See, for example, <a href=\"dart-async\/Stream\/Stream.eventTransformed.html\">Stream.eventTransformed<\/a> which uses\n<code>EventSink<\/code>s to transform events.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/EventSink-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.EventSink",
            "shortname": "EventSink",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "dart-async\/EventSink\/EventSink.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "EventSink",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.EventSink",
                    "params": []
                },
                {
                    "desc": "<p>Adds a data <code>event<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T event);<\/code><\/pre>\n    ",
                    "href": "dart-async\/EventSink\/add.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.EventSink",
                    "params": [
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds an <code>error<\/code> to the sink.<\/p>\n<p>Must not be called on a closed sink.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(Object error, [StackTrace stackTrace]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/EventSink\/addError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "addError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.EventSink",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Closes the sink.<\/p>\n<p>Calling this method more than once is allowed, but does nothing.<\/p>\n<p>Neither <a href=\"dart-async\/EventSink\/add.html\">add<\/a> nor <a href=\"dart-async\/EventSink\/addError.html\">addError<\/a> must be called after this method.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void close();<\/code><\/pre>\n    ",
                    "href": "dart-async\/EventSink\/close.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "close",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.EventSink",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>An object representing a delayed computation.<\/p>\n<p>A <a href=\"dart-async\/Future-class.html\">Future<\/a> is used to represent a potential value, or error,\nthat will be available at some time in the future.\nReceivers of a <a href=\"dart-async\/Future-class.html\">Future<\/a> can register callbacks\nthat handle the value or error once it is available.\nFor example:<\/p>\n<pre class=\"language-dart\"><code>Future&lt;int&gt; future = getFuture();\nfuture.then((value) =&gt; handleValue(value))\n      .catchError((error) =&gt; handleError(error));\n<\/code><\/pre>\n<p>A <a href=\"dart-async\/Future-class.html\">Future<\/a> can be completed in two ways:\nwith a value (\"the future succeeds\")\nor with an error (\"the future fails\").\nUsers can install callbacks for each case.<\/p>\n<p>In some cases we say that a future is completed with another future.\nThis is a short way of stating that the future is completed in the same way,\nwith the same value or error,\nas the other future once that completes.\nWhenever a function in the core library may complete a future\n(for example <a href=\"dart-async\/Completer\/complete.html\">Completer.complete<\/a> or <a href=\"dart-async\/Future\/Future.value.html\">new Future.value<\/a>),\nthen it also accepts another future and does this work for the developer.<\/p>\n<p>The result of registering a pair of callbacks is a new Future (the\n\"successor\") which in turn is completed with the result of invoking the\ncorresponding callback.\nThe successor is completed with an error if the invoked callback throws.\nFor example:<\/p>\n<pre class=\"language-dart\"><code>Future&lt;int&gt; successor = future.then((int value) {\n    \/\/ Invoked when the future is completed with a value.\n    return 42;  \/\/ The successor is completed with the value 42.\n  },\n  onError: (e) {\n    \/\/ Invoked when the future is completed with an error.\n    if (canHandle(e)) {\n      return 499;  \/\/ The successor is completed with the value 499.\n    } else {\n      throw e;  \/\/ The successor is completed with the error e.\n    }\n  });\n<\/code><\/pre>\n<p>If a future does not have a successor when it completes with an error,\nit forwards the error message to the global error-handler.\nThis behavior makes sure that no error is silently dropped.\nHowever, it also means that error handlers should be installed early,\nso that they are present as soon as a future is completed with an error.\nThe following example demonstrates this potential bug:<\/p>\n<pre class=\"language-dart\"><code>var future = getFuture();\nnew Timer(new Duration(milliseconds: 5), () {\n  \/\/ The error-handler is not attached until 5 ms after the future has\n  \/\/ been received. If the future fails before that, the error is\n  \/\/ forwarded to the global error-handler, even though there is code\n  \/\/ (just below) to eventually handle the error.\n  future.then((value) { useValue(value); },\n              onError: (e) { handleError(e); });\n});\n<\/code><\/pre>\n<p>When registering callbacks, it's often more readable to register the two\ncallbacks separately, by first using <a href=\"dart-async\/Future\/then.html\">then<\/a> with one argument\n(the value handler) and using a second <a href=\"dart-async\/Future\/catchError.html\">catchError<\/a> for handling errors.\nEach of these will forward the result that they don't handle\nto their successors, and together they handle both value and error result.\nIt also has the additional benefit of the <a href=\"dart-async\/Future\/catchError.html\">catchError<\/a> handling errors in the\n<a href=\"dart-async\/Future\/then.html\">then<\/a> value callback too.\nUsing sequential handlers instead of parallel ones often leads to code that\nis easier to reason about.\nIt also makes asynchronous code very similar to synchronous code:<\/p>\n<pre class=\"language-dart\"><code>\/\/ Synchronous code.\ntry {\n  int value = foo();\n  return bar(value);\n} catch (e) {\n  return 499;\n}\n<\/code><\/pre>\n<p>Equivalent asynchronous code, based on futures:<\/p>\n<pre class=\"language-dart\"><code>Future&lt;int&gt; future = new Future(foo);  \/\/ Result of foo() as a future.\nfuture.then((int value) =&gt; bar(value))\n      .catchError((e) =&gt; 499);\n<\/code><\/pre>\n<p>Similar to the synchronous code, the error handler (registered with\n<a href=\"dart-async\/Future\/catchError.html\">catchError<\/a>) is handling any errors thrown by either <code>foo<\/code> or <code>bar<\/code>.\nIf the error-handler had been registered as the <code>onError<\/code> parameter of\nthe <code>then<\/code> call, it would not catch errors from the <code>bar<\/code> call.<\/p>\n<p>Futures can have more than one callback-pair registered. Each successor is\ntreated independently and is handled as if it was the only successor.<\/p>\n<p>A future may also fail to ever complete. In that case, no callbacks are\ncalled.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/Future-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.Future",
            "shortname": "Future",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a future containing the result of calling <code>computation<\/code>\nasynchronously with <a href=\"dart-async\/Timer\/run.html\">Timer.run<\/a>.<\/p>\n<p>If the result of executing <code>computation<\/code> throws, the returned future is\ncompleted with the error.<\/p>\n<p>If the returned value is itself a <a href=\"dart-async\/Future-class.html\">Future<\/a>, completion of\nthe created future will wait until the returned future completes,\nand will then complete with the same result.<\/p>\n<p>If a non-future value is returned, the returned future is completed\nwith that value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Future(FutureOr&lt;T&gt; computation()) {\n  _Future&lt;T&gt; result = new _Future&lt;T&gt;();\n  Timer.run(() {\n    try {\n      result._complete(computation());\n    } catch (e, s) {\n      _completeWithErrorCallback(result, e, s);\n    }\n  });\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/Future.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Future",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "computation",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.FutureOr"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the result of the first future in <code>futures<\/code> to complete.<\/p>\n<p>The returned future is completed with the result of the first\nfuture in <code>futures<\/code> to report that it is complete,\nwhether it's with a value or an error.\nThe results of all the other futures are discarded.<\/p>\n<p>If <code>futures<\/code> is empty, or if none of its futures complete,\nthe returned future never completes.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;T&gt; any&lt;T&gt;(Iterable&lt;Future&lt;T&gt;&gt; futures) {\n  var completer = new Completer&lt;T&gt;.sync();\n  var onValue = (T value) {\n    if (!completer.isCompleted) completer.complete(value);\n  };\n  var onError = (error, StackTrace stack) {\n    if (!completer.isCompleted) completer.completeError(error, stack);\n  };\n  for (var future in futures) {\n    future.then(onValue, onError: onError);\n  }\n  return completer.future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/any.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "any",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "futures",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Iterable<dart:async.Future>"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> containing the result of this future.<\/p>\n<p>The stream will produce single data or error event containing the\ncompletion result of this future, and then it will close with a\ndone event.<\/p>\n<p>If the future never completes, the stream will not produce any events.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; asStream();<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/asStream.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "asStream",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": []
                },
                {
                    "desc": "<p>Handles errors emitted by this <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n<p>This is the asynchronous equivalent of a \"catch\" block.<\/p>\n<p>Returns a new <a href=\"dart-async\/Future-class.html\">Future<\/a> that will be completed with either the result of\nthis future or the result of calling the <code>onError<\/code> callback.<\/p>\n<p>If this future completes with a value,\nthe returned future completes with the same value.<\/p>\n<p>If this future completes with an error,\nthen <code>test<\/code> is first called with the error value.<\/p>\n<p>If <code>test<\/code> returns false, the exception is not handled by this <code>catchError<\/code>,\nand the returned future completes with the same error and stack trace\nas this future.<\/p>\n<p>If <code>test<\/code> returns <code>true<\/code>,\n<code>onError<\/code> is called with the error and possibly stack trace,\nand the returned future is completed with the result of this call\nin exactly the same way as for <a href=\"dart-async\/Future\/then.html\">then<\/a>'s <code>onError<\/code>.<\/p>\n<p>If <code>test<\/code> is omitted, it defaults to a function that always returns true.\nThe <code>test<\/code> function should not throw, but if it does, it is handled as\nif the <code>onError<\/code> function had thrown.<\/p>\n<p>Note that futures don't delay reporting of errors until listeners are\nadded. If the first <code>catchError<\/code> (or <code>then<\/code>) call happens after this future\nhas completed with an error then the error is reported as unhandled error.\nSee the description on <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">\/\/ The `Function` below stands for one of two types:\n\/\/ - (dynamic) -&gt; FutureOr&lt;T&gt;\n\/\/ - (dynamic, StackTrace) -&gt; FutureOr&lt;T&gt;\n\/\/ Given that there is a `test` function that is usually used to do an\n\/\/ `isCheck` we should also expect functions that take a specific argument.\n\/\/ Note: making `catchError` return a `Future&lt;T&gt;` in non-strong mode could be\n\/\/ a breaking change.\nFuture&lt;T&gt; catchError(Function onError, {bool test(Object error)});<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/catchError.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "catchError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        }
                    ]
                },
                {
                    "desc": "<p>Performs an operation repeatedly until it returns <code>false<\/code>.<\/p>\n<p>The operation, <code>action<\/code>, may be either synchronous or asynchronous.<\/p>\n<p>The operation is called repeatedly as long as it returns either the <a href=\"dart-core\/bool-class.html\">bool<\/a>\nvalue <code>true<\/code> or a <code>Future&lt;bool&gt;<\/code> which completes with the value <code>true<\/code>.<\/p>\n<p>If a call to <code>action<\/code> returns <code>false<\/code> or a <a href=\"dart-async\/Future-class.html\">Future<\/a> that completes to\n<code>false<\/code>, iteration ends and the future returned by <a href=\"dart-async\/Future\/doWhile.html\">doWhile<\/a> is completed\nwith a <code>null<\/code> value.<\/p>\n<p>If a call to <code>action<\/code> throws or a future returned by <code>action<\/code> completes\nwith an error, iteration ends and the future returned by <a href=\"dart-async\/Future\/doWhile.html\">doWhile<\/a>\ncompletes with the same error.<\/p>\n<p>Calls to <code>action<\/code> may happen at any time,\nincluding immediately after calling <code>doWhile<\/code>.\nThe only restriction is a new call to <code>action<\/code> won't happen before\nthe previous call has returned, and if it returned a <code>Future&lt;bool&gt;<\/code>, not\nuntil that future has completed.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future doWhile(FutureOr&lt;bool&gt; action()) {\n  _Future doneSignal = new _Future();\n  void Function(bool) nextIteration;\n  \/\/ Bind this callback explicitly so that each iteration isn't bound in the\n  \/\/ context of all the previous iterations' callbacks.\n  \/\/ This avoids, e.g., deeply nested stack traces from the stack trace\n  \/\/ package.\n  nextIteration = Zone.current.bindUnaryCallbackGuarded((bool keepGoing) {\n    while (keepGoing) {\n      FutureOr&lt;bool&gt; result;\n      try {\n        result = action();\n      } catch (error, stackTrace) {\n        \/\/ Cannot use _completeWithErrorCallback because it completes\n        \/\/ the future synchronously.\n        _asyncCompleteWithErrorCallback(doneSignal, error, stackTrace);\n        return;\n      }\n      if (result is Future&lt;bool&gt;) {\n        result.then(nextIteration, onError: doneSignal._completeError);\n        return;\n      }\n      keepGoing = result;\n    }\n    doneSignal._complete(null);\n  });\n  nextIteration(true);\n  return doneSignal;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/doWhile.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "doWhile",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "action",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.FutureOr<dart:core.bool>"
                        }
                    ]
                },
                {
                    "desc": "<p>Performs an action for each element of the iterable, in turn.<\/p>\n<p>The <code>action<\/code> may be either synchronous or asynchronous.<\/p>\n<p>Calls <code>action<\/code> with each element in <code>elements<\/code> in order.\nIf the call to <code>action<\/code> returns a <code>Future&lt;T&gt;<\/code>, the iteration waits\nuntil the future is completed before continuing with the next element.<\/p>\n<p>Returns a <a href=\"dart-async\/Future-class.html\">Future<\/a> that completes with <code>null<\/code> when all elements have been\nprocessed.<\/p>\n<p>Non-<a href=\"dart-async\/Future-class.html\">Future<\/a> return values, and completion-values of returned <a href=\"dart-async\/Future-class.html\">Future<\/a>s,\nare discarded.<\/p>\n<p>Any error from <code>action<\/code>, synchronous or asynchronous,\nwill stop the iteration and be reported in the returned <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future forEach&lt;T&gt;(Iterable&lt;T&gt; elements, FutureOr action(T element)) {\n  var iterator = elements.iterator;\n  return doWhile(() {\n    if (!iterator.moveNext()) return false;\n    var result = action(iterator.current);\n    if (result is Future) return result.then(_kTrue);\n    return true;\n  });\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/forEach.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "forEach",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "elements",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Iterable"
                        }
                    ]
                },
                {
                    "desc": "<p>Register callbacks to be called when this future completes.<\/p>\n<p>When this future completes with a value,\nthe <code>onValue<\/code> callback will be called with that value.\nIf this future is already completed, the callback will not be called\nimmediately, but will be scheduled in a later microtask.<\/p>\n<p>If <code>onError<\/code> is provided, and this future completes with an error,\nthe <code>onError<\/code> callback is called with that error and its stack trace.\nThe <code>onError<\/code> callback must accept either one argument or two arguments\nwhere the latter is a <a href=\"dart-core\/StackTrace-class.html\">StackTrace<\/a>.\nIf <code>onError<\/code> accepts two arguments,\nit is called with both the error and the stack trace,\notherwise it is called with just the error object.\nThe <code>onError<\/code> callback must return a value or future that can be used\nto complete the returned future, so it must be something assignable to\n<code>FutureOr&lt;R&gt;<\/code>.<\/p>\n<p>Returns a new <a href=\"dart-async\/Future-class.html\">Future<\/a>\nwhich is completed with the result of the call to <code>onValue<\/code>\n(if this future completes with a value)\nor to <code>onError<\/code> (if this future completes with an error).<\/p>\n<p>If the invoked callback throws,\nthe returned future is completed with the thrown error\nand a stack trace for the error.\nIn the case of <code>onError<\/code>,\nif the exception thrown is <code>identical<\/code> to the error argument to <code>onError<\/code>,\nthe throw is considered a rethrow,\nand the original stack trace is used instead.<\/p>\n<p>If the callback returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>,\nthe future returned by <code>then<\/code> will be completed with\nthe same result as the future returned by the callback.<\/p>\n<p>If <code>onError<\/code> is not given, and this future completes with an error,\nthe error is forwarded directly to the returned future.<\/p>\n<p>In most cases, it is more readable to use <a href=\"dart-async\/Future\/catchError.html\">catchError<\/a> separately, possibly\nwith a <code>test<\/code> parameter, instead of handling both value and error in a\nsingle <a href=\"dart-async\/Future\/then.html\">then<\/a> call.<\/p>\n<p>Note that futures don't delay reporting of errors until listeners are\nadded. If the first <code>then<\/code> or <code>catchError<\/code> call happens after this future\nhas completed with an error then the error is reported as unhandled error.\nSee the description on <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; onValue(T value), {Function onError});<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/then.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "then",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        },
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Time-out the future computation after <code>timeLimit<\/code> has passed.<\/p>\n<p>Returns a new future that completes with the same value as this future,\nif this future completes in time.<\/p>\n<p>If this future does not complete before <code>timeLimit<\/code> has passed,\nthe <code>onTimeout<\/code> action is executed instead, and its result (whether it\nreturns or throws) is used as the result of the returned future.\nThe <code>onTimeout<\/code> function must return a <code>T<\/code> or a <code>Future&lt;T&gt;<\/code>.<\/p>\n<p>If <code>onTimeout<\/code> is omitted, a timeout will cause the returned future to\ncomplete with a <a href=\"dart-async\/TimeoutException-class.html\">TimeoutException<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; timeout(Duration timeLimit, {FutureOr&lt;T&gt; onTimeout()});<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/timeout.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "timeout",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "onTimeout",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.FutureOr"
                        },
                        {
                            "name": "timeLimit",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        }
                    ]
                },
                {
                    "desc": "<p>Waits for multiple futures to complete and collects their results.<\/p>\n<p>Returns a future which will complete once all the provided futures\nhave completed, either with their results, or with an error if any\nof the provided futures fail.<\/p>\n<p>The value of the returned future will be a list of all the values that\nwere produced in the order that the futures are provided by iterating\n<code>futures<\/code>.<\/p>\n<p>If any future completes with an error,\nthen the returned future completes with that error.\nIf further futures also complete with errors, those errors are discarded.<\/p>\n<p>If <code>eagerError<\/code> is true, the returned future completes with an error\nimmediately on the first error from one of the futures. Otherwise all\nfutures must complete before the returned future is completed (still with\nthe first error; the remaining errors are silently dropped).<\/p>\n<p>In the case of an error, <code>cleanUp<\/code> (if provided), is invoked on any\nnon-null result of successful futures.\nThis makes it possible to <code>cleanUp<\/code> resources that would otherwise be\nlost (since the returned future does not provide access to these values).\nThe <code>cleanUp<\/code> function is unused if there is no error.<\/p>\n<p>The call to <code>cleanUp<\/code> should not throw. If it does, the error will be an\nuncaught asynchronous error.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Future&lt;List&lt;T&gt;&gt; wait&lt;T&gt;(Iterable&lt;Future&lt;T&gt;&gt; futures,\n    {bool eagerError: false, void cleanUp(T successValue)}) {\n  final _Future&lt;List&lt;T&gt;&gt; result = new _Future&lt;List&lt;T&gt;&gt;();\n  List&lt;T&gt; values; \/\/ Collects the values. Set to null on error.\n  int remaining = 0; \/\/ How many futures are we waiting for.\n  var error; \/\/ The first error from a future.\n  StackTrace stackTrace; \/\/ The stackTrace that came with the error.\n\n  \/\/ Handle an error from any of the futures.\n  \/\/ TODO(jmesserly): use `void` return type once it can be inferred for the\n  \/\/ `then` call below.\n  handleError(theError, StackTrace theStackTrace) {\n    remaining--;\n    if (values != null) {\n      if (cleanUp != null) {\n        for (var value in values) {\n          if (value != null) {\n            \/\/ Ensure errors from cleanUp are uncaught.\n            new Future.sync(() {\n              cleanUp(value);\n            });\n          }\n        }\n      }\n      values = null;\n      if (remaining == 0 || eagerError) {\n        result._completeError(theError, theStackTrace);\n      } else {\n        error = theError;\n        stackTrace = theStackTrace;\n      }\n    } else if (remaining == 0 &amp;&amp; !eagerError) {\n      result._completeError(error, stackTrace);\n    }\n  }\n\n  try {\n    \/\/ As each future completes, put its value into the corresponding\n    \/\/ position in the list of values.\n    for (var future in futures) {\n      int pos = remaining;\n      future.then((T value) {\n        remaining--;\n        if (values != null) {\n          values[pos] = value;\n          if (remaining == 0) {\n            result._completeWithValue(values);\n          }\n        } else {\n          if (cleanUp != null &amp;&amp; value != null) {\n            \/\/ Ensure errors from cleanUp are uncaught.\n            new Future.sync(() {\n              cleanUp(value);\n            });\n          }\n          if (remaining == 0 &amp;&amp; !eagerError) {\n            result._completeError(error, stackTrace);\n          }\n        }\n      }, onError: handleError);\n      \/\/ Increment the 'remaining' after the call to 'then'.\n      \/\/ If that call throws, we don't expect any future callback from\n      \/\/ the future, and we also don't increment remaining.\n      remaining++;\n    }\n    if (remaining == 0) {\n      return new Future.value(const []);\n    }\n    values = new List&lt;T&gt;(remaining);\n  } catch (e, st) {\n    \/\/ The error must have been thrown while iterating over the futures\n    \/\/ list, or while installing a callback handler on the future.\n    if (remaining == 0 || eagerError) {\n      \/\/ Throw a new Future.error.\n      \/\/ Don't just call `result._completeError` since that would propagate\n      \/\/ the error too eagerly, not giving the callers time to install\n      \/\/ error handlers.\n      \/\/ Also, don't use `_asyncCompleteError` since that one doesn't give\n      \/\/ zones the chance to intercept the error.\n      return new Future.error(e, st);\n    } else {\n      \/\/ Don't allocate a list for values, thus indicating that there was an\n      \/\/ error.\n      \/\/ Set error to the caught exception.\n      error = e;\n      stackTrace = st;\n    }\n  }\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/wait.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.List>",
                    "name": "wait",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "eagerError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "futures",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Iterable<dart:async.Future>"
                        },
                        {
                            "name": "successValue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers a function to be called when this future completes.<\/p>\n<p>The <code>action<\/code> function is called when this future completes, whether it\ndoes so with a value or with an error.<\/p>\n<p>This is the asynchronous equivalent of a \"finally\" block.<\/p>\n<p>The future returned by this call, <code>f<\/code>, will complete the same way\nas this future unless an error occurs in the <code>action<\/code> call, or in\na <a href=\"dart-async\/Future-class.html\">Future<\/a> returned by the <code>action<\/code> call. If the call to <code>action<\/code>\ndoes not return a future, its return value is ignored.<\/p>\n<p>If the call to <code>action<\/code> throws, then <code>f<\/code> is completed with the\nthrown error.<\/p>\n<p>If the call to <code>action<\/code> returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>, <code>f2<\/code>, then completion of\n<code>f<\/code> is delayed until <code>f2<\/code> completes. If <code>f2<\/code> completes with\nan error, that will be the result of <code>f<\/code> too. The value of <code>f2<\/code> is always\nignored.<\/p>\n<p>This method is equivalent to:<\/p>\n<pre class=\"language-dart\"><code>Future&lt;T&gt; whenComplete(action()) {\n  return this.then((v) {\n    var f2 = action();\n    if (f2 is Future) return f2.then((_) =&gt; v);\n    return v\n  }, onError: (e) {\n    var f2 = action();\n    if (f2 is Future) return f2.then((_) { throw e; });\n    throw e;\n  });\n}\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; whenComplete(FutureOr action());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Future\/whenComplete.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "whenComplete",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Future",
                    "params": [
                        {
                            "name": "action",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.FutureOr"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A type representing values that are either <code>Future&lt;T&gt;<\/code> or <code>T<\/code>.<\/p>\n<p>This class declaration is a public stand-in for an internal\nfuture-or-value generic type. References to this class are resolved to the\ninternal type.<\/p>\n<p>It is a compile-time error for any class to extend, mix in or implement\n<code>FutureOr<\/code>.<\/p>\n<p>Note: the <code>FutureOr&lt;T&gt;<\/code> type is interpreted as <code>dynamic<\/code> in non strong-mode.<\/p>\n<h1 id=\"examples\">Examples<\/h1>\n<pre class=\"language-dart\"><code class=\"language-dart\">\/\/ The `Future&lt;T&gt;.then` function takes a callback [f] that returns either\n\/\/ an `S` or a `Future&lt;S&gt;`.\nFuture&lt;S&gt; then&lt;S&gt;(FutureOr&lt;S&gt; f(T x), ...);\n\n\/\/ `Completer&lt;T&gt;.complete` takes either a `T` or `Future&lt;T&gt;`.\nvoid complete(FutureOr&lt;T&gt; value);\n<\/code><\/pre>\n<h1 id=\"advanced\">Advanced<\/h1>\n<p>The <code>FutureOr&lt;int&gt;<\/code> type is actually the \"type union\" of the types <code>int<\/code> and\n<code>Future&lt;int&gt;<\/code>. This type union is defined in such a way that\n<code>FutureOr&lt;Object&gt;<\/code> is both a super- and sub-type of <code>Object<\/code> (sub-type\nbecause <code>Object<\/code> is one of the types of the union, super-type because\n<code>Object<\/code> is a super-type of both of the types of the union). Together it\nmeans that <code>FutureOr&lt;Object&gt;<\/code> is equivalent to <code>Object<\/code>.<\/p>\n<p>As a corollary, <code>FutureOr&lt;Object&gt;<\/code> is equivalent to\n<code>FutureOr&lt;FutureOr&lt;Object&gt;&gt;<\/code>, <code>FutureOr&lt;Future&lt;Object&gt;&gt;<\/code> is equivalent to\n<code>Future&lt;Object&gt;<\/code>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/FutureOr-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.FutureOr",
            "shortname": "FutureOr",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": []
        },
        {
            "desc": "<p>A source of asynchronous data events.<\/p>\n<p>A Stream provides a way to receive a sequence of events.\nEach event is either a data event, also called an <em>element<\/em> of the stream,\nor an error event, which is a notification that something has failed.\nWhen a stream has emitted all its event,\na single \"done\" event will notify the listener that the end has been reached.<\/p>\n<p>You <a href=\"dart-async\/Stream\/listen.html\">listen<\/a> on a stream to make it start generating events,\nand to set up listeners that receive the events.\nWhen you listen, you receive a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> object\nwhich is the active object providing the events,\nand which can be used to stop listening again,\nor to temporarily pause events from the subscription.<\/p>\n<p>There are two kinds of streams: \"Single-subscription\" streams and\n\"broadcast\" streams.<\/p>\n<p><em>A single-subscription stream<\/em> allows only a single listener during the whole\nlifetime of the stream.\nIt doesn't start generating events until it has a listener,\nand it stops sending events when the listener is unsubscribed,\neven if the source of events could still provide more.<\/p>\n<p>Listening twice on a single-subscription stream is not allowed, even after\nthe first subscription has been canceled.<\/p>\n<p>Single-subscription streams are generally used for streaming chunks of\nlarger contiguous data like file I\/O.<\/p>\n<p><em>A broadcast stream<\/em> allows any number of listeners, and it fires\nits events when they are ready, whether there are listeners or not.<\/p>\n<p>Broadcast streams are used for independent events\/observers.<\/p>\n<p>If several listeners want to listen to a single subscription stream,\nuse <a href=\"dart-async\/Stream\/asBroadcastStream.html\">asBroadcastStream<\/a> to create a broadcast stream on top of the\nnon-broadcast stream.<\/p>\n<p>On either kind of stream, stream transformations, such as <a href=\"dart-async\/Stream\/where.html\">where<\/a> and\n<a href=\"dart-async\/Stream\/skip.html\">skip<\/a>, return the same type of stream as the one the method was called on,\nunless otherwise noted.<\/p>\n<p>When an event is fired, the listener(s) at that time will receive the event.\nIf a listener is added to a broadcast stream while an event is being fired,\nthat listener will not receive the event currently being fired.\nIf a listener is canceled, it immediately stops receiving events.\nListening on a broadcast stream can be treated as listening on a new stream\ncontaining only the events that have not yet been emitted when the <a href=\"dart-async\/Stream\/listen.html\">listen<\/a>\ncall occurs.\nFor example, the <a href=\"dart-async\/Stream\/first.html\">first<\/a> getter listens to the stream, then returns the first\nevent that listener receives.\nThis is not necessarily the first even emitted by the stream, but the first\nof the <em>remaining<\/em> events of the broadcast stream.<\/p>\n<p>When the \"done\" event is fired, subscribers are unsubscribed before\nreceiving the event. After the event has been sent, the stream has no\nsubscribers. Adding new subscribers to a broadcast stream after this point\nis allowed, but they will just receive a new \"done\" event as soon\nas possible.<\/p>\n<p>Stream subscriptions always respect \"pause\" requests. If necessary they need\nto buffer their input, but often, and preferably, they can simply request\ntheir input to pause too.<\/p>\n<p>The default implementation of <a href=\"dart-async\/Stream\/isBroadcast.html\">isBroadcast<\/a> returns false.\nA broadcast stream inheriting from <a href=\"dart-async\/Stream-class.html\">Stream<\/a> must override <a href=\"dart-async\/Stream\/isBroadcast.html\">isBroadcast<\/a>\nto return <code>true<\/code>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/Stream-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.Stream",
            "shortname": "Stream",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "async.DelegatingStream",
                "async.LazyStream",
                "async.StreamZip",
                "async.SubscriptionStream",
                "dart:async.StreamView",
                "dart:io.RawSecureServerSocket",
                "dart:io.SecureServerSocket",
                "dart:io.Stdin",
                "quiver.async.CountdownTimer",
                "quiver.async.FutureStream",
                "quiver.async.Metronome"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream();<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/Stream.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Stream",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>Checks whether <code>test<\/code> accepts any element provided by this stream.<\/p>\n<p>Calls <code>test<\/code> on each element of this stream.\nIf the call returns <code>true<\/code>, the returned future is completed with <code>true<\/code>\nand processing stops.<\/p>\n<p>If this stream ends without finding an element that <code>test<\/code> accepts,\nthe returned future is completed with <code>false<\/code>.<\/p>\n<p>If this stream emits an error, or if the call to <code>test<\/code> throws,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; any(bool test(T element)) {\n  _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T element) {\n        _runUserCode(() =&gt; test(element), (bool isMatch) {\n          if (isMatch) {\n            _cancelAndValue(subscription, future, true);\n          }\n        }, _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(false);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/any.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.bool>",
                    "name": "any",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a multi-subscription stream that produces the same events as this.<\/p>\n<p>The returned stream will subscribe to this stream when its first\nsubscriber is added, and will stay subscribed until this stream ends,\nor a callback cancels the subscription.<\/p>\n<p>If <code>onListen<\/code> is provided, it is called with a subscription-like object\nthat represents the underlying subscription to this stream. It is\npossible to pause, resume or cancel the subscription during the call\nto <code>onListen<\/code>. It is not possible to change the event handlers, including\nusing <a href=\"dart-async\/StreamSubscription\/asFuture.html\">StreamSubscription.asFuture<\/a>.<\/p>\n<p>If <code>onCancel<\/code> is provided, it is called in a similar way to <code>onListen<\/code>\nwhen the returned stream stops having listener. If it later gets\na new listener, the <code>onListen<\/code> function is called again.<\/p>\n<p>Use the callbacks, for example, for pausing the underlying subscription\nwhile having no subscribers to prevent losing events, or canceling the\nsubscription when there are no listeners.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; asBroadcastStream(\n    {void onListen(StreamSubscription&lt;T&gt; subscription),\n    void onCancel(StreamSubscription&lt;T&gt; subscription)}) {\n  return new _AsBroadcastStream&lt;T&gt;(this, onListen, onCancel);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/asBroadcastStream.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "asBroadcastStream",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "subscription",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.StreamSubscription"
                        }
                    ]
                },
                {
                    "desc": "<p>Transforms each element into a sequence of asynchronous events.<\/p>\n<p>Returns a new stream and for each event of this stream, do the following:<\/p>\n<ul>\n<li>If the event is an error event or a done event, it is emitted directly\nby the returned stream.<\/li>\n<li>Otherwise it is an element. Then the <code>convert<\/code> function is called\nwith the element as argument to produce a convert-stream for the element.<\/li>\n<li>If that call throws, the error is emitted on the returned stream.<\/li>\n<li>If the call returns <code>null<\/code>, no further action is taken for the elements.<\/li>\n<li>Otherwise, this stream is paused and convert-stream is listened to.\nEvery data and error event of the convert-stream is emitted on the returned\nstream in the order it is produced.\nWhen the convert-stream ends, this stream is resumed.<\/li>\n<\/ul>\n<p>The returned stream is a broadcast stream if this stream is.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt; convert(T event)) {\n  _StreamControllerBase&lt;E&gt; controller;\n  StreamSubscription&lt;T&gt; subscription;\n  void onListen() {\n    assert(controller is _StreamController ||\n        controller is _BroadcastStreamController);\n    subscription = this.listen((T event) {\n      Stream&lt;E&gt; newStream;\n      try {\n        newStream = convert(event);\n      } catch (e, s) {\n        controller.addError(e, s);\n        return;\n      }\n      if (newStream != null) {\n        subscription.pause();\n        controller.addStream(newStream).whenComplete(subscription.resume);\n      }\n    },\n        onError: controller._addError, \/\/ Avoid Zone error replacement.\n        onDone: controller.close);\n  }\n\n  if (this.isBroadcast) {\n    controller = new StreamController&lt;E&gt;.broadcast(\n        onListen: onListen,\n        onCancel: () {\n          subscription.cancel();\n        },\n        sync: true);\n  } else {\n    controller = new StreamController&lt;E&gt;(\n        onListen: onListen,\n        onPause: () {\n          subscription.pause();\n        },\n        onResume: () {\n          subscription.resume();\n        },\n        onCancel: () =&gt; subscription.cancel(),\n        sync: true);\n  }\n  return controller.stream;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/asyncExpand.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "asyncExpand",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a new stream with each data event of this stream asynchronously\nmapped to a new event.<\/p>\n<p>This acts like <a href=\"dart-async\/Stream\/map.html\">map<\/a>, except that <code>convert<\/code> may return a <a href=\"dart-async\/Future-class.html\">Future<\/a>,\nand in that case, this stream waits for that future to complete before\ncontinuing with its result.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; convert(T event)) {\n  _StreamControllerBase&lt;E&gt; controller;\n  StreamSubscription&lt;T&gt; subscription;\n\n  void onListen() {\n    final add = controller.add;\n    assert(controller is _StreamController&lt;E&gt; ||\n        controller is _BroadcastStreamController);\n    final addError = controller._addError;\n    subscription = this.listen((T event) {\n      FutureOr&lt;E&gt; newValue;\n      try {\n        newValue = convert(event);\n      } catch (e, s) {\n        controller.addError(e, s);\n        return;\n      }\n      if (newValue is Future&lt;E&gt;) {\n        subscription.pause();\n        newValue\n            .then(add, onError: addError)\n            .whenComplete(subscription.resume);\n      } else {\n        controller.add(newValue);\n      }\n    }, onError: addError, onDone: controller.close);\n  }\n\n  if (this.isBroadcast) {\n    controller = new StreamController&lt;E&gt;.broadcast(\n        onListen: onListen,\n        onCancel: () {\n          subscription.cancel();\n        },\n        sync: true);\n  } else {\n    controller = new StreamController&lt;E&gt;(\n        onListen: onListen,\n        onPause: () {\n          subscription.pause();\n        },\n        onResume: () {\n          subscription.resume();\n        },\n        onCancel: () =&gt; subscription.cancel(),\n        sync: true);\n  }\n  return controller.stream;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/asyncMap.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "asyncMap",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Adapt this stream to be a <code>Stream&lt;R&gt;<\/code>.<\/p>\n<p>This stream is wrapped as a <code>Stream&lt;R&gt;<\/code> which checks at run-time that\neach data event emitted by this stream is also an instance of <code>R<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;R&gt; cast&lt;R&gt;() =&gt; Stream.castFrom&lt;T, R&gt;(this);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/cast.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "cast",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>Adapts <code>source<\/code> to be a <code>Stream&lt;T&gt;<\/code>.<\/p>\n<p>This allows <code>source<\/code> to be used at the new type, but at run-time it\nmust satisfy the requirements of both the new type and its original type.<\/p>\n<p>Data events created by the source stream must also be instances of <code>T<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Stream&lt;T&gt; castFrom&lt;S, T&gt;(Stream&lt;S&gt; source) =&gt;\n    new CastStream&lt;S, T&gt;(source);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/castFrom.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "castFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "source",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns whether <code>needle<\/code> occurs in the elements provided by this stream.<\/p>\n<p>Compares each element of this stream to <code>needle<\/code> using <a href=\"dart-core\/Object\/operator_equals.html\">Object.==<\/a>.\nIf an equal element is found, the returned future is completed with <code>true<\/code>.\nIf this stream ends without finding a match, the future is completed with\n<code>false<\/code>.<\/p>\n<p>If this stream emits an error, or the call to <a href=\"dart-core\/Object\/operator_equals.html\">Object.==<\/a> throws,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; contains(Object needle) {\n  _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T element) {\n        _runUserCode(() =&gt; (element == needle), (bool isMatch) {\n          if (isMatch) {\n            _cancelAndValue(subscription, future, true);\n          }\n        }, _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(false);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/contains.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.bool>",
                    "name": "contains",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "needle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        }
                    ]
                },
                {
                    "desc": "<p>Skips data events if they are equal to the previous data event.<\/p>\n<p>The returned stream provides the same events as this stream, except\nthat it never provides two consecutive data events that are equal.\nThat is, errors are passed through to the returned stream, and\ndata events are passed through if they are distinct from the most\nrecently emitted data event.<\/p>\n<p>Equality is determined by the provided <code>equals<\/code> method. If that is\nomitted, the '==' operator on the last provided data element is used.<\/p>\n<p>If <code>equals<\/code> throws, the data event is replaced by an error event\ncontaining the thrown error. The behavior is equivalent to the\noriginal stream emitting the error event, and it doesn't change\nthe what the most recently emitted data event is.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nIf a broadcast stream is listened to more than once, each subscription\nwill individually perform the <code>equals<\/code> test.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; distinct([bool equals(T previous, T next)]) {\n  return new _DistinctStream&lt;T&gt;(this, equals);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/distinct.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "distinct",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "next",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "previous",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Discards all data on this stream, but signals when it is done or an error\noccurred.<\/p>\n<p>When subscribing using <a href=\"dart-async\/Stream\/drain.html\">drain<\/a>, cancelOnError will be true. This means\nthat the future will complete with the first error on this stream and then\ncancel the subscription.\nIf this stream emits an error, or the call to <code>combine<\/code> throws,\nthe returned future is completed with that error,\nand processing is stopped.<\/p>\n<p>In case of a <code>done<\/code> event the future completes with the given\n<code>futureValue<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;E&gt; drain&lt;E&gt;([E futureValue]) =&gt;\n    listen(null, cancelOnError: true).asFuture&lt;E&gt;(futureValue);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/drain.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "drain",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "futureValue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<E>"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the value of the <code>index<\/code>th data event of this stream.<\/p>\n<p>Stops listening to this stream after the <code>index<\/code>th data event has been\nreceived.<\/p>\n<p>Internally the method cancels its subscription after these elements. This\nmeans that single-subscription (non-broadcast) streams are closed and\ncannot be reused after a call to this method.<\/p>\n<p>If an error event occurs before the value is found, the future completes\nwith this error.<\/p>\n<p>If a done event occurs before the value is found, the future completes\nwith a <a href=\"dart-core\/RangeError-class.html\">RangeError<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; elementAt(int index) {\n  ArgumentError.checkNotNull(index, \"index\");\n  RangeError.checkNotNegative(index, \"index\");\n  _Future&lt;T&gt; future = new _Future&lt;T&gt;();\n  StreamSubscription subscription;\n  int elementIndex = 0;\n  subscription = this.listen(\n      (T value) {\n        if (index == elementIndex) {\n          _cancelAndValue(subscription, future, value);\n          return;\n        }\n        elementIndex += 1;\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._completeError(\n            new RangeError.index(index, this, \"index\", null, elementIndex));\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/elementAt.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "elementAt",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "index",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Checks whether <code>test<\/code> accepts all elements provided by this stream.<\/p>\n<p>Calls <code>test<\/code> on each element of this stream.\nIf the call returns <code>false<\/code>, the returned future is completed with <code>false<\/code>\nand processing stops.<\/p>\n<p>If this stream ends without finding an element that <code>test<\/code> rejects,\nthe returned future is completed with <code>true<\/code>.<\/p>\n<p>If this stream emits an error, or if the call to <code>test<\/code> throws,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; every(bool test(T element)) {\n  _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T element) {\n        _runUserCode(() =&gt; test(element), (bool isMatch) {\n          if (!isMatch) {\n            _cancelAndValue(subscription, future, false);\n          }\n        }, _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(true);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/every.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.bool>",
                    "name": "every",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Transforms each element of this stream into a sequence of elements.<\/p>\n<p>Returns a new stream where each element of this stream is replaced\nby zero or more data events.\nThe event values are provided as an <a href=\"dart-core\/Iterable-class.html\">Iterable<\/a> by a call to <code>convert<\/code>\nwith the element as argument, and the elements of that iterable is\nemitted in iteration order.\nIf calling <code>convert<\/code> throws, or if the iteration of the returned values\nthrows, the error is emitted on the returned stream and iteration ends\nfor that element of this stream.<\/p>\n<p>Error events and the done event of this stream are forwarded directly\nto the returned stream.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nIf a broadcast stream is listened to more than once, each subscription\nwill individually call <code>convert<\/code> and expand the events.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;S&gt; expand&lt;S&gt;(Iterable&lt;S&gt; convert(T element)) {\n  return new _ExpandStream&lt;T, S&gt;(this, convert);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/expand.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "expand",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Finds the first element of this stream matching <code>test<\/code>.<\/p>\n<p>Returns a future that is completed with the first element of this stream\nthat <code>test<\/code> returns <code>true<\/code> for.<\/p>\n<p>If no such element is found before this stream is done, and a\n<code>orElse<\/code> function is provided, the result of calling <code>orElse<\/code>\nbecomes the value of the future. If <code>orElse<\/code> throws, the returned\nfuture is completed with that error.<\/p>\n<p>If this stream emits an error before the first matching element,\nthe returned future is completed with that error, and processing stops.<\/p>\n<p>Stops listening to this stream after the first matching element or error\nhas been received.<\/p>\n<p>Internally the method cancels its subscription after the first element that\nmatches the predicate. This means that single-subscription (non-broadcast)\nstreams are closed and cannot be reused after a call to this method.<\/p>\n<p>If an error occurs, or if this stream ends without finding a match and\nwith no <code>orElse<\/code> function provided,\nthe returned future is completed with an error.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; firstWhere(bool test(T element), {T orElse()}) {\n  _Future&lt;T&gt; future = new _Future();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T value) {\n        _runUserCode(() =&gt; test(value), (bool isMatch) {\n          if (isMatch) {\n            _cancelAndValue(subscription, future, value);\n          }\n        }, _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (orElse != null) {\n          _runUserCode(orElse, future._complete, future._completeError);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          _completeWithErrorCallback(future, e, s);\n        }\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/firstWhere.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "firstWhere",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "orElse",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Combines a sequence of values by repeatedly applying <code>combine<\/code>.<\/p>\n<p>Similar to <a href=\"dart-async\/Stream\/fold.html\">Iterable.fold<\/a>, this function maintains a value,\nstarting with <code>initialValue<\/code> and updated for each element of\nthis stream.\nFor each element, the value is updated to the result of calling\n<code>combine<\/code> with the previous value and the element.<\/p>\n<p>When this stream is done, the returned future is completed with\nthe value at that time.\nFor an empty stream, the future is completed with <code>initialValue<\/code>.<\/p>\n<p>If this stream emits an error, or the call to <code>combine<\/code> throws,\nthe returned future is completed with that error,\nand processing is stopped.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S combine(S previous, T element)) {\n  _Future&lt;S&gt; result = new _Future&lt;S&gt;();\n  S value = initialValue;\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T element) {\n        _runUserCode(() =&gt; combine(value, element), (S newValue) {\n          value = newValue;\n        }, _cancelAndErrorClosure(subscription, result));\n      },\n      onError: result._completeError,\n      onDone: () {\n        result._complete(value);\n      },\n      cancelOnError: true);\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/fold.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "fold",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "initialValue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<S>"
                        },
                        {
                            "name": "previous",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<S>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes <code>action<\/code> on each element of this stream.<\/p>\n<p>Completes the returned <a href=\"dart-async\/Future-class.html\">Future<\/a> when all elements of this stream\nhave been processed.<\/p>\n<p>If this stream emits an error, or if the call to <code>action<\/code> throws,\nthe returned future completes with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future forEach(void action(T element)) {\n  _Future future = new _Future();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T element) {\n        \/\/ TODO(floitsch): the type should be 'void' and inferred.\n        _runUserCode&lt;dynamic&gt;(() =&gt; action(element), (_) {},\n            _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(null);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/forEach.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "forEach",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a wrapper Stream that intercepts some errors from this stream.<\/p>\n<p>If this stream sends an error that matches <code>test<\/code>, then it is intercepted\nby the <code>onError<\/code> function.<\/p>\n<p>The <code>onError<\/code> callback must be of type <code>void onError(error)<\/code> or\n<code>void onError(error, StackTrace stackTrace)<\/code>.\nThe function type determines whether <code>onError<\/code> is invoked with a stack\ntrace argument.\nThe stack trace argument may be <code>null<\/code> if this stream received an error\nwithout a stack trace.<\/p>\n<p>An asynchronous error <code>error<\/code> is matched by a test function if\n<code>test(error)<\/code> returns true. If <code>test<\/code> is omitted, every error is considered\nmatching.<\/p>\n<p>If the error is intercepted, the <code>onError<\/code> function can decide what to do\nwith it. It can throw if it wants to raise a new (or the same) error,\nor simply return to make this stream forget the error.\nIf the received <code>error<\/code> value is thrown again by the <code>onError<\/code> function,\nit acts like a <code>rethrow<\/code> and it is emitted along with its original\nstack trace, not the stack trace of the <code>throw<\/code> inside <code>onError<\/code>.<\/p>\n<p>If you need to transform an error into a data event, use the more generic\n<a href=\"dart-async\/Stream\/transform.html\">Stream.transform<\/a> to handle the event by writing a data event to\nthe output sink.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nIf a broadcast stream is listened to more than once, each subscription\nwill individually perform the <code>test<\/code> and handle the error.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; handleError(Function onError, {bool test(error)}) {\n  return new _HandleErrorStream&lt;T&gt;(this, onError, test);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/handleError.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "handleError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        }
                    ]
                },
                {
                    "desc": "<p>Combines the string representation of elements into a single string.<\/p>\n<p>Each element is converted to a string using its <a href=\"dart-core\/Object\/toString.html\">Object.toString<\/a> method.\nIf <code>separator<\/code> is provided, it is inserted between element string\nrepresentations.<\/p>\n<p>The returned future is completed with the combined string when this stream\nis done.<\/p>\n<p>If this stream emits an error, or the call to <a href=\"dart-core\/Object\/toString.html\">Object.toString<\/a> throws,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;String&gt; join([String separator = \"\"]) {\n  _Future&lt;String&gt; result = new _Future&lt;String&gt;();\n  StringBuffer buffer = new StringBuffer();\n  StreamSubscription subscription;\n  bool first = true;\n  subscription = this.listen(\n      (T element) {\n        if (!first) {\n          buffer.write(separator);\n        }\n        first = false;\n        try {\n          buffer.write(element);\n        } catch (e, s) {\n          _cancelAndErrorWithReplacement(subscription, result, e, s);\n        }\n      },\n      onError: result._completeError,\n      onDone: () {\n        result._complete(buffer.toString());\n      },\n      cancelOnError: true);\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/join.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.String>",
                    "name": "join",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "separator",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Finds the last element in this stream matching <code>test<\/code>.<\/p>\n<p>If this stream emits an error, the returned future is completed with that\nerror, and processing stops.<\/p>\n<p>Otherwise as <a href=\"dart-async\/Stream\/firstWhere.html\">firstWhere<\/a>, except that the last matching element is found\ninstead of the first.\nThat means that a non-error result cannot be provided before this stream\nis done.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; lastWhere(bool test(T element), {T orElse()}) {\n  _Future&lt;T&gt; future = new _Future();\n  T result;\n  bool foundResult = false;\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T value) {\n        _runUserCode(() =&gt; true == test(value), (bool isMatch) {\n          if (isMatch) {\n            foundResult = true;\n            result = value;\n          }\n        }, _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        if (orElse != null) {\n          _runUserCode(orElse, future._complete, future._completeError);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          _completeWithErrorCallback(future, e, s);\n        }\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/lastWhere.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "lastWhere",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "orElse",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds a subscription to this stream.<\/p>\n<p>Returns a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> which handles events from this stream using\nthe provided <code>onData<\/code>, <code>onError<\/code> and <code>onDone<\/code> handlers.\nThe handlers can be changed on the subscription, but they start out\nas the provided functions.<\/p>\n<p>On each data event from this stream, the subscriber's <code>onData<\/code> handler\nis called. If <code>onData<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>On errors from this stream, the <code>onError<\/code> handler is called with the\nerror object and possibly a stack trace.<\/p>\n<p>The <code>onError<\/code> callback must be of type <code>void onError(error)<\/code> or\n<code>void onError(error, StackTrace stackTrace)<\/code>. If <code>onError<\/code> accepts\ntwo arguments it is called with the error object and the stack trace\n(which could be <code>null<\/code> if this stream itself received an error without\nstack trace).\nOtherwise it is called with just the error object.\nIf <code>onError<\/code> is omitted, any errors on this stream are considered unhandled,\nand will be passed to the current <a href=\"dart-async\/Zone-class.html\">Zone<\/a>'s error handler.\nBy default unhandled async errors are treated\nas if they were uncaught top-level errors.<\/p>\n<p>If this stream closes and sends a done event, the <code>onDone<\/code> handler is\ncalled. If <code>onDone<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>If <code>cancelOnError<\/code> is true, the subscription is automatically canceled\nwhen the first error event is delivered. The default is <code>false<\/code>.<\/p>\n<p>While a subscription is paused, or when it has been canceled,\nthe subscription doesn't receive events and none of the\nevent handler functions are called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSubscription&lt;T&gt; listen(void onData(T event),\n    {Function onError, void onDone(), bool cancelOnError});<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/listen.html",
                    "isDeprecated": false,
                    "type": "dart:async.StreamSubscription",
                    "name": "listen",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "cancelOnError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "onDone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        }
                    ]
                },
                {
                    "desc": "<p>Transforms each element of this stream into a new stream event.<\/p>\n<p>Creates a new stream that converts each element of this stream\nto a new value using the <code>convert<\/code> function, and emits the result.<\/p>\n<p>For each data event, <code>o<\/code>, in this stream, the returned stream\nprovides a data event with the value <code>convert(o)<\/code>.\nIf <code>convert<\/code> throws, the returned stream reports it as an error\nevent instead.<\/p>\n<p>Error and done events are passed through unchanged to the returned stream.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nThe <code>convert<\/code> function is called once per data event per listener.\nIf a broadcast stream is listened to more than once, each subscription\nwill individually call <code>convert<\/code> on each data event.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;S&gt; map&lt;S&gt;(S convert(T event)) {\n  return new _MapStream&lt;T, S&gt;(this, convert);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/map.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "map",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Pipes the events of this stream into <code>streamConsumer<\/code>.<\/p>\n<p>All events of this stream are added to <code>streamConsumer<\/code> using\n<a href=\"dart-async\/StreamConsumer\/addStream.html\">StreamConsumer.addStream<\/a>.\nThe <code>streamConsumer<\/code> is closed when this stream has been successfully added\nto it - when the future returned by <code>addStream<\/code> completes without an error.<\/p>\n<p>Returns a future which completes when this stream has been consumed\nand the consumer has been closed.<\/p>\n<p>The returned future completes with the same result as the future returned\nby <a href=\"dart-async\/StreamConsumer\/close.html\">StreamConsumer.close<\/a>.\nIf the call to <a href=\"dart-async\/StreamConsumer\/addStream.html\">StreamConsumer.addStream<\/a> fails in some way, this\nmethod fails in the same way.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future pipe(StreamConsumer&lt;T&gt; streamConsumer) {\n  return streamConsumer.addStream(this).then((_) =&gt; streamConsumer.close());\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/pipe.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "pipe",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "streamConsumer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.StreamConsumer"
                        }
                    ]
                },
                {
                    "desc": "<p>Combines a sequence of values by repeatedly applying <code>combine<\/code>.<\/p>\n<p>Similar to <a href=\"dart-async\/Stream\/reduce.html\">Iterable.reduce<\/a>, this function maintains a value,\nstarting with the first element of this stream\nand updated for each further element of this stream.\nFor each element after the first,\nthe value is updated to the result of calling <code>combine<\/code>\nwith the previous value and the element.<\/p>\n<p>When this stream is done, the returned future is completed with\nthe value at that time.<\/p>\n<p>If this stream is empty, the returned future is completed with\nan error.\nIf this stream emits an error, or the call to <code>combine<\/code> throws,\nthe returned future is completed with that error,\nand processing is stopped.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; reduce(T combine(T previous, T element)) {\n  _Future&lt;T&gt; result = new _Future&lt;T&gt;();\n  bool seenFirst = false;\n  T value;\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T element) {\n        if (seenFirst) {\n          _runUserCode(() =&gt; combine(value, element), (T newValue) {\n            value = newValue;\n          }, _cancelAndErrorClosure(subscription, result));\n        } else {\n          value = element;\n          seenFirst = true;\n        }\n      },\n      onError: result._completeError,\n      onDone: () {\n        if (!seenFirst) {\n          try {\n            \/\/ Throw and recatch, instead of just doing\n            \/\/  _completeWithErrorCallback, e, theError, StackTrace.current),\n            \/\/ to ensure that the stackTrace is set on the error.\n            throw IterableElementError.noElement();\n          } catch (e, s) {\n            _completeWithErrorCallback(result, e, s);\n          }\n        } else {\n          result._complete(value);\n        }\n      },\n      cancelOnError: true);\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/reduce.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "reduce",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "previous",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Finds the single element in this stream matching <code>test<\/code>.<\/p>\n<p>Like <a href=\"dart-async\/Stream\/lastWhere.html\">lastWhere<\/a>, except that it is an error if more than one\nmatching element occurs in this stream.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; singleWhere(bool test(T element), {T orElse()}) {\n  _Future&lt;T&gt; future = new _Future&lt;T&gt;();\n  T result;\n  bool foundResult = false;\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T value) {\n        _runUserCode(() =&gt; true == test(value), (bool isMatch) {\n          if (isMatch) {\n            if (foundResult) {\n              try {\n                throw IterableElementError.tooMany();\n              } catch (e, s) {\n                _cancelAndErrorWithReplacement(subscription, future, e, s);\n              }\n              return;\n            }\n            foundResult = true;\n            result = value;\n          }\n        }, _cancelAndErrorClosure(subscription, future));\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        try {\n          if (orElse != null) {\n            _runUserCode(orElse, future._complete, future._completeError);\n            return;\n          }\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          _completeWithErrorCallback(future, e, s);\n        }\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/singleWhere.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "singleWhere",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "orElse",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Skips the first <code>count<\/code> data events from this stream.<\/p>\n<p>Returns a stream that emits the same events as this stream would\nif listened to at the same time, except that the first <code>count<\/code>\ndata events are not emitted.\nThe returned stream is done when this stream is.<\/p>\n<p>If this stream emits fewer than <code>count<\/code> data events\nbefore being done, the returned stream emits no data events.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nFor a broadcast stream, the events are only counted from the time\nthe returned stream is listened to.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; skip(int count) {\n  return new _SkipStream&lt;T&gt;(this, count);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/skip.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "skip",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "count",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Skip data events from this stream while they are matched by <code>test<\/code>.<\/p>\n<p>Returns a stream that emits the same events as this stream,\nexcept that data events are not emitted until a data event fails <code>test<\/code>.\nThe test fails when called with a data event\nif it returns a non-<code>true<\/code> value or if the call to <code>test<\/code> throws.\nIf the call throws, the error is emitted as an error event\non the returned stream instead of the data event,\notherwise the event that made <code>test<\/code> return non-true is emitted as the\nfirst data event.<\/p>\n<p>Error and done events are provided by the returned stream unmodified.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nFor a broadcast stream, the events are only tested from the time\nthe returned stream is listened to.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; skipWhile(bool test(T element)) {\n  return new _SkipWhileStream&lt;T&gt;(this, test);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/skipWhile.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "skipWhile",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Provides at most the first <code>count<\/code> data events of this stream.<\/p>\n<p>Returns a stream that emits the same events that this stream would\nif listened to at the same time,\nuntil either this stream ends or it has emitted <code>count<\/code> data events,\nat which point the returned stream is done.<\/p>\n<p>If this stream produces fewer than <code>count<\/code> data events before it's done,\nso will the returned stream.<\/p>\n<p>Starts listening to this stream when the returned stream is listened to\nand stops listening when the first <code>count<\/code> data events have been received.<\/p>\n<p>This means that if this is a single-subscription (non-broadcast) streams\nit cannot be reused after the returned stream has been listened to.<\/p>\n<p>If this is a broadcast stream, the returned stream is a broadcast stream.\nIn that case, the events are only counted from the time\nthe returned stream is listened to.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; take(int count) {\n  return new _TakeStream&lt;T&gt;(this, count);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/take.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "take",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "count",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Forwards data events while <code>test<\/code> is successful.<\/p>\n<p>Returns a stream that provides the same events as this stream\nuntil <code>test<\/code> fails for a data event.\nThe returned stream is done when either this stream is done,\nor when this stream first emits a data event that fails <code>test<\/code>.<\/p>\n<p>The <code>test<\/code> call is considered failing if it returns a non-<code>true<\/code> value\nor if it throws. If the <code>test<\/code> call throws, the error is emitted as the\nlast event on the returned streams.<\/p>\n<p>Stops listening to this stream after the accepted elements.<\/p>\n<p>Internally the method cancels its subscription after these elements. This\nmeans that single-subscription (non-broadcast) streams are closed and\ncannot be reused after a call to this method.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nFor a broadcast stream, the events are only tested from the time\nthe returned stream is listened to.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; takeWhile(bool test(T element)) {\n  return new _TakeWhileStream&lt;T&gt;(this, test);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/takeWhile.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "takeWhile",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "element",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a new stream with the same events as this stream.<\/p>\n<p>Whenever more than <code>timeLimit<\/code> passes between two events from this stream,\nthe <code>onTimeout<\/code> function is called, which can emit further events on\nthe returned stream.<\/p>\n<p>The countdown doesn't start until the returned stream is listened to.\nThe countdown is reset every time an event is forwarded from this stream,\nor when this stream is paused and resumed.<\/p>\n<p>The <code>onTimeout<\/code> function is called with one argument: an\n<a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> that allows putting events into the returned stream.\nThis <code>EventSink<\/code> is only valid during the call to <code>onTimeout<\/code>.\nCalling <a href=\"dart-async\/EventSink\/close.html\">EventSink.close<\/a> on the sink passed to <code>onTimeout<\/code> closes the\nreturned stream, and no further events are processed.<\/p>\n<p>If <code>onTimeout<\/code> is omitted, a timeout will just put a <a href=\"dart-async\/TimeoutException-class.html\">TimeoutException<\/a>\ninto the error channel of the returned stream.\nIf the call to <code>onTimeout<\/code> throws, the error is emitted on the returned\nstream.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nIf a broadcast stream is listened to more than once, each subscription\nwill have its individually timer that starts counting on listen,\nand the subscriptions' timers can be paused individually.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; timeout(Duration timeLimit, {void onTimeout(EventSink&lt;T&gt; sink)}) {\n  _StreamControllerBase&lt;T&gt; controller;\n  \/\/ The following variables are set on listen.\n  StreamSubscription&lt;T&gt; subscription;\n  Timer timer;\n  Zone zone;\n  _TimerCallback timeout;\n\n  void onData(T event) {\n    timer.cancel();\n    controller.add(event);\n    timer = zone.createTimer(timeLimit, timeout);\n  }\n\n  void onError(error, StackTrace stackTrace) {\n    timer.cancel();\n    assert(controller is _StreamController ||\n        controller is _BroadcastStreamController);\n    controller._addError(error, stackTrace); \/\/ Avoid Zone error replacement.\n    timer = zone.createTimer(timeLimit, timeout);\n  }\n\n  void onDone() {\n    timer.cancel();\n    controller.close();\n  }\n\n  void onListen() {\n    \/\/ This is the onListen callback for of controller.\n    \/\/ It runs in the same zone that the subscription was created in.\n    \/\/ Use that zone for creating timers and running the onTimeout\n    \/\/ callback.\n    zone = Zone.current;\n    if (onTimeout == null) {\n      timeout = () {\n        controller.addError(\n            new TimeoutException(\"No stream event\", timeLimit), null);\n      };\n    } else {\n      \/\/ TODO(floitsch): the return type should be 'void', and the type\n      \/\/ should be inferred.\n      var registeredOnTimeout =\n          zone.registerUnaryCallback&lt;dynamic, EventSink&lt;T&gt;&gt;(onTimeout);\n      var wrapper = new _ControllerEventSinkWrapper&lt;T&gt;(null);\n      timeout = () {\n        wrapper._sink = controller; \/\/ Only valid during call.\n        zone.runUnaryGuarded(registeredOnTimeout, wrapper);\n        wrapper._sink = null;\n      };\n    }\n\n    subscription = this.listen(onData, onError: onError, onDone: onDone);\n    timer = zone.createTimer(timeLimit, timeout);\n  }\n\n  Future onCancel() {\n    timer.cancel();\n    Future result = subscription.cancel();\n    subscription = null;\n    return result;\n  }\n\n  controller = isBroadcast\n      ? new _SyncBroadcastStreamController&lt;T&gt;(onListen, onCancel)\n      : new _SyncStreamController&lt;T&gt;(onListen, () {\n          \/\/ Don't null the timer, onCancel may call cancel again.\n          timer.cancel();\n          subscription.pause();\n        }, () {\n          subscription.resume();\n          timer = zone.createTimer(timeLimit, timeout);\n        }, onCancel);\n  return controller.stream;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/timeout.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "timeout",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "sink",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.EventSink"
                        },
                        {
                            "name": "timeLimit",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        }
                    ]
                },
                {
                    "desc": "<p>Collects all elements of this stream in a <a href=\"dart-core\/List-class.html\">List<\/a>.<\/p>\n<p>Creates a <code>List&lt;T&gt;<\/code> and adds all elements of this stream to the list\nin the order they arrive.\nWhen this stream ends, the returned future is completed with that list.<\/p>\n<p>If this stream emits an error,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;List&lt;T&gt;&gt; toList() {\n  List&lt;T&gt; result = &lt;T&gt;[];\n  _Future&lt;List&lt;T&gt;&gt; future = new _Future&lt;List&lt;T&gt;&gt;();\n  this.listen(\n      (T data) {\n        result.add(data);\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(result);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/toList.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.List>",
                    "name": "toList",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>Collects the data of this stream in a <a href=\"dart-core\/Set-class.html\">Set<\/a>.<\/p>\n<p>Creates a <code>Set&lt;T&gt;<\/code> and adds all elements of this stream to the set.\nin the order they arrive.\nWhen this stream ends, the returned future is completed with that set.<\/p>\n<p>The returned set is the same type as returned by <code>new Set&lt;T&gt;()<\/code>.\nIf another type of set is needed, either use <a href=\"dart-async\/Stream\/forEach.html\">forEach<\/a> to add each\nelement to the set, or use\n<code>toList().then((list) =&gt; new SomeOtherSet.from(list))<\/code>\nto create the set.<\/p>\n<p>If this stream emits an error,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;Set&lt;T&gt;&gt; toSet() {\n  Set&lt;T&gt; result = new Set&lt;T&gt;();\n  _Future&lt;Set&lt;T&gt;&gt; future = new _Future&lt;Set&lt;T&gt;&gt;();\n  this.listen(\n      (T data) {\n        result.add(data);\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(result);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/toSet.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.Set>",
                    "name": "toSet",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>Applies  <code>streamTransformer<\/code> to this stream.<\/p>\n<p>Returns the transformed stream,\nthat is, the result of <code>streamTransformer.bind(this)<\/code>.\nThis method simply allows writing the call to <code>streamTransformer.bind<\/code>\nin a chained fashion, like<\/p>\n<pre class=\"language-dart\"><code>stream.map(mapping).transform(transformation).toList()\n<\/code><\/pre>\n<p>which can be more convenient than calling <code>bind<\/code> directly.<\/p>\n<p>The <code>streamTransformer<\/code> can return any stream.\nWhether the returned stream is a broadcast stream or not,\nand which elements it will contain,\nis entirely up to the transformation.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer) {\n  return streamTransformer.bind(this);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/transform.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "transform",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "streamTransformer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.StreamTransformer"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a new stream from this stream that discards some elements.<\/p>\n<p>The new stream sends the same error and done events as this stream,\nbut it only sends the data events that satisfy the <code>test<\/code>.<\/p>\n<p>If the <code>test<\/code> function throws, the data event is dropped and the\nerror is emitted on the returned stream instead.<\/p>\n<p>The returned stream is a broadcast stream if this stream is.\nIf a broadcast stream is listened to more than once, each subscription\nwill individually perform the <code>test<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; where(bool test(T event)) {\n  return new _WhereStream&lt;T&gt;(this, test);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Stream\/where.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "where",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Stream",
                    "params": [
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The first element of this stream.<\/p>\n<p>Stops listening to this stream after the first element has been received.<\/p>\n<p>Internally the method cancels its subscription after the first element.\nThis means that single-subscription (non-broadcast) streams are closed\nand cannot be reused after a call to this getter.<\/p>\n<p>If an error event occurs before the first data event, the returned future\nis completed with that error.<\/p>\n<p>If this stream is empty (a done event occurs before the first data event),\nthe returned future completes with an error.<\/p>\n<p>Except for the type of the error, this method is equivalent to\n<code>this.elementAt(0)<\/code>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get first {\n  _Future&lt;T&gt; future = new _Future&lt;T&gt;();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T value) {\n        _cancelAndValue(subscription, future, value);\n      },\n      onError: future._completeError,\n      onDone: () {\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          _completeWithErrorCallback(future, e, s);\n        }\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n        ",
                    "href": "dart-async\/Stream\/first.html",
                    "name": "first",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>Whether this stream is a broadcast stream.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isBroadcast =&gt; false;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Stream\/isBroadcast.html",
                    "name": "isBroadcast",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>Whether this stream contains any elements.<\/p>\n<p>Waits for the first element of this stream, then completes the returned\nfuture with <code>true<\/code>.\nIf this stream ends without emitting any elements, the returned future is\ncompleted with <code>false<\/code>.<\/p>\n<p>If the first event is an error, the returned future is completed with that\nerror.<\/p>\n<p>This operation listens to this stream, and a non-broadcast stream cannot\nbe reused after checking whether it is empty.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; get isEmpty {\n  _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (_) {\n        _cancelAndValue(subscription, future, false);\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(true);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n        ",
                    "href": "dart-async\/Stream\/isEmpty.html",
                    "name": "isEmpty",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.bool>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>The last element of this stream.<\/p>\n<p>If this stream emits an error event,\nthe returned future is completed with that error\nand processing stops.<\/p>\n<p>If this stream is empty (the done event is the first event),\nthe returned future completes with an error.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get last {\n  _Future&lt;T&gt; future = new _Future&lt;T&gt;();\n  T result;\n  bool foundResult = false;\n  listen(\n      (T value) {\n        foundResult = true;\n        result = value;\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          _completeWithErrorCallback(future, e, s);\n        }\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n        ",
                    "href": "dart-async\/Stream\/last.html",
                    "name": "last",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>The number of elements in this stream.<\/p>\n<p>Waits for all elements of this stream. When this stream ends,\nthe returned future is completed with the number of elements.<\/p>\n<p>If this stream emits an error,\nthe returned future is completed with that error,\nand processing stops.<\/p>\n<p>This operation listens to this stream, and a non-broadcast stream cannot\nbe reused after finding its length.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;int&gt; get length {\n  _Future&lt;int&gt; future = new _Future&lt;int&gt;();\n  int count = 0;\n  this.listen(\n      (_) {\n        count++;\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(count);\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n        ",
                    "href": "dart-async\/Stream\/length.html",
                    "name": "length",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.int>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                },
                {
                    "desc": "<p>The single element of this stream.<\/p>\n<p>If this stream emits an error event,\nthe returned future is completed with that error\nand processing stops.<\/p>\n<p>If <a href=\"dart-async\/Stream-class.html\">this<\/a> is empty or has more than one element,\nthe returned future completes with an error.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;T&gt; get single {\n  _Future&lt;T&gt; future = new _Future&lt;T&gt;();\n  T result;\n  bool foundResult = false;\n  StreamSubscription subscription;\n  subscription = this.listen(\n      (T value) {\n        if (foundResult) {\n          \/\/ This is the second element we get.\n          try {\n            throw IterableElementError.tooMany();\n          } catch (e, s) {\n            _cancelAndErrorWithReplacement(subscription, future, e, s);\n          }\n          return;\n        }\n        foundResult = true;\n        result = value;\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          _completeWithErrorCallback(future, e, s);\n        }\n      },\n      cancelOnError: true);\n  return future;\n}<\/code><\/pre>\n        ",
                    "href": "dart-async\/Stream\/single.html",
                    "name": "single",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Stream",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Abstract interface for a \"sink\" accepting multiple entire streams.<\/p>\n<p>A consumer can accept a number of consecutive streams using <a href=\"dart-async\/StreamConsumer\/addStream.html\">addStream<\/a>,\nand when no further data need to be added, the <a href=\"dart-async\/StreamConsumer\/close.html\">close<\/a> method tells the\nconsumer to complete its work and shut down.<\/p>\n<p>The <a href=\"dart-async\/Stream\/pipe.html\">Stream.pipe<\/a> accepts a <code>StreamConsumer<\/code> and will pass the stream\nto the consumer's <a href=\"dart-async\/StreamConsumer\/addStream.html\">addStream<\/a> method. When that completes, it will\ncall <a href=\"dart-async\/StreamConsumer\/close.html\">close<\/a> and then complete its own returned future.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamConsumer-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamConsumer",
            "shortname": "StreamConsumer",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "dart-async\/StreamConsumer\/StreamConsumer.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamConsumer",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamConsumer",
                    "params": []
                },
                {
                    "desc": "<p>Consumes the elements of <code>stream<\/code>.<\/p>\n<p>Listens on <code>stream<\/code> and does something for each event.<\/p>\n<p>Returns a future which is completed when the stream is done being added,\nand the consumer is ready to accept a new stream.\nNo further calls to <a href=\"dart-async\/StreamConsumer\/addStream.html\">addStream<\/a> or <a href=\"dart-async\/StreamConsumer\/close.html\">close<\/a> should happen before the\nreturned future has completed.<\/p>\n<p>The consumer may stop listening to the stream after an error,\nit may consume all the errors and only stop at a done event,\nor it may be canceled early if the receiver don't want any further events.<\/p>\n<p>If the consumer stops listening because of some error preventing it\nfrom continuing, it may report this error in the returned future,\notherwise it will just complete the future with <code>null<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future addStream(Stream&lt;S&gt; stream);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamConsumer\/addStream.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "addStream",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamConsumer",
                    "params": [
                        {
                            "name": "stream",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Tells the consumer that no further streams will be added.<\/p>\n<p>This allows the consumer to complete any remaining work and release\nresources that are no longer needed<\/p>\n<p>Returns a future which is completed when the consumer has shut down.\nIf cleaning up can fail, the error may be reported in the returned future,\notherwise it completes with <code>null<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamConsumer\/close.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "close",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamConsumer",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A controller with the stream it controls.<\/p>\n<p>This controller allows sending data, error and done events on\nits <a href=\"dart-async\/StreamController\/stream.html\">stream<\/a>.\nThis class can be used to create a simple stream that others\ncan listen on, and to push events to that stream.<\/p>\n<p>It's possible to check whether the stream is paused or not, and whether\nit has subscribers or not, as well as getting a callback when either of\nthese change.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamController-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamController",
            "shortname": "StreamController",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [
                {
                    "desc": "<p>The callback which is called when the stream is canceled.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCancelCallback get onCancel;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/onCancel.html",
                    "isDeprecated": false,
                    "type": "dart:async.ControllerCancelCallback",
                    "name": "onCancel",
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>The callback which is called when the stream is listened to.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCallback get onListen;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/onListen.html",
                    "isDeprecated": false,
                    "type": "dart:async.ControllerCallback",
                    "name": "onListen",
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>The callback which is called when the stream is paused.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n<p>Pause related callbacks are not supported on broadcast stream controllers.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCallback get onPause;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/onPause.html",
                    "isDeprecated": false,
                    "type": "dart:async.ControllerCallback",
                    "name": "onPause",
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>The callback which is called when the stream is resumed.<\/p>\n<p>May be set to <code>null<\/code>, in which case no callback will happen.<\/p>\n<p>Pause related callbacks are not supported on broadcast stream controllers.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ControllerCallback get onResume;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/onResume.html",
                    "isDeprecated": false,
                    "type": "dart:async.ControllerCallback",
                    "name": "onResume",
                    "memberOf": "dart:async.StreamController",
                    "params": []
                }
            ],
            "methods": [
                {
                    "desc": "<p>A controller with a <a href=\"dart-async\/StreamController\/stream.html\">stream<\/a> that supports only one single subscriber.<\/p>\n<p>If <code>sync<\/code> is true, the returned stream controller is a\n<a href=\"dart-async\/SynchronousStreamController-class.html\">SynchronousStreamController<\/a>, and must be used with the care\nand attention necessary to not break the <a href=\"dart-async\/Stream-class.html\">Stream<\/a> contract. If in doubt,\nuse the non-sync version.<\/p>\n<p>Using an asynchronous controller will never give the wrong\nbehavior, but using a synchronous controller incorrectly can cause\notherwise correct programs to break.<\/p>\n<p>A synchronous controller is only intended for optimizing event\npropagation when one asynchronous event immediately triggers another.\nIt should not be used unless the calls to <a href=\"dart-async\/StreamController\/add.html\">add<\/a> or <a href=\"dart-async\/StreamController\/addError.html\">addError<\/a>\nare guaranteed to occur in places where it won't break <code>Stream<\/code> invariants.<\/p>\n<p>Use synchronous controllers only to forward (potentially transformed)\nevents from another stream or a future.<\/p>\n<p>A Stream should be inert until a subscriber starts listening on it (using\nthe <code>onListen<\/code> callback to start producing events). Streams should not\nleak resources (like websockets) when no user ever listens on the stream.<\/p>\n<p>The controller buffers all incoming events until a subscriber is\nregistered, but this feature should only be used in rare circumstances.<\/p>\n<p>The <code>onPause<\/code> function is called when the stream becomes\npaused. <code>onResume<\/code> is called when the stream resumed.<\/p>\n<p>The <code>onListen<\/code> callback is called when the stream\nreceives its listener and <code>onCancel<\/code> when the listener ends\nits subscription. If <code>onCancel<\/code> needs to perform an asynchronous operation,\n<code>onCancel<\/code> should return a future that completes when the cancel operation\nis done.<\/p>\n<p>If the stream is canceled before the controller needs new data the\n<code>onResume<\/code> call might not be executed.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamController(\n    {void onListen(),\n    void onPause(),\n    void onResume(),\n    onCancel(),\n    bool sync: false}) {\n  return sync\n      ? new _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)\n      : new _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamController\/StreamController.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamController",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamController",
                    "params": [
                        {
                            "name": "onCancel",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "onListen",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "<void>"
                        },
                        {
                            "name": "onPause",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "<void>"
                        },
                        {
                            "name": "onResume",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "<void>"
                        },
                        {
                            "name": "sync",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Sends a data <code>event<\/code>.<\/p>\n<p>Listeners receive this event in a later microtask.<\/p>\n<p>Note that a synchronous controller (created by passing true to the <code>sync<\/code>\nparameter of the <code>StreamController<\/code> constructor) delivers events\nimmediately. Since this behavior violates the contract mentioned here,\nsynchronous controllers should only be used as described in the\ndocumentation to ensure that the delivered events always <em>appear<\/em> as if\nthey were delivered in a separate microtask.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T event);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamController\/add.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamController",
                    "params": [
                        {
                            "name": "event",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Sends or enqueues an error event.<\/p>\n<p>If <code>error<\/code> is <code>null<\/code>, it is replaced by a <a href=\"dart-core\/NullThrownError-class.html\">NullThrownError<\/a>.<\/p>\n<p>Listeners receive this event at a later microtask. This behavior can be\noverridden by using <code>sync<\/code> controllers. Note, however, that sync\ncontrollers have to satisfy the preconditions mentioned in the\ndocumentation of the constructors.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(Object error, [StackTrace stackTrace]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamController\/addError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "addError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamController",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Receives events from <code>source<\/code> and puts them into this controller's stream.<\/p>\n<p>Returns a future which completes when the source stream is done.<\/p>\n<p>Events must not be added directly to this controller using <a href=\"dart-async\/StreamController\/add.html\">add<\/a>,\n<a href=\"dart-async\/StreamController\/addError.html\">addError<\/a>, <a href=\"dart-async\/StreamController\/close.html\">close<\/a> or <a href=\"dart-async\/StreamController\/addStream.html\">addStream<\/a>, until the returned future\nis complete.<\/p>\n<p>Data and error events are forwarded to this controller's stream. A done\nevent on the source will end the <code>addStream<\/code> operation and complete the\nreturned future.<\/p>\n<p>If <code>cancelOnError<\/code> is true, only the first error on <code>source<\/code> is\nforwarded to the controller's stream, and the <code>addStream<\/code> ends\nafter this. If <code>cancelOnError<\/code> is false, all errors are forwarded\nand only a done event will end the <code>addStream<\/code>.\nIf <code>cancelOnError<\/code> is omitted, it defaults to false.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future addStream(Stream&lt;T&gt; source, {bool cancelOnError});<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamController\/addStream.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "addStream",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamController",
                    "params": [
                        {
                            "name": "cancelOnError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "source",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Closes the stream.<\/p>\n<p>Listeners receive the done event at a later microtask. This behavior can be\noverridden by using <code>sync<\/code> controllers. Note, however, that sync\ncontrollers have to satisfy the preconditions mentioned in the\ndocumentation of the constructors.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamController\/close.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "close",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamController",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>Whether there is a subscriber on the <a href=\"dart-async\/Stream-class.html\">Stream<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get hasListener;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/hasListener.html",
                    "name": "hasListener",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>Whether the stream controller is closed for adding more events.<\/p>\n<p>The controller becomes closed by calling the <a href=\"dart-async\/StreamController\/close.html\">close<\/a> method.\nNew events cannot be added, by calling <a href=\"dart-async\/StreamController\/add.html\">add<\/a> or <a href=\"dart-async\/StreamController\/addError.html\">addError<\/a>,\nto a closed controller.<\/p>\n<p>If the controller is closed,\nthe \"done\" event might not have been delivered yet,\nbut it has been scheduled, and it is too late to add more events.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isClosed;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/isClosed.html",
                    "name": "isClosed",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>Whether the subscription would need to buffer events.<\/p>\n<p>This is the case if the controller's stream has a listener and it is\npaused, or if it has not received a listener yet. In that case, the\ncontroller is considered paused as well.<\/p>\n<p>A broadcast stream controller is never considered paused. It always\nforwards its events to all uncanceled subscriptions, if any,\nand let the subscriptions handle their own pausing and buffering.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isPaused;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/isPaused.html",
                    "name": "isPaused",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>Returns a view of this object that only exposes the <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> interface.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StreamSink&lt;T&gt; get sink;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/sink.html",
                    "name": "sink",
                    "isDeprecated": false,
                    "type": "dart:async.StreamSink",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamController",
                    "params": []
                },
                {
                    "desc": "<p>The stream that this controller is controlling.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; get stream;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamController\/stream.html",
                    "name": "stream",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamController",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An <a href=\"dart-core\/Iterator-class.html\">Iterator<\/a> like interface for the values of a <a href=\"dart-async\/Stream-class.html\">Stream<\/a>.<\/p>\n<p>This wraps a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> and a subscription on the stream. It listens\non the stream, and completes the future returned by <a href=\"dart-async\/StreamIterator\/moveNext.html\">moveNext<\/a> when the\nnext value becomes available.<\/p>\n<p>The stream may be paused between calls to <a href=\"dart-async\/StreamIterator\/moveNext.html\">moveNext<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamIterator-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamIterator",
            "shortname": "StreamIterator",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Create a <a href=\"dart-async\/StreamIterator-class.html\">StreamIterator<\/a> on <code>stream<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory StreamIterator(Stream&lt;T&gt; stream)\n    \/\/ TODO(lrn): use redirecting factory constructor when type\n    \/\/ arguments are supported.\n    =&gt;\n    new _StreamIterator&lt;T&gt;(stream);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamIterator\/StreamIterator.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamIterator",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamIterator",
                    "params": [
                        {
                            "name": "stream",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Cancels the stream iterator (and the underlying stream subscription) early.<\/p>\n<p>The stream iterator is automatically canceled if the <a href=\"dart-async\/StreamIterator\/moveNext.html\">moveNext<\/a> future\ncompletes with either <code>false<\/code> or an error.<\/p>\n<p>If you need to stop listening for values before the stream iterator is\nautomatically closed, you must call <a href=\"dart-async\/StreamIterator\/cancel.html\">cancel<\/a> to ensure that the stream\nis properly closed.<\/p>\n<p>If <a href=\"dart-async\/StreamIterator\/moveNext.html\">moveNext<\/a> has been called when the iterator is canceled,\nits returned future will complete with <code>false<\/code> as value,\nas will all further calls to <a href=\"dart-async\/StreamIterator\/moveNext.html\">moveNext<\/a>.<\/p>\n<p>Returns a future if the cancel-operation is not completed synchronously.\nOtherwise returns <code>null<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future cancel();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamIterator\/cancel.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "cancel",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamIterator",
                    "params": []
                },
                {
                    "desc": "<p>Wait for the next stream value to be available.<\/p>\n<p>Returns a future which will complete with either <code>true<\/code> or <code>false<\/code>.\nCompleting with <code>true<\/code> means that another event has been received and\ncan be read as <a href=\"dart-async\/StreamIterator\/current.html\">current<\/a>.\nCompleting with <code>false<\/code> means that the stream iteration is done and\nno further events will ever be available.\nThe future may complete with an error, if the stream produces an error,\nwhich also ends iteration.<\/p>\n<p>The function must not be called again until the future returned by a\nprevious call is completed.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; moveNext();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamIterator\/moveNext.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.bool>",
                    "name": "moveNext",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamIterator",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A object that accepts stream events both synchronously and asynchronously.<\/p>\n<p>A <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> combines the methods from <a href=\"dart-async\/StreamConsumer-class.html\">StreamConsumer<\/a> and <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a>.<\/p>\n<p>The <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> methods can't be used while the <a href=\"dart-async\/StreamConsumer\/addStream.html\">addStream<\/a> is called.\nAs soon as the <a href=\"dart-async\/StreamConsumer\/addStream.html\">addStream<\/a>'s <a href=\"dart-async\/Future-class.html\">Future<\/a> completes with a value, the\n<a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> methods can be used again.<\/p>\n<p>If <a href=\"dart-async\/StreamConsumer\/addStream.html\">addStream<\/a> is called after any of the <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> methods, it'll\nbe delayed until the underlying system has consumed the data added by the\n<a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> methods.<\/p>\n<p>When <a href=\"dart-async\/EventSink-class.html\">EventSink<\/a> methods are used, the <a href=\"dart-async\/StreamSink\/done.html\">done<\/a> <a href=\"dart-async\/Future-class.html\">Future<\/a> can be used to\ncatch any errors.<\/p>\n<p>When <a href=\"dart-async\/StreamSink\/close.html\">close<\/a> is called, it will return the <a href=\"dart-async\/StreamSink\/done.html\">done<\/a> <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamSink-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamSink",
            "shortname": "StreamSink",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "dart-async\/StreamSink\/StreamSink.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamSink",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamSink",
                    "params": []
                },
                {
                    "desc": "<p>Tells the stream sink that no further streams will be added.<\/p>\n<p>This allows the stream sink to complete any remaining work and release\nresources that are no longer needed<\/p>\n<p>Returns a future which is completed when the stream sink has shut down.\nIf cleaning up can fail, the error may be reported in the returned future,\notherwise it completes with <code>null<\/code>.<\/p>\n<p>Returns the same future as <a href=\"dart-async\/StreamSink\/done.html\">done<\/a>.<\/p>\n<p>The stream sink may close before the <a href=\"dart-async\/StreamSink\/close.html\">close<\/a> method is called, either due\nto an error or because it is itself providing events to someone who has\nstopped listening. In that case, the <a href=\"dart-async\/StreamSink\/done.html\">done<\/a> future is completed first,\nand the <code>close<\/code> method will return the <code>done<\/code> future when called.<\/p>\n<p>Unifies <a href=\"dart-async\/StreamSink\/close.html\">StreamConsumer.close<\/a> and <a href=\"dart-async\/StreamSink\/close.html\">EventSink.close<\/a> which both mark their\nobject as not expecting any further events.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSink\/close.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "close",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSink",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>Return a future which is completed when the <a href=\"dart-async\/StreamSink-class.html\">StreamSink<\/a> is finished.<\/p>\n<p>If the <code>StreamSink<\/code> fails with an error,\nperhaps in response to adding events using <a href=\"dart-async\/EventSink\/add.html\">add<\/a>, <a href=\"dart-async\/EventSink\/addError.html\">addError<\/a> or <a href=\"dart-async\/StreamSink\/close.html\">close<\/a>,\nthe <a href=\"dart-async\/StreamSink\/done.html\">done<\/a> future will complete with that error.<\/p>\n<p>Otherwise, the returned future will complete when either:<\/p>\n<ul>\n<li>all events have been processed and the sink has been closed, or<\/li>\n<li>the sink has otherwise been stopped from handling more events\n(for example by canceling a stream subscription).<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future get done;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamSink\/done.html",
                    "name": "done",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamSink",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A subscription on events from a <a href=\"dart-async\/Stream-class.html\">Stream<\/a>.<\/p>\n<p>When you listen on a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> using <a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>,\na <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> object is returned.<\/p>\n<p>The subscription provides events to the listener,\nand holds the callbacks used to handle the events.\nThe subscription can also be used to unsubscribe from the events,\nor to temporarily pause the events from the stream.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamSubscription-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamSubscription",
            "shortname": "StreamSubscription",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "dart-async\/StreamSubscription\/StreamSubscription.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamSubscription",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": []
                },
                {
                    "desc": "<p>Returns a future that handles the <a href=\"dart-async\/StreamSubscription\/onDone.html\">onDone<\/a> and <a href=\"dart-async\/StreamSubscription\/onError.html\">onError<\/a> callbacks.<\/p>\n<p>This method <em>overwrites<\/em> the existing <a href=\"dart-async\/StreamSubscription\/onDone.html\">onDone<\/a> and <a href=\"dart-async\/StreamSubscription\/onError.html\">onError<\/a> callbacks\nwith new ones that complete the returned future.<\/p>\n<p>In case of an error the subscription will automatically cancel (even\nwhen it was listening with <code>cancelOnError<\/code> set to <code>false<\/code>).<\/p>\n<p>In case of a <code>done<\/code> event the future completes with the given\n<code>futureValue<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;E&gt; asFuture&lt;E&gt;([E futureValue]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/asFuture.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "asFuture",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": [
                        {
                            "name": "futureValue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<E>"
                        }
                    ]
                },
                {
                    "desc": "<p>Cancels this subscription.<\/p>\n<p>After this call, the subscription no longer receives events.<\/p>\n<p>The stream may need to shut down the source of events and clean up after\nthe subscription is canceled.<\/p>\n<p>Returns a future that is completed once the stream has finished\nits cleanup.<\/p>\n<p>For historical reasons, may also return <code>null<\/code> if no cleanup was necessary.\nReturning <code>null<\/code> is deprecated and should be avoided.<\/p>\n<p>Typically, futures are returned when the stream needs to release resources.\nFor example, a stream might need to close an open file (as an asynchronous\noperation). If the listener wants to delete the file after having\ncanceled the subscription, it must wait for the cleanup future to complete.<\/p>\n<p>A returned future completes with a <code>null<\/code> value.\nIf the cleanup throws, which it really shouldn't, the returned future\ncompletes with that error.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future cancel();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/cancel.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "cancel",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": []
                },
                {
                    "desc": "<p>Replaces the data event handler of this subscription.<\/p>\n<p>The <code>handleData<\/code> function is called for each element of the stream\nafter this function is called.\nIf <code>handleData<\/code> is <code>null<\/code>, further elements are ignored.<\/p>\n<p>This method replaces the current handler set by the invocation of\n<a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a> or by a previous call to <a href=\"dart-async\/StreamSubscription\/onData.html\">onData<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void onData(void handleData(T data));<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/onData.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "onData",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": [
                        {
                            "name": "data",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Replaces the done event handler of this subscription.<\/p>\n<p>The <code>handleDone<\/code> function is called when the stream closes.\nThe value may be <code>null<\/code>, in which case no function is called.<\/p>\n<p>This method replaces the current handler set by the invocation of\n<a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>, by calling <a href=\"dart-async\/StreamSubscription\/asFuture.html\">asFuture<\/a>, or by a previous call to <a href=\"dart-async\/StreamSubscription\/onDone.html\">onDone<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void onDone(void handleDone());<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/onDone.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "onDone",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": [
                        {
                            "name": "handleDone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        }
                    ]
                },
                {
                    "desc": "<p>Replaces the error event handler of this subscription.<\/p>\n<p>The <code>handleError<\/code> function must be able to be called with either\none positional argument, or with two positional arguments\nwhere the seconds is always a <a href=\"dart-core\/StackTrace-class.html\">StackTrace<\/a>.<\/p>\n<p>The <code>handleError<\/code> argument may be <code>null<\/code>, in which case further\nerror events are considered unhandled, and will be reported to\n<a href=\"dart-async\/Zone\/handleUncaughtError.html\">Zone.handleUncaughtError<\/a>.<\/p>\n<p>The provided function is called for all error events from the\nstream subscription.<\/p>\n<p>This method replaces the current handler set by the invocation of\n<a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>, by calling <a href=\"dart-async\/StreamSubscription\/asFuture.html\">asFuture<\/a>, or by a previous call to <a href=\"dart-async\/StreamSubscription\/onError.html\">onError<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void onError(Function handleError);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/onError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "onError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": [
                        {
                            "name": "handleError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        }
                    ]
                },
                {
                    "desc": "<p>Request that the stream pauses events until further notice.<\/p>\n<p>While paused, the subscription will not fire any events.\nIf it receives events from its source, they will be buffered until\nthe subscription is resumed.\nFor non-broadcast streams, the underlying source is usually informed\nabout the pause,\nso it can stop generating events until the subscription is resumed.<\/p>\n<p>To avoid buffering events on a broadcast stream, it is better to\ncancel this subscription, and start to listen again when events\nare needed, if the intermediate events are not important.<\/p>\n<p>If <code>resumeSignal<\/code> is provided, the stream subscription will undo the pause\nwhen the future completes, as if by a call to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a>.\nIf the future completes with an error,\nthe stream will still resume, but the error will be considered unhandled\nand is passed to <a href=\"dart-async\/Zone\/handleUncaughtError.html\">Zone.handleUncaughtError<\/a>.<\/p>\n<p>A call to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a> will also undo a pause.<\/p>\n<p>If the subscription is paused more than once, an equal number\nof resumes must be performed to resume the stream.\nCalls to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a> and the completion of a <code>resumeSignal<\/code> are\ninterchangeable - the <a href=\"dart-async\/StreamSubscription\/pause.html\">pause<\/a> which was passed a <code>resumeSignal<\/code> may be\nended by a call to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a>, and completing the <code>resumeSignal<\/code> may end a\ndifferent <a href=\"dart-async\/StreamSubscription\/pause.html\">pause<\/a>.<\/p>\n<p>It is safe to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a> or complete a <code>resumeSignal<\/code> even when the\nsubscription is not paused, and the resume will have no effect.<\/p>\n<p>Currently DOM streams silently drop events when the stream is paused. This\nis a bug and will be fixed.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void pause([Future resumeSignal]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/pause.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "pause",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": [
                        {
                            "name": "resumeSignal",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Future"
                        }
                    ]
                },
                {
                    "desc": "<p>Resume after a pause.<\/p>\n<p>This undoes one previous call to <a href=\"dart-async\/StreamSubscription\/pause.html\">pause<\/a>.\nWhen all previously calls to <a href=\"dart-async\/StreamSubscription\/pause.html\">pause<\/a> have been matched by a calls to\n<a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a>, possibly through a <code>resumeSignal<\/code> passed to <a href=\"dart-async\/StreamSubscription\/pause.html\">pause<\/a>,\nthe stream subscription may emit events again.<\/p>\n<p>It is safe to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a> even when the subscription is not paused, and the\nresume will have no effect.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void resume();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamSubscription\/resume.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "resume",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>Whether the <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> is currently paused.<\/p>\n<p>If there have been more calls to <a href=\"dart-async\/StreamSubscription\/pause.html\">pause<\/a> than to <a href=\"dart-async\/StreamSubscription\/resume.html\">resume<\/a> on this\nstream subscription, the subscription is paused, and this getter\nreturns <code>true<\/code>.<\/p>\n<p>Returns <code>false<\/code> if the stream can currently emit events, or if\nthe subscription has completed or been cancelled.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isPaused;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamSubscription\/isPaused.html",
                    "name": "isPaused",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamSubscription",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Transforms a Stream.<\/p>\n<p>When a stream's <a href=\"dart-async\/Stream\/transform.html\">Stream.transform<\/a> method is invoked with a\n<a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a>, the stream calls the <a href=\"dart-async\/StreamTransformer\/bind.html\">bind<\/a> method on the provided\ntransformer. The resulting stream is then returned from the\n<a href=\"dart-async\/Stream\/transform.html\">Stream.transform<\/a> method.<\/p>\n<p>Conceptually, a transformer is simply a function from <a href=\"dart-async\/Stream-class.html\">Stream<\/a> to <a href=\"dart-async\/Stream-class.html\">Stream<\/a>\nthat is encapsulated into a class.<\/p>\n<p>It is good practice to write transformers that can be used multiple times.<\/p>\n<p>All other transforming methods on <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, such as <a href=\"dart-async\/Stream\/map.html\">Stream.map<\/a>,\n<a href=\"dart-async\/Stream\/where.html\">Stream.where<\/a> or <a href=\"dart-async\/Stream\/expand.html\">Stream.expand<\/a> can be implemented using\n<a href=\"dart-async\/Stream\/transform.html\">Stream.transform<\/a>. A <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> is thus very powerful but often\nalso a bit more complicated to use.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamTransformer-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamTransformer",
            "shortname": "StreamTransformer",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> based on the given <code>onListen<\/code> callback.<\/p>\n<p>The returned stream transformer uses the provided <code>onListen<\/code> callback\nwhen a transformed stream is listened to. At that time, the callback\nreceives the input stream (the one passed to <a href=\"dart-async\/StreamTransformer\/bind.html\">bind<\/a>) and a\nboolean flag <code>cancelOnError<\/code> to create a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>.<\/p>\n<p>The <code>onListen<\/code> callback does <em>not<\/em> receive the handlers that were passed\nto <a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>. These are automatically set after the call to the\n<code>onListen<\/code> callback (using <a href=\"dart-async\/StreamSubscription\/onData.html\">StreamSubscription.onData<\/a>,\n<a href=\"dart-async\/StreamSubscription\/onError.html\">StreamSubscription.onError<\/a> and <a href=\"dart-async\/StreamSubscription\/onDone.html\">StreamSubscription.onDone<\/a>).<\/p>\n<p>Most commonly, an <code>onListen<\/code> callback will first call <a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a> on\nthe provided stream (with the corresponding <code>cancelOnError<\/code> flag), and then\nreturn a new <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>.<\/p>\n<p>There are two common ways to create a StreamSubscription:<\/p>\n<ol>\n<li>by allocating a <a href=\"dart-async\/StreamController-class.html\">StreamController<\/a> and to return the result of\nlistening to its stream. It's important to forward pause, resume and\ncancel events (unless the transformer intentionally wants to change\nthis behavior).<\/li>\n<li>by creating a new class that implements <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a>.\nNote that the subscription should run callbacks in the <a href=\"dart-async\/Zone-class.html\">Zone<\/a> the\nstream was listened to (see <a href=\"dart-async\/Zone-class.html\">Zone<\/a> and <a href=\"dart-async\/Zone\/bindCallback.html\">Zone.bindCallback<\/a>).<\/li>\n<\/ol>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code>\/\/\/ Starts listening to [input] and duplicates all non-error events.\nStreamSubscription&lt;int&gt; _onListen(Stream&lt;int&gt; input, bool cancelOnError) {\n  StreamSubscription&lt;String&gt; subscription;\n  \/\/ Create controller that forwards pause, resume and cancel events.\n  var controller = new StreamController&lt;String&gt;(\n      onPause: () {\n        subscription.pause();\n      },\n      onResume: () {\n        subscription.resume();\n      },\n      onCancel: () =&gt; subscription.cancel(),\n      sync: true); \/\/ \"sync\" is correct here, since events are forwarded.\n\n  \/\/ Listen to the provided stream using `cancelOnError`.\n  subscription = input.listen((data) {\n    \/\/ Duplicate the data.\n    controller.add(data);\n    controller.add(data);\n  },\n      onError: controller.addError,\n      onDone: controller.close,\n      cancelOnError: cancelOnError);\n\n  \/\/ Return a new [StreamSubscription] by listening to the controller's\n  \/\/ stream.\n  return controller.stream.listen(null);\n}\n\n\/\/ Instantiate a transformer:\nvar duplicator = const StreamTransformer&lt;int, int&gt;(_onListen);\n\n\/\/ Use as follows:\nintStream.transform(duplicator);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const factory StreamTransformer(\n        StreamSubscription&lt;T&gt; onListen(\n            Stream&lt;S&gt; stream, bool cancelOnError)) =\n    _StreamSubscriptionTransformer&lt;S, T&gt;;<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamTransformer\/StreamTransformer.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamTransformer",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamTransformer",
                    "params": [
                        {
                            "name": "cancelOnError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "stream",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Transforms the provided <code>stream<\/code>.<\/p>\n<p>Returns a new stream with events that are computed from events of the\nprovided <code>stream<\/code>.<\/p>\n<p>The <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> interface is completely generic,\nso it cannot say what subclasses do.\nEach <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a> should document clearly how it transforms the\nstream (on the class or variable used to access the transformer),\nas well as any differences from the following typical behavior:<\/p>\n<ul>\n<li>When the returned stream is listened to, it starts listening to the\ninput <code>stream<\/code>.<\/li>\n<li>Subscriptions of the returned stream forward (in a reasonable time)\na <a href=\"dart-async\/StreamSubscription\/pause.html\">StreamSubscription.pause<\/a> call to the subscription of the input\n<code>stream<\/code>.<\/li>\n<li>Similarly, canceling a subscription of the returned stream eventually\n(in reasonable time) cancels the subscription of the input <code>stream<\/code>.<\/li>\n<\/ul>\n<p>\"Reasonable time\" depends on the transformer and stream. Some transformers,\nlike a \"timeout\" transformer, might make these operations depend on a\nduration. Others might not delay them at all, or just by a microtask.<\/p>\n<p>Transformers are free to handle errors in any way.\nA transformer implementation may choose to propagate errors,\nor convert them to other events, or ignore them completely,\nbut if errors are ignored, it should be documented explicitly.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; bind(Stream&lt;S&gt; stream);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamTransformer\/bind.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "bind",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamTransformer",
                    "params": [
                        {
                            "name": "stream",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Provides a <code>StreamTransformer&lt;RS, RT&gt;<\/code> view of this stream transformer.<\/p>\n<p>The resulting transformer will check at run-time that all data events\nof the stream it transforms are actually instances of <code>S<\/code>,\nand it will check that all data events produced by this transformer\nare actually instances of <code>RT<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamTransformer&lt;RS, RT&gt; cast&lt;RS, RT&gt;();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamTransformer\/cast.html",
                    "isDeprecated": false,
                    "type": "dart:async.StreamTransformer",
                    "name": "cast",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamTransformer",
                    "params": []
                },
                {
                    "desc": "<p>Adapts <code>source<\/code> to be a <code>StreamTransformer&lt;TS, TT&gt;<\/code>.<\/p>\n<p>This allows <code>source<\/code> to be used at the new type, but at run-time it\nmust satisfy the requirements of both the new type and its original type.<\/p>\n<p>Data events passed into the returned transformer must also be instances\nof <code>SS<\/code>, and data events produced by <code>source<\/code> for those events must\nalso be instances of <code>TT<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static StreamTransformer&lt;TS, TT&gt; castFrom&lt;SS, ST, TS, TT&gt;(\n    StreamTransformer&lt;SS, ST&gt; source) {\n  return new CastStreamTransformer&lt;SS, ST, TS, TT&gt;(source);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamTransformer\/castFrom.html",
                    "isDeprecated": false,
                    "type": "dart:async.StreamTransformer",
                    "name": "castFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamTransformer",
                    "params": [
                        {
                            "name": "source",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.StreamTransformer"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Base class for implementing <a href=\"dart-async\/StreamTransformer-class.html\">StreamTransformer<\/a>.<\/p>\n<p>Contains default implementations of every method except <a href=\"dart-async\/StreamTransformer\/bind.html\">bind<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamTransformerBase-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamTransformerBase",
            "shortname": "StreamTransformerBase",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "async.SingleSubscriptionTransformer",
                "convert.HexDecoder",
                "convert.HexEncoder",
                "convert.PercentDecoder",
                "convert.PercentEncoder",
                "crypto.Hmac",
                "crypto.MD5",
                "crypto.Sha1",
                "crypto.Sha256",
                "dart:convert.AsciiDecoder",
                "dart:convert.AsciiEncoder",
                "dart:convert.Base64Decoder",
                "dart:convert.Base64Encoder",
                "dart:convert.HtmlEscape",
                "dart:convert.JsonDecoder",
                "dart:convert.JsonEncoder",
                "dart:convert.JsonUtf8Encoder",
                "dart:convert.Latin1Decoder",
                "dart:convert.Latin1Encoder",
                "dart:convert.LineSplitter",
                "dart:convert.Utf8Decoder",
                "dart:convert.Utf8Encoder",
                "dart:io.ZLibDecoder",
                "dart:io.ZLibEncoder"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const StreamTransformerBase();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamTransformerBase\/StreamTransformerBase.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamTransformerBase",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamTransformerBase",
                    "params": []
                },
                {
                    "desc": "<p>Provides a <code>StreamTransformer&lt;RS, RT&gt;<\/code> view of this stream transformer.<\/p>\n<p>The resulting transformer will check at run-time that all data events\nof the stream it transforms are actually instances of <code>S<\/code>,\nand it will check that all data events produced by this transformer\nare actually instances of <code>RT<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamTransformer&lt;RS, RT&gt; cast&lt;RS, RT&gt;() =&gt;\n    StreamTransformer.castFrom&lt;S, T, RS, RT&gt;(this);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamTransformerBase\/cast.html",
                    "isDeprecated": false,
                    "type": "dart:async.StreamTransformer",
                    "name": "cast",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamTransformerBase",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p><a href=\"dart-async\/Stream-class.html\">Stream<\/a> wrapper that only exposes the <a href=\"dart-async\/Stream-class.html\">Stream<\/a> interface.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/StreamView-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.StreamView",
            "shortname": "StreamView",
            "extends": [
                "dart:async.Stream",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "async.DelegatingStream"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const StreamView(Stream&lt;T&gt; stream)\n    : _stream = stream,\n      super._internal();<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamView\/StreamView.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StreamView",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.StreamView",
                    "params": [
                        {
                            "name": "stream",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.Stream"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a multi-subscription stream that produces the same events as this.<\/p>\n<p>The returned stream will subscribe to this stream when its first\nsubscriber is added, and will stay subscribed until this stream ends,\nor a callback cancels the subscription.<\/p>\n<p>If <code>onListen<\/code> is provided, it is called with a subscription-like object\nthat represents the underlying subscription to this stream. It is\npossible to pause, resume or cancel the subscription during the call\nto <code>onListen<\/code>. It is not possible to change the event handlers, including\nusing <a href=\"dart-async\/StreamSubscription\/asFuture.html\">StreamSubscription.asFuture<\/a>.<\/p>\n<p>If <code>onCancel<\/code> is provided, it is called in a similar way to <code>onListen<\/code>\nwhen the returned stream stops having listener. If it later gets\na new listener, the <code>onListen<\/code> function is called again.<\/p>\n<p>Use the callbacks, for example, for pausing the underlying subscription\nwhile having no subscribers to prevent losing events, or canceling the\nsubscription when there are no listeners.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Stream&lt;T&gt; asBroadcastStream(\n        {void onListen(StreamSubscription&lt;T&gt; subscription),\n        void onCancel(StreamSubscription&lt;T&gt; subscription)}) =&gt;\n    _stream.asBroadcastStream(onListen: onListen, onCancel: onCancel);<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamView\/asBroadcastStream.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "asBroadcastStream",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamView",
                    "params": [
                        {
                            "name": "subscription",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.StreamSubscription"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds a subscription to this stream.<\/p>\n<p>Returns a <a href=\"dart-async\/StreamSubscription-class.html\">StreamSubscription<\/a> which handles events from this stream using\nthe provided <code>onData<\/code>, <code>onError<\/code> and <code>onDone<\/code> handlers.\nThe handlers can be changed on the subscription, but they start out\nas the provided functions.<\/p>\n<p>On each data event from this stream, the subscriber's <code>onData<\/code> handler\nis called. If <code>onData<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>On errors from this stream, the <code>onError<\/code> handler is called with the\nerror object and possibly a stack trace.<\/p>\n<p>The <code>onError<\/code> callback must be of type <code>void onError(error)<\/code> or\n<code>void onError(error, StackTrace stackTrace)<\/code>. If <code>onError<\/code> accepts\ntwo arguments it is called with the error object and the stack trace\n(which could be <code>null<\/code> if this stream itself received an error without\nstack trace).\nOtherwise it is called with just the error object.\nIf <code>onError<\/code> is omitted, any errors on this stream are considered unhandled,\nand will be passed to the current <a href=\"dart-async\/Zone-class.html\">Zone<\/a>'s error handler.\nBy default unhandled async errors are treated\nas if they were uncaught top-level errors.<\/p>\n<p>If this stream closes and sends a done event, the <code>onDone<\/code> handler is\ncalled. If <code>onDone<\/code> is <code>null<\/code>, nothing happens.<\/p>\n<p>If <code>cancelOnError<\/code> is true, the subscription is automatically canceled\nwhen the first error event is delivered. The default is <code>false<\/code>.<\/p>\n<p>While a subscription is paused, or when it has been canceled,\nthe subscription doesn't receive events and none of the\nevent handler functions are called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StreamSubscription&lt;T&gt; listen(void onData(T value),\n    {Function onError, void onDone(), bool cancelOnError}) {\n  return _stream.listen(onData,\n      onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/StreamView\/listen.html",
                    "isDeprecated": false,
                    "type": "dart:async.StreamSubscription",
                    "name": "listen",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.StreamView",
                    "params": [
                        {
                            "name": "cancelOnError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "onDone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        },
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Whether this stream is a broadcast stream.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isBroadcast =&gt; _stream.isBroadcast;<\/code><\/pre>\n        ",
                    "href": "dart-async\/StreamView\/isBroadcast.html",
                    "name": "isBroadcast",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.StreamView",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A stream controller that delivers its events synchronously.<\/p>\n<p>A synchronous stream controller is intended for cases where\nan already asynchronous event triggers an event on a stream.<\/p>\n<p>Instead of adding the event to the stream in a later microtask,\ncausing extra latency, the event is instead fired immediately by the\nsynchronous stream controller, as if the stream event was\nthe current event or microtask.<\/p>\n<p>The synchronous stream controller can be used to break the contract\non <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, and it must be used carefully to avoid doing so.<\/p>\n<p>The only advantage to using a <a href=\"dart-async\/SynchronousStreamController-class.html\">SynchronousStreamController<\/a> over a\nnormal <a href=\"dart-async\/StreamController-class.html\">StreamController<\/a> is the improved latency.\nOnly use the synchronous version if the improvement is significant,\nand if its use is safe. Otherwise just use a normal stream controller,\nwhich will always have the correct behavior for a <a href=\"dart-async\/Stream-class.html\">Stream<\/a>, and won't\naccidentally break other code.<\/p>\n<p>Adding events to a synchronous controller should only happen as the\nvery last part of the handling of the original event.\nAt that point, adding an event to the stream is equivalent to\nreturning to the event loop and adding the event in the next microtask.<\/p>\n<p>Each listener callback will be run as if it was a top-level event\nor microtask. This means that if it throws, the error will be reported as\nuncaught as soon as possible.\nThis is one reason to add the event as the last thing in the original event\nhandler - any action done after adding the event will delay the report of\nerrors in the event listener callbacks.<\/p>\n<p>If an event is added in a setting that isn't known to be another event,\nit may cause the stream's listener to get that event before the listener\nis ready to handle it. We promise that after calling <a href=\"dart-async\/Stream\/listen.html\">Stream.listen<\/a>,\nyou won't get any events until the code doing the listen has completed.\nCalling <a href=\"dart-async\/SynchronousStreamController\/add.html\">add<\/a> in response to a function call of unknown origin may break\nthat promise.<\/p>\n<p>An <a href=\"dart-async\/StreamController\/onListen.html\">onListen<\/a> callback from the controller is <em>not<\/em> an asynchronous event,\nand adding events to the controller in the <code>onListen<\/code> callback is always\nwrong. The events will be delivered before the listener has even received\nthe subscription yet.<\/p>\n<p>The synchronous broadcast stream controller also has a restrictions that a\nnormal stream controller does not:\nThe <a href=\"dart-async\/SynchronousStreamController\/add.html\">add<\/a>, <a href=\"dart-async\/SynchronousStreamController\/addError.html\">addError<\/a>, <a href=\"dart-async\/SynchronousStreamController\/close.html\">close<\/a> and <a href=\"dart-async\/StreamController\/addStream.html\">addStream<\/a> methods <em>must not<\/em> be\ncalled while an event is being delivered.\nThat is, if a callback on a subscription on the controller's stream causes\na call to any of the functions above, the call will fail.\nA broadcast stream may have more than one listener, and if an\nevent is added synchronously while another is being also in the process\nof being added, the latter event might reach some listeners before\nthe former. To prevent that, an event cannot be added while a previous\nevent is being fired.\nThis guarantees that an event is fully delivered when the\nfirst <a href=\"dart-async\/SynchronousStreamController\/add.html\">add<\/a>, <a href=\"dart-async\/SynchronousStreamController\/addError.html\">addError<\/a> or <a href=\"dart-async\/SynchronousStreamController\/close.html\">close<\/a> returns,\nand further events will be delivered in the correct order.<\/p>\n<p>This still only guarantees that the event is delivered to the subscription.\nIf the subscription is paused, the actual callback may still happen later,\nand the event will instead be buffered by the subscription.\nBarring pausing, and the following buffered events that haven't been\ndelivered yet, callbacks will be called synchronously when an event is added.<\/p>\n<p>Adding an event to a synchronous non-broadcast stream controller while\nanother event is in progress may cause the second event to be delayed\nand not be delivered synchronously, and until that event is delivered,\nthe controller will not act synchronously.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/SynchronousStreamController-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.SynchronousStreamController",
            "shortname": "SynchronousStreamController",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "dart-async\/SynchronousStreamController\/SynchronousStreamController.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "SynchronousStreamController",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.SynchronousStreamController",
                    "params": []
                },
                {
                    "desc": "<p>Adds event to the controller's stream.<\/p>\n<p>As <a href=\"dart-async\/SynchronousStreamController\/add.html\">StreamController.add<\/a>, but must not be called while an event is\nbeing added by <a href=\"dart-async\/SynchronousStreamController\/add.html\">add<\/a>, <a href=\"dart-async\/SynchronousStreamController\/addError.html\">addError<\/a> or <a href=\"dart-async\/SynchronousStreamController\/close.html\">close<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void add(T data);<\/code><\/pre>\n    ",
                    "href": "dart-async\/SynchronousStreamController\/add.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.SynchronousStreamController",
                    "params": [
                        {
                            "name": "data",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds error to the controller's stream.<\/p>\n<p>As <a href=\"dart-async\/SynchronousStreamController\/addError.html\">StreamController.addError<\/a>, but must not be called while an event is\nbeing added by <a href=\"dart-async\/SynchronousStreamController\/add.html\">add<\/a>, <a href=\"dart-async\/SynchronousStreamController\/addError.html\">addError<\/a> or <a href=\"dart-async\/SynchronousStreamController\/close.html\">close<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addError(Object error, [StackTrace stackTrace]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/SynchronousStreamController\/addError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "addError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.SynchronousStreamController",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Closes the controller's stream.<\/p>\n<p>As <a href=\"dart-async\/SynchronousStreamController\/close.html\">StreamController.close<\/a>, but must not be called while an event is\nbeing added by <a href=\"dart-async\/SynchronousStreamController\/add.html\">add<\/a>, <a href=\"dart-async\/SynchronousStreamController\/addError.html\">addError<\/a> or <a href=\"dart-async\/SynchronousStreamController\/close.html\">close<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future close();<\/code><\/pre>\n    ",
                    "href": "dart-async\/SynchronousStreamController\/close.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "close",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.SynchronousStreamController",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Thrown when a scheduled timeout happens while waiting for an async result.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/TimeoutException-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.TimeoutException",
            "shortname": "TimeoutException",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TimeoutException(this.message, [this.duration]);<\/code><\/pre>\n    ",
                    "href": "dart-async\/TimeoutException\/TimeoutException.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TimeoutException",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.TimeoutException",
                    "params": [
                        {
                            "name": "duration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.Duration"
                        },
                        {
                            "name": "message",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">String toString() {\n  String result = \"TimeoutException\";\n  if (duration != null) result = \"TimeoutException after $duration\";\n  if (message != null) result = \"$result: $message\";\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/TimeoutException\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.TimeoutException",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The duration that was exceeded.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Duration duration\n\n<\/code><\/pre>\n        ",
                    "href": "dart-async\/TimeoutException\/duration.html",
                    "name": "duration",
                    "isDeprecated": false,
                    "type": "dart:core.Duration",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.TimeoutException",
                    "params": []
                },
                {
                    "desc": "<p>Description of the cause of the timeout.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String message\n\n<\/code><\/pre>\n        ",
                    "href": "dart-async\/TimeoutException\/message.html",
                    "name": "message",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.TimeoutException",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A count-down timer that can be configured to fire once or repeatedly.<\/p>\n<p>The timer counts down from the specified duration to 0.\nWhen the timer reaches 0, the timer invokes the specified callback function.\nUse a periodic timer to repeatedly count down the same interval.<\/p>\n<p>A negative duration is treated the same as a duration of 0.\nIf the duration is statically known to be 0, consider using <a href=\"dart-async\/Timer\/run.html\">run<\/a>.<\/p>\n<p>Frequently the duration is either a constant or computed as in the\nfollowing example (taking advantage of the multiplication operator of\nthe <a href=\"dart-core\/Duration-class.html\">Duration<\/a> class):<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">const timeout = const Duration(seconds: 3);\nconst ms = const Duration(milliseconds: 1);\n\nstartTimeout([int milliseconds]) {\n  var duration = milliseconds == null ? timeout : ms * milliseconds;\n  return new Timer(duration, handleTimeout);\n}\n...\nvoid handleTimeout() {  \/\/ callback function\n  ...\n}\n<\/code><\/pre>\n<p>Note: If Dart code using Timer is compiled to JavaScript, the finest\ngranularity available in the browser is 4 milliseconds.<\/p>\n<p>See <a href=\"dart-core\/Stopwatch-class.html\">Stopwatch<\/a> for measuring elapsed time.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/Timer-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.Timer",
            "shortname": "Timer",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a new timer.<\/p>\n<p>The <code>callback<\/code> function is invoked after the given <code>duration<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">factory Timer(Duration duration, void callback()) {\n  if (Zone.current == Zone.root) {\n    \/\/ No need to bind the callback. We know that the root's timer will\n    \/\/ be invoked in the root zone.\n    return Zone.current.createTimer(duration, callback);\n  }\n  return Zone.current\n      .createTimer(duration, Zone.current.bindCallbackGuarded(callback));\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Timer\/Timer.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Timer",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.Timer",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "<void>"
                        },
                        {
                            "name": "duration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.Duration"
                        }
                    ]
                },
                {
                    "desc": "<p>Cancels the timer.<\/p>\n<p>Once a <a href=\"dart-async\/Timer-class.html\">Timer<\/a> has been canceled, the callback function will not be called\nby the timer. Calling <a href=\"dart-async\/Timer\/cancel.html\">cancel<\/a> more than once on a <a href=\"dart-async\/Timer-class.html\">Timer<\/a> is allowed, and\nwill have no further effect.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void cancel();<\/code><\/pre>\n    ",
                    "href": "dart-async\/Timer\/cancel.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "cancel",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Timer",
                    "params": []
                },
                {
                    "desc": "<p>Runs the given <code>callback<\/code> asynchronously as soon as possible.<\/p>\n<p>This function is equivalent to <code>new Timer(Duration.zero, callback)<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static void run(void callback()) {\n  new Timer(Duration.zero, callback);\n}<\/code><\/pre>\n    ",
                    "href": "dart-async\/Timer\/run.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "run",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Timer",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Returns whether the timer is still active.<\/p>\n<p>A non-periodic timer is active if the callback has not been executed,\nand the timer has not been canceled.<\/p>\n<p>A periodic timer is active if it has not been canceled.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isActive;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Timer\/isActive.html",
                    "name": "isActive",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Timer",
                    "params": []
                },
                {
                    "desc": "<p>The number of durations preceding the most recent timer event.<\/p>\n<p>The value starts at zero and is incremented each time a timer event\noccurs, so each callback will see a larger value than the previous one.<\/p>\n<p>If a periodic timer with a non-zero duration is delayed too much,\nso more than one tick should have happened,\nall but the last tick in the past are considered \"missed\",\nand no callback is invoked for them.\nThe <a href=\"dart-async\/Timer\/tick.html\">tick<\/a> count reflects the number of durations that have passed and\nnot the number of callback invocations that have happened.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get tick;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Timer\/tick.html",
                    "name": "tick",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Timer",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A zone represents an environment that remains stable across asynchronous\ncalls.<\/p>\n<p>Code is always executed in the context of a zone, available as\n<a href=\"dart-async\/Zone\/current.html\">Zone.current<\/a>. The initial <code>main<\/code> function runs in the context of the\ndefault zone (<a href=\"dart-async\/Zone\/root-constant.html\">Zone.root<\/a>). Code can be run in a different zone using either\n<a href=\"dart-async\/runZoned.html\">runZoned<\/a>, to create a new zone, or <a href=\"dart-async\/Zone\/run.html\">Zone.run<\/a> to run code in the context of\nan existing zone likely created using <a href=\"dart-async\/Zone\/fork.html\">Zone.fork<\/a>.<\/p>\n<p>Developers can create a new zone that overrides some of the functionality of\nan existing zone. For example, custom zones can replace of modify the\nbehavior of <code>print<\/code>, timers, microtasks or how uncaught errors are handled.<\/p>\n<p>The <a href=\"dart-async\/Zone-class.html\">Zone<\/a> class is not subclassable, but users can provide custom zones by\nforking an existing zone (usually <a href=\"dart-async\/Zone\/current.html\">Zone.current<\/a>) with a <a href=\"dart-async\/ZoneSpecification-class.html\">ZoneSpecification<\/a>.\nThis is similar to creating a new class that extends the base <code>Zone<\/code> class\nand that overrides some methods, except without actually creating a new\nclass. Instead the overriding methods are provided as functions that\nexplicitly take the equivalent of their own class, the \"super\" class and the\n<code>this<\/code> object as parameters.<\/p>\n<p>Asynchronous callbacks always run in the context of the zone where they were\nscheduled. This is implemented using two steps:<\/p>\n<ol>\n<li>the callback is first registered using one of <a href=\"dart-async\/Zone\/registerCallback.html\">registerCallback<\/a>,\n  <a href=\"dart-async\/Zone\/registerUnaryCallback.html\">registerUnaryCallback<\/a>, or <a href=\"dart-async\/Zone\/registerBinaryCallback.html\">registerBinaryCallback<\/a>. This allows the zone\n  to record that a callback exists and potentially modify it (by returning a\n  different callback). The code doing the registration (e.g., <code>Future.then<\/code>)\n  also remembers the current zone so that it can later run the callback in\n  that zone.<\/li>\n<li>At a later point the registered callback is run in the remembered zone.<\/li>\n<\/ol>\n<p>This is all handled internally by the platform code and most users don't need\nto worry about it. However, developers of new asynchronous operations,\nprovided by the underlying system or through native extensions, must follow\nthe protocol to be zone compatible.<\/p>\n<p>For convenience, zones provide <a href=\"dart-async\/Zone\/bindCallback.html\">bindCallback<\/a> (and the corresponding\n<a href=\"dart-async\/Zone\/bindUnaryCallback.html\">bindUnaryCallback<\/a> and <a href=\"dart-async\/Zone\/bindBinaryCallback.html\">bindBinaryCallback<\/a>) to make it easier to respect\nthe zone contract: these functions first invoke the corresponding <code>register<\/code>\nfunctions and then wrap the returned function so that it runs in the current\nzone when it is later asynchronously invoked.<\/p>\n<p>Similarly, zones provide <a href=\"dart-async\/Zone\/bindCallbackGuarded.html\">bindCallbackGuarded<\/a> (and the corresponding\n<a href=\"dart-async\/Zone\/bindUnaryCallbackGuarded.html\">bindUnaryCallbackGuarded<\/a> and <a href=\"dart-async\/Zone\/bindBinaryCallbackGuarded.html\">bindBinaryCallbackGuarded<\/a>), when the\ncallback should be invoked through <a href=\"dart-async\/Zone\/runGuarded.html\">Zone.runGuarded<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/Zone-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.Zone",
            "shortname": "Zone",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Registers the provided <code>callback<\/code> and returns a function that will\n execute in this zone.<\/p>\n<p> Equivalent to:<\/p>\n<pre class=\"language-dart\"><code> ZoneCallback registered = registerBinaryCallback(callback);\n return (arg1, arg2) =&gt; thin.runBinary(registered, arg1, arg2);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneBinaryCallback&lt;R, T1, T2&gt; bindBinaryCallback&lt;R, T1, T2&gt;(\n    R callback(T1 argument1, T2 argument2));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/bindBinaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneBinaryCallback",
                    "name": "bindBinaryCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "argument2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the provided <code>callback<\/code> and returns a function that will\n execute in this zone.<\/p>\n<p> Equivalent to:<\/p>\n<pre class=\"language-dart\"><code> ZoneCallback registered = registerBinaryCallback(callback);\n return (arg1, arg2) =&gt; this.runBinaryGuarded(registered, arg1, arg2);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void Function(T1, T2) bindBinaryCallbackGuarded&lt;T1, T2&gt;(\n    void callback(T1 argument1, T2 argument2));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/bindBinaryCallbackGuarded.html",
                    "isDeprecated": false,
                    "type": "<void Function(T1<  T2)>>",
                    "name": "bindBinaryCallbackGuarded",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "argument2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the provided <code>callback<\/code> and returns a function that will\n execute in this zone.<\/p>\n<p> Equivalent to:<\/p>\n<pre class=\"language-dart\"><code> ZoneCallback registered = this.registerCallback(callback);\n return () =&gt; this.run(registered);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneCallback&lt;R&gt; bindCallback&lt;R&gt;(R callback());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/bindCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneCallback",
                    "name": "bindCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<R>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the provided <code>callback<\/code> and returns a function that will\nexecute in this zone.<\/p>\n<p>When the function executes, errors are caught and treated as uncaught\nerrors.<\/p>\n<p>Equivalent to:<\/p>\n<pre class=\"language-dart\"><code>ZoneCallback registered = this.registerCallback(callback);\nreturn () =&gt; this.runGuarded(registered);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void Function() bindCallbackGuarded(void callback());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/bindCallbackGuarded.html",
                    "isDeprecated": false,
                    "type": "<void Function()>",
                    "name": "bindCallbackGuarded",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the provided <code>callback<\/code> and returns a function that will\n execute in this zone.<\/p>\n<p> Equivalent to:<\/p>\n<pre class=\"language-dart\"><code> ZoneCallback registered = this.registerUnaryCallback(callback);\n return (arg) =&gt; thin.runUnary(registered, arg);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneUnaryCallback&lt;R, T&gt; bindUnaryCallback&lt;R, T&gt;(R callback(T argument));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/bindUnaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneUnaryCallback",
                    "name": "bindUnaryCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the provided <code>callback<\/code> and returns a function that will\nexecute in this zone.<\/p>\n<p>When the function executes, errors are caught and treated as uncaught\nerrors.<\/p>\n<p>Equivalent to:<\/p>\n<pre class=\"language-dart\"><code>ZoneCallback registered = this.registerUnaryCallback(callback);\nreturn (arg) =&gt; this.runUnaryGuarded(registered, arg);\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void Function(T) bindUnaryCallbackGuarded&lt;T&gt;(void callback(T argument));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/bindUnaryCallbackGuarded.html",
                    "isDeprecated": false,
                    "type": "<void Function(T)>",
                    "name": "bindUnaryCallbackGuarded",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a periodic Timer where the callback is executed in this zone.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Timer createPeriodicTimer(Duration period, void callback(Timer timer));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/createPeriodicTimer.html",
                    "isDeprecated": false,
                    "type": "dart:async.Timer",
                    "name": "createPeriodicTimer",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "period",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        },
                        {
                            "name": "timer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Timer"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a Timer where the callback is executed in this zone.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Timer createTimer(Duration duration, void callback());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/createTimer.html",
                    "isDeprecated": false,
                    "type": "dart:async.Timer",
                    "name": "createTimer",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "duration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        }
                    ]
                },
                {
                    "desc": "<p>Intercepts errors when added programmatically to a <code>Future<\/code> or <code>Stream<\/code>.<\/p>\n<p>When calling <a href=\"dart-async\/Completer\/completeError.html\">Completer.completeError<\/a>, <a href=\"dart-async\/StreamController\/addError.html\">StreamController.addError<\/a>,\nor some <a href=\"dart-async\/Future-class.html\">Future<\/a> constructors, the current zone is allowed to intercept\nand replace the error.<\/p>\n<p>Future constructors invoke this function when the error is received\ndirectly, for example with <a href=\"dart-async\/Future\/Future.error.html\">Future.error<\/a>, or when the error is caught\nsynchronously, for example with <a href=\"dart-async\/Future\/Future.sync.html\">Future.sync<\/a>.<\/p>\n<p>There is no guarantee that an error is only sent through <a href=\"dart-async\/Zone\/errorCallback.html\">errorCallback<\/a>\nonce. Libraries that use intermediate controllers or completers might\nend up invoking <a href=\"dart-async\/Zone\/errorCallback.html\">errorCallback<\/a> multiple times.<\/p>\n<p>Returns <code>null<\/code> if no replacement is desired. Otherwise returns an instance\nof <a href=\"dart-async\/AsyncError-class.html\">AsyncError<\/a> holding the new pair of error and stack trace.<\/p>\n<p>Although not recommended, the returned instance may have its <code>error<\/code> member\n(<a href=\"dart-async\/AsyncError\/error.html\">AsyncError.error<\/a>) be equal to <code>null<\/code> in which case the error should be\nreplaced by a <a href=\"dart-core\/NullThrownError-class.html\">NullThrownError<\/a>.<\/p>\n<p>Custom zones may intercept this operation.<\/p>\n<p>Implementations of a new asynchronous primitive that converts synchronous\nerrors to asynchronous errors rarely need to invoke <a href=\"dart-async\/Zone\/errorCallback.html\">errorCallback<\/a>, since\nerrors are usually reported through future completers or stream\ncontrollers.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">AsyncError errorCallback(Object error, StackTrace stackTrace);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/errorCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.AsyncError",
                    "name": "errorCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a new zone as a child of <code>this<\/code>.<\/p>\n<p>The new zone uses the closures in the given <code>specification<\/code> to override\nthe current's zone behavior. All specification entries that are <code>null<\/code>\ninherit the behavior from the parent zone (<code>this<\/code>).<\/p>\n<p>The new zone inherits the stored values (accessed through <a href=\"dart-async\/Zone\/operator_get.html\">operator []<\/a>)\nof this zone and updates them with values from <code>zoneValues<\/code>, which either\nadds new values or overrides existing ones.<\/p>\n<p>Note that the fork operation is interceptible. A zone can thus change\nthe zone specification (or zone values), giving the forking zone full\ncontrol over the child zone.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Zone fork({ZoneSpecification specification, Map zoneValues});<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/fork.html",
                    "isDeprecated": false,
                    "type": "dart:async.Zone",
                    "name": "fork",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "specification",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.ZoneSpecification"
                        },
                        {
                            "name": "zoneValues",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Map"
                        }
                    ]
                },
                {
                    "desc": "<p>Handles uncaught asynchronous errors.<\/p>\n<p>There are two kind of asynchronous errors that are handled by this\nfunction:<\/p>\n<ol>\n<li>Uncaught errors that were thrown in asynchronous callbacks, for example,\n  a <code>throw<\/code> in the function passed to <a href=\"dart-async\/Zone\/run.html\">Timer.run<\/a>.<\/li>\n<li>Asynchronous errors that are pushed through <a href=\"dart-async\/Future-class.html\">Future<\/a> and <a href=\"dart-async\/Stream-class.html\">Stream<\/a>\n  chains, but for which no child registered an error handler.\n  Most asynchronous classes, like <a href=\"dart-async\/Future-class.html\">Future<\/a> or <a href=\"dart-async\/Stream-class.html\">Stream<\/a> push errors to their\n  listeners. Errors are propagated this way until either a listener handles\n  the error (for example with <a href=\"dart-async\/Future\/catchError.html\">Future.catchError<\/a>), or no listener is\n  available anymore. In the latter case, futures and streams invoke the\n  zone's <a href=\"dart-async\/Zone\/handleUncaughtError.html\">handleUncaughtError<\/a>.<\/li>\n<\/ol>\n<p>By default, when handled by the root zone, uncaught asynchronous errors are\ntreated like uncaught synchronous exceptions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void handleUncaughtError(error, StackTrace stackTrace);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/handleUncaughtError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "handleUncaughtError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns true if <code>this<\/code> and <code>otherZone<\/code> are in the same error zone.<\/p>\n<p>Two zones are in the same error zone if they have the same <a href=\"dart-async\/Zone\/errorZone.html\">errorZone<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool inSameErrorZone(Zone otherZone);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/inSameErrorZone.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "inSameErrorZone",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "otherZone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "<p>Prints the given <code>line<\/code>.<\/p>\n<p>The global <code>print<\/code> function delegates to the current zone's <a href=\"dart-async\/Zone\/print.html\">print<\/a>\nfunction which makes it possible to intercept printing.<\/p>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code>import 'dart:async';\n\nmain() {\n  runZoned(() {\n    \/\/ Ends up printing: \"Intercepted: in zone\".\n    print(\"in zone\");\n  }, zoneSpecification: new ZoneSpecification(\n      print: (Zone self, ZoneDelegate parent, Zone zone, String line) {\n    parent.print(zone, \"Intercepted: $line\");\n  }));\n}\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void print(String line);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/print.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "print",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "line",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the given callback in this zone.<\/p>\n<p>Similar to <a href=\"dart-async\/Zone\/registerCallback.html\">registerCallback<\/a> but with a unary callback.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneBinaryCallback&lt;R, T1, T2&gt; registerBinaryCallback&lt;R, T1, T2&gt;(\n    R callback(T1 arg1, T2 arg2));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/registerBinaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneBinaryCallback",
                    "name": "registerBinaryCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "arg1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "arg2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the given callback in this zone.<\/p>\n<p>When implementing an asynchronous primitive that uses callbacks, the\ncallback must be registered using <a href=\"dart-async\/Zone\/registerCallback.html\">registerCallback<\/a> at the point where the\nuser provides the callback. This allows zones to record other information\nthat they need at the same time, perhaps even wrapping the callback, so\nthat the callback is prepared when it is later run in the same zones\n(using <a href=\"dart-async\/Zone\/run.html\">run<\/a>). For example, a zone may decide\nto store the stack trace (at the time of the registration) with the\ncallback.<\/p>\n<p>Returns the callback that should be used in place of the provided\n<code>callback<\/code>. Frequently zones simply return the original callback.<\/p>\n<p>Custom zones may intercept this operation. The default implementation in\n<a href=\"dart-async\/Zone\/root-constant.html\">Zone.root<\/a> returns the original callback unchanged.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneCallback&lt;R&gt; registerCallback&lt;R&gt;(R callback());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/registerCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneCallback",
                    "name": "registerCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<R>"
                        }
                    ]
                },
                {
                    "desc": "<p>Registers the given callback in this zone.<\/p>\n<p>Similar to <a href=\"dart-async\/Zone\/registerCallback.html\">registerCallback<\/a> but with a unary callback.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneUnaryCallback&lt;R, T&gt; registerUnaryCallback&lt;R, T&gt;(R callback(T arg));<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/registerUnaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneUnaryCallback",
                    "name": "registerUnaryCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "arg",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes <code>action<\/code> in this zone.<\/p>\n<p>By default (as implemented in the <a href=\"dart-async\/Zone\/root-constant.html\">root<\/a> zone), runs <code>action<\/code>\nwith <a href=\"dart-async\/Zone\/current.html\">current<\/a> set to this zone.<\/p>\n<p>If <code>action<\/code> throws, the synchronous exception is not caught by the zone's\nerror handler. Use <a href=\"dart-async\/Zone\/runGuarded.html\">runGuarded<\/a> to achieve that.<\/p>\n<p>Since the root zone is the only zone that can modify the value of\n<a href=\"dart-async\/Zone\/current.html\">current<\/a>, custom zones intercepting run should always delegate to their\nparent zone. They may take actions before and after the call.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">R run&lt;R&gt;(R action());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/run.html",
                    "isDeprecated": false,
                    "type": "<R>",
                    "name": "run",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "action",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<R>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes the given <code>action<\/code> with <code>argument1<\/code> and <code>argument2<\/code> in this\nzone.<\/p>\n<p>As <a href=\"dart-async\/Zone\/run.html\">run<\/a> except that <code>action<\/code> is called with two arguments instead of none.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">R runBinary&lt;R, T1, T2&gt;(\n    R action(T1 argument1, T2 argument2), T1 argument1, T2 argument2);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/runBinary.html",
                    "isDeprecated": false,
                    "type": "<R>",
                    "name": "runBinary",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "argument2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes the given <code>action<\/code> with <code>argument1<\/code> and <code>argument2<\/code> in this\nzone and catches synchronous errors.<\/p>\n<p>See <a href=\"dart-async\/Zone\/runGuarded.html\">runGuarded<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void runBinaryGuarded&lt;T1, T2&gt;(\n    void action(T1 argument1, T2 argument2), T1 argument1, T2 argument2);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/runBinaryGuarded.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "runBinaryGuarded",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "argument2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes the given <code>action<\/code> in this zone and catches synchronous\nerrors.<\/p>\n<p>This function is equivalent to:<\/p>\n<pre class=\"language-dart\"><code>try {\n  this.run(action);\n} catch (e, s) {\n  this.handleUncaughtError(e, s);\n}\n<\/code><\/pre>\n<p>See <a href=\"dart-async\/Zone\/run.html\">run<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void runGuarded(void action());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/runGuarded.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "runGuarded",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "action",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes the given <code>action<\/code> with <code>argument<\/code> in this zone.<\/p>\n<p>As <a href=\"dart-async\/Zone\/run.html\">run<\/a> except that <code>action<\/code> is called with one <code>argument<\/code> instead of\nnone.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">R runUnary&lt;R, T&gt;(R action(T argument), T argument);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/runUnary.html",
                    "isDeprecated": false,
                    "type": "<R>",
                    "name": "runUnary",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Executes the given <code>action<\/code> with <code>argument<\/code> in this zone and\ncatches synchronous errors.<\/p>\n<p>See <a href=\"dart-async\/Zone\/runGuarded.html\">runGuarded<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void runUnaryGuarded&lt;T&gt;(void action(T argument), T argument);<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/runUnaryGuarded.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "runUnaryGuarded",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "argument",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Runs <code>callback<\/code> asynchronously in this zone.<\/p>\n<p>The global <code>scheduleMicrotask<\/code> delegates to the current zone's\n<a href=\"dart-async\/Zone\/scheduleMicrotask.html\">scheduleMicrotask<\/a>. The root zone's implementation interacts with the\nunderlying system to schedule the given callback as a microtask.<\/p>\n<p>Custom zones may intercept this operation (for example to wrap the given\n<code>callback<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void scheduleMicrotask(void callback());<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/scheduleMicrotask.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "scheduleMicrotask",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.Zone",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The zone that is currently active.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">static Zone get current =&gt; _current;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Zone\/current.html",
                    "name": "current",
                    "isDeprecated": false,
                    "type": "dart:async.Zone",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Zone",
                    "params": []
                },
                {
                    "desc": "<p>The error zone is the one that is responsible for dealing with uncaught\nerrors.<\/p>\n<p>This is the closest parent zone of this zone that provides a\n<a href=\"dart-async\/Zone\/handleUncaughtError.html\">handleUncaughtError<\/a> method.<\/p>\n<p>Asynchronous errors never cross zone boundaries between zones with\ndifferent error handlers.<\/p>\n<p>Example:<\/p>\n<pre class=\"language-dart\"><code>import 'dart:async';\n\nmain() {\n  var future;\n  runZoned(() {\n    \/\/ The asynchronous error is caught by the custom zone which prints\n    \/\/ 'asynchronous error'.\n    future = new Future.error(\"asynchronous error\");\n  }, onError: (e) { print(e); });  \/\/ Creates a zone with an error handler.\n  \/\/ The following `catchError` handler is never invoked, because the\n  \/\/ custom zone created by the call to `runZoned` provides an\n  \/\/ error handler.\n  future.catchError((e) { throw \"is never reached\"; });\n}\n<\/code><\/pre>\n<p>Note that errors cannot enter a child zone with a different error handler\neither:<\/p>\n<pre class=\"language-dart\"><code>import 'dart:async';\n\nmain() {\n  runZoned(() {\n    \/\/ The following asynchronous error is *not* caught by the `catchError`\n    \/\/ in the nested zone, since errors are not to cross zone boundaries\n    \/\/ with different error handlers.\n    \/\/ Instead the error is handled by the current error handler,\n    \/\/ printing \"Caught by outer zone: asynchronous error\".\n    var future = new Future.error(\"asynchronous error\");\n    runZoned(() {\n      future.catchError((e) { throw \"is never reached\"; });\n    }, onError: (e) { throw \"is never reached\"; });\n  }, onError: (e) { print(\"Caught by outer zone: $e\"); });\n}\n<\/code><\/pre>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Zone get errorZone;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Zone\/errorZone.html",
                    "name": "errorZone",
                    "isDeprecated": false,
                    "type": "dart:async.Zone",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Zone",
                    "params": []
                },
                {
                    "desc": "<p>The parent zone of the this zone.<\/p>\n<p>Is <code>null<\/code> if <code>this<\/code> is the <a href=\"dart-async\/Zone\/root-constant.html\">root<\/a> zone.<\/p>\n<p>Zones are created by <a href=\"dart-async\/Zone\/fork.html\">fork<\/a> on an existing zone, or by <a href=\"dart-async\/runZoned.html\">runZoned<\/a> which\nforks the <a href=\"dart-async\/Zone\/current.html\">current<\/a> zone. The new zone's parent zone is the zone it was\nforked from.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Zone get parent;<\/code><\/pre>\n        ",
                    "href": "dart-async\/Zone\/parent.html",
                    "name": "parent",
                    "isDeprecated": false,
                    "type": "dart:async.Zone",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "dart:async.Zone",
                    "params": []
                },
                {
                    "desc": "<p>The root zone.<\/p>\n<p>All isolate entry functions (<code>main<\/code> or spawned functions) start running in\nthe root zone (that is, <a href=\"dart-async\/Zone\/current.html\">Zone.current<\/a> is identical to <a href=\"dart-async\/Zone\/root-constant.html\">Zone.root<\/a> when the\nentry function is called). If no custom zone is created, the rest of the\nprogram always runs in the root zone.<\/p>\n<p>The root zone implements the default behavior of all zone operations.\nMany methods, like <a href=\"dart-async\/Zone\/registerCallback.html\">registerCallback<\/a> do the bare minimum required of the\nfunction, and are only provided as a hook for custom zones. Others, like\n<a href=\"dart-async\/Zone\/scheduleMicrotask.html\">scheduleMicrotask<\/a>, interact with the underlying system to implement the\ndesired behavior.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Zone root = _rootZone\n\n<\/code><\/pre>\n    ",
                    "href": "dart-async\/Zone\/root-constant.html",
                    "name": "root",
                    "isDeprecated": false,
                    "type": "dart:async.Zone",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "dart:async.Zone",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An adapted view of the parent zone.<\/p>\n<p>This class allows the implementation of a zone method to invoke methods on\nthe parent zone while retaining knowledge of the originating zone.<\/p>\n<p>Custom zones (created through <a href=\"dart-async\/ZoneDelegate\/fork.html\">Zone.fork<\/a> or <a href=\"dart-async\/runZoned.html\">runZoned<\/a>) can provide\nimplementations of most methods of zones. This is similar to overriding\nmethods on <a href=\"dart-async\/Zone-class.html\">Zone<\/a>, except that this mechanism doesn't require subclassing.<\/p>\n<p>A custom zone function (provided through a <a href=\"dart-async\/ZoneSpecification-class.html\">ZoneSpecification<\/a>) typically\nrecords or wraps its parameters and then delegates the operation to its\nparent zone using the provided <a href=\"dart-async\/ZoneDelegate-class.html\">ZoneDelegate<\/a>.<\/p>\n<p>While zones have access to their parent zone (through <a href=\"dart-async\/Zone\/parent.html\">Zone.parent<\/a>) it is\nrecommended to call the methods on the provided parent delegate for two\nreasons:<\/p>\n<ol>\n<li>the delegate methods take an additional <code>zone<\/code> argument which is the\n  zone the action has been initiated in.<\/li>\n<li>delegate calls are more efficient, since the implementation knows how\n  to skip zones that would just delegate to their parents.<\/li>\n<\/ol>",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/ZoneDelegate-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.ZoneDelegate",
            "shortname": "ZoneDelegate",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "dart-async\/ZoneDelegate\/ZoneDelegate.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ZoneDelegate",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Timer createPeriodicTimer(Zone zone, Duration period, void f(Timer timer));<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/createPeriodicTimer.html",
                    "isDeprecated": false,
                    "type": "dart:async.Timer",
                    "name": "createPeriodicTimer",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "period",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        },
                        {
                            "name": "timer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Timer"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Timer createTimer(Zone zone, Duration duration, void f());<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/createTimer.html",
                    "isDeprecated": false,
                    "type": "dart:async.Timer",
                    "name": "createTimer",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "duration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        },
                        {
                            "name": "f",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">AsyncError errorCallback(Zone zone, Object error, StackTrace stackTrace);<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/errorCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.AsyncError",
                    "name": "errorCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Zone fork(Zone zone, ZoneSpecification specification, Map zoneValues);<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/fork.html",
                    "isDeprecated": false,
                    "type": "dart:async.Zone",
                    "name": "fork",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "specification",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.ZoneSpecification"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        },
                        {
                            "name": "zoneValues",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Map"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void handleUncaughtError(Zone zone, error, StackTrace stackTrace);<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/handleUncaughtError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "handleUncaughtError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "stackTrace",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void print(Zone zone, String line);<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/print.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "print",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "line",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneBinaryCallback&lt;R, T1, T2&gt; registerBinaryCallback&lt;R, T1, T2&gt;(\n    Zone zone, R f(T1 arg1, T2 arg2));<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/registerBinaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneBinaryCallback",
                    "name": "registerBinaryCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "arg1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "arg2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneCallback&lt;R&gt; registerCallback&lt;R&gt;(Zone zone, R f());<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/registerCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneCallback",
                    "name": "registerCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "f",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<R>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ZoneUnaryCallback&lt;R, T&gt; registerUnaryCallback&lt;R, T&gt;(Zone zone, R f(T arg));<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/registerUnaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ZoneUnaryCallback",
                    "name": "registerUnaryCallback",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "arg",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">R run&lt;R&gt;(Zone zone, R f());<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/run.html",
                    "isDeprecated": false,
                    "type": "<R>",
                    "name": "run",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "f",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<R>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">R runBinary&lt;R, T1, T2&gt;(Zone zone, R f(T1 arg1, T2 arg2), T1 arg1, T2 arg2);<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/runBinary.html",
                    "isDeprecated": false,
                    "type": "<R>",
                    "name": "runBinary",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "arg1",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T1>"
                        },
                        {
                            "name": "arg2",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T2>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">R runUnary&lt;R, T&gt;(Zone zone, R f(T arg), T arg);<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/runUnary.html",
                    "isDeprecated": false,
                    "type": "<R>",
                    "name": "runUnary",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "arg",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void scheduleMicrotask(Zone zone, void f());<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneDelegate\/scheduleMicrotask.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "scheduleMicrotask",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "dart:async.ZoneDelegate",
                    "params": [
                        {
                            "name": "f",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "zone",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:async.Zone"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>This class provides the specification for a forked zone.<\/p>\n<p>When forking a new zone (see <a href=\"dart-async\/ZoneSpecification\/fork.html\">Zone.fork<\/a>) one can override the default\nbehavior of the zone by providing callbacks. These callbacks must be\ngiven in an instance of this class.<\/p>\n<p>Handlers have the same signature as the same-named methods on <a href=\"dart-async\/Zone-class.html\">Zone<\/a> but\nreceive three additional arguments:<\/p>\n<ol>\n<li>the zone the handlers are attached to (the \"self\" zone).<\/li>\n<li>a <a href=\"dart-async\/ZoneDelegate-class.html\">ZoneDelegate<\/a> to the parent zone.<\/li>\n<li>the zone that first received the request (before the request was\n    bubbled up).<\/li>\n<\/ol>\n<p>Handlers can either stop propagation the request (by simply not calling the\nparent handler), or forward to the parent zone, potentially modifying the\narguments on the way.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "dart-async\/ZoneSpecification-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "dart:async",
            "name": "dart:async.ZoneSpecification",
            "shortname": "ZoneSpecification",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">CreatePeriodicTimerHandler get createPeriodicTimer;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/createPeriodicTimer.html",
                    "isDeprecated": false,
                    "type": "dart:async.CreatePeriodicTimerHandler",
                    "name": "createPeriodicTimer",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">CreateTimerHandler get createTimer;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/createTimer.html",
                    "isDeprecated": false,
                    "type": "dart:async.CreateTimerHandler",
                    "name": "createTimer",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ErrorCallbackHandler get errorCallback;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/errorCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.ErrorCallbackHandler",
                    "name": "errorCallback",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ForkHandler get fork;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/fork.html",
                    "isDeprecated": false,
                    "type": "dart:async.ForkHandler",
                    "name": "fork",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">HandleUncaughtErrorHandler get handleUncaughtError;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/handleUncaughtError.html",
                    "isDeprecated": false,
                    "type": "dart:async.HandleUncaughtErrorHandler",
                    "name": "handleUncaughtError",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">PrintHandler get print;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/print.html",
                    "isDeprecated": false,
                    "type": "dart:async.PrintHandler",
                    "name": "print",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RegisterBinaryCallbackHandler get registerBinaryCallback;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/registerBinaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.RegisterBinaryCallbackHandler",
                    "name": "registerBinaryCallback",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RegisterCallbackHandler get registerCallback;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/registerCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.RegisterCallbackHandler",
                    "name": "registerCallback",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RegisterUnaryCallbackHandler get registerUnaryCallback;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/registerUnaryCallback.html",
                    "isDeprecated": false,
                    "type": "dart:async.RegisterUnaryCallbackHandler",
                    "name": "registerUnaryCallback",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RunHandler get run;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/run.html",
                    "isDeprecated": false,
                    "type": "dart:async.RunHandler",
                    "name": "run",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RunBinaryHandler get runBinary;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/runBinary.html",
                    "isDeprecated": false,
                    "type": "dart:async.RunBinaryHandler",
                    "name": "runBinary",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">RunUnaryHandler get runUnary;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/runUnary.html",
                    "isDeprecated": false,
                    "type": "dart:async.RunUnaryHandler",
                    "name": "runUnary",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                },
                {
                    "desc": "",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ScheduleMicrotaskHandler get scheduleMicrotask;<\/code><\/pre>\n        ",
                    "href": "dart-async\/ZoneSpecification\/scheduleMicrotask.html",
                    "isDeprecated": false,
                    "type": "dart:async.ScheduleMicrotaskHandler",
                    "name": "scheduleMicrotask",
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": []
                }
            ],
            "methods": [
                {
                    "desc": "<p>Creates a specification with the provided handlers.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const factory ZoneSpecification(\n    {HandleUncaughtErrorHandler handleUncaughtError,\n    RunHandler run,\n    RunUnaryHandler runUnary,\n    RunBinaryHandler runBinary,\n    RegisterCallbackHandler registerCallback,\n    RegisterUnaryCallbackHandler registerUnaryCallback,\n    RegisterBinaryCallbackHandler registerBinaryCallback,\n    ErrorCallbackHandler errorCallback,\n    ScheduleMicrotaskHandler scheduleMicrotask,\n    CreateTimerHandler createTimer,\n    CreatePeriodicTimerHandler createPeriodicTimer,\n    PrintHandler print,\n    ForkHandler fork}) = _ZoneSpecification;<\/code><\/pre>\n    ",
                    "href": "dart-async\/ZoneSpecification\/ZoneSpecification.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ZoneSpecification",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "dart:async.ZoneSpecification",
                    "params": [
                        {
                            "name": "createPeriodicTimer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.CreatePeriodicTimerHandler"
                        },
                        {
                            "name": "createTimer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.CreateTimerHandler"
                        },
                        {
                            "name": "errorCallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.ErrorCallbackHandler"
                        },
                        {
                            "name": "fork",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.ForkHandler"
                        },
                        {
                            "name": "handleUncaughtError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.HandleUncaughtErrorHandler"
                        },
                        {
                            "name": "print",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.PrintHandler"
                        },
                        {
                            "name": "registerBinaryCallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.RegisterBinaryCallbackHandler"
                        },
                        {
                            "name": "registerCallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.RegisterCallbackHandler"
                        },
                        {
                            "name": "registerUnaryCallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.RegisterUnaryCallbackHandler"
                        },
                        {
                            "name": "run",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.RunHandler"
                        },
                        {
                            "name": "runBinary",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.RunBinaryHandler"
                        },
                        {
                            "name": "runUnary",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.RunUnaryHandler"
                        },
                        {
                            "name": "scheduleMicrotask",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.ScheduleMicrotaskHandler"
                        }
                    ]
                }
            ],
            "props": []
        }
    ],
    "mixin": [],
    "enum": [],
    "typedef": []
}