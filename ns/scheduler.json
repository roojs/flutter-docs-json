{
    "class": [
        {
            "desc": "<p>A task priority, as passed to <a href=\"scheduler\/SchedulerBinding\/scheduleTask.html\">SchedulerBinding.scheduleTask<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "scheduler\/Priority-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.Priority",
            "shortname": "Priority",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "<p>A task to run even when animations are running.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Priority animation = Priority._(100000)\n\n<\/code><\/pre>\n    ",
                    "href": "scheduler\/Priority\/animation-constant.html",
                    "name": "animation",
                    "isDeprecated": false,
                    "type": "scheduler.Priority",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.Priority",
                    "params": []
                },
                {
                    "desc": "<p>A task to run after all other tasks, when no animations are running.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Priority idle = Priority._(0)\n\n<\/code><\/pre>\n    ",
                    "href": "scheduler\/Priority\/idle-constant.html",
                    "name": "idle",
                    "isDeprecated": false,
                    "type": "scheduler.Priority",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.Priority",
                    "params": []
                },
                {
                    "desc": "<p>Maximum offset by which to clamp relative priorities.<\/p>\n<p>It is still possible to have priorities that are offset by more\nthan this amount by repeatedly taking relative offsets, but that\nis generally discouraged.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const int kMaxOffset = 10000\n\n<\/code><\/pre>\n    ",
                    "href": "scheduler\/Priority\/kMaxOffset-constant.html",
                    "name": "kMaxOffset",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.Priority",
                    "params": []
                },
                {
                    "desc": "<p>A task to run even when the user is interacting with the device.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Priority touch = Priority._(200000)\n\n<\/code><\/pre>\n    ",
                    "href": "scheduler\/Priority\/touch-constant.html",
                    "name": "touch",
                    "isDeprecated": false,
                    "type": "scheduler.Priority",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.Priority",
                    "params": []
                },
                {
                    "desc": "<p>Integer that describes this Priority value.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get value =&gt; _value;<\/code><\/pre>\n        ",
                    "href": "scheduler\/Priority\/value.html",
                    "name": "value",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Priority",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Calls its callback once per animation frame.<\/p>\n<p>When created, a ticker is initially disabled. Call <a href=\"scheduler\/Ticker\/start.html\">start<\/a> to\nenable the ticker.<\/p>\n<p>A <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> can be silenced by setting <a href=\"scheduler\/Ticker\/muted.html\">muted<\/a> to true. While silenced, time\nstill elapses, and <a href=\"scheduler\/Ticker\/start.html\">start<\/a> and <a href=\"scheduler\/Ticker\/stop.html\">stop<\/a> can still be called, but no callbacks\nare called.<\/p>\n<p>By convention, the <a href=\"scheduler\/Ticker\/start.html\">start<\/a> and <a href=\"scheduler\/Ticker\/stop.html\">stop<\/a> methods are used by the ticker's\nconsumer, and the <a href=\"scheduler\/Ticker\/muted.html\">muted<\/a> property is controlled by the <a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a>\nthat created the ticker.<\/p>\n<p>Tickers are driven by the <a href=\"scheduler\/SchedulerBinding-mixin.html\">SchedulerBinding<\/a>. See\n<a href=\"scheduler\/SchedulerBinding\/scheduleFrameCallback.html\">SchedulerBinding.scheduleFrameCallback<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "scheduler\/Ticker-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.Ticker",
            "shortname": "Ticker",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a ticker that will call the provided callback once per frame while\nrunning.<\/p>\n<p>An optional label can be provided for debugging purposes. That label\nwill appear in the <a href=\"scheduler\/Ticker\/toString.html\">toString<\/a> output in debug builds.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Ticker(this._onTick, { this.debugLabel }) {\n  assert(() {\n    _debugCreationStack = StackTrace.current;\n    return true;\n  }());\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/Ticker.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Ticker",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": [
                        {
                            "name": "_onTick",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "scheduler.TickerCallback"
                        },
                        {
                            "name": "debugLabel",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Makes this <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> take the state of another ticker, and disposes the\nother ticker.<\/p>\n<p>This is useful if an object with a <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> is given a new\n<a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a> but needs to maintain continuity. In particular, this\nmaintains the identity of the <a href=\"scheduler\/TickerFuture-class.html\">TickerFuture<\/a> returned by the <a href=\"scheduler\/Ticker\/start.html\">start<\/a>\nfunction of the original <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> if the original ticker is active.<\/p>\n<p>This ticker must not be active when this method is called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void absorbTicker(Ticker originalTicker) {\n  assert(!isActive);\n  assert(_future == null);\n  assert(_startTime == null);\n  assert(_animationId == null);\n  assert((originalTicker._future == null) == (originalTicker._startTime == null), 'Cannot absorb Ticker after it has been disposed.');\n  if (originalTicker._future != null) {\n    _future = originalTicker._future;\n    _startTime = originalTicker._startTime;\n    if (shouldScheduleTick)\n      scheduleTick();\n    originalTicker._future = null; \/\/ so that it doesn't get disposed when we dispose of originalTicker\n    originalTicker.unscheduleTick();\n  }\n  originalTicker.dispose();\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/absorbTicker.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "absorbTicker",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": [
                        {
                            "name": "originalTicker",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "scheduler.Ticker"
                        }
                    ]
                },
                {
                    "desc": "<p>Release the resources used by this object. The object is no longer usable\nafter this method is called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@mustCallSuper\nvoid dispose() {\n  if (_future != null) {\n    final TickerFuture localFuture = _future;\n    _future = null;\n    assert(!isActive);\n    unscheduleTick();\n    localFuture._cancel(this);\n  }\n  assert(() {\n    \/\/ We intentionally don't null out _startTime. This means that if start()\n    \/\/ was ever called, the object is now in a bogus state. This weakly helps\n    \/\/ catch cases of use-after-dispose.\n    _startTime = Duration.zero;\n    return true;\n  }());\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/dispose.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "dispose",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Schedules a tick for the next frame.<\/p>\n<p>This should only be called if <a href=\"scheduler\/Ticker\/shouldScheduleTick.html\">shouldScheduleTick<\/a> is true.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid scheduleTick({ bool rescheduling = false }) {\n  assert(!scheduled);\n  assert(shouldScheduleTick);\n  _animationId = SchedulerBinding.instance.scheduleFrameCallback(_tick, rescheduling: rescheduling);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/scheduleTick.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "scheduleTick",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": [
                        {
                            "name": "rescheduling",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Starts the clock for this <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a>. If the ticker is not <a href=\"scheduler\/Ticker\/muted.html\">muted<\/a>, then this\nalso starts calling the ticker's callback once per animation frame.<\/p>\n<p>The returned future resolves once the ticker <a href=\"scheduler\/Ticker\/stop.html\">stop<\/a>s ticking. If the\nticker is disposed, the future does not resolve. A derivative future is\navailable from the returned <a href=\"scheduler\/TickerFuture-class.html\">TickerFuture<\/a> object that resolves with an\nerror in that case, via <a href=\"scheduler\/TickerFuture\/orCancel.html\">TickerFuture.orCancel<\/a>.<\/p>\n<p>Calling this sets <a href=\"scheduler\/Ticker\/isActive.html\">isActive<\/a> to true.<\/p>\n<p>This method cannot be called while the ticker is active. To restart the\nticker, first <a href=\"scheduler\/Ticker\/stop.html\">stop<\/a> it.<\/p>\n<p>By convention, this method is used by the object that receives the ticks\n(as opposed to the <a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a> which created the ticker).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TickerFuture start() {\n  assert(() {\n    if (isActive) {\n      throw FlutterError(\n        'A ticker was started twice.\\n'\n        'A ticker that is already active cannot be started again without first stopping it.\\n'\n        'The affected ticker was: ${ toString(debugIncludeStack: true) }'\n      );\n    }\n    return true;\n  }());\n  assert(_startTime == null);\n  _future = TickerFuture._();\n  if (shouldScheduleTick) {\n    scheduleTick();\n  }\n  if (SchedulerBinding.instance.schedulerPhase.index &gt; SchedulerPhase.idle.index &amp;&amp;\n      SchedulerBinding.instance.schedulerPhase.index &lt; SchedulerPhase.postFrameCallbacks.index)\n    _startTime = SchedulerBinding.instance.currentFrameTimeStamp;\n  return _future;\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/start.html",
                    "isDeprecated": false,
                    "type": "scheduler.TickerFuture",
                    "name": "start",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Stops calling this <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a>'s callback.<\/p>\n<p>If called with the <code>canceled<\/code> argument set to false (the default), causes\nthe future returned by <a href=\"scheduler\/Ticker\/start.html\">start<\/a> to resolve. If called with the <code>canceled<\/code>\nargument set to true, the future does not resolve, and the future obtained\nfrom <a href=\"scheduler\/TickerFuture\/orCancel.html\">TickerFuture.orCancel<\/a>, if any, resolves with a <a href=\"scheduler\/TickerCanceled-class.html\">TickerCanceled<\/a>\nerror.<\/p>\n<p>Calling this sets <a href=\"scheduler\/Ticker\/isActive.html\">isActive<\/a> to false.<\/p>\n<p>This method does nothing if called when the ticker is inactive.<\/p>\n<p>By convention, this method is used by the object that receives the ticks\n(as opposed to the <a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a> which created the ticker).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void stop({ bool canceled = false }) {\n  if (!isActive)\n    return;\n\n  \/\/ We take the _future into a local variable so that isTicking is false\n  \/\/ when we actually complete the future (isTicking uses _future to\n  \/\/ determine its state).\n  final TickerFuture localFuture = _future;\n  _future = null;\n  _startTime = null;\n  assert(!isActive);\n\n  unscheduleTick();\n  if (canceled) {\n    localFuture._cancel(this);\n  } else {\n    localFuture._complete();\n  }\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/stop.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "stop",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": [
                        {
                            "name": "canceled",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString({ bool debugIncludeStack = false }) {\n  final StringBuffer buffer = StringBuffer();\n  buffer.write('$runtimeType(');\n  assert(() {\n    buffer.write(debugLabel ?? '');\n    return true;\n  }());\n  buffer.write(')');\n  assert(() {\n    if (debugIncludeStack) {\n      buffer.writeln();\n      buffer.writeln('The stack trace when the $runtimeType was actually created was:');\n      FlutterError.defaultStackFilter(_debugCreationStack.toString().trimRight().split('\\n')).forEach(buffer.writeln);\n    }\n    return true;\n  }());\n  return buffer.toString();\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": [
                        {
                            "name": "debugIncludeStack",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Cancels the frame callback that was requested by <a href=\"scheduler\/Ticker\/scheduleTick.html\">scheduleTick<\/a>, if any.<\/p>\n<p>Calling this method when no tick is <a href=\"scheduler\/Ticker\/scheduled.html\">scheduled<\/a> is harmless.<\/p>\n<p>This method should not be called when <a href=\"scheduler\/Ticker\/shouldScheduleTick.html\">shouldScheduleTick<\/a> would return\ntrue if no tick was scheduled.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid unscheduleTick() {\n  if (scheduled) {\n    SchedulerBinding.instance.cancelFrameCallbackWithId(_animationId);\n    _animationId = null;\n  }\n  assert(!shouldScheduleTick);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/Ticker\/unscheduleTick.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "unscheduleTick",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>An optional label can be provided for debugging purposes.<\/p>\n<p>This label will appear in the <a href=\"scheduler\/Ticker\/toString.html\">toString<\/a> output in debug builds.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String debugLabel\n\n<\/code><\/pre>\n        ",
                    "href": "scheduler\/Ticker\/debugLabel.html",
                    "name": "debugLabel",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Whether time is elapsing for this <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a>. Becomes true when <a href=\"scheduler\/Ticker\/start.html\">start<\/a> is\ncalled and false when <a href=\"scheduler\/Ticker\/stop.html\">stop<\/a> is called.<\/p>\n<p>A ticker can be active yet not be actually ticking (i.e. not be calling\nthe callback). To determine if a ticker is actually ticking, use\n<a href=\"scheduler\/Ticker\/isTicking.html\">isTicking<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isActive =&gt; _future != null;<\/code><\/pre>\n        ",
                    "href": "scheduler\/Ticker\/isActive.html",
                    "name": "isActive",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Whether this <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> has scheduled a call to call its callback\non the next frame.<\/p>\n<p>A ticker that is <a href=\"scheduler\/Ticker\/muted.html\">muted<\/a> can be active (see <a href=\"scheduler\/Ticker\/isActive.html\">isActive<\/a>) yet not be\nticking. In that case, the ticker will not call its callback, and\n<a href=\"scheduler\/Ticker\/isTicking.html\">isTicking<\/a> will be false, but time will still be progressing.<\/p>\n<p>This will return false if the <code>Scheduler.lifecycleState<\/code> is one that\nindicates the application is not currently visible (e.g. if the device's\nscreen is turned off).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isTicking {\n  if (_future == null)\n    return false;\n  if (muted)\n    return false;\n  if (SchedulerBinding.instance.framesEnabled)\n    return true;\n  if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.idle)\n    return true; \/\/ for example, we might be in a warm-up frame or forced frame\n  return false;\n}<\/code><\/pre>\n        ",
                    "href": "scheduler\/Ticker\/isTicking.html",
                    "name": "isTicking",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Whether this ticker has been silenced.<\/p>\n<p>While silenced, a ticker's clock can still run, but the callback will not\nbe called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get muted =&gt; _muted;<\/code><\/pre>\n        ",
                    "href": "scheduler\/Ticker\/muted.html",
                    "name": "muted",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Whether this <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> has already scheduled a frame callback.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nbool get scheduled =&gt; _animationId != null;<\/code><\/pre>\n        ",
                    "href": "scheduler\/Ticker\/scheduled.html",
                    "name": "scheduled",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                },
                {
                    "desc": "<p>Whether a tick should be scheduled.<\/p>\n<p>If this is true, then calling <a href=\"scheduler\/Ticker\/scheduleTick.html\">scheduleTick<\/a> should succeed.<\/p>\n<p>Reasons why a tick should not be scheduled include:<\/p>\n<ul>\n<li>A tick has already been scheduled for the coming frame.<\/li>\n<li>The ticker is not active (<a href=\"scheduler\/Ticker\/start.html\">start<\/a> has not been called).<\/li>\n<li>The ticker is not ticking, e.g. because it is <a href=\"scheduler\/Ticker\/muted.html\">muted<\/a> (see <a href=\"scheduler\/Ticker\/isTicking.html\">isTicking<\/a>).<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nbool get shouldScheduleTick =&gt; !muted &amp;&amp; isActive &amp;&amp; !scheduled;<\/code><\/pre>\n        ",
                    "href": "scheduler\/Ticker\/shouldScheduleTick.html",
                    "name": "shouldScheduleTick",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.Ticker",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Exception thrown by <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> objects on the <a href=\"scheduler\/TickerFuture\/orCancel.html\">TickerFuture.orCancel<\/a> future\nwhen the ticker is canceled.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "scheduler\/TickerCanceled-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.TickerCanceled",
            "shortname": "TickerCanceled",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a canceled-ticker exception.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const TickerCanceled([this.ticker]);<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerCanceled\/TickerCanceled.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TickerCanceled",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "scheduler.TickerCanceled",
                    "params": [
                        {
                            "name": "ticker",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "scheduler.Ticker"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  if (ticker != null)\n    return 'This ticker was canceled: $ticker';\n  return 'The ticker was canceled before the \"orCancel\" property was first used.';\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerCanceled\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerCanceled",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>Reference to the <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> object that was canceled.<\/p>\n<p>This may be null in the case that the <a href=\"dart-async\/Future-class.html\">Future<\/a> created for\n<a href=\"scheduler\/TickerFuture\/orCancel.html\">TickerFuture.orCancel<\/a> was created after the ticker was canceled.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Ticker ticker\n\n<\/code><\/pre>\n        ",
                    "href": "scheduler\/TickerCanceled\/ticker.html",
                    "name": "ticker",
                    "isDeprecated": false,
                    "type": "scheduler.Ticker",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.TickerCanceled",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An object representing an ongoing <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> sequence.<\/p>\n<p>The <a href=\"scheduler\/Ticker\/start.html\">Ticker.start<\/a> method returns a <a href=\"scheduler\/TickerFuture-class.html\">TickerFuture<\/a>. The <a href=\"scheduler\/TickerFuture-class.html\">TickerFuture<\/a> will\ncomplete successfully if the <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> is stopped using <a href=\"scheduler\/Ticker\/stop.html\">Ticker.stop<\/a> with\nthe <code>canceled<\/code> argument set to false (the default).<\/p>\n<p>If the <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> is disposed without being stopped, or if it is stopped with\n<code>canceled<\/code> set to true, then this Future will never complete.<\/p>\n<p>This class works like a normal <a href=\"dart-async\/Future-class.html\">Future<\/a>, but has an additional property,\n<a href=\"scheduler\/TickerFuture\/orCancel.html\">orCancel<\/a>, which returns a derivative <a href=\"dart-async\/Future-class.html\">Future<\/a> that completes with an error\nif the <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> that returned the <a href=\"scheduler\/TickerFuture-class.html\">TickerFuture<\/a> was stopped with <code>canceled<\/code>\nset to true, or if it was disposed without being stopped.<\/p>\n<p>To run a callback when either this future resolves or when the ticker is\ncanceled, use <a href=\"scheduler\/TickerFuture\/whenCompleteOrCancel.html\">whenCompleteOrCancel<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "scheduler\/TickerFuture-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.TickerFuture",
            "shortname": "TickerFuture",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a <a href=\"dart-async\/Stream-class.html\">Stream<\/a> containing the result of this future.<\/p>\n<p>The stream will produce single data or error event containing the\ncompletion result of this future, and then it will close with a\ndone event.<\/p>\n<p>If the future never completes, the stream will not produce any events.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nStream&lt;void&gt; asStream() {\n  return _primaryCompleter.future.asStream();\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/asStream.html",
                    "isDeprecated": false,
                    "type": "dart:async.Stream",
                    "name": "asStream",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": []
                },
                {
                    "desc": "<p>Handles errors emitted by this <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n<p>This is the asynchronous equivalent of a \"catch\" block.<\/p>\n<p>Returns a new <a href=\"dart-async\/Future-class.html\">Future<\/a> that will be completed with either the result of\nthis future or the result of calling the <code>onError<\/code> callback.<\/p>\n<p>If this future completes with a value,\nthe returned future completes with the same value.<\/p>\n<p>If this future completes with an error,\nthen <code>test<\/code> is first called with the error value.<\/p>\n<p>If <code>test<\/code> returns false, the exception is not handled by this <code>catchError<\/code>,\nand the returned future completes with the same error and stack trace\nas this future.<\/p>\n<p>If <code>test<\/code> returns <code>true<\/code>,\n<code>onError<\/code> is called with the error and possibly stack trace,\nand the returned future is completed with the result of this call\nin exactly the same way as for <a href=\"scheduler\/TickerFuture\/then.html\">then<\/a>'s <code>onError<\/code>.<\/p>\n<p>If <code>test<\/code> is omitted, it defaults to a function that always returns true.\nThe <code>test<\/code> function should not throw, but if it does, it is handled as\nif the <code>onError<\/code> function had thrown.<\/p>\n<p>Note that futures don't delay reporting of errors until listeners are\nadded. If the first <code>catchError<\/code> (or <code>then<\/code>) call happens after this future\nhas completed with an error then the error is reported as unhandled error.\nSee the description on <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; catchError(Function onError, { bool test(dynamic error) }) {\n  return _primaryCompleter.future.catchError(onError, test: test);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/catchError.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "catchError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": [
                        {
                            "name": "error",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        }
                    ]
                },
                {
                    "desc": "<p>Register callbacks to be called when this future completes.<\/p>\n<p>When this future completes with a value,\nthe <code>onValue<\/code> callback will be called with that value.\nIf this future is already completed, the callback will not be called\nimmediately, but will be scheduled in a later microtask.<\/p>\n<p>If <code>onError<\/code> is provided, and this future completes with an error,\nthe <code>onError<\/code> callback is called with that error and its stack trace.\nThe <code>onError<\/code> callback must accept either one argument or two arguments\nwhere the latter is a <a href=\"dart-core\/StackTrace-class.html\">StackTrace<\/a>.\nIf <code>onError<\/code> accepts two arguments,\nit is called with both the error and the stack trace,\notherwise it is called with just the error object.\nThe <code>onError<\/code> callback must return a value or future that can be used\nto complete the returned future, so it must be something assignable to\n<code>FutureOr&lt;R&gt;<\/code>.<\/p>\n<p>Returns a new <a href=\"dart-async\/Future-class.html\">Future<\/a>\nwhich is completed with the result of the call to <code>onValue<\/code>\n(if this future completes with a value)\nor to <code>onError<\/code> (if this future completes with an error).<\/p>\n<p>If the invoked callback throws,\nthe returned future is completed with the thrown error\nand a stack trace for the error.\nIn the case of <code>onError<\/code>,\nif the exception thrown is <code>identical<\/code> to the error argument to <code>onError<\/code>,\nthe throw is considered a rethrow,\nand the original stack trace is used instead.<\/p>\n<p>If the callback returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>,\nthe future returned by <code>then<\/code> will be completed with\nthe same result as the future returned by the callback.<\/p>\n<p>If <code>onError<\/code> is not given, and this future completes with an error,\nthe error is forwarded directly to the returned future.<\/p>\n<p>In most cases, it is more readable to use <a href=\"scheduler\/TickerFuture\/catchError.html\">catchError<\/a> separately, possibly\nwith a <code>test<\/code> parameter, instead of handling both value and error in a\nsingle <a href=\"scheduler\/TickerFuture\/then.html\">then<\/a> call.<\/p>\n<p>Note that futures don't delay reporting of errors until listeners are\nadded. If the first <code>then<\/code> or <code>catchError<\/code> call happens after this future\nhas completed with an error then the error is reported as unhandled error.\nSee the description on <a href=\"dart-async\/Future-class.html\">Future<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;E&gt; then&lt;E&gt;(dynamic f(void value), { Function onError }) {\n  return _primaryCompleter.future.then&lt;E&gt;(f, onError: onError);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/then.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "then",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": [
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Function"
                        },
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        }
                    ]
                },
                {
                    "desc": "<p>Time-out the future computation after <code>timeLimit<\/code> has passed.<\/p>\n<p>Returns a new future that completes with the same value as this future,\nif this future completes in time.<\/p>\n<p>If this future does not complete before <code>timeLimit<\/code> has passed,\nthe <code>onTimeout<\/code> action is executed instead, and its result (whether it\nreturns or throws) is used as the result of the returned future.\nThe <code>onTimeout<\/code> function must return a <code>T<\/code> or a <code>Future&lt;T&gt;<\/code>.<\/p>\n<p>If <code>onTimeout<\/code> is omitted, a timeout will cause the returned future to\ncomplete with a <a href=\"dart-async\/TimeoutException-class.html\">TimeoutException<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; timeout(Duration timeLimit, { dynamic onTimeout() }) {\n  return _primaryCompleter.future.timeout(timeLimit, onTimeout: onTimeout);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/timeout.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "timeout",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": [
                        {
                            "name": "onTimeout",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "timeLimit",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Duration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '${describeIdentity(this)}(${ _completed == null ? \"active\" : _completed ? \"complete\" : \"canceled\" })';<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": []
                },
                {
                    "desc": "<p>Registers a function to be called when this future completes.<\/p>\n<p>The <code>action<\/code> function is called when this future completes, whether it\ndoes so with a value or with an error.<\/p>\n<p>This is the asynchronous equivalent of a \"finally\" block.<\/p>\n<p>The future returned by this call, <code>f<\/code>, will complete the same way\nas this future unless an error occurs in the <code>action<\/code> call, or in\na <a href=\"dart-async\/Future-class.html\">Future<\/a> returned by the <code>action<\/code> call. If the call to <code>action<\/code>\ndoes not return a future, its return value is ignored.<\/p>\n<p>If the call to <code>action<\/code> throws, then <code>f<\/code> is completed with the\nthrown error.<\/p>\n<p>If the call to <code>action<\/code> returns a <a href=\"dart-async\/Future-class.html\">Future<\/a>, <code>f2<\/code>, then completion of\n<code>f<\/code> is delayed until <code>f2<\/code> completes. If <code>f2<\/code> completes with\nan error, that will be the result of <code>f<\/code> too. The value of <code>f2<\/code> is always\nignored.<\/p>\n<p>This method is equivalent to:<\/p>\n<pre class=\"language-dart\"><code>Future&lt;T&gt; whenComplete(action()) {\n  return this.then((v) {\n    var f2 = action();\n    if (f2 is Future) return f2.then((_) =&gt; v);\n    return v\n  }, onError: (e) {\n    var f2 = action();\n    if (f2 is Future) return f2.then((_) { throw e; });\n    throw e;\n  });\n}\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; whenComplete(dynamic action()) {\n  return _primaryCompleter.future.whenComplete(action);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/whenComplete.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "whenComplete",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": [
                        {
                            "name": "action",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        }
                    ]
                },
                {
                    "desc": "<p>Calls <code>callback<\/code> either when this future resolves or when the ticker is\ncanceled.<\/p>\n<p>Calling this method registers an exception handler for the <a href=\"scheduler\/TickerFuture\/orCancel.html\">orCancel<\/a>\nfuture, so even if the <a href=\"scheduler\/TickerFuture\/orCancel.html\">orCancel<\/a> property is accessed, canceling the\nticker will not cause an uncaught exception in the current zone.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void whenCompleteOrCancel(VoidCallback callback) {\n  void thunk(dynamic value) {\n    callback();\n  }\n  orCancel.then&lt;void&gt;(thunk, onError: thunk);\n}<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerFuture\/whenCompleteOrCancel.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "whenCompleteOrCancel",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": [
                        {
                            "name": "callback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>A future that resolves when this future resolves or throws when the ticker\nis canceled.<\/p>\n<p>If this property is never accessed, then canceling the ticker does not\nthrow any exceptions. Once this property is accessed, though, if the\ncorresponding ticker is canceled, then the <a href=\"dart-async\/Future-class.html\">Future<\/a> returned by this\ngetter will complete with an error, and if that error is not caught, there\nwill be an uncaught exception in the current zone.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; get orCancel {\n  if (_secondaryCompleter == null) {\n    _secondaryCompleter = Completer&lt;void&gt;();\n    if (_completed != null) {\n      if (_completed) {\n        _secondaryCompleter.complete();\n      } else {\n        _secondaryCompleter.completeError(const TickerCanceled());\n      }\n    }\n  }\n  return _secondaryCompleter.future;\n}<\/code><\/pre>\n        ",
                    "href": "scheduler\/TickerFuture\/orCancel.html",
                    "name": "orCancel",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "scheduler.TickerFuture",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An interface implemented by classes that can vend <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a> objects.<\/p>\n<p>Tickers can be used by any object that wants to be notified whenever a frame\ntriggers, but are most commonly used indirectly via an\n<a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>. <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>s need a <a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a> to\nobtain their <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a>. If you are creating an <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a> from a\n<a href=\"widgets\/State-class.html\">State<\/a>, then you can use the <a href=\"widgets\/TickerProviderStateMixin-mixin.html\">TickerProviderStateMixin<\/a> and\n<a href=\"widgets\/SingleTickerProviderStateMixin-mixin.html\">SingleTickerProviderStateMixin<\/a> classes to obtain a suitable\n<a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a>. The widget test framework <a href=\"flutter_test\/WidgetTester-class.html\">WidgetTester<\/a> object can be\nused as a ticker provider in the context of tests. In other contexts, you\nwill have to either pass a <a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a> from a higher level (e.g.\nindirectly from a <a href=\"widgets\/State-class.html\">State<\/a> that mixes in <a href=\"widgets\/TickerProviderStateMixin-mixin.html\">TickerProviderStateMixin<\/a>), or\ncreate a custom <a href=\"scheduler\/TickerProvider-class.html\">TickerProvider<\/a> subclass.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "scheduler\/TickerProvider-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.TickerProvider",
            "shortname": "TickerProvider",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const TickerProvider();<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerProvider\/TickerProvider.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TickerProvider",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "scheduler.TickerProvider",
                    "params": []
                },
                {
                    "desc": "<p>Creates a ticker with the given callback.<\/p>\n<p>The kind of ticker provided depends on the kind of ticker provider.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Ticker createTicker(TickerCallback onTick);<\/code><\/pre>\n    ",
                    "href": "scheduler\/TickerProvider\/createTicker.html",
                    "isDeprecated": false,
                    "type": "scheduler.Ticker",
                    "name": "createTicker",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "scheduler.TickerProvider",
                    "params": [
                        {
                            "name": "onTick",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "scheduler.TickerCallback"
                        }
                    ]
                }
            ],
            "props": []
        }
    ],
    "mixin": [
        {
            "desc": "<p>Scheduler for running the following:<\/p>\n<ul>\n<li>\n<p><em>Transient callbacks<\/em>, triggered by the system's <a href=\"dart-ui\/Window\/onBeginFrame.html\">Window.onBeginFrame<\/a>\ncallback, for synchronizing the application's behavior to the system's\ndisplay. For example, <a href=\"scheduler\/Ticker-class.html\">Ticker<\/a>s and <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>s trigger from\nthese.<\/p>\n<\/li>\n<li>\n<p><em>Persistent callbacks<\/em>, triggered by the system's <a href=\"dart-ui\/Window\/onDrawFrame.html\">Window.onDrawFrame<\/a>\ncallback, for updating the system's display after transient callbacks have\nexecuted. For example, the rendering layer uses this to drive its\nrendering pipeline.<\/p>\n<\/li>\n<li>\n<p><em>Post-frame callbacks<\/em>, which are run after persistent callbacks, just\nbefore returning from the <a href=\"dart-ui\/Window\/onDrawFrame.html\">Window.onDrawFrame<\/a> callback.<\/p>\n<\/li>\n<li>\n<p>Non-rendering tasks, to be run between frames. These are given a\npriority and are executed in priority order according to a\n<a href=\"scheduler\/SchedulerBinding\/schedulingStrategy.html\">schedulingStrategy<\/a>.<\/p>\n<\/li>\n<\/ul>",
            "dtype": "mixin",
            "example": "",
            "href": "scheduler\/SchedulerBinding-mixin.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.SchedulerBinding",
            "shortname": "SchedulerBinding",
            "extends": [],
            "is_enum": false,
            "is_mixin": true,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": []
        }
    ],
    "enum": [
        {
            "desc": "<p>The various phases that a <a href=\"scheduler\/SchedulerBinding-mixin.html\">SchedulerBinding<\/a> goes through during\n<a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">SchedulerBinding.handleBeginFrame<\/a>.<\/p>\n<p>This is exposed by <a href=\"scheduler\/SchedulerBinding\/schedulerPhase.html\">SchedulerBinding.schedulerPhase<\/a>.<\/p>\n<p>The values of this enum are ordered in the same order as the phases occur,\nso their relative index values can be compared to each other.<\/p>\n<p>See also the discussion at <a href=\"widgets\/WidgetsBinding\/drawFrame.html\">WidgetsBinding.drawFrame<\/a>.<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "scheduler\/SchedulerPhase-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "scheduler",
            "name": "scheduler.SchedulerPhase",
            "shortname": "SchedulerPhase",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>No frame is being processed. Tasks (scheduled by\n<code>WidgetsBinding.scheduleTask<\/code>), microtasks (scheduled by\n<a href=\"dart-async\/scheduleMicrotask.html\">scheduleMicrotask<\/a>), <a href=\"dart-async\/Timer-class.html\">Timer<\/a> callbacks, event handlers (e.g. from user\ninput), and other callbacks (e.g. from <a href=\"dart-async\/Future-class.html\">Future<\/a>s, <a href=\"dart-async\/Stream-class.html\">Stream<\/a>s, and the like)\nmay be executing.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const SchedulerPhase(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "idle",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.SchedulerPhase",
                    "params": []
                },
                {
                    "desc": "\n          <p>Microtasks scheduled during the processing of transient callbacks are\ncurrent executing.<\/p>\n<p>This may include, for instance, callbacks from futures resulted during the\n<a href=\"scheduler\/SchedulerPhase-class.html\">transientCallbacks<\/a> phase.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const SchedulerPhase(2)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "midFrameMicrotasks",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.SchedulerPhase",
                    "params": []
                },
                {
                    "desc": "\n          <p>The persistent callbacks (scheduled by\n<code>WidgetsBinding.addPersistentFrameCallback<\/code>) are currently executing.<\/p>\n<p>Typically, this is the build\/layout\/paint pipeline. See\n<a href=\"widgets\/WidgetsBinding\/drawFrame.html\">WidgetsBinding.drawFrame<\/a> and <a href=\"scheduler\/SchedulerBinding\/handleDrawFrame.html\">SchedulerBinding.handleDrawFrame<\/a>.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const SchedulerPhase(3)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "persistentCallbacks",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.SchedulerPhase",
                    "params": []
                },
                {
                    "desc": "\n          <p>The post-frame callbacks (scheduled by\n<code>WidgetsBinding.addPostFrameCallback<\/code>) are currently executing.<\/p>\n<p>Typically, these callbacks handle cleanup and scheduling of work for the\nnext frame.<\/p>\n<p>See <a href=\"scheduler\/SchedulerBinding\/handleDrawFrame.html\">SchedulerBinding.handleDrawFrame<\/a>.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const SchedulerPhase(4)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "postFrameCallbacks",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.SchedulerPhase",
                    "params": []
                },
                {
                    "desc": "\n          <p>The transient callbacks (scheduled by\n<code>WidgetsBinding.scheduleFrameCallback<\/code>) are currently executing.<\/p>\n<p>Typically, these callbacks handle updating objects to new animation\nstates.<\/p>\n<p>See <a href=\"scheduler\/SchedulerBinding\/handleBeginFrame.html\">SchedulerBinding.handleBeginFrame<\/a>.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const SchedulerPhase(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "transientCallbacks",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.SchedulerPhase",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">SchedulerPhase<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "scheduler.SchedulerPhase",
                    "params": []
                }
            ]
        }
    ],
    "typedef": []
}