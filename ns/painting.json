{
    "class": [
        {
            "desc": "<p>A point within a rectangle.<\/p>\n<p><code>Alignment(0.0, 0.0)<\/code> represents the center of the rectangle. The distance\nfrom -1.0 to +1.0 is the distance from one side of the rectangle to the\nother side of the rectangle. Therefore, 2.0 units horizontally (or\nvertically) is equivalent to the width (or height) of the rectangle.<\/p>\n<p><code>Alignment(-1.0, -1.0)<\/code> represents the top left of the rectangle.<\/p>\n<p><code>Alignment(1.0, 1.0)<\/code> represents the bottom right of the rectangle.<\/p>\n<p><code>Alignment(0.0, 3.0)<\/code> represents a point that is horizontally centered with\nrespect to the rectangle and vertically below the bottom of the rectangle by\nthe height of the rectangle.<\/p>\n<p><code>Alignment(0.0, -0.5)<\/code> represents a point that is horizontally centered with\nrespect to the rectangle and vertically half way between the top edge and\nthe center.<\/p>\n<p><code>Alignment(x, y)<\/code> in a rectangle with height h and width w describes\nthe point (x * w\/2 + w\/2, y * h\/2 + h\/2) in the coordinate system of the\nrectangle.<\/p>\n<p><a href=\"painting\/Alignment-class.html\">Alignment<\/a> uses visual coordinates, which means increasing <a href=\"painting\/Alignment\/x.html\">x<\/a> moves the\npoint from left to right. To support layouts with a right-to-left\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, consider using <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, in which the\ndirection the point moves when increasing the horizontal value depends on\nthe <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n<p>A variety of widgets use <a href=\"painting\/Alignment-class.html\">Alignment<\/a> in their configuration, most\nnotably:<\/p>\n<ul><li>\n<a href=\"widgets\/Align-class.html\">Align<\/a> positions a child according to an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>.<\/li><\/ul>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, which has a horizontal coordinate orientation\nthat depends on the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/li>\n<li>\n<a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a>, which is an abstract type that is agnostic as to\nwhether the horizontal direction depends on the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/Alignment-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.Alignment",
            "shortname": "Alignment",
            "extends": [
                "painting.AlignmentGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.FractionalOffset",
                "rendering.AlignmentTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an alignment.<\/p>\n<p>The <code>x<\/code> and <code>y<\/code> arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const Alignment(this.x, this.y)\n  : assert(x != null),\n    assert(y != null);<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/Alignment.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Alignment",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "x",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "y",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/Alignment-class.html\">Alignment<\/a> or two <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/Alignment\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/Alignment-class.html\">Alignment<\/a> or\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/Alignment-class.html\">Alignment<\/a> using <a href=\"painting\/Alignment\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nAlignmentGeometry add(AlignmentGeometry other) {\n  if (other is Alignment)\n    return this + other;\n  return super.add(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/add.html",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the offset that is this fraction in the direction of the given offset.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Offset alongOffset(Offset other) {\n  final double centerX = other.dx \/ 2.0;\n  final double centerY = other.dy \/ 2.0;\n  return Offset(centerX + x * centerX, centerY + y * centerY);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/alongOffset.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "name": "alongOffset",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the offset that is this fraction within the given size.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Offset alongSize(Size other) {\n  final double centerX = other.width \/ 2.0;\n  final double centerY = other.height \/ 2.0;\n  return Offset(centerX + x * centerX, centerY + y * centerY);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/alongSize.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "name": "alongSize",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a rect of the given size, aligned within given rect as specified\nby this alignment.<\/p>\n<p>For example, a 100\u00d7100 size inscribed on a 200\u00d7200 rect using\n<a href=\"painting\/Alignment\/topLeft-constant.html\">Alignment.topLeft<\/a> would be the 100\u00d7100 rect at the top left of\nthe 200\u00d7200 rect.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Rect inscribe(Size size, Rect rect) {\n  final double halfWidthDelta = (rect.width - size.width) \/ 2.0;\n  final double halfHeightDelta = (rect.height - size.height) \/ 2.0;\n  return Rect.fromLTWH(\n    rect.left + halfWidthDelta + x * halfWidthDelta,\n    rect.top + halfHeightDelta + y * halfHeightDelta,\n    size.width,\n    size.height,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/inscribe.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Rect",
                    "name": "inscribe",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/Alignment-class.html\">Alignment<\/a>s.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/Alignment\/center-constant.html\">Alignment.center<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Alignment lerp(Alignment a, Alignment b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return Alignment(ui.lerpDouble(0.0, b.x, t), ui.lerpDouble(0.0, b.y, t));\n  if (b == null)\n    return Alignment(ui.lerpDouble(a.x, 0.0, t), ui.lerpDouble(a.y, 0.0, t));\n  return Alignment(ui.lerpDouble(a.x, b.x, t), ui.lerpDouble(a.y, b.y, t));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Alignment"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Alignment"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, which uses literal\ncoordinates (the <code>x<\/code> coordinate being explicitly a distance from the\nleft).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nAlignment resolve(TextDirection direction) =&gt; this;<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; _stringify(x, y);<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>Returns the point that is this fraction within the given rect.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Offset withinRect(Rect rect) {\n  final double halfWidth = rect.width \/ 2.0;\n  final double halfHeight = rect.height \/ 2.0;\n  return Offset(\n    rect.left + halfWidth + x * halfWidth,\n    rect.top + halfHeight + y * halfHeight,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/withinRect.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "name": "withinRect",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Alignment",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The center point along the bottom edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment bottomCenter = Alignment(0.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/bottomCenter-constant.html",
                    "name": "bottomCenter",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The bottom left corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment bottomLeft = Alignment(-1.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/bottomLeft-constant.html",
                    "name": "bottomLeft",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The bottom right corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment bottomRight = Alignment(1.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/bottomRight-constant.html",
                    "name": "bottomRight",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The center point, both horizontally and vertically.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment center = Alignment(0.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/center-constant.html",
                    "name": "center",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the left edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment centerLeft = Alignment(-1.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/centerLeft-constant.html",
                    "name": "centerLeft",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the right edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment centerRight = Alignment(1.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/centerRight-constant.html",
                    "name": "centerRight",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the top edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment topCenter = Alignment(0.0, -1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/topCenter-constant.html",
                    "name": "topCenter",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The top left corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment topLeft = Alignment(-1.0, -1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/topLeft-constant.html",
                    "name": "topLeft",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The top right corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const Alignment topRight = Alignment(1.0, -1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/Alignment\/topRight-constant.html",
                    "name": "topRight",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The distance fraction in the horizontal direction.<\/p>\n<p>A value of -1.0 corresponds to the leftmost edge. A value of 1.0\ncorresponds to the rightmost edge. Values are not limited to that range;\nvalues less than -1.0 represent positions to the left of the left edge,\nand values greater than 1.0 represent positions to the right of the right\nedge.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double x\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Alignment\/x.html",
                    "name": "x",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Alignment",
                    "params": []
                },
                {
                    "desc": "<p>The distance fraction in the vertical direction.<\/p>\n<p>A value of -1.0 corresponds to the topmost edge. A value of 1.0\ncorresponds to the bottommost edge. Values are not limited to that range;\nvalues less than -1.0 represent positions above the top, and values\ngreater than 1.0 represent positions below the bottom.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double y\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Alignment\/y.html",
                    "name": "y",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Alignment",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An offset that's expressed as a fraction of a <a href=\"dart-ui\/Size-class.html\">Size<\/a>, but whose horizontal\ncomponent is dependent on the writing direction.<\/p>\n<p>This can be used to indicate an offset from the left in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a>\ntext and an offset from the right in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a> text without having\nto be aware of the current text direction.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a>, a variant that is defined in physical terms (i.e.\nwhose horizontal component does not depend on the text direction).<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/AlignmentDirectional-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AlignmentDirectional",
            "shortname": "AlignmentDirectional",
            "extends": [
                "painting.AlignmentGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a directional alignment.<\/p>\n<p>The <code>start<\/code> and <code>y<\/code> arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const AlignmentDirectional(this.start, this.y)\n  : assert(start != null),\n    assert(y != null);<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/AlignmentDirectional.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AlignmentDirectional",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": [
                        {
                            "name": "start",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "y",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/Alignment-class.html\">Alignment<\/a> or two <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/AlignmentDirectional\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/Alignment-class.html\">Alignment<\/a> or\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/Alignment-class.html\">Alignment<\/a> using <a href=\"painting\/AlignmentDirectional\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nAlignmentGeometry add(AlignmentGeometry other) {\n  if (other is AlignmentDirectional)\n    return this + other;\n  return super.add(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/add.html",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>s.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/AlignmentDirectional\/center-constant.html\">AlignmentDirectional.center<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static AlignmentDirectional lerp(AlignmentDirectional a, AlignmentDirectional b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return AlignmentDirectional(ui.lerpDouble(0.0, b.start, t), ui.lerpDouble(0.0, b.y, t));\n  if (b == null)\n    return AlignmentDirectional(ui.lerpDouble(a.start, 0.0, t), ui.lerpDouble(a.y, 0.0, t));\n  return AlignmentDirectional(ui.lerpDouble(a.start, b.start, t), ui.lerpDouble(a.y, b.y, t));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentDirectional"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentDirectional"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, which uses literal\ncoordinates (the <code>x<\/code> coordinate being explicitly a distance from the\nleft).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nAlignment resolve(TextDirection direction) {\n  assert(direction != null);\n  switch (direction) {\n    case TextDirection.rtl:\n      return Alignment(-start, y);\n    case TextDirection.ltr:\n      return Alignment(start, y);\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; _stringify(start, y);<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The center point along the bottom edge.<\/p>\n<p>Consider using <a href=\"painting\/AlignmentDirectional\/bottomCenter-constant.html\">Alignment.bottomCenter<\/a> instead, as it does not\nneed to be <a href=\"painting\/AlignmentDirectional\/resolve.html\">resolve<\/a>d to be used.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional bottomCenter = AlignmentDirectional(0.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/bottomCenter-constant.html",
                    "name": "bottomCenter",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The bottom corner on the \"end\" side.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional bottomEnd = AlignmentDirectional(1.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/bottomEnd-constant.html",
                    "name": "bottomEnd",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The bottom corner on the \"start\" side.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional bottomStart = AlignmentDirectional(-1.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/bottomStart-constant.html",
                    "name": "bottomStart",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The center point, both horizontally and vertically.<\/p>\n<p>Consider using <a href=\"painting\/AlignmentDirectional\/center-constant.html\">Alignment.center<\/a> instead, as it does not need to\nbe <a href=\"painting\/AlignmentDirectional\/resolve.html\">resolve<\/a>d to be used.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional center = AlignmentDirectional(0.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/center-constant.html",
                    "name": "center",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the \"end\" edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional centerEnd = AlignmentDirectional(1.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/centerEnd-constant.html",
                    "name": "centerEnd",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the \"start\" edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional centerStart = AlignmentDirectional(-1.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/centerStart-constant.html",
                    "name": "centerStart",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The distance fraction in the horizontal direction.<\/p>\n<p>A value of -1.0 corresponds to the edge on the \"start\" side, which is the\nleft side in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a> contexts and the right side in\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a> contexts. A value of 1.0 corresponds to the opposite\nedge, the \"end\" side. Values are not limited to that range; values less\nthan -1.0 represent positions beyond the start edge, and values greater than\n1.0 represent positions beyond the end edge.<\/p>\n<p>This value is normalized into an <a href=\"painting\/Alignment\/x.html\">Alignment.x<\/a> value by the <a href=\"painting\/AlignmentDirectional\/resolve.html\">resolve<\/a>\nmethod.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double start\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AlignmentDirectional\/start.html",
                    "name": "start",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the top edge.<\/p>\n<p>Consider using <a href=\"painting\/AlignmentDirectional\/topCenter-constant.html\">Alignment.topCenter<\/a> instead, as it does not need\nto be <a href=\"painting\/AlignmentDirectional\/resolve.html\">resolve<\/a>d to be used.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional topCenter = AlignmentDirectional(0.0, -1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/topCenter-constant.html",
                    "name": "topCenter",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The top corner on the \"end\" side.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional topEnd = AlignmentDirectional(1.0, -1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/topEnd-constant.html",
                    "name": "topEnd",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The top corner on the \"start\" side.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const AlignmentDirectional topStart = AlignmentDirectional(-1.0, -1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentDirectional\/topStart-constant.html",
                    "name": "topStart",
                    "isDeprecated": false,
                    "type": "painting.AlignmentDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The distance fraction in the vertical direction.<\/p>\n<p>A value of -1.0 corresponds to the topmost edge. A value of 1.0\ncorresponds to the bottommost edge. Values are not limited to that range;\nvalues less than -1.0 represent positions above the top, and values\ngreater than 1.0 represent positions below the bottom.<\/p>\n<p>This value is passed through to <a href=\"painting\/AlignmentDirectional\/y.html\">Alignment.y<\/a> unmodified by the\n<a href=\"painting\/AlignmentDirectional\/resolve.html\">resolve<\/a> method.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double y\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AlignmentDirectional\/y.html",
                    "name": "y",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AlignmentDirectional",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Base class for <a href=\"painting\/Alignment-class.html\">Alignment<\/a> that allows for text-direction aware\nresolution.<\/p>\n<p>A property or argument of this type accepts classes created either with <a href=\"painting\/Alignment\/Alignment.html\">new\nAlignment<\/a> and its variants, or <a href=\"painting\/AlignmentDirectional\/AlignmentDirectional.html\">new AlignmentDirectional<\/a>.<\/p>\n<p>To convert an <a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a> object of indeterminate type into an\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a> object, call the <a href=\"painting\/AlignmentGeometry\/resolve.html\">resolve<\/a> method.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/AlignmentGeometry-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AlignmentGeometry",
            "shortname": "AlignmentGeometry",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.Alignment",
                "painting.AlignmentDirectional",
                "painting.FractionalOffset",
                "rendering.AlignmentGeometryTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const AlignmentGeometry();<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentGeometry\/AlignmentGeometry.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AlignmentGeometry",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.AlignmentGeometry",
                    "params": []
                },
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/Alignment-class.html\">Alignment<\/a> or two <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/AlignmentGeometry\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/Alignment-class.html\">Alignment<\/a> or\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/Alignment-class.html\">Alignment<\/a> using <a href=\"painting\/AlignmentGeometry\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">AlignmentGeometry add(AlignmentGeometry other) {\n  return _MixedAlignment(\n    _x + other._x,\n    _start + other._start,\n    _y + other._y,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentGeometry\/add.html",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentGeometry",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a> objects.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/Alignment\/center-constant.html\">Alignment.center<\/a>, and\nthe result is an object of the same type as the non-null argument.<\/p>\n<p>If <a href=\"painting\/AlignmentGeometry\/lerp.html\">lerp<\/a> is applied to two objects of the same type (<a href=\"painting\/Alignment-class.html\">Alignment<\/a> or\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/Alignment-class.html\">Alignment<\/a> using <a href=\"painting\/AlignmentGeometry\/resolve.html\">resolve<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static AlignmentGeometry lerp(AlignmentGeometry a, AlignmentGeometry b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b * t;\n  if (b == null)\n    return a * (1.0 - t);\n  if (a is Alignment &amp;&amp; b is Alignment)\n    return Alignment.lerp(a, b, t);\n  if (a is AlignmentDirectional &amp;&amp; b is AlignmentDirectional)\n    return AlignmentDirectional.lerp(a, b, t);\n  return _MixedAlignment(\n    ui.lerpDouble(a._x, b._x, t),\n    ui.lerpDouble(a._start, b._start, t),\n    ui.lerpDouble(a._y, b._y, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentGeometry\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentGeometry",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, which uses literal\ncoordinates (the <code>x<\/code> coordinate being explicitly a distance from the\nleft).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Alignment resolve(TextDirection direction);<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentGeometry\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.Alignment",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentGeometry",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  if (_start == 0.0)\n    return Alignment._stringify(_x, _y);\n  if (_x == 0.0)\n    return AlignmentDirectional._stringify(_start, _y);\n  return Alignment._stringify(_x, _y) + ' + ' + AlignmentDirectional._stringify(_start, 0.0);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AlignmentGeometry\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AlignmentGeometry",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/AlignmentGeometry\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/AlignmentGeometry\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/AlignmentGeometry\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/AlignmentGeometry\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/AlignmentGeometry\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/AlignmentGeometry\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(_x, _start, _y);<\/code><\/pre>\n        ",
                    "href": "painting\/AlignmentGeometry\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AlignmentGeometry",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Key for the image obtained by an <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a> or <a href=\"painting\/ExactAssetImage-class.html\">ExactAssetImage<\/a>.<\/p>\n<p>This is used to identify the precise resource in the <a href=\"painting\/imageCache.html\">imageCache<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/AssetBundleImageKey-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AssetBundleImageKey",
            "shortname": "AssetBundleImageKey",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.AssetImage",
                "painting.ExactAssetImage"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates the key for an <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a> or <a href=\"painting\/AssetBundleImageProvider-class.html\">AssetBundleImageProvider<\/a>.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const AssetBundleImageKey({\n  @required this.bundle,\n  @required this.name,\n  @required this.scale,\n}) : assert(bundle != null),\n     assert(name != null),\n     assert(scale != null);<\/code><\/pre>\n    ",
                    "href": "painting\/AssetBundleImageKey\/AssetBundleImageKey.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AssetBundleImageKey",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.AssetBundleImageKey",
                    "params": [
                        {
                            "name": "bundle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "services.AssetBundle"
                        },
                        {
                            "name": "name",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(bundle: $bundle, name: \"$name\", scale: $scale)';<\/code><\/pre>\n    ",
                    "href": "painting\/AssetBundleImageKey\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AssetBundleImageKey",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The bundle from which the image will be obtained.<\/p>\n<p>The image is obtained by calling <a href=\"services\/AssetBundle\/load.html\">AssetBundle.load<\/a> on the given <a href=\"painting\/AssetBundleImageKey\/bundle.html\">bundle<\/a>\nusing the key given by <a href=\"painting\/AssetBundleImageKey\/name.html\">name<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AssetBundle bundle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AssetBundleImageKey\/bundle.html",
                    "name": "bundle",
                    "isDeprecated": false,
                    "type": "services.AssetBundle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetBundleImageKey",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/AssetBundleImageKey\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/AssetBundleImageKey\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/AssetBundleImageKey\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/AssetBundleImageKey\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/AssetBundleImageKey\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/AssetBundleImageKey\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(bundle, name, scale);<\/code><\/pre>\n        ",
                    "href": "painting\/AssetBundleImageKey\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetBundleImageKey",
                    "params": []
                },
                {
                    "desc": "<p>The key to use to obtain the resource from the <a href=\"painting\/AssetBundleImageKey\/bundle.html\">bundle<\/a>. This is the\nargument passed to <a href=\"services\/AssetBundle\/load.html\">AssetBundle.load<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String name\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AssetBundleImageKey\/name.html",
                    "name": "name",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetBundleImageKey",
                    "params": []
                },
                {
                    "desc": "<p>The scale to place in the <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object of the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double scale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AssetBundleImageKey\/scale.html",
                    "name": "scale",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetBundleImageKey",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A subclass of <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> that knows about <a href=\"services\/AssetBundle-class.html\">AssetBundle<\/a>s.<\/p>\n<p>This factors out the common logic of <a href=\"services\/AssetBundle-class.html\">AssetBundle<\/a>-based <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>\nclasses, simplifying what subclasses must implement to just <a href=\"painting\/ImageProvider\/obtainKey.html\">obtainKey<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/AssetBundleImageProvider-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AssetBundleImageProvider",
            "shortname": "AssetBundleImageProvider",
            "extends": [
                "painting.AssetBundleImageKey",
                "painting.ImageProvider",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.AssetImage",
                "painting.ExactAssetImage"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const AssetBundleImageProvider();<\/code><\/pre>\n    ",
                    "href": "painting\/AssetBundleImageProvider\/AssetBundleImageProvider.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AssetBundleImageProvider",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.AssetBundleImageProvider",
                    "params": []
                },
                {
                    "desc": "<p>Converts a key into an <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a>, and begins fetching the\nimage using <code>loadAsync<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nImageStreamCompleter load(AssetBundleImageKey key) {\n  return MultiFrameImageStreamCompleter(\n    codec: _loadAsync(key),\n    scale: key.scale,\n    informationCollector: (StringBuffer information) {\n      information.writeln('Image provider: $this');\n      information.write('Image key: $key');\n    },\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AssetBundleImageProvider\/load.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "name": "load",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AssetBundleImageProvider",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.AssetBundleImageKey"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Fetches an image from an <a href=\"services\/AssetBundle-class.html\">AssetBundle<\/a>, having determined the exact image to\nuse based on the context.<\/p>\n<p>Given a main asset and a set of variants, AssetImage chooses the most\nappropriate asset for the current context, based on the device pixel ratio\nand size given in the configuration passed to <a href=\"painting\/ImageProvider\/resolve.html\">resolve<\/a>.<\/p>\n<p>To show a specific image from a bundle without any asset resolution, use an\n<a href=\"painting\/AssetBundleImageProvider-class.html\">AssetBundleImageProvider<\/a>.<\/p>\n<h2 id=\"naming-assets-for-matching-with-different-pixel-densities\">Naming assets for matching with different pixel densities<\/h2>\n<p>Main assets are presumed to match a nominal pixel ratio of 1.0. To specify\nassets targeting different pixel ratios, place the variant assets in\nthe application bundle under subdirectories named in the form \"Nx\", where\nN is the nominal device pixel ratio for that asset.<\/p>\n<p>For example, suppose an application wants to use an icon named\n\"heart.png\". This icon has representations at 1.0 (the main icon), as well\nas 1.5 and 2.0 pixel ratios (variants). The asset bundle should then contain\nthe following assets:<\/p>\n<pre class=\"language-dart\"><code>heart.png\n1.5x\/heart.png\n2.0x\/heart.png\n<\/code><\/pre>\n<p>On a device with a 1.0 device pixel ratio, the image chosen would be\nheart.png; on a device with a 1.3 device pixel ratio, the image chosen\nwould be 1.5x\/heart.png.<\/p>\n<p>The directory level of the asset does not matter as long as the variants are\nat the equivalent level; that is, the following is also a valid bundle\nstructure:<\/p>\n<pre class=\"language-dart\"><code>icons\/heart.png\nicons\/1.5x\/heart.png\nicons\/2.0x\/heart.png\n<\/code><\/pre>\n<p>assets\/icons\/3.0x\/heart.png would be a valid variant of\nassets\/icons\/heart.png.<\/p>\n<h2 id=\"fetching-assets\">Fetching assets<\/h2>\n<p>When fetching an image provided by the app itself, use the <a href=\"painting\/AssetImage\/assetName.html\">assetName<\/a>\nargument to name the asset to choose. For instance, consider the structure\nabove. First, the <code>pubspec.yaml<\/code> of the project should specify its assets in\nthe <code>flutter<\/code> section:<\/p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">flutter:\n  assets:\n    - icons\/heart.png\n<\/code><\/pre>\n<p>Then, to fetch the image, use<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">AssetImage('icons\/heart.png')\n<\/code><\/pre>\n<h2 id=\"assets-in-packages\">Assets in packages<\/h2>\n<p>To fetch an asset from a package, the <a href=\"painting\/AssetImage\/package.html\">package<\/a> argument must be provided.\nFor instance, suppose the structure above is inside a package called\n<code>my_icons<\/code>. Then to fetch the image, use:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">AssetImage('icons\/heart.png', package: 'my_icons')\n<\/code><\/pre>\n<p>Assets used by the package itself should also be fetched using the <a href=\"painting\/AssetImage\/package.html\">package<\/a>\nargument as above.<\/p>\n<p>If the desired asset is specified in the <code>pubspec.yaml<\/code> of the package, it\nis bundled automatically with the app. In particular, assets used by the\npackage itself must be specified in its <code>pubspec.yaml<\/code>.<\/p>\n<p>A package can also choose to have assets in its 'lib\/' folder that are not\nspecified in its <code>pubspec.yaml<\/code>. In this case for those images to be\nbundled, the app has to specify which ones to include. For instance a\npackage named <code>fancy_backgrounds<\/code> could have:<\/p>\n<pre class=\"language-dart\"><code>lib\/backgrounds\/background1.png\nlib\/backgrounds\/background2.png\nlib\/backgrounds\/background3.png\n<\/code><\/pre>\n<p>To include, say the first image, the <code>pubspec.yaml<\/code> of the app should specify\nit in the <code>assets<\/code> section:<\/p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">  assets:\n    - packages\/fancy_backgrounds\/backgrounds\/background1.png\n<\/code><\/pre>\n<p>The <code>lib\/<\/code> is implied, so it should not be included in the asset path.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/Image\/Image.asset.html\">Image.asset<\/a> for a shorthand of an <a href=\"widgets\/Image-class.html\">Image<\/a> widget backed by <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a>\nwhen used without a scale.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/AssetImage-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AssetImage",
            "shortname": "AssetImage",
            "extends": [
                "painting.AssetBundleImageProvider",
                "painting.AssetBundleImageKey",
                "painting.ImageProvider",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object that fetches an image from an asset bundle.<\/p>\n<p>The <code>assetName<\/code> argument must not be null. It should name the main asset\nfrom the set of images to choose from. The <code>package<\/code> argument must be\nnon-null when fetching an asset that is included in package. See the\ndocumentation for the <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a> class itself for details.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const AssetImage(\n  this.assetName, {\n  this.bundle,\n  this.package,\n}) : assert(assetName != null);<\/code><\/pre>\n    ",
                    "href": "painting\/AssetImage\/AssetImage.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AssetImage",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.AssetImage",
                    "params": [
                        {
                            "name": "assetName",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "bundle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "services.AssetBundle"
                        },
                        {
                            "name": "package",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.<\/p>\n<p>The type of the key is determined by the subclass. It is a value that\nunambiguously identifies the image (<em>including its scale<\/em>) that the <a href=\"painting\/AssetBundleImageProvider\/load.html\">load<\/a>\nmethod will fetch. Different <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>s given the same constructor\narguments and <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects should return keys that are\n'==' to each other (possibly by using a class for the key that itself\nimplements <code>==<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;AssetBundleImageKey&gt; obtainKey(ImageConfiguration configuration) {\n  \/\/ This function tries to return a SynchronousFuture if possible. We do this\n  \/\/ because otherwise showing an image would always take at least one frame,\n  \/\/ which would be sad. (This code is called from inside build\/layout\/paint,\n  \/\/ which all happens in one call frame; using native Futures would guarantee\n  \/\/ that we resolve each future in a new call frame, and thus not in this\n  \/\/ build\/layout\/paint sequence.)\n  final AssetBundle chosenBundle = bundle ?? configuration.bundle ?? rootBundle;\n  Completer&lt;AssetBundleImageKey&gt; completer;\n  Future&lt;AssetBundleImageKey&gt; result;\n\n  chosenBundle.loadStructuredData&lt;Map&lt;String, List&lt;String&gt;&gt;&gt;(_kAssetManifestFileName, _manifestParser).then&lt;void&gt;(\n    (Map&lt;String, List&lt;String&gt;&gt; manifest) {\n      final String chosenName = _chooseVariant(\n        keyName,\n        configuration,\n        manifest == null ? null : manifest[keyName],\n      );\n      final double chosenScale = _parseScale(chosenName);\n      final AssetBundleImageKey key = AssetBundleImageKey(\n        bundle: chosenBundle,\n        name: chosenName,\n        scale: chosenScale,\n      );\n      if (completer != null) {\n        \/\/ We already returned from this function, which means we are in the\n        \/\/ asynchronous mode. Pass the value to the completer. The completer's\n        \/\/ future is what we returned.\n        completer.complete(key);\n      } else {\n        \/\/ We haven't yet returned, so we must have been called synchronously\n        \/\/ just after loadStructuredData returned (which means it provided us\n        \/\/ with a SynchronousFuture). Let's return a SynchronousFuture\n        \/\/ ourselves.\n        result = SynchronousFuture&lt;AssetBundleImageKey&gt;(key);\n      }\n    }\n  ).catchError((dynamic error, StackTrace stack) {\n    \/\/ We had an error. (This guarantees we weren't called synchronously.)\n    \/\/ Forward the error to the caller.\n    assert(completer != null);\n    assert(result == null);\n    completer.completeError(error, stack);\n  });\n  if (result != null) {\n    \/\/ The code above ran synchronously, and came up with an answer.\n    \/\/ Return the SynchronousFuture that we created above.\n    return result;\n  }\n  \/\/ The code above hasn't yet run its \"then\" handler yet. Let's prepare a\n  \/\/ completer for it to use when it does run.\n  completer = Completer&lt;AssetBundleImageKey&gt;();\n  return completer.future;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AssetImage\/obtainKey.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<painting.AssetBundleImageKey>",
                    "name": "obtainKey",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AssetImage",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(bundle: $bundle, name: \"$keyName\")';<\/code><\/pre>\n    ",
                    "href": "painting\/AssetImage\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AssetImage",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The name of the main asset from the set of images to choose from. See the\ndocumentation for the <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a> class itself for details.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String assetName\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AssetImage\/assetName.html",
                    "name": "assetName",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The bundle from which the image will be obtained.<\/p>\n<p>If the provided <a href=\"painting\/AssetImage\/bundle.html\">bundle<\/a> is null, the bundle provided in the\n<a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> passed to the <a href=\"painting\/ImageProvider\/resolve.html\">resolve<\/a> call will be used instead. If\nthat is also null, the <a href=\"services\/rootBundle.html\">rootBundle<\/a> is used.<\/p>\n<p>The image is obtained by calling <a href=\"painting\/AssetBundleImageProvider\/load.html\">AssetBundle.load<\/a> on the given <a href=\"painting\/AssetImage\/bundle.html\">bundle<\/a>\nusing the key given by <a href=\"painting\/AssetImage\/keyName.html\">keyName<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AssetBundle bundle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AssetImage\/bundle.html",
                    "name": "bundle",
                    "isDeprecated": false,
                    "type": "services.AssetBundle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/AssetImage\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/AssetImage\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/AssetImage\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/AssetImage\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/AssetImage\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/AssetImage\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(keyName, bundle);<\/code><\/pre>\n        ",
                    "href": "painting\/AssetImage\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The name used to generate the key to obtain the asset. For local assets\nthis is <a href=\"painting\/AssetImage\/assetName.html\">assetName<\/a>, and for assets from packages the <a href=\"painting\/AssetImage\/assetName.html\">assetName<\/a> is\nprefixed 'packages\/&lt;package_name&gt;\/'.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get keyName =&gt; package == null ? assetName : 'packages\/$package\/$assetName';<\/code><\/pre>\n        ",
                    "href": "painting\/AssetImage\/keyName.html",
                    "name": "keyName",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The name of the package from which the image is included. See the\ndocumentation for the <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a> class itself for details.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String package\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AssetImage\/package.html",
                    "name": "package",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AssetImage",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a> created from <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>s.<\/p>\n<p>Two shapes can be provided. The <a href=\"painting\/AutomaticNotchedShape\/host.html\">host<\/a> is the shape of the widget that\nuses the <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a> (typically a <a href=\"material\/BottomAppBar-class.html\">BottomAppBar<\/a>). The <a href=\"painting\/AutomaticNotchedShape\/guest.html\">guest<\/a> is\nsubtracted from the <a href=\"painting\/AutomaticNotchedShape\/host.html\">host<\/a> to create the notch (typically to make room\nfor a <a href=\"material\/FloatingActionButton-class.html\">FloatingActionButton<\/a>).<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/AutomaticNotchedShape-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AutomaticNotchedShape",
            "shortname": "AutomaticNotchedShape",
            "extends": [
                "painting.NotchedShape",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a> that is defined by two <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>s.<\/p>\n<p>The <code>host<\/code> must not be null.<\/p>\n<p>The <code>guest<\/code> may be null, in which case no notch is created even\nif a guest rectangle is provided to <a href=\"painting\/AutomaticNotchedShape\/getOuterPath.html\">getOuterPath<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const AutomaticNotchedShape(this.host, [ this.guest ]);<\/code><\/pre>\n    ",
                    "href": "painting\/AutomaticNotchedShape\/AutomaticNotchedShape.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "AutomaticNotchedShape",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.AutomaticNotchedShape",
                    "params": [
                        {
                            "name": "guest",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "host",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.ShapeBorder"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outline of the shape.<\/p>\n<p>The <code>host<\/code> is the bounding rectangle of the shape.<\/p>\n<p>The <code>guest<\/code> is the bounding rectangle of the shape for which a notch will\nbe made. It is null when there is no guest.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect hostRect, Rect guestRect) { \/\/ ignore: avoid_renaming_method_parameters, the\n  \/\/ parameters are renamed over the baseclass because they would clash\n  \/\/ with properties of this object, and the use of all four of them in\n  \/\/ the code below is really confusing if they have the same names.\n  final Path hostPath = host.getOuterPath(hostRect);\n  if (guest != null &amp;&amp; guestRect != null) {\n    final Path guestPath = guest.getOuterPath(guestRect);\n    return Path.combine(PathOperation.difference, hostPath, guestPath);\n  }\n  return hostPath;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/AutomaticNotchedShape\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.AutomaticNotchedShape",
                    "params": [
                        {
                            "name": "guestRect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "hostRect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The shape to subtract from the <a href=\"painting\/AutomaticNotchedShape\/host.html\">host<\/a> to make the notch.<\/p>\n<p>This shape cannot depend on the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, as no text direction\nis available to <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a>s.<\/p>\n<p>If this is null, <a href=\"painting\/AutomaticNotchedShape\/getOuterPath.html\">getOuterPath<\/a> ignores the guest rectangle.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ShapeBorder guest\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AutomaticNotchedShape\/guest.html",
                    "name": "guest",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AutomaticNotchedShape",
                    "params": []
                },
                {
                    "desc": "<p>The shape of the widget that uses the <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a> (typically a\n<a href=\"material\/BottomAppBar-class.html\">BottomAppBar<\/a>).<\/p>\n<p>This shape cannot depend on the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, as no text direction\nis available to <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a>s.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ShapeBorder host\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/AutomaticNotchedShape\/host.html",
                    "name": "host",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.AutomaticNotchedShape",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A rectangular border with flattened or \"beveled\" corners.<\/p>\n<p>The line segments that connect the rectangle's four sides will\nbegin and at locations offset by the corresponding border radius,\nbut not farther than the side's center. If all the border radii\nexceed the sides' half widths\/heights the resulting shape is\ndiamond made by connecting the centers of the sides.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/BeveledRectangleBorder-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BeveledRectangleBorder",
            "shortname": "BeveledRectangleBorder",
            "extends": [
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a border like a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a> except that the corners\nare joined by straight lines instead of arcs.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BeveledRectangleBorder({\n  this.side = BorderSide.none,\n  this.borderRadius = BorderRadius.zero,\n}) : assert(side != null),\n     assert(borderRadius != null);<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/BeveledRectangleBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BeveledRectangleBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderRadiusGeometry"
                        },
                        {
                            "name": "side",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/BeveledRectangleBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/BeveledRectangleBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BeveledRectangleBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getInnerPath(Rect rect, { TextDirection textDirection }) {\n  return _getPath(borderRadius.resolve(textDirection).toRRect(rect).deflate(side.width));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/BeveledRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/BeveledRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BeveledRectangleBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect rect, { TextDirection textDirection }) {\n  return _getPath(borderRadius.resolve(textDirection).toRRect(rect));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/BeveledRectangleBorder\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/BeveledRectangleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  assert(t != null);\n  if (a is BeveledRectangleBorder) {\n    return BeveledRectangleBorder(\n      side: BorderSide.lerp(a.side, side, t),\n      borderRadius: BorderRadiusGeometry.lerp(a.borderRadius, borderRadius, t),\n    );\n  }\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/BeveledRectangleBorder\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/BeveledRectangleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  assert(t != null);\n  if (b is BeveledRectangleBorder) {\n    return BeveledRectangleBorder(\n      side: BorderSide.lerp(side, b.side, t),\n      borderRadius: BorderRadiusGeometry.lerp(borderRadius, b.borderRadius, t),\n    );\n  }\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(Canvas canvas, Rect rect, { TextDirection textDirection }) {\n  if (rect.isEmpty)\n    return;\n  switch (side.style) {\n    case BorderStyle.none:\n      break;\n    case BorderStyle.solid:\n    final Path path = getOuterPath(rect, textDirection: textDirection)\n        ..addPath(getInnerPath(rect, textDirection: textDirection), Offset.zero);\n      canvas.drawPath(path, side.toPaint());\n      break;\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/BeveledRectangleBorder\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder scale(double t) {\n  return BeveledRectangleBorder(\n    side: side.scale(t),\n    borderRadius: borderRadius * t,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($side, $borderRadius)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BeveledRectangleBorder\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The radii for each corner.<\/p>\n<p>Each corner <a href=\"dart-ui\/Radius-class.html\">Radius<\/a> defines the endpoints of a line segment that\nspans the corner. The endpoints are located in the same place as\nthey would be for <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>, but they're connected\nby a straight line instead of an arc.<\/p>\n<p>Negative radius values are clamped to 0.0 by <a href=\"painting\/BeveledRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> and\n<a href=\"painting\/BeveledRectangleBorder\/getOuterPath.html\">getOuterPath<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderRadiusGeometry borderRadius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BeveledRectangleBorder\/borderRadius.html",
                    "name": "borderRadius",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/BeveledRectangleBorder\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/BeveledRectangleBorder\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsets.all(side.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/BeveledRectangleBorder\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BeveledRectangleBorder\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BeveledRectangleBorder\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BeveledRectangleBorder\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BeveledRectangleBorder\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BeveledRectangleBorder\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BeveledRectangleBorder\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(side, borderRadius);<\/code><\/pre>\n        ",
                    "href": "painting\/BeveledRectangleBorder\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The style of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide side\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BeveledRectangleBorder\/side.html",
                    "name": "side",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BeveledRectangleBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A border of a box, comprised of four sides: top, right, bottom, left.<\/p>\n<p>The sides are represented by <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nAll four borders the same, two-pixel wide solid white:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Border.all(width: 2.0, color: const Color(0xFFFFFFFF))<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe border for a material design divider:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Border(bottom: BorderSide(color: Theme.of(context).dividerColor))<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nA 1990s-era \"OK\" button:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Container(\n  decoration: const BoxDecoration(\n    border: Border(\n      top: BorderSide(width: 1.0, color: Color(0xFFFFFFFFFF)),\n      left: BorderSide(width: 1.0, color: Color(0xFFFFFFFFFF)),\n      right: BorderSide(width: 1.0, color: Color(0xFFFF000000)),\n      bottom: BorderSide(width: 1.0, color: Color(0xFFFF000000)),\n    ),\n  ),\n  child: Container(\n    padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 2.0),\n    decoration: const BoxDecoration(\n      border: Border(\n        top: BorderSide(width: 1.0, color: Color(0xFFFFDFDFDF)),\n        left: BorderSide(width: 1.0, color: Color(0xFFFFDFDFDF)),\n        right: BorderSide(width: 1.0, color: Color(0xFFFF7F7F7F)),\n        bottom: BorderSide(width: 1.0, color: Color(0xFFFF7F7F7F)),\n      ),\n      color: Color(0xFFBFBFBF),\n    ),\n    child: const Text(\n      'OK',\n      textAlign: TextAlign.center,\n      style: TextStyle(color: Color(0xFF000000))\n    ),\n  ),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which uses this class to describe its edge decoration.<\/li>\n<li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe each side of the box.<\/li>\n<li>\n<a href=\"material\/Theme-class.html\">Theme<\/a>, from the material layer, which can be queried to obtain appropriate colors\nto use for borders in a material app, as shown in the \"divider\" sample above.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/Border-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.Border",
            "shortname": "Border",
            "extends": [
                "painting.BoxBorder",
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "widgets.BorderTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a border.<\/p>\n<p>All the sides of the border default to <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const Border({\n  this.top = BorderSide.none,\n  this.right = BorderSide.none,\n  this.bottom = BorderSide.none,\n  this.left = BorderSide.none,\n}) : assert(top != null),\n     assert(right != null),\n     assert(bottom != null),\n     assert(left != null);<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/Border.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Border",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "bottom",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "left",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "right",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "top",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Attempts to create a new object that represents the amalgamation of <code>this<\/code>\nborder and the <code>other<\/code> border.<\/p>\n<p>If the type of the other border isn't known, or the given instance cannot\nbe reasonably added to this instance, then this should return null.<\/p>\n<p>This method is used by the <a href=\"painting\/ShapeBorder\/operator_plus.html\">operator +<\/a> implementation.<\/p>\n<p>The <code>reversed<\/code> argument is true if this object was the right operand of\nthe <code>+<\/code> operator, and false if it was the left operand.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorder add(ShapeBorder other, { bool reversed = false }) {\n  if (other is! Border)\n    return null;\n  final Border typedOther = other;\n  if (BorderSide.canMerge(top, typedOther.top) &amp;&amp;\n      BorderSide.canMerge(right, typedOther.right) &amp;&amp;\n      BorderSide.canMerge(bottom, typedOther.bottom) &amp;&amp;\n      BorderSide.canMerge(left, typedOther.left)) {\n    return Border.merge(this, typedOther);\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/add.html",
                    "isDeprecated": false,
                    "type": "painting.Border",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "reversed",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two borders.<\/p>\n<p>If a border is null, it is treated as having four <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>\nborders.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Border lerp(Border a, Border b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  return Border(\n    top: BorderSide.lerp(a.top, b.top, t),\n    right: BorderSide.lerp(a.right, b.right, t),\n    bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n    left: BorderSide.lerp(a.left, b.left, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.Border",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Border"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Border"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/Border\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/Border\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/Border\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/Border\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  if (a is Border)\n    return Border.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/Border\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/Border\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/Border\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/Border\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  if (b is Border)\n    return Border.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"painting\/Border-class.html\">Border<\/a> that represents the addition of the two given\n<a href=\"painting\/Border-class.html\">Border<\/a>s.<\/p>\n<p>It is only valid to call this if <a href=\"painting\/BorderSide\/canMerge.html\">BorderSide.canMerge<\/a> returns true for\nthe pairwise combination of each side on both <a href=\"painting\/Border-class.html\">Border<\/a>s.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Border merge(Border a, Border b) {\n  assert(a != null);\n  assert(b != null);\n  assert(BorderSide.canMerge(a.top, b.top));\n  assert(BorderSide.canMerge(a.right, b.right));\n  assert(BorderSide.canMerge(a.bottom, b.bottom));\n  assert(BorderSide.canMerge(a.left, b.left));\n  return Border(\n    top: BorderSide.merge(a.top, b.top),\n    right: BorderSide.merge(a.right, b.right),\n    bottom: BorderSide.merge(a.bottom, b.bottom),\n    left: BorderSide.merge(a.left, b.left),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/merge.html",
                    "isDeprecated": false,
                    "type": "painting.Border",
                    "name": "merge",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Border"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Border"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>Uniform borders are more efficient to paint than more complex borders.<\/p>\n<p>You can provide a <a href=\"painting\/BoxShape-class.html\">BoxShape<\/a> to draw the border on. If the <code>shape<\/code> in\n<a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a>, there is the requirement that the border <a href=\"painting\/Border\/isUniform.html\">isUniform<\/a>.<\/p>\n<p>If you specify a rectangular box shape (<a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>), then you\nmay specify a <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>. If a <code>borderRadius<\/code> is specified, there is\nthe requirement that the border <a href=\"painting\/Border\/isUniform.html\">isUniform<\/a>.<\/p>\n<p>The <a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a> and <a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a> methods do not know about the\n<code>shape<\/code> and <code>borderRadius<\/code> arguments.<\/p>\n<p>The <code>textDirection<\/code> argument is not used by this paint method.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/paintBorder.html\">paintBorder<\/a>, which is used if the border is not uniform.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(\n  Canvas canvas,\n  Rect rect, {\n  TextDirection textDirection,\n  BoxShape shape = BoxShape.rectangle,\n  BorderRadius borderRadius,\n}) {\n  if (isUniform) {\n    switch (top.style) {\n      case BorderStyle.none:\n        return;\n      case BorderStyle.solid:\n        switch (shape) {\n          case BoxShape.circle:\n            assert(borderRadius == null, 'A borderRadius can only be given for rectangular boxes.');\n            BoxBorder._paintUniformBorderWithCircle(canvas, rect, top);\n            break;\n          case BoxShape.rectangle:\n            if (borderRadius != null) {\n              BoxBorder._paintUniformBorderWithRadius(canvas, rect, top, borderRadius);\n              return;\n            }\n            BoxBorder._paintUniformBorderWithRectangle(canvas, rect, top);\n            break;\n        }\n        return;\n    }\n  }\n\n  assert(borderRadius == null, 'A borderRadius can only be given for uniform borders.');\n  assert(shape == BoxShape.rectangle, 'A border can only be drawn as a circle if it is uniform.');\n\n  paintBorder(canvas, rect, top: top, right: right, bottom: bottom, left: left);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadius"
                        },
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "shape",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxShape"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/Border\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorder scale(double t) {\n  return Border(\n    top: top.scale(t),\n    right: right.scale(t),\n    bottom: bottom.scale(t),\n    left: left.scale(t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.Border",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  if (isUniform)\n    return '$runtimeType.all($top)';\n  final List&lt;String&gt; arguments = &lt;String&gt;[];\n  if (top != BorderSide.none)\n    arguments.add('top: $top');\n  if (right != BorderSide.none)\n    arguments.add('right: $right');\n  if (bottom != BorderSide.none)\n    arguments.add('bottom: $bottom');\n  if (left != BorderSide.none)\n    arguments.add('left: $left');\n  return '$runtimeType(${arguments.join(\", \")})';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Border\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Border",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The bottom side of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide bottom\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/bottom.html",
                    "name": "bottom",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                },
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/Border\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/Border\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsets.fromLTRB(left.width, top.width, right.width, bottom.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/Border\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/Border\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/Border\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/Border\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/Border\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/Border\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(top, right, bottom, left);<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                },
                {
                    "desc": "<p>Whether all four sides of the border are identical. Uniform borders are\ntypically more efficient to paint.<\/p>\n<p>A uniform border by definition has no text direction dependency and\ntherefore could be expressed as a <a href=\"painting\/Border-class.html\">Border<\/a>, even if it is currently a\n<a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. A uniform border can also be expressed as a\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isUniform {\n  final Color topColor = top.color;\n  if (right.color != topColor ||\n      bottom.color != topColor ||\n      left.color != topColor)\n    return false;\n\n  final double topWidth = top.width;\n  if (right.width != topWidth ||\n      bottom.width != topWidth ||\n      left.width != topWidth)\n    return false;\n\n  final BorderStyle topStyle = top.style;\n  if (right.style != topStyle ||\n      bottom.style != topStyle ||\n      left.style != topStyle)\n    return false;\n\n  return true;\n}<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/isUniform.html",
                    "name": "isUniform",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                },
                {
                    "desc": "<p>The left side of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide left\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/left.html",
                    "name": "left",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                },
                {
                    "desc": "<p>The right side of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide right\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/right.html",
                    "name": "right",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                },
                {
                    "desc": "<p>The top side of this border.<\/p>\n<p>This getter is available on both <a href=\"painting\/Border-class.html\">Border<\/a> and <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. If\n<a href=\"painting\/Border\/isUniform.html\">isUniform<\/a> is true, then this is the same style as all the other sides.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide top\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Border\/top.html",
                    "name": "top",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Border",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A border of a box, comprised of four sides, the lateral sides of which\nflip over based on the reading direction.<\/p>\n<p>The lateral sides are called <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> and <a href=\"painting\/BorderDirectional\/end.html\">end<\/a>. When painted in\nleft-to-right environments, the <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> side will be painted on the left and\nthe <a href=\"painting\/BorderDirectional\/end.html\">end<\/a> side on the right; in right-to-left environments, it is the\nreverse. The other two sides are <a href=\"painting\/BorderDirectional\/top.html\">top<\/a> and <a href=\"painting\/BorderDirectional\/bottom.html\">bottom<\/a>.<\/p>\n<p>The sides are represented by <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects.<\/p>\n<p>If the <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> and <a href=\"painting\/BorderDirectional\/end.html\">end<\/a> sides are the same, then it is slightly more\nefficient to use a <a href=\"painting\/Border-class.html\">Border<\/a> object rather than a <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> object.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which uses this class to describe its edge decoration.<\/li>\n<li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe each side of the box.<\/li>\n<li>\n<a href=\"material\/Theme-class.html\">Theme<\/a>, from the material layer, which can be queried to obtain appropriate colors\nto use for borders in a material app, as shown in the \"divider\" sample above.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/BorderDirectional-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BorderDirectional",
            "shortname": "BorderDirectional",
            "extends": [
                "painting.BoxBorder",
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a border.<\/p>\n<p>The <code>start<\/code> and <code>end<\/code> sides represent the horizontal sides; the start side\nis on the leading edge given the reading direction, and the end side is on\nthe trailing edge. They are resolved during <a href=\"painting\/BorderDirectional\/paint.html\">paint<\/a>.<\/p>\n<p>All the sides of the border default to <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BorderDirectional({\n  this.top = BorderSide.none,\n  this.start = BorderSide.none,\n  this.end = BorderSide.none,\n  this.bottom = BorderSide.none,\n}) : assert(top != null),\n     assert(start != null),\n     assert(end != null),\n     assert(bottom != null);<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/BorderDirectional.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BorderDirectional",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "bottom",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "end",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "start",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "top",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Attempts to create a new object that represents the amalgamation of <code>this<\/code>\nborder and the <code>other<\/code> border.<\/p>\n<p>If the type of the other border isn't known, or the given instance cannot\nbe reasonably added to this instance, then this should return null.<\/p>\n<p>This method is used by the <a href=\"painting\/ShapeBorder\/operator_plus.html\">operator +<\/a> implementation.<\/p>\n<p>The <code>reversed<\/code> argument is true if this object was the right operand of\nthe <code>+<\/code> operator, and false if it was the left operand.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxBorder add(ShapeBorder other, { bool reversed = false }) {\n  if (other is BorderDirectional) {\n    final BorderDirectional typedOther = other;\n    if (BorderSide.canMerge(top, typedOther.top) &amp;&amp;\n        BorderSide.canMerge(start, typedOther.start) &amp;&amp;\n        BorderSide.canMerge(end, typedOther.end) &amp;&amp;\n        BorderSide.canMerge(bottom, typedOther.bottom)) {\n      return BorderDirectional.merge(this, typedOther);\n    }\n    return null;\n  }\n  if (other is Border) {\n    final Border typedOther = other;\n    if (!BorderSide.canMerge(typedOther.top, top) ||\n        !BorderSide.canMerge(typedOther.bottom, bottom))\n      return null;\n    if (start != BorderSide.none ||\n        end != BorderSide.none) {\n      if (typedOther.left != BorderSide.none ||\n          typedOther.right != BorderSide.none)\n        return null;\n      assert(typedOther.left == BorderSide.none);\n      assert(typedOther.right == BorderSide.none);\n      return BorderDirectional(\n        top: BorderSide.merge(typedOther.top, top),\n        start: start,\n        end: end,\n        bottom: BorderSide.merge(typedOther.bottom, bottom),\n      );\n    }\n    assert(start == BorderSide.none);\n    assert(end == BorderSide.none);\n    return Border(\n      top: BorderSide.merge(typedOther.top, top),\n      right: typedOther.right,\n      bottom: BorderSide.merge(typedOther.bottom, bottom),\n      left: typedOther.left,\n    );\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/add.html",
                    "isDeprecated": false,
                    "type": "painting.BoxBorder",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "reversed",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two borders.<\/p>\n<p>If a border is null, it is treated as having four <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>\nborders.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderDirectional lerp(BorderDirectional a, BorderDirectional b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  return BorderDirectional(\n    top: BorderSide.lerp(a.top, b.top, t),\n    end: BorderSide.lerp(a.end, b.end, t),\n    bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n    start: BorderSide.lerp(a.start, b.start, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BorderDirectional",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderDirectional"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderDirectional"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/BorderDirectional\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/BorderDirectional\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/BorderDirectional\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/BorderDirectional\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  if (a is BorderDirectional)\n    return BorderDirectional.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/BorderDirectional\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/BorderDirectional\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/BorderDirectional\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/BorderDirectional\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  if (b is BorderDirectional)\n    return BorderDirectional.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> that represents the addition of the two\ngiven <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>s.<\/p>\n<p>It is only valid to call this if <a href=\"painting\/BorderSide\/canMerge.html\">BorderSide.canMerge<\/a> returns true for\nthe pairwise combination of each side on both <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>s.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderDirectional merge(BorderDirectional a, BorderDirectional b) {\n  assert(a != null);\n  assert(b != null);\n  assert(BorderSide.canMerge(a.top, b.top));\n  assert(BorderSide.canMerge(a.start, b.start));\n  assert(BorderSide.canMerge(a.end, b.end));\n  assert(BorderSide.canMerge(a.bottom, b.bottom));\n  return BorderDirectional(\n    top: BorderSide.merge(a.top, b.top),\n    start: BorderSide.merge(a.start, b.start),\n    end: BorderSide.merge(a.end, b.end),\n    bottom: BorderSide.merge(a.bottom, b.bottom),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/merge.html",
                    "isDeprecated": false,
                    "type": "painting.BorderDirectional",
                    "name": "merge",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderDirectional"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderDirectional"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>Uniform borders are more efficient to paint than more complex borders.<\/p>\n<p>You can provide a <a href=\"painting\/BoxShape-class.html\">BoxShape<\/a> to draw the border on. If the <code>shape<\/code> in\n<a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a>, there is the requirement that the border <a href=\"painting\/BorderDirectional\/isUniform.html\">isUniform<\/a>.<\/p>\n<p>If you specify a rectangular box shape (<a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>), then you\nmay specify a <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>. If a <code>borderRadius<\/code> is specified, there is\nthe requirement that the border <a href=\"painting\/BorderDirectional\/isUniform.html\">isUniform<\/a>.<\/p>\n<p>The <a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a> and <a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a> methods do not know about the\n<code>shape<\/code> and <code>borderRadius<\/code> arguments.<\/p>\n<p>The <code>textDirection<\/code> argument is used to determine which of <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> and\n<a href=\"painting\/BorderDirectional\/end.html\">end<\/a> map to the left and right. For <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a>, the <a href=\"painting\/BorderDirectional\/start.html\">start<\/a> is\nthe left and the <a href=\"painting\/BorderDirectional\/end.html\">end<\/a> is the right; for <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a>, it is the\nreverse.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/paintBorder.html\">paintBorder<\/a>, which is used if the border is not uniform.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(\n  Canvas canvas,\n  Rect rect, {\n  TextDirection textDirection,\n  BoxShape shape = BoxShape.rectangle,\n  BorderRadius borderRadius,\n}) {\n  if (isUniform) {\n    switch (top.style) {\n      case BorderStyle.none:\n        return;\n      case BorderStyle.solid:\n        switch (shape) {\n          case BoxShape.circle:\n            assert(borderRadius == null, 'A borderRadius can only be given for rectangular boxes.');\n            BoxBorder._paintUniformBorderWithCircle(canvas, rect, top);\n            break;\n          case BoxShape.rectangle:\n            if (borderRadius != null) {\n              BoxBorder._paintUniformBorderWithRadius(canvas, rect, top, borderRadius);\n              return;\n            }\n            BoxBorder._paintUniformBorderWithRectangle(canvas, rect, top);\n            break;\n        }\n        return;\n    }\n  }\n\n  assert(borderRadius == null, 'A borderRadius can only be given for uniform borders.');\n  assert(shape == BoxShape.rectangle, 'A border can only be drawn as a circle if it is uniform.');\n\n  BorderSide left, right;\n  assert(textDirection != null, 'Non-uniform BorderDirectional objects require a TextDirection when painting.');\n  switch (textDirection) {\n    case TextDirection.rtl:\n      left = end;\n      right = start;\n      break;\n    case TextDirection.ltr:\n      left = start;\n      right = end;\n      break;\n  }\n  paintBorder(canvas, rect, top: top, left: left, bottom: bottom, right: right);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadius"
                        },
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "shape",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxShape"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/BorderDirectional\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderDirectional scale(double t) {\n  return BorderDirectional(\n    top: top.scale(t),\n    start: start.scale(t),\n    end: end.scale(t),\n    bottom: bottom.scale(t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.BorderDirectional",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  final List&lt;String&gt; arguments = &lt;String&gt;[];\n  if (top != BorderSide.none)\n    arguments.add('top: $top');\n  if (start != BorderSide.none)\n    arguments.add('start: $start');\n  if (end != BorderSide.none)\n    arguments.add('end: $end');\n  if (bottom != BorderSide.none)\n    arguments.add('bottom: $bottom');\n  return '$runtimeType(${arguments.join(\", \")})';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderDirectional\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The bottom side of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide bottom\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/bottom.html",
                    "name": "bottom",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/BorderDirectional\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/BorderDirectional\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsetsDirectional.fromSTEB(start.width, top.width, end.width, bottom.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The end side of this border.<\/p>\n<p>This is the side on the right in left-to-right text and on the left in\nright-to-left text.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which is used to describe the reading direction.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide end\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/end.html",
                    "name": "end",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BorderDirectional\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BorderDirectional\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(top, start, end, bottom);<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                },
                {
                    "desc": "<p>Whether all four sides of the border are identical. Uniform borders are\ntypically more efficient to paint.<\/p>\n<p>A uniform border by definition has no text direction dependency and\ntherefore could be expressed as a <a href=\"painting\/Border-class.html\">Border<\/a>, even if it is currently a\n<a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. A uniform border can also be expressed as a\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isUniform {\n  final Color topColor = top.color;\n  if (start.color != topColor ||\n      end.color != topColor ||\n      bottom.color != topColor)\n    return false;\n\n  final double topWidth = top.width;\n  if (start.width != topWidth ||\n      end.width != topWidth ||\n      bottom.width != topWidth)\n    return false;\n\n  final BorderStyle topStyle = top.style;\n  if (start.style != topStyle ||\n      end.style != topStyle ||\n      bottom.style != topStyle)\n    return false;\n\n  return true;\n}<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/isUniform.html",
                    "name": "isUniform",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The start side of this border.<\/p>\n<p>This is the side on the left in left-to-right text and on the right in\nright-to-left text.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which is used to describe the reading direction.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide start\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/start.html",
                    "name": "start",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The top side of this border.<\/p>\n<p>This getter is available on both <a href=\"painting\/Border-class.html\">Border<\/a> and <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. If\n<a href=\"painting\/BorderDirectional\/isUniform.html\">isUniform<\/a> is true, then this is the same style as all the other sides.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide top\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderDirectional\/top.html",
                    "name": "top",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderDirectional",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable set of radii for each corner of a rectangle.<\/p>\n<p>Used by <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> when the shape is a <a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>.<\/p>\n<p>The <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> class specifies offsets in terms of visual corners, e.g.\n<a href=\"painting\/BorderRadius\/topLeft.html\">topLeft<\/a>. These values are not affected by the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. To support\nboth left-to-right and right-to-left layouts, consider using\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>, which is expressed in terms that are relative to\na <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a> (typically obtained from the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a>).<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/BorderRadius-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BorderRadius",
            "shortname": "BorderRadius",
            "extends": [
                "painting.BorderRadiusGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "widgets.BorderRadiusTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or two <a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/BorderRadius\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadius\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderRadiusGeometry add(BorderRadiusGeometry other) {\n  if (other is BorderRadius)\n    return this + other;\n  return super.add(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadius\/add.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadius",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> objects.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/BorderRadius\/zero-constant.html\">BorderRadius.zero<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderRadius lerp(BorderRadius a, BorderRadius b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b * t;\n  if (b == null)\n    return a * (1.0 - t);\n  return BorderRadius.only(\n    topLeft: Radius.lerp(a.topLeft, b.topLeft, t),\n    topRight: Radius.lerp(a.topRight, b.topRight, t),\n    bottomLeft: Radius.lerp(a.bottomLeft, b.bottomLeft, t),\n    bottomRight: Radius.lerp(a.bottomRight, b.bottomRight, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadius\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadius",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadius",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadius"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadius"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into a <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, so that the radii are\nexpressed for specific physical corners (top-left, top-right, etc) rather\nthan in a direction-dependent manner.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderRadius resolve(TextDirection direction) =&gt; this;<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadius\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadius",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadius",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the difference between two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If you know you are applying this to two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or two\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a> objects, consider using the binary infix <code>-<\/code>\noperator instead, which always returns an object of the same type as the\noperands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/BorderRadius\/subtract.html\">subtract<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadius\/resolve.html\">resolve<\/a>.<\/p>\n<p>This method returns the same result as <a href=\"painting\/BorderRadius\/add.html\">add<\/a> applied to the result of\nnegating the argument (using the prefix unary <code>-<\/code> operator or multiplying\nthe argument by -1.0 using the <code>*<\/code> operator).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderRadiusGeometry subtract(BorderRadiusGeometry other) {\n  if (other is BorderRadius)\n    return this - other;\n  return super.subtract(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadius\/subtract.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "subtract",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadius",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates an <a href=\"dart-ui\/RRect-class.html\">RRect<\/a> from the current border radius and a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RRect toRRect(Rect rect) {\n  return RRect.fromRectAndCorners(\n    rect,\n    topLeft: topLeft,\n    topRight: topRight,\n    bottomLeft: bottomLeft,\n    bottomRight: bottomRight,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadius\/toRRect.html",
                    "isDeprecated": false,
                    "type": "dart:ui.RRect",
                    "name": "toRRect",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadius",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The bottom-left <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius bottomLeft\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadius\/bottomLeft.html",
                    "name": "bottomLeft",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadius",
                    "params": []
                },
                {
                    "desc": "<p>The bottom-right <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius bottomRight\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadius\/bottomRight.html",
                    "name": "bottomRight",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadius",
                    "params": []
                },
                {
                    "desc": "<p>The top-left <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius topLeft\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadius\/topLeft.html",
                    "name": "topLeft",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadius",
                    "params": []
                },
                {
                    "desc": "<p>The top-right <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius topRight\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadius\/topRight.html",
                    "name": "topRight",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadius",
                    "params": []
                },
                {
                    "desc": "<p>A border radius with all zero radii.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const BorderRadius zero = BorderRadius.all(Radius.zero)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadius\/zero-constant.html",
                    "name": "zero",
                    "isDeprecated": false,
                    "type": "painting.BorderRadius",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BorderRadius",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable set of radii for each corner of a rectangle, but with the\ncorners specified in a manner dependent on the writing direction.<\/p>\n<p>This can be used to specify a corner radius on the leading or trailing edge\nof a box, so that it flips to the other side when the text alignment flips\n(e.g. being on the top right in English text but the top left in Arabic\ntext).<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, a variant that uses physical labels (<code>topLeft<\/code> and\n<code>topRight<\/code> instead of <code>topStart<\/code> and <code>topEnd<\/code>).<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/BorderRadiusDirectional-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BorderRadiusDirectional",
            "shortname": "BorderRadiusDirectional",
            "extends": [
                "painting.BorderRadiusGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or two <a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/BorderRadiusDirectional\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadiusDirectional\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderRadiusGeometry add(BorderRadiusGeometry other) {\n  if (other is BorderRadiusDirectional)\n    return this + other;\n  return super.add(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusDirectional\/add.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a> objects.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/BorderRadiusDirectional\/zero-constant.html\">BorderRadiusDirectional.zero<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderRadiusDirectional lerp(BorderRadiusDirectional a, BorderRadiusDirectional b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b * t;\n  if (b == null)\n    return a * (1.0 - t);\n  return BorderRadiusDirectional.only(\n    topStart: Radius.lerp(a.topStart, b.topStart, t),\n    topEnd: Radius.lerp(a.topEnd, b.topEnd, t),\n    bottomStart: Radius.lerp(a.bottomStart, b.bottomStart, t),\n    bottomEnd: Radius.lerp(a.bottomEnd, b.bottomEnd, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusDirectional\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusDirectional",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusDirectional"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusDirectional"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into a <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, so that the radii are\nexpressed for specific physical corners (top-left, top-right, etc) rather\nthan in a direction-dependent manner.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderRadius resolve(TextDirection direction) {\n  assert(direction != null);\n  switch (direction) {\n    case TextDirection.rtl:\n      return BorderRadius.only(\n        topLeft: topEnd,\n        topRight: topStart,\n        bottomLeft: bottomEnd,\n        bottomRight: bottomStart,\n      );\n    case TextDirection.ltr:\n      return BorderRadius.only(\n        topLeft: topStart,\n        topRight: topEnd,\n        bottomLeft: bottomStart,\n        bottomRight: bottomEnd,\n      );\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusDirectional\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadius",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the difference between two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If you know you are applying this to two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or two\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a> objects, consider using the binary infix <code>-<\/code>\noperator instead, which always returns an object of the same type as the\noperands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/BorderRadiusDirectional\/subtract.html\">subtract<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadiusDirectional\/resolve.html\">resolve<\/a>.<\/p>\n<p>This method returns the same result as <a href=\"painting\/BorderRadiusDirectional\/add.html\">add<\/a> applied to the result of\nnegating the argument (using the prefix unary <code>-<\/code> operator or multiplying\nthe argument by -1.0 using the <code>*<\/code> operator).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBorderRadiusGeometry subtract(BorderRadiusGeometry other) {\n  if (other is BorderRadiusDirectional)\n    return this - other;\n  return super.subtract(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusDirectional\/subtract.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "subtract",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The bottom-end <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius bottomEnd\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadiusDirectional\/bottomEnd.html",
                    "name": "bottomEnd",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The bottom-start <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius bottomStart\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadiusDirectional\/bottomStart.html",
                    "name": "bottomStart",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The top-end <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius topEnd\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadiusDirectional\/topEnd.html",
                    "name": "topEnd",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The top-start <a href=\"dart-ui\/Radius-class.html\">Radius<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Radius topStart\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadiusDirectional\/topStart.html",
                    "name": "topStart",
                    "isDeprecated": false,
                    "type": "dart:ui.Radius",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": []
                },
                {
                    "desc": "<p>A border radius with all zero radii.<\/p>\n<p>Consider using <a href=\"painting\/BorderRadiusDirectional\/zero-constant.html\">EdgeInsets.zero<\/a> instead, since that object has the same\neffect, but will be cheaper to <a href=\"painting\/BorderRadiusDirectional\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const BorderRadiusDirectional zero = BorderRadiusDirectional.all(Radius.zero)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusDirectional\/zero-constant.html",
                    "name": "zero",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BorderRadiusDirectional",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Base class for <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> that allows for text-direction aware resolution.<\/p>\n<p>A property or argument of this type accepts classes created either with <a href=\"painting\/BorderRadius\/BorderRadius.only.html\">new\nBorderRadius.only<\/a> and its variants, or <a href=\"painting\/BorderRadiusDirectional\/BorderRadiusDirectional.only.html\">new BorderRadiusDirectional.only<\/a>\nand its variants.<\/p>\n<p>To convert a <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> object of indeterminate type into a\n<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> object, call the <a href=\"painting\/BorderRadiusGeometry\/resolve.html\">resolve<\/a> method.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/BorderRadiusGeometry-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BorderRadiusGeometry",
            "shortname": "BorderRadiusGeometry",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.BorderRadius",
                "painting.BorderRadiusDirectional"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BorderRadiusGeometry();<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusGeometry\/BorderRadiusGeometry.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BorderRadiusGeometry",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": []
                },
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or two <a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/BorderRadiusGeometry\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadiusGeometry\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BorderRadiusGeometry add(BorderRadiusGeometry other) {\n  return _MixedBorderRadius(\n    _topLeft + other._topLeft,\n    _topRight + other._topRight,\n    _bottomLeft + other._bottomLeft,\n    _bottomRight + other._bottomRight,\n    _topStart + other._topStart,\n    _topEnd + other._topEnd,\n    _bottomStart + other._bottomStart,\n    _bottomEnd + other._bottomEnd,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusGeometry\/add.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/BorderRadius\/zero-constant.html\">BorderRadius.zero<\/a>,\nand the result is an object of the same type as the non-null argument. (If\nboth are null, this returns null.)<\/p>\n<p>If <a href=\"painting\/BorderRadiusGeometry\/lerp.html\">lerp<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadiusGeometry\/resolve.html\">resolve<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderRadiusGeometry lerp(BorderRadiusGeometry a, BorderRadiusGeometry b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  a ??= BorderRadius.zero;\n  b ??= BorderRadius.zero;\n  return a.add((b.subtract(a)) * t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusGeometry\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into a <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, so that the radii are\nexpressed for specific physical corners (top-left, top-right, etc) rather\nthan in a direction-dependent manner.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BorderRadius resolve(TextDirection direction);<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusGeometry\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadius",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the difference between two <a href=\"painting\/BorderRadiusGeometry-class.html\">BorderRadiusGeometry<\/a> objects.<\/p>\n<p>If you know you are applying this to two <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or two\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a> objects, consider using the binary infix <code>-<\/code>\noperator instead, which always returns an object of the same type as the\noperands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/BorderRadiusGeometry\/subtract.html\">subtract<\/a> is applied to two objects of the same type (<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> or\n<a href=\"painting\/BorderRadiusDirectional-class.html\">BorderRadiusDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a> using <a href=\"painting\/BorderRadiusGeometry\/resolve.html\">resolve<\/a>.<\/p>\n<p>This method returns the same result as <a href=\"painting\/BorderRadiusGeometry\/add.html\">add<\/a> applied to the result of\nnegating the argument (using the prefix unary <code>-<\/code> operator or multiplying\nthe argument by -1.0 using the <code>*<\/code> operator).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BorderRadiusGeometry subtract(BorderRadiusGeometry other) {\n  return _MixedBorderRadius(\n    _topLeft - other._topLeft,\n    _topRight - other._topRight,\n    _bottomLeft - other._bottomLeft,\n    _bottomRight - other._bottomRight,\n    _topStart - other._topStart,\n    _topEnd - other._topEnd,\n    _bottomStart - other._bottomStart,\n    _bottomEnd - other._bottomEnd,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusGeometry\/subtract.html",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "name": "subtract",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadiusGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  String visual, logical;\n  if (_topLeft == _topRight &amp;&amp;\n      _topRight == _bottomLeft &amp;&amp;\n      _bottomLeft == _bottomRight) {\n    if (_topLeft != Radius.zero) {\n      if (_topLeft.x == _topLeft.y) {\n        visual = 'BorderRadius.circular(${_topLeft.x.toStringAsFixed(1)})';\n      } else {\n        visual = 'BorderRadius.all($_topLeft)';\n      }\n    }\n  } else {\n    \/\/ visuals aren't the same and at least one isn't zero\n    final StringBuffer result = StringBuffer();\n    result.write('BorderRadius.only(');\n    bool comma = false;\n    if (_topLeft != Radius.zero) {\n      result.write('topLeft: $_topLeft');\n      comma = true;\n    }\n    if (_topRight != Radius.zero) {\n      if (comma)\n        result.write(', ');\n      result.write('topRight: $_topRight');\n      comma = true;\n    }\n    if (_bottomLeft != Radius.zero) {\n      if (comma)\n        result.write(', ');\n      result.write('bottomLeft: $_bottomLeft');\n      comma = true;\n    }\n    if (_bottomRight != Radius.zero) {\n      if (comma)\n        result.write(', ');\n      result.write('bottomRight: $_bottomRight');\n    }\n    result.write(')');\n    visual = result.toString();\n  }\n  if (_topStart == _topEnd &amp;&amp;\n      _topEnd == _bottomEnd &amp;&amp;\n      _bottomEnd == _bottomStart) {\n    if (_topStart != Radius.zero) {\n      if (_topStart.x == _topStart.y) {\n        logical = 'BorderRadiusDirectional.circular(${_topStart.x.toStringAsFixed(1)})';\n      } else {\n        logical = 'BorderRadiusDirectional.all($_topStart)';\n      }\n    }\n  } else {\n    \/\/ logicals aren't the same and at least one isn't zero\n    final StringBuffer result = StringBuffer();\n    result.write('BorderRadiusDirectional.only(');\n    bool comma = false;\n    if (_topStart != Radius.zero) {\n      result.write('topStart: $_topStart');\n      comma = true;\n    }\n    if (_topEnd != Radius.zero) {\n      if (comma)\n        result.write(', ');\n      result.write('topEnd: $_topEnd');\n      comma = true;\n    }\n    if (_bottomStart != Radius.zero) {\n      if (comma)\n        result.write(', ');\n      result.write('bottomStart: $_bottomStart');\n      comma = true;\n    }\n    if (_bottomEnd != Radius.zero) {\n      if (comma)\n        result.write(', ');\n      result.write('bottomEnd: $_bottomEnd');\n    }\n    result.write(')');\n    logical = result.toString();\n  }\n  if (visual != null &amp;&amp; logical != null)\n    return '$visual + $logical';\n  if (visual != null)\n    return visual;\n  if (logical != null)\n    return logical;\n  return 'BorderRadius.zero';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderRadiusGeometry\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BorderRadiusGeometry\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BorderRadiusGeometry\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BorderRadiusGeometry\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BorderRadiusGeometry\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BorderRadiusGeometry\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BorderRadiusGeometry\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode {\n  return hashValues(\n    _topLeft,\n    _topRight,\n    _bottomLeft,\n    _bottomRight,\n    _topStart,\n    _topEnd,\n    _bottomStart,\n    _bottomEnd,\n  );\n}<\/code><\/pre>\n        ",
                    "href": "painting\/BorderRadiusGeometry\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderRadiusGeometry",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A side of a border of a box.<\/p>\n<p>A <a href=\"painting\/Border-class.html\">Border<\/a> consists of four <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects: <a href=\"painting\/Border\/top.html\">Border.top<\/a>,\n<a href=\"painting\/Border\/left.html\">Border.left<\/a>, <a href=\"painting\/Border\/right.html\">Border.right<\/a>, and <a href=\"painting\/Border\/bottom.html\">Border.bottom<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis sample shows how <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects can be used in a <a href=\"widgets\/Container-class.html\">Container<\/a>, via\na <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> and a <a href=\"painting\/Border-class.html\">Border<\/a>, to decorate some <a href=\"widgets\/Text-class.html\">Text<\/a>. In this example,\nthe text has a thick bar above it that is light blue, and a thick bar below\nit that is a darker shade of blue.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Container(\n  padding: EdgeInsets.all(8.0),\n  decoration: BoxDecoration(\n    border: Border(\n      top: BorderSide(width: 16.0, color: Colors.lightBlue.shade50),\n      bottom: BorderSide(width: 16.0, color: Colors.lightBlue.shade900),\n    ),\n  ),\n  child: Text('Flutter in the sky', textAlign: TextAlign.center),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/Border-class.html\">Border<\/a>, which uses <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects to represent its sides.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which optionally takes a <a href=\"painting\/Border-class.html\">Border<\/a> object.<\/li>\n<li>\n<a href=\"rendering\/TableBorder-class.html\">TableBorder<\/a>, which is similar to <a href=\"painting\/Border-class.html\">Border<\/a> but has two more sides\n(<a href=\"rendering\/TableBorder\/horizontalInside.html\">TableBorder.horizontalInside<\/a> and <a href=\"rendering\/TableBorder\/verticalInside.html\">TableBorder.verticalInside<\/a>), both\nof which are also <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> objects.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/BorderSide-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BorderSide",
            "shortname": "BorderSide",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates the side of a border.<\/p>\n<p>By default, the border is 1.0 logical pixels wide and solid black.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BorderSide({\n  this.color = const Color(0xFF000000),\n  this.width = 1.0,\n  this.style = BorderStyle.solid,\n}) : assert(color != null),\n     assert(width != null),\n     assert(width &gt;= 0.0),\n     assert(style != null);<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/BorderSide.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BorderSide",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": [
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "style",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderStyle"
                        },
                        {
                            "name": "width",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Whether the two given <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>s can be merged using <a href=\"painting\/BorderSide\/merge.html\">new\nBorderSide.merge<\/a>.<\/p>\n<p>Two sides can be merged if one or both are zero-width with\n<a href=\"painting\/BorderSide\/none-constant.html\">BorderStyle.none<\/a>, or if they both have the same color and style.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool canMerge(BorderSide a, BorderSide b) {\n  assert(a != null);\n  assert(b != null);\n  if ((a.style == BorderStyle.none &amp;&amp; a.width == 0.0) ||\n      (b.style == BorderStyle.none &amp;&amp; b.width == 0.0))\n    return true;\n  return a.style == b.style\n      &amp;&amp; a.color == b.color;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/canMerge.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "canMerge",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border but with the given fields replaced with the new values.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BorderSide copyWith({\n  Color color,\n  double width,\n  BorderStyle style,\n}) {\n  assert(width == null || width &gt;= 0.0);\n  return BorderSide(\n    color: color ?? this.color,\n    width: width ?? this.width,\n    style: style ?? this.style,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/copyWith.html",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "name": "copyWith",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": [
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "style",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderStyle"
                        },
                        {
                            "name": "width",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two border sides.<\/p>\n<p>The arguments must not be null.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderSide lerp(BorderSide a, BorderSide b, double t) {\n  assert(a != null);\n  assert(b != null);\n  assert(t != null);\n  if (t == 0.0)\n    return a;\n  if (t == 1.0)\n    return b;\n  final double width = ui.lerpDouble(a.width, b.width, t);\n  if (width &lt; 0.0)\n    return BorderSide.none;\n  if (a.style == b.style) {\n    return BorderSide(\n      color: Color.lerp(a.color, b.color, t),\n      width: width,\n      style: a.style, \/\/ == b.style\n    );\n  }\n  Color colorA, colorB;\n  switch (a.style) {\n    case BorderStyle.solid:\n      colorA = a.color;\n      break;\n    case BorderStyle.none:\n      colorA = a.color.withAlpha(0x00);\n      break;\n  }\n  switch (b.style) {\n    case BorderStyle.solid:\n      colorB = b.color;\n      break;\n    case BorderStyle.none:\n      colorB = b.color.withAlpha(0x00);\n      break;\n  }\n  return BorderSide(\n    color: Color.lerp(colorA, colorB, t),\n    width: width,\n    style: BorderStyle.solid,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> that represents the addition of the two given\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>s.<\/p>\n<p>It is only valid to call this if <a href=\"painting\/BorderSide\/canMerge.html\">canMerge<\/a> returns true for the two\nsides.<\/p>\n<p>If one of the sides is zero-width with <a href=\"painting\/BorderSide\/none-constant.html\">BorderStyle.none<\/a>, then the other\nside is return as-is. If both of the sides are zero-width with\n<a href=\"painting\/BorderSide\/none-constant.html\">BorderStyle.none<\/a>, then <code>BorderSide.zero<\/code> is returned.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BorderSide merge(BorderSide a, BorderSide b) {\n  assert(a != null);\n  assert(b != null);\n  assert(canMerge(a, b));\n  final bool aIsNone = a.style == BorderStyle.none &amp;&amp; a.width == 0.0;\n  final bool bIsNone = b.style == BorderStyle.none &amp;&amp; b.width == 0.0;\n  if (aIsNone &amp;&amp; bIsNone)\n    return BorderSide.none;\n  if (aIsNone)\n    return b;\n  if (bIsNone)\n    return a;\n  assert(a.color == b.color);\n  assert(a.style == b.style);\n  return BorderSide(\n    color: a.color, \/\/ == b.color\n    width: a.width + b.width,\n    style: a.style, \/\/ == b.style\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/merge.html",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "name": "merge",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderSide"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border side description but with the width scaled\nby the factor <code>t<\/code>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are treated like zero.<\/p>\n<p>Since a zero width is normally painted as a hairline width rather than no\nborder at all, the zero factor is special-cased to instead change the\nstyle no <a href=\"painting\/BorderSide\/none-constant.html\">BorderStyle.none<\/a>.<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BorderSide scale(double t) {\n  assert(t != null);\n  return BorderSide(\n    color: color,\n    width: math.max(0.0, width * t),\n    style: t &lt;= 0.0 ? BorderStyle.none : style,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Paint-class.html\">Paint<\/a> object that, if used to stroke a line, will draw the line\nin this border's style.<\/p>\n<p>Not all borders use this method to paint their border sides. For example,\nnon-uniform rectangular <a href=\"painting\/Border-class.html\">Border<\/a>s have beveled edges and so paint their\nborder sides as filled shapes rather than using a stroke.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Paint toPaint() {\n  switch (style) {\n    case BorderStyle.solid:\n      return Paint()\n        ..color = color\n        ..strokeWidth = width\n        ..style = PaintingStyle.stroke;\n    case BorderStyle.none:\n      return Paint()\n        ..color = const Color(0x00000000)\n        ..strokeWidth = 0.0\n        ..style = PaintingStyle.stroke;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/toPaint.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Paint",
                    "name": "toPaint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": []
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType($color, ${width.toStringAsFixed(1)}, $style)';<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BorderSide",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The color of this side of the border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color color\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderSide\/color.html",
                    "name": "color",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderSide",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BorderSide\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BorderSide\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BorderSide\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BorderSide\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BorderSide\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BorderSide\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(color, width, style);<\/code><\/pre>\n        ",
                    "href": "painting\/BorderSide\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderSide",
                    "params": []
                },
                {
                    "desc": "<p>A hairline black border that is not rendered.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const BorderSide none = BorderSide(width: 0.0, style: BorderStyle.none)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/BorderSide\/none-constant.html",
                    "name": "none",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BorderSide",
                    "params": []
                },
                {
                    "desc": "<p>The style of this side of the border.<\/p>\n<p>To omit a side, set <a href=\"painting\/BorderSide\/style.html\">style<\/a> to <a href=\"painting\/BorderSide\/none-constant.html\">BorderStyle.none<\/a>. This skips\npainting the border, but the border still has a <a href=\"painting\/BorderSide\/width.html\">width<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderStyle style\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderSide\/style.html",
                    "name": "style",
                    "isDeprecated": false,
                    "type": "painting.BorderStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderSide",
                    "params": []
                },
                {
                    "desc": "<p>The width of this side of the border, in logical pixels. A\nzero-width border is a hairline border. To omit the border\nentirely, set the <a href=\"painting\/BorderSide\/style.html\">style<\/a> to <a href=\"painting\/BorderSide\/none-constant.html\">BorderStyle.none<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double width\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BorderSide\/width.html",
                    "name": "width",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BorderSide",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Base class for box borders that can paint as rectangles, circles, or rounded\nrectangles.<\/p>\n<p>This class is extended by <a href=\"painting\/Border-class.html\">Border<\/a> and <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> to provide\nconcrete versions of four-sided borders using different conventions for\nspecifying the sides.<\/p>\n<p>The only API difference that this class introduces over <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> is\nthat its <a href=\"painting\/BoxBorder\/paint.html\">paint<\/a> method takes additional arguments.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe each side of the box.<\/li>\n<li>\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>, another way of describing a box's border.<\/li>\n<li>\n<a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>, another way of describing a circle border.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which uses a <a href=\"painting\/BoxBorder-class.html\">BoxBorder<\/a> to describe its borders.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/BoxBorder-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BoxBorder",
            "shortname": "BoxBorder",
            "extends": [
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.Border",
                "painting.BorderDirectional"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BoxBorder();<\/code><\/pre>\n    ",
                    "href": "painting\/BoxBorder\/BoxBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BoxBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BoxBorder",
                    "params": []
                },
                {
                    "desc": "<p>Attempts to create a new object that represents the amalgamation of <code>this<\/code>\nborder and the <code>other<\/code> border.<\/p>\n<p>If the type of the other border isn't known, or the given instance cannot\nbe reasonably added to this instance, then this should return null.<\/p>\n<p>This method is used by the <a href=\"painting\/ShapeBorder\/operator_plus.html\">operator +<\/a> implementation.<\/p>\n<p>The <code>reversed<\/code> argument is true if this object was the right operand of\nthe <code>+<\/code> operator, and false if it was the left operand.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxBorder add(ShapeBorder other, { bool reversed = false }) =&gt; null;<\/code><\/pre>\n    ",
                    "href": "painting\/BoxBorder\/add.html",
                    "isDeprecated": false,
                    "type": "painting.BoxBorder",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxBorder",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "reversed",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getInnerPath(Rect rect, { @required TextDirection textDirection }) {\n  assert(textDirection != null, 'The textDirection argument to $runtimeType.getInnerPath must not be null.');\n  return Path()\n    ..addRect(dimensions.resolve(textDirection).deflateRect(rect));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect rect, { @required TextDirection textDirection }) {\n  assert(textDirection != null, 'The textDirection argument to $runtimeType.getOuterPath must not be null.');\n  return Path()\n    ..addRect(rect);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two borders.<\/p>\n<p>If a border is null, it is treated as having four <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>\nborders.<\/p>\n<p>This supports interpolating between <a href=\"painting\/Border-class.html\">Border<\/a> and <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>\nobjects. If both objects are different types but both have sides on one or\nboth of their lateral edges (the two sides that aren't the top and bottom)\nother than <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>, then the sides are interpolated by reducing\n<code>a<\/code>'s lateral edges to <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a> over the first half of the\nanimation, and then bringing <code>b<\/code>'s lateral edges <em>from<\/em> <a href=\"painting\/BorderSide\/none-constant.html\">BorderSide.none<\/a>\nover the second half of the animation.<\/p>\n<p>For a more flexible approach, consider <a href=\"painting\/BoxBorder\/lerp.html\">ShapeBorder.lerp<\/a>, which would\ninstead <a href=\"painting\/BoxBorder\/add.html\">add<\/a> the two sets of sides and interpolate them simultaneously.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BoxBorder lerp(BoxBorder a, BoxBorder b, double t) {\n  assert(t != null);\n  if ((a is Border || a == null) &amp;&amp; (b is Border || b == null))\n    return Border.lerp(a, b, t);\n  if ((a is BorderDirectional || a == null) &amp;&amp; (b is BorderDirectional || b == null))\n    return BorderDirectional.lerp(a, b, t);\n  if (b is Border &amp;&amp; a is BorderDirectional) {\n    final BoxBorder c = b;\n    b = a;\n    a = c;\n    t = 1.0 - t;\n    \/\/ fall through to next case\n  }\n  if (a is Border &amp;&amp; b is BorderDirectional) {\n    if (b.start == BorderSide.none &amp;&amp; b.end == BorderSide.none) {\n      \/\/ The fact that b is a BorderDirectional really doesn't matter, it turns out.\n      return Border(\n        top: BorderSide.lerp(a.top, b.top, t),\n        right: BorderSide.lerp(a.right, BorderSide.none, t),\n        bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n        left: BorderSide.lerp(a.left, BorderSide.none, t),\n      );\n    }\n    if (a.left == BorderSide.none &amp;&amp; a.right == BorderSide.none) {\n      \/\/ The fact that a is a Border really doesn't matter, it turns out.\n      return BorderDirectional(\n        top: BorderSide.lerp(a.top, b.top, t),\n        start: BorderSide.lerp(BorderSide.none, b.start, t),\n        end: BorderSide.lerp(BorderSide.none, b.end, t),\n        bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n      );\n    }\n    \/\/ Since we have to swap a visual border for a directional one,\n    \/\/ we speed up the horizontal sides' transitions and switch from\n    \/\/ one mode to the other at t=0.5.\n    if (t &lt; 0.5) {\n      return Border(\n        top: BorderSide.lerp(a.top, b.top, t),\n        right: BorderSide.lerp(a.right, BorderSide.none, t * 2.0),\n        bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n        left: BorderSide.lerp(a.left, BorderSide.none, t * 2.0),\n      );\n    }\n    return BorderDirectional(\n      top: BorderSide.lerp(a.top, b.top, t),\n      start: BorderSide.lerp(BorderSide.none, b.start, (t - 0.5) * 2.0),\n      end: BorderSide.lerp(BorderSide.none, b.end, (t - 0.5) * 2.0),\n      bottom: BorderSide.lerp(a.bottom, b.bottom, t),\n    );\n  }\n  throw FlutterError(\n    'BoxBorder.lerp can only interpolate Border and BorderDirectional classes.\\n'\n    'BoxBorder.lerp() was called with two objects of type ${a.runtimeType} and ${b.runtimeType}:\\n'\n    '  $a\\n'\n    '  $b\\n'\n    'However, only Border and BorderDirectional classes are supported by this method. '\n    'For a more general interpolation method, consider using ShapeBorder.lerp instead.'\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxBorder\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BoxBorder",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxBorder"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>This is an extension of the <a href=\"painting\/BoxBorder\/paint.html\">ShapeBorder.paint<\/a> method. It allows\n<a href=\"painting\/BoxBorder-class.html\">BoxBorder<\/a> borders to be applied to different <a href=\"painting\/BoxShape-class.html\">BoxShape<\/a>s and with\ndifferent <code>borderRadius<\/code> parameters, without changing the <a href=\"painting\/BoxBorder-class.html\">BoxBorder<\/a>\nobject itself.<\/p>\n<p>The <code>shape<\/code> argument specifies the <a href=\"painting\/BoxShape-class.html\">BoxShape<\/a> to draw the border on.<\/p>\n<p>If the <code>shape<\/code> is specifies a rectangular box shape\n(<a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>), then the <code>borderRadius<\/code> argument describes the\ncorners of the rectangle.<\/p>\n<p>The <a href=\"painting\/BoxBorder\/getInnerPath.html\">getInnerPath<\/a> and <a href=\"painting\/BoxBorder\/getOuterPath.html\">getOuterPath<\/a> methods do not know about the\n<code>shape<\/code> and <code>borderRadius<\/code> arguments.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/paintBorder.html\">paintBorder<\/a>, which is used if the border is not uniform.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(\n  Canvas canvas,\n  Rect rect, {\n  TextDirection textDirection,\n  BoxShape shape = BoxShape.rectangle,\n  BorderRadius borderRadius,\n});<\/code><\/pre>\n    ",
                    "href": "painting\/BoxBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxBorder",
                    "params": [
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BorderRadius"
                        },
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "shape",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxShape"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The bottom side of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">BorderSide get bottom;<\/code><\/pre>\n        ",
                    "href": "painting\/BoxBorder\/bottom.html",
                    "name": "bottom",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxBorder",
                    "params": []
                },
                {
                    "desc": "<p>Whether all four sides of the border are identical. Uniform borders are\ntypically more efficient to paint.<\/p>\n<p>A uniform border by definition has no text direction dependency and\ntherefore could be expressed as a <a href=\"painting\/Border-class.html\">Border<\/a>, even if it is currently a\n<a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. A uniform border can also be expressed as a\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isUniform;<\/code><\/pre>\n        ",
                    "href": "painting\/BoxBorder\/isUniform.html",
                    "name": "isUniform",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxBorder",
                    "params": []
                },
                {
                    "desc": "<p>The top side of this border.<\/p>\n<p>This getter is available on both <a href=\"painting\/Border-class.html\">Border<\/a> and <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a>. If\n<a href=\"painting\/BoxBorder\/isUniform.html\">isUniform<\/a> is true, then this is the same style as all the other sides.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">BorderSide get top;<\/code><\/pre>\n        ",
                    "href": "painting\/BoxBorder\/top.html",
                    "name": "top",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable description of how to paint a box.<\/p>\n<p>The <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> class provides a variety of ways to draw a box.<\/p>\n<p>The box has a <a href=\"painting\/BoxDecoration\/border.html\">border<\/a>, a body, and may cast a <a href=\"painting\/BoxDecoration\/boxShadow.html\">boxShadow<\/a>.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> of the box can be a circle or a rectangle. If it is a rectangle,\nthen the <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a> property controls the roundness of the corners.<\/p>\n<p>The body of the box is painted in layers. The bottom-most layer is the\n<a href=\"painting\/BoxDecoration\/color.html\">color<\/a>, which fills the box. Above that is the <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a>, which also fills\nthe box. Finally there is the <a href=\"painting\/BoxDecoration\/image.html\">image<\/a>, the precise alignment of which is\ncontrolled by the <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a> class.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/border.html\">border<\/a> paints over the body; the <a href=\"painting\/BoxDecoration\/boxShadow.html\">boxShadow<\/a>, naturally, paints below it.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe following example uses the <a href=\"widgets\/Container-class.html\">Container<\/a> widget from the widgets layer to\ndraw an image with a border:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    color: const Color(0xff7c94b6),\n    image: DecorationImage(\n      image: ExactAssetImage('images\/flowers.jpeg'),\n      fit: BoxFit.cover,\n    ),\n    border: Border.all(\n      color: Colors.black,\n      width: 8.0,\n    ),\n  ),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>The <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> or the <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a> won't clip the children of the\ndecorated <a href=\"widgets\/Container-class.html\">Container<\/a>. If the clip is required, insert a clip widget\n(e.g., <a href=\"widgets\/ClipRect-class.html\">ClipRect<\/a>, <a href=\"widgets\/ClipRRect-class.html\">ClipRRect<\/a>, <a href=\"widgets\/ClipPath-class.html\">ClipPath<\/a>) as the child of the <a href=\"widgets\/Container-class.html\">Container<\/a>.\nBe aware that clipping may be costly in terms of performance.\nSee also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> and <a href=\"widgets\/Container-class.html\">Container<\/a>, widgets that can be configured with\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> objects.<\/li>\n<li>\n<a href=\"widgets\/CustomPaint-class.html\">CustomPaint<\/a>, a widget that lets you draw arbitrary graphics.<\/li>\n<li>\n<a href=\"painting\/Decoration-class.html\">Decoration<\/a>, the base class which lets you define other decorations.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/BoxDecoration-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BoxDecoration",
            "shortname": "BoxDecoration",
            "extends": [
                "painting.Decoration",
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a box decoration.<\/p>\n<ul>\n<li>If <code>color<\/code> is null, this decoration does not paint a background color.<\/li>\n<li>If <code>image<\/code> is null, this decoration does not paint a background image.<\/li>\n<li>If <code>border<\/code> is null, this decoration does not paint a border.<\/li>\n<li>If <code>borderRadius<\/code> is null, this decoration uses more efficient background\npainting commands. The <code>borderRadius<\/code> argument must be null if <code>shape<\/code> is\n<a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a>.<\/li>\n<li>If <code>boxShadow<\/code> is null, this decoration does not paint a shadow.<\/li>\n<li>If <code>gradient<\/code> is null, this decoration does not paint gradients.<\/li>\n<li>If <code>backgroundBlendMode<\/code> is null, this decoration paints with <a href=\"dart-ui\/BlendMode-class.html\">BlendMode.srcOver<\/a>\n<\/li>\n<\/ul>\n<p>The <code>shape<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BoxDecoration({\n  this.color,\n  this.image,\n  this.border,\n  this.borderRadius,\n  this.boxShadow,\n  this.gradient,\n  this.backgroundBlendMode,\n  this.shape = BoxShape.rectangle,\n}) : assert(shape != null),\n     assert(\n       backgroundBlendMode == null || color != null || gradient != null,\n       'backgroundBlendMode applies to BoxDecoration\\'s background color or '\n       'gradient, but no color or gradient was provided.'\n     );<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/BoxDecoration.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BoxDecoration",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "backgroundBlendMode",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.BlendMode"
                        },
                        {
                            "name": "border",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BoxBorder"
                        },
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderRadiusGeometry"
                        },
                        {
                            "name": "boxShadow",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<painting.BoxShadow>"
                        },
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "gradient",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "image",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.DecorationImage"
                        },
                        {
                            "name": "shape",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BoxShape"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> that will paint this decoration.<\/p>\n<p>The <code>onChanged<\/code> argument configures <a href=\"painting\/BoxPainter\/onChanged.html\">BoxPainter.onChanged<\/a>. It can be\nomitted if there is no chance that the painter will change (for example,\nif it is a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> with definitely no <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\n_BoxDecorationPainter createBoxPainter([ VoidCallback onChanged ]) {\n  assert(onChanged != null || image == null);\n  return _BoxDecorationPainter(this, onChanged);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/createBoxPainter.html",
                    "isDeprecated": false,
                    "type": "<_BoxDecorationPainter>",
                    "name": "createBoxPainter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "onChanged",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                },
                {
                    "desc": "<p>In checked mode, throws an exception if the object is not in a\nvalid configuration. Otherwise, returns true.<\/p>\n<p>This is intended to be used as follows:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">assert(myDecoration.debugAssertIsValid());\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool debugAssertIsValid() {\n  assert(shape != BoxShape.circle ||\n        borderRadius == null); \/\/ Can't have a border radius if you're a circle.\n  return super.debugAssertIsValid();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/debugAssertIsValid.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "debugAssertIsValid",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"painting\/BoxDecoration\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/Diagnosticable\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties\n    ..defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.whitespace\n    ..emptyBodyDescription = '&lt;no decorations specified&gt;';\n\n  properties.add(DiagnosticsProperty&lt;Color&gt;('color', color, defaultValue: null));\n  properties.add(DiagnosticsProperty&lt;DecorationImage&gt;('image', image, defaultValue: null));\n  properties.add(DiagnosticsProperty&lt;BoxBorder&gt;('border', border, defaultValue: null));\n  properties.add(DiagnosticsProperty&lt;BorderRadiusGeometry&gt;('borderRadius', borderRadius, defaultValue: null));\n  properties.add(IterableProperty&lt;BoxShadow&gt;('boxShadow', boxShadow, defaultValue: null, style: DiagnosticsTreeStyle.whitespace));\n  properties.add(DiagnosticsProperty&lt;Gradient&gt;('gradient', gradient, defaultValue: null));\n  properties.add(EnumProperty&lt;BoxShape&gt;('shape', shape, defaultValue: BoxShape.rectangle));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Tests whether the given point, on a rectangle of a given size,\nwould be considered to hit the decoration or not. For example,\nif the decoration only draws a circle, this function might\nreturn true if the point was inside the circle and false\notherwise.<\/p>\n<p>The decoration may be sensitive to the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. The\n<code>textDirection<\/code> argument should therefore be provided. If it is known that\nthe decoration is not affected by the text direction, then the argument\nmay be omitted or set to null.<\/p>\n<p>When a <a href=\"painting\/Decoration-class.html\">Decoration<\/a> is painted in a <a href=\"widgets\/Container-class.html\">Container<\/a> or <a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> (which\nis what <a href=\"widgets\/Container-class.html\">Container<\/a> uses), the <code>textDirection<\/code> parameter will be populated\nbased on the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a> (by way of the <a href=\"rendering\/RenderDecoratedBox-class.html\">RenderDecoratedBox<\/a>\nrenderer).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool hitTest(Size size, Offset position, { TextDirection textDirection }) {\n  assert(shape != null);\n  assert((Offset.zero &amp; size).contains(position));\n  switch (shape) {\n    case BoxShape.rectangle:\n      if (borderRadius != null) {\n        final RRect bounds = borderRadius.resolve(textDirection).toRRect(Offset.zero &amp; size);\n        return bounds.contains(position);\n      }\n      return true;\n    case BoxShape.circle:\n      \/\/ Circles are inscribed into our smallest dimension.\n      final Offset center = size.center(Offset.zero);\n      final double distance = (position - center).distance;\n      return distance &lt;= math.min(size.width, size.height) \/ 2.0;\n  }\n  assert(shape != null);\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/hitTest.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "hitTest",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two box decorations.<\/p>\n<p>Interpolates each parameter of the box decoration separately.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> is not interpolated. To interpolate the shape, consider using\na <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> with different border shapes.<\/p>\n<p>If both values are null, this returns null. Otherwise, it returns a\nnon-null value. If one of the values is null, then the result is obtained\nby applying <a href=\"painting\/BoxDecoration\/scale.html\">scale<\/a> to the other value. If neither value is null and <code>t ==\n0.0<\/code>, then <code>a<\/code> is returned unmodified; if <code>t == 1.0<\/code> then <code>b<\/code> is returned\nunmodified. Otherwise, the values are computed by interpolating the\nproperties appropriately.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BoxDecoration\/lerp.html\">Decoration.lerp<\/a>, which can interpolate between any two types of\n<a href=\"painting\/Decoration-class.html\">Decoration<\/a>s, not just <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>s.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration\/lerpFrom.html\">lerpFrom<\/a> and <a href=\"painting\/BoxDecoration\/lerpTo.html\">lerpTo<\/a>, which are used to implement <a href=\"painting\/BoxDecoration\/lerp.html\">Decoration.lerp<\/a>\nand which use <a href=\"painting\/BoxDecoration\/lerp.html\">BoxDecoration.lerp<\/a> when interpolating two\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>s or a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> to or from null.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BoxDecoration lerp(BoxDecoration a, BoxDecoration b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  if (t == 0.0)\n    return a;\n  if (t == 1.0)\n    return b;\n  return BoxDecoration(\n    color: Color.lerp(a.color, b.color, t),\n    image: t &lt; 0.5 ? a.image : b.image, \/\/ TODO(ianh): cross-fade the image\n    border: BoxBorder.lerp(a.border, b.border, t),\n    borderRadius: BorderRadiusGeometry.lerp(a.borderRadius, b.borderRadius, t),\n    boxShadow: BoxShadow.lerpList(a.boxShadow, b.boxShadow, t),\n    gradient: Gradient.lerp(a.gradient, b.gradient, t),\n    shape: t &lt; 0.5 ? a.shape : b.shape,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BoxDecoration",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxDecoration"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxDecoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of a\ndifferent class) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/BoxDecoration\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/BoxDecoration\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>Supporting interpolating from null is recommended as the <a href=\"painting\/BoxDecoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/BoxDecoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxDecoration lerpFrom(Decoration a, double t) {\n  if (a == null)\n    return scale(t);\n  if (a is BoxDecoration)\n    return BoxDecoration.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.BoxDecoration",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of\na different class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/BoxDecoration\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/BoxDecoration\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>Supporting interpolating to null is recommended as the <a href=\"painting\/BoxDecoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/BoxDecoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxDecoration lerpTo(Decoration b, double t) {\n  if (b == null)\n    return scale(1.0 - t);\n  if (b is BoxDecoration)\n    return BoxDecoration.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.BoxDecoration",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new box decoration that is scaled by the given factor.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BoxDecoration scale(double factor) {\n  return BoxDecoration(\n    color: Color.lerp(null, color, factor),\n    image: image, \/\/ TODO(ianh): fade the image from transparent\n    border: BoxBorder.lerp(null, border, factor),\n    borderRadius: BorderRadiusGeometry.lerp(null, borderRadius, factor),\n    boxShadow: BoxShadow.lerpList(null, boxShadow, factor),\n    gradient: gradient?.scale(factor),\n    shape: shape,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxDecoration\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.BoxDecoration",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": [
                        {
                            "name": "factor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The blend mode applied to the <a href=\"painting\/BoxDecoration\/color.html\">color<\/a> or <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a> background of the box.<\/p>\n<p>If no <a href=\"painting\/BoxDecoration\/backgroundBlendMode.html\">backgroundBlendMode<\/a> is provided then the default painting blend\nmode is used.<\/p>\n<p>If no <a href=\"painting\/BoxDecoration\/color.html\">color<\/a> or <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a> is provided then the blend mode has no impact.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BlendMode backgroundBlendMode\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/backgroundBlendMode.html",
                    "name": "backgroundBlendMode",
                    "isDeprecated": false,
                    "type": "dart:ui.BlendMode",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>A border to draw above the background <a href=\"painting\/BoxDecoration\/color.html\">color<\/a>, <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a>, or <a href=\"painting\/BoxDecoration\/image.html\">image<\/a>.<\/p>\n<p>Follows the <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> and <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a>.<\/p>\n<p>Use <a href=\"painting\/Border-class.html\">Border<\/a> objects to describe borders that do not depend on the reading\ndirection.<\/p>\n<p>Use <a href=\"painting\/BoxBorder-class.html\">BoxBorder<\/a> objects to describe borders that should flip their left\nand right edges based on whether the text is being read left-to-right or\nright-to-left.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BoxBorder border\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/border.html",
                    "name": "border",
                    "isDeprecated": false,
                    "type": "painting.BoxBorder",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>If non-null, the corners of this box are rounded by this <a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>.<\/p>\n<p>Applies only to boxes with rectangular shapes; ignored if <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> is not\n<a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> or the <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a> won't clip the children of the\ndecorated <a href=\"widgets\/Container-class.html\">Container<\/a>. If the clip is required, insert a clip widget\n(e.g., <a href=\"widgets\/ClipRect-class.html\">ClipRect<\/a>, <a href=\"widgets\/ClipRRect-class.html\">ClipRRect<\/a>, <a href=\"widgets\/ClipPath-class.html\">ClipPath<\/a>) as the child of the <a href=\"widgets\/Container-class.html\">Container<\/a>.\nBe aware that clipping may be costly in terms of performance.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderRadiusGeometry borderRadius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/borderRadius.html",
                    "name": "borderRadius",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>A list of shadows cast by this box behind the box.<\/p>\n<p>The shadow follows the <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> of the box.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final List&lt;BoxShadow&gt; boxShadow\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/boxShadow.html",
                    "name": "boxShadow",
                    "isDeprecated": false,
                    "type": "dart:core.List<painting.BoxShadow>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The color to fill in the background of the box.<\/p>\n<p>The color is filled into the <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> of the box (e.g., either a rectangle,\npotentially with a <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a>, or a circle).<\/p>\n<p>This is ignored if <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a> is non-null.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/color.html\">color<\/a> is drawn under the <a href=\"painting\/BoxDecoration\/image.html\">image<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color color\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/color.html",
                    "name": "color",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>A gradient to use when filling the box.<\/p>\n<p>If this is specified, <a href=\"painting\/BoxDecoration\/color.html\">color<\/a> has no effect.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a> is drawn under the <a href=\"painting\/BoxDecoration\/image.html\">image<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Gradient gradient\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/gradient.html",
                    "name": "gradient",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BoxDecoration\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BoxDecoration\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BoxDecoration\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BoxDecoration\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BoxDecoration\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BoxDecoration\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode {\n  return hashValues(\n    color,\n    image,\n    border,\n    borderRadius,\n    boxShadow,\n    gradient,\n    shape,\n  );\n}<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>An image to paint above the background <a href=\"painting\/BoxDecoration\/color.html\">color<\/a> or <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a>.<\/p>\n<p>If <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> is <a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a> then the image is clipped to the circle's\nboundary; if <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a> is non-null then the image is clipped to the\ngiven radii.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final DecorationImage image\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/image.html",
                    "name": "image",
                    "isDeprecated": false,
                    "type": "painting.DecorationImage",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Whether this decoration is complex enough to benefit from caching its painting.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isComplex =&gt; boxShadow != null;<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/isComplex.html",
                    "name": "isComplex",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Returns the insets to apply when using this decoration on a box\nthat has contents, so that the contents do not overlap the edges\nof the decoration. For example, if the decoration draws a frame\naround its edge, the padding would return the distance by which\nto inset the children so as to not overlap the frame.<\/p>\n<p>This only works for decorations that have absolute sizes. If the padding\nneeded would change based on the size at which the decoration is drawn,\nthen this will return incorrect padding values.<\/p>\n<p>For example, when a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> has <a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a>, the padding\ndoes not take into account that the circle is drawn in the center of the\nbox regardless of the ratio of the box; it does not provide the extra\npadding that is implied by changing the ratio.<\/p>\n<p>The value returned by this getter must be resolved (using\n<a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">EdgeInsetsGeometry.resolve<\/a> to obtain an absolute <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>. (For\nexample, <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> will return an <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> for\nits <a href=\"painting\/BoxDecoration\/padding.html\">padding<\/a>.)<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get padding =&gt; border?.dimensions;<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/padding.html",
                    "name": "padding",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The shape to fill the background <a href=\"painting\/BoxDecoration\/color.html\">color<\/a>, <a href=\"painting\/BoxDecoration\/gradient.html\">gradient<\/a>, and <a href=\"painting\/BoxDecoration\/image.html\">image<\/a> into and\nto cast as the <a href=\"painting\/BoxDecoration\/boxShadow.html\">boxShadow<\/a>.<\/p>\n<p>If this is <a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a> then <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a> is ignored.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> cannot be interpolated; animating between two <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>s\nwith different <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a>s will result in a discontinuity in the rendering.\nTo interpolate between two shapes, consider using <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> and\ndifferent <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>s; in particular, <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a> instead of\n<a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a> and <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a> instead of\n<a href=\"painting\/BoxShape-class.html\">BoxShape.rectangle<\/a>.<\/p>\n<p>The <a href=\"painting\/BoxDecoration\/shape.html\">shape<\/a> or the <a href=\"painting\/BoxDecoration\/borderRadius.html\">borderRadius<\/a> won't clip the children of the\ndecorated <a href=\"widgets\/Container-class.html\">Container<\/a>. If the clip is required, insert a clip widget\n(e.g., <a href=\"widgets\/ClipRect-class.html\">ClipRect<\/a>, <a href=\"widgets\/ClipRRect-class.html\">ClipRRect<\/a>, <a href=\"widgets\/ClipPath-class.html\">ClipPath<\/a>) as the child of the <a href=\"widgets\/Container-class.html\">Container<\/a>.\nBe aware that clipping may be costly in terms of performance.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BoxShape shape\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxDecoration\/shape.html",
                    "name": "shape",
                    "isDeprecated": false,
                    "type": "painting.BoxShape",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxDecoration",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A stateful class that can paint a particular <a href=\"painting\/Decoration-class.html\">Decoration<\/a>.<\/p>\n<p><a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> objects can cache resources so that they can be used\nmultiple times.<\/p>\n<p>Some resources used by <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> may load asynchronously. When this\nhappens, the <a href=\"painting\/BoxPainter\/onChanged.html\">onChanged<\/a> callback will be invoked. To stop this callback\nfrom being called after the painter has been discarded, call <a href=\"painting\/BoxPainter\/dispose.html\">dispose<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/BoxPainter-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BoxPainter",
            "shortname": "BoxPainter",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [
                {
                    "desc": "<p>Callback that is invoked if an asynchronously-loading resource used by the\ndecoration finishes loading. For example, an image. When this is invoked,\nthe <a href=\"painting\/BoxPainter\/paint.html\">paint<\/a> method should be called again.<\/p>\n<p>Resources might not start to load until after <a href=\"painting\/BoxPainter\/paint.html\">paint<\/a> has been called,\nbecause they might depend on the configuration.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final VoidCallback onChanged\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxPainter\/onChanged.html",
                    "isDeprecated": false,
                    "type": "dart:ui.VoidCallback",
                    "name": "onChanged",
                    "memberOf": "painting.BoxPainter",
                    "params": []
                }
            ],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BoxPainter([this.onChanged]);<\/code><\/pre>\n    ",
                    "href": "painting\/BoxPainter\/BoxPainter.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BoxPainter",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BoxPainter",
                    "params": [
                        {
                            "name": "onChanged",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                },
                {
                    "desc": "<p>Discard any resources being held by the object.<\/p>\n<p>The <a href=\"painting\/BoxPainter\/onChanged.html\">onChanged<\/a> callback will not be invoked after this method has been\ncalled.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@mustCallSuper\nvoid dispose() { }<\/code><\/pre>\n    ",
                    "href": "painting\/BoxPainter\/dispose.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "dispose",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxPainter",
                    "params": []
                },
                {
                    "desc": "<p>Paints the <a href=\"painting\/Decoration-class.html\">Decoration<\/a> for which this object was created on the\ngiven canvas using the given configuration.<\/p>\n<p>The <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> object passed as the third argument must, at a\nminimum, have a non-null <a href=\"dart-ui\/Size-class.html\">Size<\/a>.<\/p>\n<p>If this object caches resources for painting (e.g. <a href=\"dart-ui\/Paint-class.html\">Paint<\/a> objects), the\ncache may be flushed when <a href=\"painting\/BoxPainter\/paint.html\">paint<\/a> is called with a new configuration. For\nthis reason, it may be more efficient to call\n<a href=\"painting\/Decoration\/createBoxPainter.html\">Decoration.createBoxPainter<\/a> for each different rectangle that is being\npainted in a particular frame.<\/p>\n<p>For example, if a decoration's owner wants to paint a particular\ndecoration once for its whole size, and once just in the bottom\nright, it might get two <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> instances, one for each.\nHowever, when its size changes, it could continue using those\nsame instances, since the previous resources would no longer be\nrelevant and thus losing them would not be an issue.<\/p>\n<p>Implementations should paint their decorations on the canvas in a\nrectangle whose top left corner is at the given <code>offset<\/code> and whose size is\ngiven by <code>configuration.size<\/code>.<\/p>\n<p>When a <a href=\"painting\/Decoration-class.html\">Decoration<\/a> is painted in a <a href=\"widgets\/Container-class.html\">Container<\/a> or <a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> (which\nis what <a href=\"widgets\/Container-class.html\">Container<\/a> uses), the <a href=\"painting\/ImageConfiguration\/textDirection.html\">ImageConfiguration.textDirection<\/a> property\nwill be populated based on the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void paint(Canvas canvas, Offset offset, ImageConfiguration configuration);<\/code><\/pre>\n    ",
                    "href": "painting\/BoxPainter\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxPainter",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        },
                        {
                            "name": "offset",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A shadow cast by a box.<\/p>\n<p>Inherits from <a href=\"dart-ui\/Shadow-class.html\">Shadow<\/a><\/p>\n<p><a href=\"painting\/BoxShadow-class.html\">BoxShadow<\/a> can cast non-rectangular shadows if the box is non-rectangular\n(e.g., has a border radius or a circular shape).<\/p>\n<p>This class is similar to CSS box-shadow.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"dart-ui\/Canvas\/drawShadow.html\">Canvas.drawShadow<\/a>, which is a more efficient way to draw shadows.<\/li>\n<li>\n<a href=\"dart-ui\/Shadow-class.html\">Shadow<\/a>, which is the parent class that lacks <a href=\"painting\/BoxShadow\/spreadRadius.html\">spreadRadius<\/a>.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/BoxShadow-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BoxShadow",
            "shortname": "BoxShadow",
            "extends": [
                "dart:ui.Shadow",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a box shadow.<\/p>\n<p>By default, the shadow is solid black with zero <code>offset<\/code>, <code>blurRadius<\/code>,\nand <code>spreadRadius<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const BoxShadow({\n  Color color = const Color(0xFF000000),\n  Offset offset = Offset.zero,\n  double blurRadius = 0.0,\n  this.spreadRadius = 0.0,\n}) : super(color: color, offset: offset, blurRadius: blurRadius);<\/code><\/pre>\n    ",
                    "href": "painting\/BoxShadow\/BoxShadow.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "BoxShadow",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.BoxShadow",
                    "params": [
                        {
                            "name": "blurRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "offset",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Offset"
                        },
                        {
                            "name": "spreadRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two box shadows.<\/p>\n<p>If either box shadow is null, this function linearly interpolates from a\na box shadow that matches the other box shadow in color but has a zero\noffset and a zero blurRadius.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static BoxShadow lerp(BoxShadow a, BoxShadow b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  return BoxShadow(\n    color: Color.lerp(a.color, b.color, t),\n    offset: Offset.lerp(a.offset, b.offset, t),\n    blurRadius: ui.lerpDouble(a.blurRadius, b.blurRadius, t),\n    spreadRadius: ui.lerpDouble(a.spreadRadius, b.spreadRadius, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxShadow\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.BoxShadow",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxShadow",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxShadow"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.BoxShadow"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two lists of box shadows.<\/p>\n<p>If the lists differ in length, excess items are lerped with null.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static List&lt;BoxShadow&gt; lerpList(List&lt;BoxShadow&gt; a, List&lt;BoxShadow&gt; b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  a ??= &lt;BoxShadow&gt;[];\n  b ??= &lt;BoxShadow&gt;[];\n  final List&lt;BoxShadow&gt; result = &lt;BoxShadow&gt;[];\n  final int commonLength = math.min(a.length, b.length);\n  for (int i = 0; i &lt; commonLength; i += 1)\n    result.add(BoxShadow.lerp(a[i], b[i], t));\n  for (int i = commonLength; i &lt; a.length; i += 1)\n    result.add(a[i].scale(1.0 - t));\n  for (int i = commonLength; i &lt; b.length; i += 1)\n    result.add(b[i].scale(t));\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxShadow\/lerpList.html",
                    "isDeprecated": false,
                    "type": "dart:core.List<painting.BoxShadow>",
                    "name": "lerpList",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxShadow",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.List<painting.BoxShadow>"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.List<painting.BoxShadow>"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new box shadow with its offset, blurRadius, and spreadRadius scaled by the given factor.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxShadow scale(double factor) {\n  return BoxShadow(\n    color: color,\n    offset: offset * factor,\n    blurRadius: blurRadius * factor,\n    spreadRadius: spreadRadius * factor,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxShadow\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.BoxShadow",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxShadow",
                    "params": [
                        {
                            "name": "factor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Create the <a href=\"dart-ui\/Paint-class.html\">Paint<\/a> object that corresponds to this shadow description.<\/p>\n<p>The <a href=\"dart-ui\/Shadow\/offset.html\">offset<\/a> and <a href=\"painting\/BoxShadow\/spreadRadius.html\">spreadRadius<\/a> are not represented in the <a href=\"dart-ui\/Paint-class.html\">Paint<\/a> object.\nTo honor those as well, the shape should be inflated by <a href=\"painting\/BoxShadow\/spreadRadius.html\">spreadRadius<\/a> pixels\nin every direction and then translated by <a href=\"dart-ui\/Shadow\/offset.html\">offset<\/a> before being filled using\nthis <a href=\"dart-ui\/Paint-class.html\">Paint<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPaint toPaint() {\n  final Paint result = Paint()\n    ..color = color\n    ..maskFilter = MaskFilter.blur(BlurStyle.normal, blurSigma);\n  assert(() {\n    if (debugDisableShadows)\n      result.maskFilter = null;\n    return true;\n  }());\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/BoxShadow\/toPaint.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Paint",
                    "name": "toPaint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxShadow",
                    "params": []
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; 'BoxShadow($color, $offset, $blurRadius, $spreadRadius)';<\/code><\/pre>\n    ",
                    "href": "painting\/BoxShadow\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.BoxShadow",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/BoxShadow\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/BoxShadow\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/BoxShadow\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/BoxShadow\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/BoxShadow\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/BoxShadow\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(color, offset, blurRadius, spreadRadius);<\/code><\/pre>\n        ",
                    "href": "painting\/BoxShadow\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxShadow",
                    "params": []
                },
                {
                    "desc": "<p>The amount the box should be inflated prior to applying the blur.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double spreadRadius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/BoxShadow\/spreadRadius.html",
                    "name": "spreadRadius",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.BoxShadow",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A border that fits a circle within the available space.<\/p>\n<p>Typically used with <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> to draw a circle.<\/p>\n<p>The <a href=\"painting\/CircleBorder\/dimensions.html\">dimensions<\/a> assume that the border is being used in a square space.\nWhen applied to a rectangular space, the border paints in the center of the\nrectangle.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe each side of the box.<\/li>\n<li>\n<a href=\"painting\/Border-class.html\">Border<\/a>, which, when used with <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, can also\ndescribe a circle.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/CircleBorder-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.CircleBorder",
            "shortname": "CircleBorder",
            "extends": [
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Create a circle border.<\/p>\n<p>The <code>side<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const CircleBorder({ this.side = BorderSide.none }) : assert(side != null);<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/CircleBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "CircleBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "side",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/CircleBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/CircleBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/CircleBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getInnerPath(Rect rect, { TextDirection textDirection }) {\n  return Path()\n    ..addOval(Rect.fromCircle(\n      center: rect.center,\n      radius: math.max(0.0, rect.shortestSide \/ 2.0 - side.width),\n    ));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/CircleBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/CircleBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/CircleBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect rect, { TextDirection textDirection }) {\n  return Path()\n    ..addOval(Rect.fromCircle(\n      center: rect.center,\n      radius: rect.shortestSide \/ 2.0,\n    ));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/CircleBorder\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/CircleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  if (a is CircleBorder)\n    return CircleBorder(side: BorderSide.lerp(a.side, side, t));\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/CircleBorder\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/CircleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  if (b is CircleBorder)\n    return CircleBorder(side: BorderSide.lerp(side, b.side, t));\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(Canvas canvas, Rect rect, { TextDirection textDirection }) {\n  switch (side.style) {\n    case BorderStyle.none:\n      break;\n    case BorderStyle.solid:\n      canvas.drawCircle(rect.center, (rect.shortestSide - side.width) \/ 2.0, side.toPaint());\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/CircleBorder\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder scale(double t) =&gt; CircleBorder(side: side.scale(t));<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($side)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircleBorder\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircleBorder",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/CircleBorder\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/CircleBorder\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsets.all(side.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/CircleBorder\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.CircleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/CircleBorder\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/CircleBorder\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/CircleBorder\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/CircleBorder\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/CircleBorder\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/CircleBorder\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; side.hashCode;<\/code><\/pre>\n        ",
                    "href": "painting\/CircleBorder\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.CircleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The style of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide side\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/CircleBorder\/side.html",
                    "name": "side",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.CircleBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A rectangle with a smooth circular notch.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>, a <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> that describes a circle.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/CircularNotchedRectangle-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.CircularNotchedRectangle",
            "shortname": "CircularNotchedRectangle",
            "extends": [
                "painting.NotchedShape",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a <a href=\"painting\/CircularNotchedRectangle-class.html\">CircularNotchedRectangle<\/a>.<\/p>\n<p>The same object can be used to create multiple shapes.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const CircularNotchedRectangle();<\/code><\/pre>\n    ",
                    "href": "painting\/CircularNotchedRectangle\/CircularNotchedRectangle.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "CircularNotchedRectangle",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.CircularNotchedRectangle",
                    "params": []
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes a rectangle with a smooth circular notch.<\/p>\n<p><code>host<\/code> is the bounding box for the returned shape. Conceptually this is\nthe rectangle to which the notch will be applied.<\/p>\n<p><code>guest<\/code> is the bounding box of a circle that the notch accommodates. All\npoints in the circle bounded by <code>guest<\/code> will be outside of the returned\npath.<\/p>\n<p>The notch is curve that smoothly connects the host's top edge and\nthe guest circle.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">\/\/ TODO(amirh): add an example diagram here.\n@override\nPath getOuterPath(Rect host, Rect guest) {\n  if (guest == null || !host.overlaps(guest))\n    return Path()..addRect(host);\n\n  \/\/ The guest's shape is a circle bounded by the guest rectangle.\n  \/\/ So the guest's radius is half the guest width.\n  final double notchRadius = guest.width \/ 2.0;\n\n  \/\/ We build a path for the notch from 3 segments:\n  \/\/ Segment A - a Bezier curve from the host's top edge to segment B.\n  \/\/ Segment B - an arc with radius notchRadius.\n  \/\/ Segment C - a Bezier curve from segment B back to the host's top edge.\n  \/\/\n  \/\/ A detailed explanation and the derivation of the formulas below is\n  \/\/ available at: https:\/\/goo.gl\/Ufzrqn\n\n  const double s1 = 15.0;\n  const double s2 = 1.0;\n\n  final double r = notchRadius;\n  final double a = -1.0 * r - s2;\n  final double b = host.top - guest.center.dy;\n\n  final double n2 = math.sqrt(b * b * r * r * (a * a + b * b - r * r));\n  final double p2xA = ((a * r * r) - n2) \/ (a * a + b * b);\n  final double p2xB = ((a * r * r) + n2) \/ (a * a + b * b);\n  final double p2yA = math.sqrt(r * r - p2xA * p2xA);\n  final double p2yB = math.sqrt(r * r - p2xB * p2xB);\n\n  final List&lt;Offset&gt; p = List&lt;Offset&gt;(6);\n\n  \/\/ p0, p1, and p2 are the control points for segment A.\n  p[0] = Offset(a - s1, b);\n  p[1] = Offset(a, b);\n  final double cmp = b &lt; 0 ? -1.0 : 1.0;\n  p[2] = cmp * p2yA &gt; cmp * p2yB ? Offset(p2xA, p2yA) : Offset(p2xB, p2yB);\n\n  \/\/ p3, p4, and p5 are the control points for segment B, which is a mirror\n  \/\/ of segment A around the y axis.\n  p[3] = Offset(-1.0 * p[2].dx, p[2].dy);\n  p[4] = Offset(-1.0 * p[1].dx, p[1].dy);\n  p[5] = Offset(-1.0 * p[0].dx, p[0].dy);\n\n  \/\/ translate all points back to the absolute coordinate system.\n  for (int i = 0; i &lt; p.length; i += 1)\n    p[i] += guest.center;\n\n  return Path()\n    ..moveTo(host.left, host.top)\n    ..lineTo(p[0].dx, p[0].dy)\n    ..quadraticBezierTo(p[1].dx, p[1].dy, p[2].dx, p[2].dy)\n    ..arcToPoint(\n      p[3],\n      radius: Radius.circular(notchRadius),\n      clockwise: false,\n    )\n    ..quadraticBezierTo(p[4].dx, p[4].dy, p[5].dx, p[5].dy)\n    ..lineTo(host.right, host.top)\n    ..lineTo(host.right, host.bottom)\n    ..lineTo(host.left, host.bottom)\n    ..close();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/CircularNotchedRectangle\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.CircularNotchedRectangle",
                    "params": [
                        {
                            "name": "guest",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "host",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Clip utilities used by <a href=\"rendering\/PaintingContext-class.html\">PaintingContext<\/a> and <code>TestRecordingPaintingContext<\/code>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/ClipContext-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ClipContext",
            "shortname": "ClipContext",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "rendering.PaintingContext"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "painting\/ClipContext\/ClipContext.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ClipContext",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ClipContext",
                    "params": []
                },
                {
                    "desc": "<p>Clip <a href=\"painting\/ClipContext\/canvas.html\">canvas<\/a> with <a href=\"dart-ui\/Path-class.html\">Path<\/a> according to <a href=\"dart-ui\/Clip-class.html\">Clip<\/a> and then paint. <a href=\"painting\/ClipContext\/canvas.html\">canvas<\/a> is\nrestored to the pre-clip status afterwards.<\/p>\n<p><code>bounds<\/code> is the saveLayer bounds used for <a href=\"dart-ui\/Clip-class.html\">Clip.antiAliasWithSaveLayer<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void clipPathAndPaint(Path path, Clip clipBehavior, Rect bounds, void painter()) {\n  _clipAndPaint((bool doAntiAias) =&gt; canvas.clipPath(path, doAntiAlias: doAntiAias), clipBehavior, bounds, painter);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ClipContext\/clipPathAndPaint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "clipPathAndPaint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ClipContext",
                    "params": [
                        {
                            "name": "bounds",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "clipBehavior",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Clip"
                        },
                        {
                            "name": "painter",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "path",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Path"
                        }
                    ]
                },
                {
                    "desc": "<p>Clip <a href=\"painting\/ClipContext\/canvas.html\">canvas<\/a> with <a href=\"dart-ui\/Path-class.html\">Path<\/a> according to <a href=\"dart-ui\/RRect-class.html\">RRect<\/a> and then paint. <a href=\"painting\/ClipContext\/canvas.html\">canvas<\/a> is\nrestored to the pre-clip status afterwards.<\/p>\n<p><code>bounds<\/code> is the saveLayer bounds used for <a href=\"dart-ui\/Clip-class.html\">Clip.antiAliasWithSaveLayer<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void clipRRectAndPaint(RRect rrect, Clip clipBehavior, Rect bounds, void painter()) {\n  _clipAndPaint((bool doAntiAias) =&gt; canvas.clipRRect(rrect, doAntiAlias: doAntiAias), clipBehavior, bounds, painter);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ClipContext\/clipRRectAndPaint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "clipRRectAndPaint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ClipContext",
                    "params": [
                        {
                            "name": "bounds",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "clipBehavior",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Clip"
                        },
                        {
                            "name": "painter",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "rrect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.RRect"
                        }
                    ]
                },
                {
                    "desc": "<p>Clip <a href=\"painting\/ClipContext\/canvas.html\">canvas<\/a> with <a href=\"dart-ui\/Path-class.html\">Path<\/a> according to <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> and then paint. <a href=\"painting\/ClipContext\/canvas.html\">canvas<\/a> is\nrestored to the pre-clip status afterwards.<\/p>\n<p><code>bounds<\/code> is the saveLayer bounds used for <a href=\"dart-ui\/Clip-class.html\">Clip.antiAliasWithSaveLayer<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void clipRectAndPaint(Rect rect, Clip clipBehavior, Rect bounds, void painter()) {\n  _clipAndPaint((bool doAntiAias) =&gt; canvas.clipRect(rect, doAntiAlias: doAntiAias), clipBehavior, bounds, painter);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ClipContext\/clipRectAndPaint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "clipRectAndPaint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ClipContext",
                    "params": [
                        {
                            "name": "bounds",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "clipBehavior",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Clip"
                        },
                        {
                            "name": "painter",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<void>"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The canvas on which to paint.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Canvas get canvas;<\/code><\/pre>\n        ",
                    "href": "painting\/ClipContext\/canvas.html",
                    "name": "canvas",
                    "isDeprecated": false,
                    "type": "dart:ui.Canvas",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ClipContext",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A color that has a small table of related colors called a \"swatch\".<\/p>\n<p>The table is indexed by values of type <code>T<\/code>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"material\/MaterialColor-class.html\">MaterialColor<\/a> and <a href=\"material\/MaterialAccentColor-class.html\">MaterialAccentColor<\/a>, which define material design\nprimary and accent color swatches.<\/li>\n<li>\n<a href=\"material\/Colors-class.html\">material.Colors<\/a>, which defines all of the standard material design\ncolors.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ColorSwatch-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ColorSwatch",
            "shortname": "ColorSwatch",
            "extends": [
                "dart:ui.Color",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "material.MaterialAccentColor",
                "material.MaterialColor"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a color that has a small table of related colors called a \"swatch\".<\/p>\n<p>The <code>primary<\/code> argument should be the 32 bit ARGB value of one of the\nvalues in the swatch, as would be passed to the <a href=\"dart-ui\/Color\/Color.html\">new Color<\/a> constructor\nfor that same color, and as is exposed by <a href=\"dart-ui\/Color\/value.html\">value<\/a>. (This is distinct from\nthe specific index of the color in the swatch.)<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ColorSwatch(int primary, this._swatch) : super(primary);<\/code><\/pre>\n    ",
                    "href": "painting\/ColorSwatch\/ColorSwatch.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ColorSwatch",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ColorSwatch",
                    "params": [
                        {
                            "name": "_swatch",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.Map<dart:ui.Color>"
                        },
                        {
                            "name": "primary",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(primary value: ${super.toString()})';<\/code><\/pre>\n    ",
                    "href": "painting\/ColorSwatch\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ColorSwatch",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/ColorSwatch\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/ColorSwatch\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/ColorSwatch\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/ColorSwatch\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/ColorSwatch\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/ColorSwatch\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(runtimeType, value, _swatch);<\/code><\/pre>\n        ",
                    "href": "painting\/ColorSwatch\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ColorSwatch",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A rectangular border with smooth continuous transitions between the straight\nsides and the rounded corners.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Widget build(BuildContext context) {\n  return Material(\n    shape: ContinuousRectangleBorder(\n      borderRadius: BorderRadius.circular(28.0),\n    ),\n  );\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a> Which creates rectangles with rounded corners,\nhowever its straight sides change into a rounded corner with a circular\nradius in a step function instead of gradually like the\n<a href=\"painting\/ContinuousRectangleBorder-class.html\">ContinuousRectangleBorder<\/a>.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ContinuousRectangleBorder-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ContinuousRectangleBorder",
            "shortname": "ContinuousRectangleBorder",
            "extends": [
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ContinuousRectangleBorder({\n  this.side = BorderSide.none,\n  this.borderRadius = BorderRadius.zero,\n}) : assert(side != null),\n     assert(borderRadius != null);<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/ContinuousRectangleBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ContinuousRectangleBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderRadiusGeometry"
                        },
                        {
                            "name": "side",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/ContinuousRectangleBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/ContinuousRectangleBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ContinuousRectangleBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getInnerPath(Rect rect, { TextDirection textDirection }) {\n  return _getPath(borderRadius.resolve(textDirection).toRRect(rect).deflate(side.width));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/ContinuousRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/ContinuousRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ContinuousRectangleBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect rect, { TextDirection textDirection }) {\n  return _getPath(borderRadius.resolve(textDirection).toRRect(rect));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/ContinuousRectangleBorder\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/ContinuousRectangleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  assert(t != null);\n  if (a is ContinuousRectangleBorder) {\n    return ContinuousRectangleBorder(\n      side: BorderSide.lerp(a.side, side, t),\n      borderRadius: BorderRadiusGeometry.lerp(a.borderRadius, borderRadius, t),\n    );\n  }\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/ContinuousRectangleBorder\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/ContinuousRectangleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  assert(t != null);\n  if (b is ContinuousRectangleBorder) {\n    return ContinuousRectangleBorder(\n      side: BorderSide.lerp(side, b.side, t),\n      borderRadius: BorderRadiusGeometry.lerp(borderRadius, b.borderRadius, t),\n    );\n  }\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(Canvas canvas, Rect rect, { TextDirection textDirection }) {\n  if (rect.isEmpty)\n    return;\n  switch (side.style) {\n    case BorderStyle.none:\n    break;\n    case BorderStyle.solid:\n      final Path path = getOuterPath(rect, textDirection: textDirection);\n      final Paint paint = side.toPaint();\n      canvas.drawPath(path, paint);\n      break;\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/ContinuousRectangleBorder\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder scale(double t) {\n  return ContinuousRectangleBorder(\n    side: side.scale(t),\n    borderRadius: borderRadius * t,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($side, $borderRadius)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ContinuousRectangleBorder\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The radius for each corner.<\/p>\n<p>Negative radius values are clamped to 0.0 by <a href=\"painting\/ContinuousRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> and\n<a href=\"painting\/ContinuousRectangleBorder\/getOuterPath.html\">getOuterPath<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderRadiusGeometry borderRadius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ContinuousRectangleBorder\/borderRadius.html",
                    "name": "borderRadius",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/ContinuousRectangleBorder\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/ContinuousRectangleBorder\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions =&gt; EdgeInsets.all(side.width);<\/code><\/pre>\n        ",
                    "href": "painting\/ContinuousRectangleBorder\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/ContinuousRectangleBorder\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/ContinuousRectangleBorder\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/ContinuousRectangleBorder\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/ContinuousRectangleBorder\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/ContinuousRectangleBorder\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/ContinuousRectangleBorder\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(side, borderRadius);<\/code><\/pre>\n        ",
                    "href": "painting\/ContinuousRectangleBorder\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The style of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide side\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ContinuousRectangleBorder\/side.html",
                    "name": "side",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ContinuousRectangleBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A description of a box decoration (a decoration applied to a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a>).<\/p>\n<p>This class presents the abstract interface for all decorations.\nSee <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> for a concrete example.<\/p>\n<p>To actually paint a <a href=\"painting\/Decoration-class.html\">Decoration<\/a>, use the <a href=\"painting\/Decoration\/createBoxPainter.html\">createBoxPainter<\/a>\nmethod to obtain a <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a>. <a href=\"painting\/Decoration-class.html\">Decoration<\/a> objects can be\nshared between boxes; <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> objects can cache resources to\nmake painting on a particular surface faster.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/Decoration-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.Decoration",
            "shortname": "Decoration",
            "extends": [
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "material.UnderlineTabIndicator",
                "painting.BoxDecoration",
                "painting.FlutterLogoDecoration",
                "painting.ShapeDecoration",
                "widgets.DecorationTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const Decoration();<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/Decoration.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Decoration",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": []
                },
                {
                    "desc": "<p>Returns a <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> that will paint this decoration.<\/p>\n<p>The <code>onChanged<\/code> argument configures <a href=\"painting\/BoxPainter\/onChanged.html\">BoxPainter.onChanged<\/a>. It can be\nomitted if there is no chance that the painter will change (for example,\nif it is a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> with definitely no <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">BoxPainter createBoxPainter([ VoidCallback onChanged ]);<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/createBoxPainter.html",
                    "isDeprecated": false,
                    "type": "painting.BoxPainter",
                    "name": "createBoxPainter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": [
                        {
                            "name": "onChanged",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                },
                {
                    "desc": "<p>In checked mode, throws an exception if the object is not in a\nvalid configuration. Otherwise, returns true.<\/p>\n<p>This is intended to be used as follows:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">assert(myDecoration.debugAssertIsValid());\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool debugAssertIsValid() =&gt; true;<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/debugAssertIsValid.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "debugAssertIsValid",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": []
                },
                {
                    "desc": "<p>Tests whether the given point, on a rectangle of a given size,\nwould be considered to hit the decoration or not. For example,\nif the decoration only draws a circle, this function might\nreturn true if the point was inside the circle and false\notherwise.<\/p>\n<p>The decoration may be sensitive to the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. The\n<code>textDirection<\/code> argument should therefore be provided. If it is known that\nthe decoration is not affected by the text direction, then the argument\nmay be omitted or set to null.<\/p>\n<p>When a <a href=\"painting\/Decoration-class.html\">Decoration<\/a> is painted in a <a href=\"widgets\/Container-class.html\">Container<\/a> or <a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> (which\nis what <a href=\"widgets\/Container-class.html\">Container<\/a> uses), the <code>textDirection<\/code> parameter will be populated\nbased on the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a> (by way of the <a href=\"rendering\/RenderDecoratedBox-class.html\">RenderDecoratedBox<\/a>\nrenderer).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool hitTest(Size size, Offset position, { TextDirection textDirection }) =&gt; true;<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/hitTest.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "hitTest",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": [
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates between two <a href=\"painting\/Decoration-class.html\">Decoration<\/a>s.<\/p>\n<p>This attempts to use <a href=\"painting\/Decoration\/lerpFrom.html\">lerpFrom<\/a> and <a href=\"painting\/Decoration\/lerpTo.html\">lerpTo<\/a> on <code>b<\/code> and <code>a<\/code>\nrespectively to find a solution. If the two values can't directly be\ninterpolated, then the interpolation is done via null (at <code>t == 0.5<\/code>).<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Decoration lerp(Decoration a, Decoration b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.lerpFrom(null, t) ?? b;\n  if (b == null)\n    return a.lerpTo(null, t) ?? a;\n  if (t == 0.0)\n    return a;\n  if (t == 1.0)\n    return b;\n  return b.lerpFrom(a, t)\n      ?? a.lerpTo(b, t)\n      ?? (t &lt; 0.5 ? (a.lerpTo(null, t * 2.0) ?? a) : (b.lerpFrom(null, (t - 0.5) * 2.0) ?? b));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.Decoration",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of a\ndifferent class) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/Decoration\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/Decoration\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>Supporting interpolating from null is recommended as the <a href=\"painting\/Decoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/Decoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nDecoration lerpFrom(Decoration a, double t) =&gt; null;<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.Decoration",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of\na different class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/Decoration\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/Decoration\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>Supporting interpolating to null is recommended as the <a href=\"painting\/Decoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/Decoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nDecoration lerpTo(Decoration b, double t) =&gt; null;<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.Decoration",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>A brief description of this object, usually just the <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and the\n<a href=\"dart-core\/Object\/hashCode.html\">hashCode<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>, for a detailed description of the object.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toStringShort() =&gt; '$runtimeType';<\/code><\/pre>\n    ",
                    "href": "painting\/Decoration\/toStringShort.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toStringShort",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Decoration",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>Whether this decoration is complex enough to benefit from caching its painting.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isComplex =&gt; false;<\/code><\/pre>\n        ",
                    "href": "painting\/Decoration\/isComplex.html",
                    "name": "isComplex",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Decoration",
                    "params": []
                },
                {
                    "desc": "<p>Returns the insets to apply when using this decoration on a box\nthat has contents, so that the contents do not overlap the edges\nof the decoration. For example, if the decoration draws a frame\naround its edge, the padding would return the distance by which\nto inset the children so as to not overlap the frame.<\/p>\n<p>This only works for decorations that have absolute sizes. If the padding\nneeded would change based on the size at which the decoration is drawn,\nthen this will return incorrect padding values.<\/p>\n<p>For example, when a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> has <a href=\"painting\/BoxShape-class.html\">BoxShape.circle<\/a>, the padding\ndoes not take into account that the circle is drawn in the center of the\nbox regardless of the ratio of the box; it does not provide the extra\npadding that is implied by changing the ratio.<\/p>\n<p>The value returned by this getter must be resolved (using\n<a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">EdgeInsetsGeometry.resolve<\/a> to obtain an absolute <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>. (For\nexample, <a href=\"painting\/BorderDirectional-class.html\">BorderDirectional<\/a> will return an <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> for\nits <a href=\"painting\/Decoration\/padding.html\">padding<\/a>.)<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsetsGeometry get padding =&gt; EdgeInsets.zero;<\/code><\/pre>\n        ",
                    "href": "painting\/Decoration\/padding.html",
                    "name": "padding",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Decoration",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An image for a box decoration.<\/p>\n<p>The image is painted using <a href=\"painting\/paintImage.html\">paintImage<\/a>, which describes the meanings of the\nvarious fields on this class in more detail.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/DecorationImage-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.DecorationImage",
            "shortname": "DecorationImage",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an image to show in a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>.<\/p>\n<p>The <code>image<\/code>, <code>alignment<\/code>, <code>repeat<\/code>, and <code>matchTextDirection<\/code> arguments\nmust not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const DecorationImage({\n  @required this.image,\n  this.colorFilter,\n  this.fit,\n  this.alignment = Alignment.center,\n  this.centerSlice,\n  this.repeat = ImageRepeat.noRepeat,\n  this.matchTextDirection = false,\n}) : assert(image != null),\n     assert(alignment != null),\n     assert(repeat != null),\n     assert(matchTextDirection != null);<\/code><\/pre>\n    ",
                    "href": "painting\/DecorationImage\/DecorationImage.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "DecorationImage",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.DecorationImage",
                    "params": [
                        {
                            "name": "alignment",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "centerSlice",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "colorFilter",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.ColorFilter"
                        },
                        {
                            "name": "fit",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BoxFit"
                        },
                        {
                            "name": "image",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.ImageProvider"
                        },
                        {
                            "name": "matchTextDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "repeat",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.ImageRepeat"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"painting\/DecorationImagePainter-class.html\">DecorationImagePainter<\/a> for this <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a>.<\/p>\n<p>The <code>onChanged<\/code> argument must not be null. It will be called whenever the\nimage needs to be repainted, e.g. because it is loading incrementally or\nbecause it is animated.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">DecorationImagePainter createPainter(VoidCallback onChanged) {\n  assert(onChanged != null);\n  return DecorationImagePainter._(this, onChanged);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/DecorationImage\/createPainter.html",
                    "isDeprecated": false,
                    "type": "painting.DecorationImagePainter",
                    "name": "createPainter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.DecorationImage",
                    "params": [
                        {
                            "name": "onChanged",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  final List&lt;String&gt; properties = &lt;String&gt;[];\n  properties.add('$image');\n  if (colorFilter != null)\n    properties.add('$colorFilter');\n  if (fit != null &amp;&amp;\n      !(fit == BoxFit.fill &amp;&amp; centerSlice != null) &amp;&amp;\n      !(fit == BoxFit.scaleDown &amp;&amp; centerSlice == null))\n    properties.add('$fit');\n  properties.add('$alignment');\n  if (centerSlice != null)\n    properties.add('centerSlice: $centerSlice');\n  if (repeat != ImageRepeat.noRepeat)\n    properties.add('$repeat');\n  if (matchTextDirection)\n    properties.add('match text direction');\n  return '$runtimeType(${properties.join(\", \")})';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/DecorationImage\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>How to align the image within its bounds.<\/p>\n<p>The alignment aligns the given position in the image to the given position\nin the layout bounds. For example, an <a href=\"painting\/Alignment-class.html\">Alignment<\/a> alignment of (-1.0,\n-1.0) aligns the image to the top-left corner of its layout bounds, while a\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a> alignment of (1.0, 1.0) aligns the bottom right of the\nimage with the bottom right corner of its layout bounds. Similarly, an\nalignment of (0.0, 1.0) aligns the bottom middle of the image with the\nmiddle of the bottom edge of its layout bounds.<\/p>\n<p>To display a subpart of an image, consider using a <a href=\"rendering\/CustomPainter-class.html\">CustomPainter<\/a> and\n<a href=\"dart-ui\/Canvas\/drawImageRect.html\">Canvas.drawImageRect<\/a>.<\/p>\n<p>If the <a href=\"painting\/DecorationImage\/alignment.html\">alignment<\/a> is <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>-dependent (i.e. if it is a\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>), then a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a> must be available\nwhen the image is painted.<\/p>\n<p>Defaults to <a href=\"painting\/Alignment\/center-constant.html\">Alignment.center<\/a>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a>, a class with convenient constants typically used to\nspecify an <a href=\"painting\/AlignmentGeometry-class.html\">AlignmentGeometry<\/a>.<\/li>\n<li>\n<a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, like <a href=\"painting\/Alignment-class.html\">Alignment<\/a> for specifying alignments\nrelative to text direction.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AlignmentGeometry alignment\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/alignment.html",
                    "name": "alignment",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>The center slice for a nine-patch image.<\/p>\n<p>The region of the image inside the center slice will be stretched both\nhorizontally and vertically to fit the image into its destination. The\nregion of the image above and below the center slice will be stretched\nonly horizontally and the region of the image to the left and right of\nthe center slice will be stretched only vertically.<\/p>\n<p>The stretching will be applied in order to make the image fit into the box\nspecified by <a href=\"painting\/DecorationImage\/fit.html\">fit<\/a>. When <a href=\"painting\/DecorationImage\/centerSlice.html\">centerSlice<\/a> is not null, <a href=\"painting\/DecorationImage\/fit.html\">fit<\/a> defaults to\n<a href=\"painting\/BoxFit-class.html\">BoxFit.fill<\/a>, which distorts the destination image size relative to the\nimage's original aspect ratio. Values of <a href=\"painting\/BoxFit-class.html\">BoxFit<\/a> which do not distort the\ndestination image size will result in <a href=\"painting\/DecorationImage\/centerSlice.html\">centerSlice<\/a> having no effect\n(since the nine regions of the image will be rendered with the same\nscaling, as if it wasn't specified).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Rect centerSlice\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/centerSlice.html",
                    "name": "centerSlice",
                    "isDeprecated": false,
                    "type": "dart:ui.Rect",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>A color filter to apply to the image before painting it.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ColorFilter colorFilter\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/colorFilter.html",
                    "name": "colorFilter",
                    "isDeprecated": false,
                    "type": "dart:ui.ColorFilter",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>How the image should be inscribed into the box.<\/p>\n<p>The default is <a href=\"painting\/BoxFit-class.html\">BoxFit.scaleDown<\/a> if <a href=\"painting\/DecorationImage\/centerSlice.html\">centerSlice<\/a> is null, and\n<a href=\"painting\/BoxFit-class.html\">BoxFit.fill<\/a> if <a href=\"painting\/DecorationImage\/centerSlice.html\">centerSlice<\/a> is not null.<\/p>\n<p>See the discussion at <a href=\"painting\/paintImage.html\">paintImage<\/a> for more details.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BoxFit fit\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/fit.html",
                    "name": "fit",
                    "isDeprecated": false,
                    "type": "painting.BoxFit",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/DecorationImage\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/DecorationImage\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/DecorationImage\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/DecorationImage\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/DecorationImage\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/DecorationImage\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(image, colorFilter, fit, alignment, centerSlice, repeat, matchTextDirection);<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>The image to be painted into the decoration.<\/p>\n<p>Typically this will be an <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a> (for an image shipped with the\napplication) or a <a href=\"painting\/NetworkImage-class.html\">NetworkImage<\/a> (for an image obtained from the network).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ImageProvider image\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/image.html",
                    "name": "image",
                    "isDeprecated": false,
                    "type": "painting.ImageProvider",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>Whether to paint the image in the direction of the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n<p>If this is true, then in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a> contexts, the image will be\ndrawn with its origin in the top left (the \"normal\" painting direction for\nimages); and in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a> contexts, the image will be drawn with\na scaling factor of -1 in the horizontal direction so that the origin is\nin the top right.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final bool matchTextDirection\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/matchTextDirection.html",
                    "name": "matchTextDirection",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                },
                {
                    "desc": "<p>How to paint any portions of the box that would not otherwise be covered\nby the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ImageRepeat repeat\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/DecorationImage\/repeat.html",
                    "name": "repeat",
                    "isDeprecated": false,
                    "type": "painting.ImageRepeat",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.DecorationImage",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>The painter for a <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a>.<\/p>\n<p>To obtain a painter, call <a href=\"painting\/DecorationImage\/createPainter.html\">DecorationImage.createPainter<\/a>.<\/p>\n<p>To paint, call <a href=\"painting\/DecorationImagePainter\/paint.html\">paint<\/a>. The <code>onChanged<\/code> callback passed to\n<a href=\"painting\/DecorationImage\/createPainter.html\">DecorationImage.createPainter<\/a> will be called if the image needs to paint\nagain (e.g. because it is animated or because it had not yet loaded the\nfirst time the <a href=\"painting\/DecorationImagePainter\/paint.html\">paint<\/a> method was called).<\/p>\n<p>This object should be disposed using the <a href=\"painting\/DecorationImagePainter\/dispose.html\">dispose<\/a> method when it is no\nlonger needed.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/DecorationImagePainter-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.DecorationImagePainter",
            "shortname": "DecorationImagePainter",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Releases the resources used by this painter.<\/p>\n<p>This should be called whenever the painter is no longer needed.<\/p>\n<p>After this method has been called, the object is no longer usable.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@mustCallSuper\nvoid dispose() {\n  _imageStream?.removeListener(_imageListener);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/DecorationImagePainter\/dispose.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "dispose",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.DecorationImagePainter",
                    "params": []
                },
                {
                    "desc": "<p>Draw the image onto the given canvas.<\/p>\n<p>The image is drawn at the position and size given by the <code>rect<\/code> argument.<\/p>\n<p>The image is clipped to the given <code>clipPath<\/code>, if any.<\/p>\n<p>The <code>configuration<\/code> object is used to resolve the image (e.g. to pick\nresolution-specific assets), and to implement the\n<a href=\"painting\/DecorationImage\/matchTextDirection.html\">DecorationImage.matchTextDirection<\/a> feature.<\/p>\n<p>If the image needs to be painted again, e.g. because it is animated or\nbecause it had not yet been loaded the first time this method was called,\nthen the <code>onChanged<\/code> callback passed to <a href=\"painting\/DecorationImage\/createPainter.html\">DecorationImage.createPainter<\/a>\nwill be called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void paint(Canvas canvas, Rect rect, Path clipPath, ImageConfiguration configuration) {\n  assert(canvas != null);\n  assert(rect != null);\n  assert(configuration != null);\n\n  bool flipHorizontally = false;\n  if (_details.matchTextDirection) {\n    assert(() {\n      \/\/ We check this first so that the assert will fire immediately, not just\n      \/\/ when the image is ready.\n      if (configuration.textDirection == null) {\n        throw FlutterError(\n          'ImageDecoration.matchTextDirection can only be used when a TextDirection is available.\\n'\n          'When DecorationImagePainter.paint() was called, there was no text direction provided '\n          'in the ImageConfiguration object to match.\\n'\n          'The DecorationImage was:\\n'\n          '  $_details\\n'\n          'The ImageConfiguration was:\\n'\n          '  $configuration'\n        );\n      }\n      return true;\n    }());\n    if (configuration.textDirection == TextDirection.rtl)\n      flipHorizontally = true;\n  }\n\n  final ImageStream newImageStream = _details.image.resolve(configuration);\n  if (newImageStream.key != _imageStream?.key) {\n    _imageStream?.removeListener(_imageListener);\n    _imageStream = newImageStream;\n    _imageStream.addListener(_imageListener);\n  }\n  if (_image == null)\n    return;\n\n  if (clipPath != null) {\n    canvas.save();\n    canvas.clipPath(clipPath);\n  }\n\n  paintImage(\n    canvas: canvas,\n    rect: rect,\n    image: _image.image,\n    scale: _image.scale,\n    colorFilter: _details.colorFilter,\n    fit: _details.fit,\n    alignment: _details.alignment.resolve(configuration.textDirection),\n    centerSlice: _details.centerSlice,\n    repeat: _details.repeat,\n    flipHorizontally: flipHorizontally,\n    filterQuality: FilterQuality.low,\n  );\n\n  if (clipPath != null)\n    canvas.restore();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/DecorationImagePainter\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.DecorationImagePainter",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "clipPath",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Path"
                        },
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType(stream: $_imageStream, image: $_image) for $_details';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/DecorationImagePainter\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.DecorationImagePainter",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Default way of warming up Skia shader compilations.<\/p>\n<p>The draw operations being warmed up here are decided according to Flutter\nengineers' observation and experience based on the apps and the performance\nissues seen so far.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/DefaultShaderWarmUp-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.DefaultShaderWarmUp",
            "shortname": "DefaultShaderWarmUp",
            "extends": [
                "painting.ShaderWarmUp",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Allow <a href=\"painting\/DefaultShaderWarmUp-class.html\">DefaultShaderWarmUp<\/a> to be used as the default value of parameters.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const DefaultShaderWarmUp();<\/code><\/pre>\n    ",
                    "href": "painting\/DefaultShaderWarmUp\/DefaultShaderWarmUp.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "DefaultShaderWarmUp",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.DefaultShaderWarmUp",
                    "params": []
                },
                {
                    "desc": "<p>Trigger common draw operations on a canvas to warm up GPU shader\ncompilation cache.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;void&gt; warmUpOnCanvas(ui.Canvas canvas) async {\n  final ui.RRect rrect = ui.RRect.fromLTRBXY(20.0, 20.0, 60.0, 60.0, 10.0, 10.0);\n  final ui.Path rrectPath = ui.Path()..addRRect(rrect);\n\n  final ui.Path circlePath = ui.Path()..addOval(\n      ui.Rect.fromCircle(center: const ui.Offset(40.0, 40.0), radius: 20.0)\n  );\n\n  \/\/ The following path is based on\n  \/\/ https:\/\/skia.org\/user\/api\/SkCanvas_Reference#SkCanvas_drawPath\n  final ui.Path path = ui.Path();\n  path.moveTo(20.0, 60.0);\n  path.quadraticBezierTo(60.0, 20.0, 60.0, 60.0);\n  path.close();\n  path.moveTo(60.0, 20.0);\n  path.quadraticBezierTo(60.0, 60.0, 20.0, 60.0);\n\n  final ui.Path convexPath = ui.Path();\n  convexPath.moveTo(20.0, 30.0);\n  convexPath.lineTo(40.0, 20.0);\n  convexPath.lineTo(60.0, 30.0);\n  convexPath.lineTo(60.0, 60.0);\n  convexPath.lineTo(20.0, 60.0);\n  convexPath.close();\n\n  \/\/ Skia uses different shaders based on the kinds of paths being drawn and\n  \/\/ the associated paint configurations. According to our experience and\n  \/\/ tracing, drawing the following paths\/paints generates various of\n  \/\/ shaders that are commonly used.\n  final List&lt;ui.Path&gt; paths = &lt;ui.Path&gt;[rrectPath, circlePath, path, convexPath];\n\n  final List&lt;ui.Paint&gt; paints = &lt;ui.Paint&gt;[\n    ui.Paint()\n      ..isAntiAlias = true\n      ..style = ui.PaintingStyle.fill,\n    ui.Paint()\n      ..isAntiAlias = false\n      ..style = ui.PaintingStyle.fill,\n    ui.Paint()\n      ..isAntiAlias = true\n      ..style = ui.PaintingStyle.stroke\n      ..strokeWidth = 10,\n    ui.Paint()\n      ..isAntiAlias = true\n      ..style = ui.PaintingStyle.stroke\n      ..strokeWidth = 0.1,  \/\/ hairline\n  ];\n\n  \/\/ Warm up path stroke and fill shaders.\n  for (int i = 0; i &lt; paths.length; i += 1) {\n    canvas.save();\n    for (ui.Paint paint in paints) {\n      canvas.drawPath(paths[i], paint);\n      canvas.translate(80.0, 0.0);\n    }\n    canvas.restore();\n    canvas.translate(0.0, 80.0);\n  }\n\n  \/\/ Warm up shadow shaders.\n  const ui.Color black = ui.Color(0xFF000000);\n  canvas.save();\n  canvas.drawShadow(rrectPath, black, 10.0, true);\n  canvas.translate(80.0, 0.0);\n  canvas.drawShadow(rrectPath, black, 10.0, false);\n  canvas.restore();\n\n  \/\/ Warm up text shaders.\n  canvas.translate(0.0, 80.0);\n  final ui.ParagraphBuilder paragraphBuilder = ui.ParagraphBuilder(\n    ui.ParagraphStyle(textDirection: ui.TextDirection.ltr),\n  )..pushStyle(ui.TextStyle(color: black))..addText('_');\n  final ui.Paragraph paragraph = paragraphBuilder.build()\n    ..layout(const ui.ParagraphConstraints(width: 60.0));\n  canvas.drawParagraph(paragraph, const ui.Offset(20.0, 20.0));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/DefaultShaderWarmUp\/warmUpOnCanvas.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "warmUpOnCanvas",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.DefaultShaderWarmUp",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>An immutable set of offsets in each of the four cardinal directions.<\/p>\n<p>Typically used for an offset from each of the four sides of a box. For\nexample, the padding inside a box can be represented using this class.<\/p>\n<p>The <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> class specifies offsets in terms of visual edges, left,\ntop, right, and bottom. These values are not affected by the\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. To support both left-to-right and right-to-left layouts,\nconsider using <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, which is expressed in terms of\n<em>start<\/em>, top, <em>end<\/em>, and bottom, where start and end are resolved in terms\nof a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a> (typically obtained from the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a>).<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nHere are some examples of how to create <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> instances:\n<p>Typical eight-pixel margin on all sides:\n<\/p>\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const EdgeInsets.all(8.0)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nEight pixel margin above and below, no horizontal margins:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const EdgeInsets.symmetric(vertical: 8.0)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nLeft margin indent of 40 pixels:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const EdgeInsets.only(left: 40.0)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/Padding-class.html\">Padding<\/a>, a widget that accepts <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> to describe its margins.<\/li>\n<li>\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, which (for properties and arguments that accept\nthe type <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a>) allows the horizontal insets to be\nspecified in a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>-aware manner.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/EdgeInsets-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.EdgeInsets",
            "shortname": "EdgeInsets",
            "extends": [
                "painting.EdgeInsetsGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "widgets.EdgeInsetsTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or two <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/EdgeInsets\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsets\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry add(EdgeInsetsGeometry other) {\n  if (other is EdgeInsets)\n    return this + other;\n  return super.add(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/add.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this EdgeInsets but with the given fields replaced\nwith the new values.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsets copyWith({\n  double left,\n  double top,\n  double right,\n  double bottom,\n}) {\n  return EdgeInsets.only(\n    left: left ?? this.left,\n    top: top ?? this.top,\n    right: right ?? this.right,\n    bottom: bottom ?? this.bottom,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/copyWith.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "name": "copyWith",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "bottom",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "left",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "right",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "top",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new rect that is smaller than the given rect in each direction by\nthe amount of inset in each direction. Specifically, the left edge of the\nrect is moved right by <a href=\"painting\/EdgeInsets\/left.html\">left<\/a>, the top edge of the rect is moved down by\n<a href=\"painting\/EdgeInsets\/top.html\">top<\/a>, the right edge of the rect is moved left by <a href=\"painting\/EdgeInsets\/right.html\">right<\/a>, and the\nbottom edge of the rect is moved up by <a href=\"painting\/EdgeInsets\/bottom.html\">bottom<\/a>.<\/p>\n<p>If the argument's <a href=\"dart-ui\/Rect\/size.html\">Rect.size<\/a> is smaller than <a href=\"painting\/EdgeInsetsGeometry\/collapsedSize.html\">collapsedSize<\/a>, then the\nresulting rectangle will have negative dimensions.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsetsGeometry\/deflateSize.html\">deflateSize<\/a>, to deflate a <a href=\"dart-ui\/Size-class.html\">Size<\/a> rather than a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/li>\n<li>\n<a href=\"painting\/EdgeInsets\/inflateRect.html\">inflateRect<\/a>, to inflate a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> rather than deflating it.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Rect deflateRect(Rect rect) {\n  return Rect.fromLTRB(rect.left + left, rect.top + top, rect.right - right, rect.bottom - bottom);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/deflateRect.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Rect",
                    "name": "deflateRect",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new rect that is bigger than the given rect in each direction by\nthe amount of inset in each direction. Specifically, the left edge of the\nrect is moved left by <a href=\"painting\/EdgeInsets\/left.html\">left<\/a>, the top edge of the rect is moved up by\n<a href=\"painting\/EdgeInsets\/top.html\">top<\/a>, the right edge of the rect is moved right by <a href=\"painting\/EdgeInsets\/right.html\">right<\/a>, and the\nbottom edge of the rect is moved down by <a href=\"painting\/EdgeInsets\/bottom.html\">bottom<\/a>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsetsGeometry\/inflateSize.html\">inflateSize<\/a>, to inflate a <a href=\"dart-ui\/Size-class.html\">Size<\/a> rather than a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/li>\n<li>\n<a href=\"painting\/EdgeInsets\/deflateRect.html\">deflateRect<\/a>, to deflate a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> rather than inflating it.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Rect inflateRect(Rect rect) {\n  return Rect.fromLTRB(rect.left - left, rect.top - top, rect.right + right, rect.bottom + bottom);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/inflateRect.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Rect",
                    "name": "inflateRect",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/EdgeInsets\/zero-constant.html\">EdgeInsets.zero<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static EdgeInsets lerp(EdgeInsets a, EdgeInsets b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b * t;\n  if (b == null)\n    return a * (1.0 - t);\n  return EdgeInsets.fromLTRB(\n    ui.lerpDouble(a.left, b.left, t),\n    ui.lerpDouble(a.top, b.top, t),\n    ui.lerpDouble(a.right, b.right, t),\n    ui.lerpDouble(a.bottom, b.bottom, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsets"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsets"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, which uses literal coordinates\n(i.e. the <code>left<\/code> coordinate being explicitly a distance from the left, and\nthe <code>right<\/code> coordinate being explicitly a distance from the right).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsets resolve(TextDirection direction) =&gt; this;<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the difference between two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If you know you are applying this to two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or two\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> objects, consider using the binary infix <code>-<\/code>\noperator instead, which always returns an object of the same type as the\noperands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/EdgeInsets\/subtract.html\">subtract<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsets\/resolve.html\">resolve<\/a>.<\/p>\n<p>This method returns the same result as <a href=\"painting\/EdgeInsets\/add.html\">add<\/a> applied to the result of\nnegating the argument (using the prefix unary <code>-<\/code> operator or multiplying\nthe argument by -1.0 using the <code>*<\/code> operator).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry subtract(EdgeInsetsGeometry other) {\n  if (other is EdgeInsets)\n    return this - other;\n  return super.subtract(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/subtract.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "subtract",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The offset from the bottom.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double bottom\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/bottom.html",
                    "name": "bottom",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>An Offset describing the vector from the bottom left of a rectangle to the\nbottom left of that rectangle inset by this object.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Offset get bottomLeft =&gt; Offset(left, -bottom);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/bottomLeft.html",
                    "name": "bottomLeft",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>An Offset describing the vector from the bottom right of a rectangle to the\nbottom right of that rectangle inset by this object.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Offset get bottomRight =&gt; Offset(-right, -bottom);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/bottomRight.html",
                    "name": "bottomRight",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>An <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> with top and bottom as well as left and right flipped.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsets get flipped =&gt; EdgeInsets.fromLTRB(right, bottom, left, top);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/flipped.html",
                    "name": "flipped",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>The offset from the left.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double left\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/left.html",
                    "name": "left",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>The offset from the right.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double right\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/right.html",
                    "name": "right",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>The offset from the top.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double top\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/top.html",
                    "name": "top",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>An Offset describing the vector from the top left of a rectangle to the\ntop left of that rectangle inset by this object.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Offset get topLeft =&gt; Offset(left, top);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/topLeft.html",
                    "name": "topLeft",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>An Offset describing the vector from the top right of a rectangle to the\ntop right of that rectangle inset by this object.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Offset get topRight =&gt; Offset(-right, top);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsets\/topRight.html",
                    "name": "topRight",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                },
                {
                    "desc": "<p>An <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> with zero offsets in each direction.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const EdgeInsets zero = EdgeInsets.only()\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsets\/zero-constant.html",
                    "name": "zero",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.EdgeInsets",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable set of offsets in each of the four cardinal directions, but\nwhose horizontal components are dependent on the writing direction.<\/p>\n<p>This can be used to indicate padding from the left in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a>\ntext and padding from the right in <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a> text without having\nto be aware of the current text direction.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, a variant that uses physical labels (left and right instead\nof start and end).<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/EdgeInsetsDirectional-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.EdgeInsetsDirectional",
            "shortname": "EdgeInsetsDirectional",
            "extends": [
                "painting.EdgeInsetsGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or two <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/EdgeInsetsDirectional\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry add(EdgeInsetsGeometry other) {\n  if (other is EdgeInsetsDirectional)\n    return this + other;\n  return super.add(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsDirectional\/add.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/EdgeInsetsDirectional\/zero-constant.html\">EdgeInsetsDirectional.zero<\/a>.<\/p>\n<p>To interpolate between two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects of arbitrary type\n(either <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), consider the\n<a href=\"painting\/EdgeInsetsDirectional\/lerp.html\">EdgeInsetsGeometry.lerp<\/a> static method.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static EdgeInsetsDirectional lerp(EdgeInsetsDirectional a, EdgeInsetsDirectional b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b * t;\n  if (b == null)\n    return a * (1.0 - t);\n  return EdgeInsetsDirectional.fromSTEB(\n    ui.lerpDouble(a.start, b.start, t),\n    ui.lerpDouble(a.top, b.top, t),\n    ui.lerpDouble(a.end, b.end, t),\n    ui.lerpDouble(a.bottom, b.bottom, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsDirectional\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsDirectional",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsDirectional"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsDirectional"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, which uses literal coordinates\n(i.e. the <code>left<\/code> coordinate being explicitly a distance from the left, and\nthe <code>right<\/code> coordinate being explicitly a distance from the right).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsets resolve(TextDirection direction) {\n  assert(direction != null);\n  switch (direction) {\n    case TextDirection.rtl:\n      return EdgeInsets.fromLTRB(end, top, start, bottom);\n    case TextDirection.ltr:\n      return EdgeInsets.fromLTRB(start, top, end, bottom);\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsDirectional\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the difference between two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If you know you are applying this to two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or two\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> objects, consider using the binary infix <code>-<\/code>\noperator instead, which always returns an object of the same type as the\noperands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/EdgeInsetsDirectional\/subtract.html\">subtract<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a>.<\/p>\n<p>This method returns the same result as <a href=\"painting\/EdgeInsetsDirectional\/add.html\">add<\/a> applied to the result of\nnegating the argument (using the prefix unary <code>-<\/code> operator or multiplying\nthe argument by -1.0 using the <code>*<\/code> operator).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry subtract(EdgeInsetsGeometry other) {\n  if (other is EdgeInsetsDirectional)\n    return this - other;\n  return super.subtract(other);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsDirectional\/subtract.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "subtract",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The offset from the bottom.<\/p>\n<p>This value is passed through to <a href=\"painting\/EdgeInsetsDirectional\/bottom.html\">EdgeInsets.bottom<\/a> unmodified by the\n<a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a> method.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double bottom\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsDirectional\/bottom.html",
                    "name": "bottom",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The offset from the end side, the side on which the user ends reading\ntext.<\/p>\n<p>This value is normalized into an <a href=\"painting\/EdgeInsets\/left.html\">EdgeInsets.left<\/a> or <a href=\"painting\/EdgeInsets\/right.html\">EdgeInsets.right<\/a>\nvalue by the <a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a> method.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double end\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsDirectional\/end.html",
                    "name": "end",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                },
                {
                    "desc": "<p>An <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> with <a href=\"painting\/EdgeInsetsDirectional\/top.html\">top<\/a> and <a href=\"painting\/EdgeInsetsDirectional\/bottom.html\">bottom<\/a> as well as <a href=\"painting\/EdgeInsetsDirectional\/start.html\">start<\/a> and <a href=\"painting\/EdgeInsetsDirectional\/end.html\">end<\/a> flipped.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsDirectional get flipped =&gt; EdgeInsetsDirectional.fromSTEB(end, bottom, start, top);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsDirectional\/flipped.html",
                    "name": "flipped",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsDirectional",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                },
                {
                    "desc": "<p>Whether every dimension is non-negative.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isNonNegative =&gt; start &gt;= 0.0 &amp;&amp; top &gt;= 0.0 &amp;&amp; end &gt;= 0.0 &amp;&amp; bottom &gt;= 0.0;<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsDirectional\/isNonNegative.html",
                    "name": "isNonNegative",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The offset from the start side, the side from which the user will start\nreading text.<\/p>\n<p>This value is normalized into an <a href=\"painting\/EdgeInsets\/left.html\">EdgeInsets.left<\/a> or <a href=\"painting\/EdgeInsets\/right.html\">EdgeInsets.right<\/a>\nvalue by the <a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a> method.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double start\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsDirectional\/start.html",
                    "name": "start",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                },
                {
                    "desc": "<p>The offset from the top.<\/p>\n<p>This value is passed through to <a href=\"painting\/EdgeInsetsDirectional\/top.html\">EdgeInsets.top<\/a> unmodified by the\n<a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a> method.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double top\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsDirectional\/top.html",
                    "name": "top",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                },
                {
                    "desc": "<p>An <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> with zero offsets in each direction.<\/p>\n<p>Consider using <a href=\"painting\/EdgeInsetsDirectional\/zero-constant.html\">EdgeInsets.zero<\/a> instead, since that object has the same\neffect, but will be cheaper to <a href=\"painting\/EdgeInsetsDirectional\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const EdgeInsetsDirectional zero = EdgeInsetsDirectional.only()\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsDirectional\/zero-constant.html",
                    "name": "zero",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsDirectional",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.EdgeInsetsDirectional",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Base class for <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> that allows for text-direction aware\nresolution.<\/p>\n<p>A property or argument of this type accepts classes created either with <a href=\"painting\/EdgeInsets\/EdgeInsets.fromLTRB.html\">new\nEdgeInsets.fromLTRB<\/a> and its variants, or <a href=\"painting\/EdgeInsetsDirectional\/EdgeInsetsDirectional.fromSTEB.html\">new\nEdgeInsetsDirectional.fromSTEB<\/a> and its variants.<\/p>\n<p>To convert an <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> object of indeterminate type into a\n<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> object, call the <a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">resolve<\/a> method.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/Padding-class.html\">Padding<\/a>, a widget that describes margins using <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a>.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/EdgeInsetsGeometry-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.EdgeInsetsGeometry",
            "shortname": "EdgeInsetsGeometry",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.EdgeInsets",
                "painting.EdgeInsetsDirectional",
                "widgets.EdgeInsetsGeometryTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const EdgeInsetsGeometry();<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/EdgeInsetsGeometry.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "EdgeInsetsGeometry",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                },
                {
                    "desc": "<p>Returns the sum of two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If you know you are adding two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or two <a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>\nobjects, consider using the <code>+<\/code> operator instead, which always returns an\nobject of the same type as the operands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/EdgeInsetsGeometry\/add.html\">add<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">resolve<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsetsGeometry add(EdgeInsetsGeometry other) {\n  return _MixedEdgeInsets.fromLRSETB(\n    _left + other._left,\n    _right + other._right,\n    _start + other._start,\n    _end + other._end,\n    _top + other._top,\n    _bottom + other._bottom,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/add.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>The total offset in the given direction.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">double along(Axis axis) {\n  assert(axis != null);\n  switch (axis) {\n    case Axis.horizontal:\n      return horizontal;\n    case Axis.vertical:\n      return vertical;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/along.html",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "name": "along",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "axis",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Axis"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new size that is smaller than the given size by the amount of\ninset in the horizontal and vertical directions.<\/p>\n<p>If the argument is smaller than <a href=\"painting\/EdgeInsetsGeometry\/collapsedSize.html\">collapsedSize<\/a>, then the resulting size\nwill have negative dimensions.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsets\/deflateRect.html\">EdgeInsets.deflateRect<\/a>, to deflate a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> rather than a <a href=\"dart-ui\/Size-class.html\">Size<\/a>. (for\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, requires first calling <a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">resolve<\/a> to establish\nhow the start and end map to the left or right).<\/li>\n<li>\n<a href=\"painting\/EdgeInsetsGeometry\/inflateSize.html\">inflateSize<\/a>, to inflate a <a href=\"dart-ui\/Size-class.html\">Size<\/a> rather than deflating it.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Size deflateSize(Size size) {\n  return Size(size.width - horizontal, size.height - vertical);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/deflateSize.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "name": "deflateSize",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new size that is bigger than the given size by the amount of\ninset in the horizontal and vertical directions.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsets\/inflateRect.html\">EdgeInsets.inflateRect<\/a>, to inflate a <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> rather than a <a href=\"dart-ui\/Size-class.html\">Size<\/a> (for\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, requires first calling <a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">resolve<\/a> to establish\nhow the start and end map to the left or right).<\/li>\n<li>\n<a href=\"painting\/EdgeInsetsGeometry\/deflateSize.html\">deflateSize<\/a>, to deflate a <a href=\"dart-ui\/Size-class.html\">Size<\/a> rather than inflating it.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Size inflateSize(Size size) {\n  return Size(size.width + horizontal, size.height + vertical);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/inflateSize.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "name": "inflateSize",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/EdgeInsets\/zero-constant.html\">EdgeInsets.zero<\/a>, and\nthe result is an object of the same type as the non-null argument.<\/p>\n<p>If <a href=\"painting\/EdgeInsetsGeometry\/lerp.html\">lerp<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">resolve<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static EdgeInsetsGeometry lerp(EdgeInsetsGeometry a, EdgeInsetsGeometry b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b * t;\n  if (b == null)\n    return a * (1.0 - t);\n  if (a is EdgeInsets &amp;&amp; b is EdgeInsets)\n    return EdgeInsets.lerp(a, b, t);\n  if (a is EdgeInsetsDirectional &amp;&amp; b is EdgeInsetsDirectional)\n    return EdgeInsetsDirectional.lerp(a, b, t);\n  return _MixedEdgeInsets.fromLRSETB(\n    ui.lerpDouble(a._left, b._left, t),\n    ui.lerpDouble(a._right, b._right, t),\n    ui.lerpDouble(a._start, b._start, t),\n    ui.lerpDouble(a._end, b._end, t),\n    ui.lerpDouble(a._top, b._top, t),\n    ui.lerpDouble(a._bottom, b._bottom, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Convert this instance into an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, which uses literal coordinates\n(i.e. the <code>left<\/code> coordinate being explicitly a distance from the left, and\nthe <code>right<\/code> coordinate being explicitly a distance from the right).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>, for which this is a no-op (returns itself).<\/li>\n<li>\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>, which flips the horizontal direction\nbased on the <code>direction<\/code> argument.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsets resolve(TextDirection direction);<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "direction",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the difference between two <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> objects.<\/p>\n<p>If you know you are applying this to two <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or two\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a> objects, consider using the binary infix <code>-<\/code>\noperator instead, which always returns an object of the same type as the\noperands, and is typed accordingly.<\/p>\n<p>If <a href=\"painting\/EdgeInsetsGeometry\/subtract.html\">subtract<\/a> is applied to two objects of the same type (<a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> or\n<a href=\"painting\/EdgeInsetsDirectional-class.html\">EdgeInsetsDirectional<\/a>), an object of that type will be returned (though\nthis is not reflected in the type system). Otherwise, an object\nrepresenting a combination of both is returned. That object can be turned\ninto a concrete <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> using <a href=\"painting\/EdgeInsetsGeometry\/resolve.html\">resolve<\/a>.<\/p>\n<p>This method returns the same result as <a href=\"painting\/EdgeInsetsGeometry\/add.html\">add<\/a> applied to the result of\nnegating the argument (using the prefix unary <code>-<\/code> operator or multiplying\nthe argument by -1.0 using the <code>*<\/code> operator).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsetsGeometry subtract(EdgeInsetsGeometry other) {\n  return _MixedEdgeInsets.fromLRSETB(\n    _left - other._left,\n    _right - other._right,\n    _start - other._start,\n    _end - other._end,\n    _top - other._top,\n    _bottom - other._bottom,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/subtract.html",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "name": "subtract",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.EdgeInsetsGeometry"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  if (_start == 0.0 &amp;&amp; _end == 0.0) {\n    if (_left == 0.0 &amp;&amp; _right == 0.0 &amp;&amp; _top == 0.0 &amp;&amp; _bottom == 0.0)\n      return 'EdgeInsets.zero';\n    if (_left == _right &amp;&amp; _right == _top &amp;&amp; _top == _bottom)\n      return 'EdgeInsets.all(${_left.toStringAsFixed(1)})';\n    return 'EdgeInsets(${_left.toStringAsFixed(1)}, '\n                      '${_top.toStringAsFixed(1)}, '\n                      '${_right.toStringAsFixed(1)}, '\n                      '${_bottom.toStringAsFixed(1)})';\n  }\n  if (_left == 0.0 &amp;&amp; _right == 0.0) {\n    return 'EdgeInsetsDirectional(${_start.toStringAsFixed(1)}, '\n                                 '${_top.toStringAsFixed(1)}, '\n                                 '${_end.toStringAsFixed(1)}, '\n                                 '${_bottom.toStringAsFixed(1)})';\n  }\n  return 'EdgeInsets(${_left.toStringAsFixed(1)}, '\n                    '${_top.toStringAsFixed(1)}, '\n                    '${_right.toStringAsFixed(1)}, '\n                    '${_bottom.toStringAsFixed(1)})'\n         ' + '\n         'EdgeInsetsDirectional(${_start.toStringAsFixed(1)}, '\n                               '0.0, '\n                               '${_end.toStringAsFixed(1)}, '\n                               '0.0)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/EdgeInsetsGeometry\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The size that this <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a> would occupy with an empty interior.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Size get collapsedSize =&gt; Size(horizontal, vertical);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsGeometry\/collapsedSize.html",
                    "name": "collapsedSize",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                },
                {
                    "desc": "<p>An <a href=\"painting\/EdgeInsetsGeometry-class.html\">EdgeInsetsGeometry<\/a> with top and bottom, left and right, and start and end flipped.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsetsGeometry get flipped =&gt; _MixedEdgeInsets.fromLRSETB(_right, _left, _end, _start, _bottom, _top);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsGeometry\/flipped.html",
                    "name": "flipped",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/EdgeInsetsGeometry\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/EdgeInsetsGeometry\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/EdgeInsetsGeometry\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/EdgeInsetsGeometry\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/EdgeInsetsGeometry\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/EdgeInsetsGeometry\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(_left, _right, _start, _end, _top, _bottom);<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsGeometry\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                },
                {
                    "desc": "<p>The total offset in the horizontal direction.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get horizontal =&gt; _left + _right + _start + _end;<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsGeometry\/horizontal.html",
                    "name": "horizontal",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                },
                {
                    "desc": "<p>Whether every dimension is non-negative.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get isNonNegative {\n  return _left &gt;= 0.0\n      &amp;&amp; _right &gt;= 0.0\n      &amp;&amp; _start &gt;= 0.0\n      &amp;&amp; _end &gt;= 0.0\n      &amp;&amp; _top &gt;= 0.0\n      &amp;&amp; _bottom &gt;= 0.0;\n}<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsGeometry\/isNonNegative.html",
                    "name": "isNonNegative",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                },
                {
                    "desc": "<p>The total offset in the vertical direction.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get vertical =&gt; _top + _bottom;<\/code><\/pre>\n        ",
                    "href": "painting\/EdgeInsetsGeometry\/vertical.html",
                    "name": "vertical",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.EdgeInsetsGeometry",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Fetches an image from an <a href=\"services\/AssetBundle-class.html\">AssetBundle<\/a>, associating it with the given scale.<\/p>\n<p>This implementation requires an explicit final <a href=\"painting\/ExactAssetImage\/assetName.html\">assetName<\/a> and <a href=\"painting\/ExactAssetImage\/scale.html\">scale<\/a> on\nconstruction, and ignores the device pixel ratio and size in the\nconfiguration passed into <a href=\"painting\/ImageProvider\/resolve.html\">resolve<\/a>. For a resolution-aware variant that\nuses the configuration to pick an appropriate image based on the device\npixel ratio and size, see <a href=\"painting\/AssetImage-class.html\">AssetImage<\/a>.<\/p>\n<h2 id=\"fetching-assets\">Fetching assets<\/h2>\n<p>When fetching an image provided by the app itself, use the <a href=\"painting\/ExactAssetImage\/assetName.html\">assetName<\/a>\nargument to name the asset to choose. For instance, consider a directory\n<code>icons<\/code> with an image <code>heart.png<\/code>. First, the <code>pubspec.yaml<\/code> of the project\nshould specify its assets in the <code>flutter<\/code> section:<\/p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">flutter:\n  assets:\n    - icons\/heart.png\n<\/code><\/pre>\n<p>Then, to fetch the image and associate it with scale <code>1.5<\/code>, use<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">AssetImage('icons\/heart.png', scale: 1.5)\n<\/code><\/pre>\n<h2 id=\"assets-in-packages\">Assets in packages<\/h2>\n<p>To fetch an asset from a package, the <a href=\"painting\/ExactAssetImage\/package.html\">package<\/a> argument must be provided.\nFor instance, suppose the structure above is inside a package called\n<code>my_icons<\/code>. Then to fetch the image, use:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">AssetImage('icons\/heart.png', scale: 1.5, package: 'my_icons')\n<\/code><\/pre>\n<p>Assets used by the package itself should also be fetched using the <a href=\"painting\/ExactAssetImage\/package.html\">package<\/a>\nargument as above.<\/p>\n<p>If the desired asset is specified in the <code>pubspec.yaml<\/code> of the package, it\nis bundled automatically with the app. In particular, assets used by the\npackage itself must be specified in its <code>pubspec.yaml<\/code>.<\/p>\n<p>A package can also choose to have assets in its 'lib\/' folder that are not\nspecified in its <code>pubspec.yaml<\/code>. In this case for those images to be\nbundled, the app has to specify which ones to include. For instance a\npackage named <code>fancy_backgrounds<\/code> could have:<\/p>\n<pre class=\"language-dart\"><code>lib\/backgrounds\/background1.png\nlib\/backgrounds\/background2.png\nlib\/backgrounds\/background3.png\n<\/code><\/pre>\n<p>To include, say the first image, the <code>pubspec.yaml<\/code> of the app should specify\nit in the <code>assets<\/code> section:<\/p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">  assets:\n    - packages\/fancy_backgrounds\/backgrounds\/background1.png\n<\/code><\/pre>\n<p>The <code>lib\/<\/code> is implied, so it should not be included in the asset path.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/Image\/Image.asset.html\">Image.asset<\/a> for a shorthand of an <a href=\"widgets\/Image-class.html\">Image<\/a> widget backed by\n<a href=\"painting\/ExactAssetImage-class.html\">ExactAssetImage<\/a> when using a scale.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ExactAssetImage-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ExactAssetImage",
            "shortname": "ExactAssetImage",
            "extends": [
                "painting.AssetBundleImageProvider",
                "painting.AssetBundleImageKey",
                "painting.ImageProvider",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object that fetches the given image from an asset bundle.<\/p>\n<p>The <code>assetName<\/code> and <code>scale<\/code> arguments must not be null. The <code>scale<\/code> arguments\ndefaults to 1.0. The <code>bundle<\/code> argument may be null, in which case the\nbundle provided in the <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> passed to the <a href=\"painting\/ImageProvider\/resolve.html\">resolve<\/a> call\nwill be used instead.<\/p>\n<p>The <code>package<\/code> argument must be non-null when fetching an asset that is\nincluded in a package. See the documentation for the <a href=\"painting\/ExactAssetImage-class.html\">ExactAssetImage<\/a> class\nitself for details.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ExactAssetImage(\n  this.assetName, {\n  this.scale = 1.0,\n  this.bundle,\n  this.package,\n}) : assert(assetName != null),\n     assert(scale != null);<\/code><\/pre>\n    ",
                    "href": "painting\/ExactAssetImage\/ExactAssetImage.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ExactAssetImage",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": [
                        {
                            "name": "assetName",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "bundle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "services.AssetBundle"
                        },
                        {
                            "name": "package",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.<\/p>\n<p>The type of the key is determined by the subclass. It is a value that\nunambiguously identifies the image (<em>including its scale<\/em>) that the <a href=\"painting\/AssetBundleImageProvider\/load.html\">load<\/a>\nmethod will fetch. Different <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>s given the same constructor\narguments and <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects should return keys that are\n'==' to each other (possibly by using a class for the key that itself\nimplements <code>==<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;AssetBundleImageKey&gt; obtainKey(ImageConfiguration configuration) {\n  return SynchronousFuture&lt;AssetBundleImageKey&gt;(AssetBundleImageKey(\n    bundle: bundle ?? configuration.bundle ?? rootBundle,\n    name: keyName,\n    scale: scale,\n  ));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ExactAssetImage\/obtainKey.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<painting.AssetBundleImageKey>",
                    "name": "obtainKey",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(name: \"$keyName\", scale: $scale, bundle: $bundle)';<\/code><\/pre>\n    ",
                    "href": "painting\/ExactAssetImage\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The name of the asset.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String assetName\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ExactAssetImage\/assetName.html",
                    "name": "assetName",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The bundle from which the image will be obtained.<\/p>\n<p>If the provided <a href=\"painting\/ExactAssetImage\/bundle.html\">bundle<\/a> is null, the bundle provided in the\n<a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> passed to the <a href=\"painting\/ImageProvider\/resolve.html\">resolve<\/a> call will be used instead. If\nthat is also null, the <a href=\"services\/rootBundle.html\">rootBundle<\/a> is used.<\/p>\n<p>The image is obtained by calling <a href=\"painting\/AssetBundleImageProvider\/load.html\">AssetBundle.load<\/a> on the given <a href=\"painting\/ExactAssetImage\/bundle.html\">bundle<\/a>\nusing the key given by <a href=\"painting\/ExactAssetImage\/keyName.html\">keyName<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AssetBundle bundle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ExactAssetImage\/bundle.html",
                    "name": "bundle",
                    "isDeprecated": false,
                    "type": "services.AssetBundle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/ExactAssetImage\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/ExactAssetImage\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/ExactAssetImage\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/ExactAssetImage\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/ExactAssetImage\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/ExactAssetImage\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(keyName, scale, bundle);<\/code><\/pre>\n        ",
                    "href": "painting\/ExactAssetImage\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The key to use to obtain the resource from the <a href=\"painting\/ExactAssetImage\/bundle.html\">bundle<\/a>. This is the\nargument passed to <a href=\"painting\/AssetBundleImageProvider\/load.html\">AssetBundle.load<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get keyName =&gt; package == null ? assetName : 'packages\/$package\/$assetName';<\/code><\/pre>\n        ",
                    "href": "painting\/ExactAssetImage\/keyName.html",
                    "name": "keyName",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The name of the package from which the image is included. See the\ndocumentation for the <a href=\"painting\/ExactAssetImage-class.html\">ExactAssetImage<\/a> class itself for details.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String package\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ExactAssetImage\/package.html",
                    "name": "package",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                },
                {
                    "desc": "<p>The scale to place in the <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object of the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double scale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ExactAssetImage\/scale.html",
                    "name": "scale",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ExactAssetImage",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Decodes the given <a href=\"dart-io\/File-class.html\">File<\/a> object as an image, associating it with the given\nscale.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/FileImage\/file.html\">Image.file<\/a> for a shorthand of an <a href=\"widgets\/Image-class.html\">Image<\/a> widget backed by <a href=\"painting\/FileImage-class.html\">FileImage<\/a>.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/FileImage-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.FileImage",
            "shortname": "FileImage",
            "extends": [
                "painting.FileImage",
                "painting.ImageProvider",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.FileImage"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object that decodes a <a href=\"dart-io\/File-class.html\">File<\/a> as an image.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const FileImage(this.file, { this.scale = 1.0 })\n  : assert(file != null),\n    assert(scale != null);<\/code><\/pre>\n    ",
                    "href": "painting\/FileImage\/FileImage.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "FileImage",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.FileImage",
                    "params": [
                        {
                            "name": "file",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:io.File"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts a key into an <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a>, and begins fetching the\nimage.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nImageStreamCompleter load(FileImage key) {\n  return MultiFrameImageStreamCompleter(\n    codec: _loadAsync(key),\n    scale: key.scale,\n    informationCollector: (StringBuffer information) {\n      information.writeln('Path: ${file?.path}');\n    },\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FileImage\/load.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "name": "load",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FileImage",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.FileImage"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.<\/p>\n<p>The type of the key is determined by the subclass. It is a value that\nunambiguously identifies the image (<em>including its scale<\/em>) that the <a href=\"painting\/FileImage\/load.html\">load<\/a>\nmethod will fetch. Different <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>s given the same constructor\narguments and <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects should return keys that are\n'==' to each other (possibly by using a class for the key that itself\nimplements <code>==<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;FileImage&gt; obtainKey(ImageConfiguration configuration) {\n  return SynchronousFuture&lt;FileImage&gt;(this);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FileImage\/obtainKey.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<painting.FileImage>",
                    "name": "obtainKey",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FileImage",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(\"${file?.path}\", scale: $scale)';<\/code><\/pre>\n    ",
                    "href": "painting\/FileImage\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FileImage",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The file to decode into an image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final File file\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FileImage\/file.html",
                    "name": "file",
                    "isDeprecated": false,
                    "type": "dart:io.File",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FileImage",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/FileImage\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/FileImage\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/FileImage\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/FileImage\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/FileImage\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/FileImage\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(file?.path, scale);<\/code><\/pre>\n        ",
                    "href": "painting\/FileImage\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FileImage",
                    "params": []
                },
                {
                    "desc": "<p>The scale to place in the <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object of the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double scale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FileImage\/scale.html",
                    "name": "scale",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FileImage",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>The pair of sizes returned by <a href=\"painting\/applyBoxFit.html\">applyBoxFit<\/a>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/FittedSizes-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.FittedSizes",
            "shortname": "FittedSizes",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object to store a pair of sizes,\nas would be returned by <a href=\"painting\/applyBoxFit.html\">applyBoxFit<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const FittedSizes(this.source, this.destination);<\/code><\/pre>\n    ",
                    "href": "painting\/FittedSizes\/FittedSizes.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "FittedSizes",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.FittedSizes",
                    "params": [
                        {
                            "name": "destination",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "source",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Size"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The size of the part of the output on which to show the input.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Size destination\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FittedSizes\/destination.html",
                    "name": "destination",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FittedSizes",
                    "params": []
                },
                {
                    "desc": "<p>The size of the part of the input to show on the output.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Size source\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FittedSizes\/source.html",
                    "name": "source",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FittedSizes",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable description of how to paint Flutter's logo.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/FlutterLogoDecoration-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.FlutterLogoDecoration",
            "shortname": "FlutterLogoDecoration",
            "extends": [
                "painting.Decoration",
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a decoration that knows how to paint Flutter's logo.<\/p>\n<p>The <code>lightColor<\/code> and <code>darkColor<\/code> are used to fill the logo. The <code>style<\/code>\ncontrols whether and where to draw the \"Flutter\" label. If one is shown,\nthe <code>textColor<\/code> controls the color of the label.<\/p>\n<p>The <code>lightColor<\/code>, <code>darkColor<\/code>, <code>textColor<\/code>, <code>style<\/code>, and <code>margin<\/code>\narguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const FlutterLogoDecoration({\n  this.lightColor = const Color(0xFF42A5F5), \/\/ Colors.blue[400]\n  this.darkColor = const Color(0xFF0D47A1), \/\/ Colors.blue[900]\n  this.textColor = const Color(0xFF616161),\n  this.style = FlutterLogoStyle.markOnly,\n  this.margin = EdgeInsets.zero,\n}) : assert(lightColor != null),\n     assert(darkColor != null),\n     assert(textColor != null),\n     assert(style != null),\n     assert(margin != null),\n     _position = style == FlutterLogoStyle.markOnly ? 0.0 : style == FlutterLogoStyle.horizontal ? 1.0 : -1.0, \/\/ ignore: CONST_EVAL_TYPE_BOOL_NUM_STRING\n     \/\/ (see https:\/\/github.com\/dart-lang\/sdk\/issues\/26980 for details about that ignore statement)\n     _opacity = 1.0;<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/FlutterLogoDecoration.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "FlutterLogoDecoration",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "darkColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "lightColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "margin",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.EdgeInsets"
                        },
                        {
                            "name": "style",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.FlutterLogoStyle"
                        },
                        {
                            "name": "textColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> that will paint this decoration.<\/p>\n<p>The <code>onChanged<\/code> argument configures <a href=\"painting\/BoxPainter\/onChanged.html\">BoxPainter.onChanged<\/a>. It can be\nomitted if there is no chance that the painter will change (for example,\nif it is a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> with definitely no <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nBoxPainter createBoxPainter([ VoidCallback onChanged ]) {\n  assert(debugAssertIsValid());\n  return _FlutterLogoPainter(this);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/createBoxPainter.html",
                    "isDeprecated": false,
                    "type": "painting.BoxPainter",
                    "name": "createBoxPainter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "onChanged",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                },
                {
                    "desc": "<p>In checked mode, throws an exception if the object is not in a\nvalid configuration. Otherwise, returns true.<\/p>\n<p>This is intended to be used as follows:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">assert(myDecoration.debugAssertIsValid());\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool debugAssertIsValid() {\n  assert(lightColor != null\n      &amp;&amp; darkColor != null\n      &amp;&amp; textColor != null\n      &amp;&amp; style != null\n      &amp;&amp; margin != null\n      &amp;&amp; _position != null\n      &amp;&amp; _position.isFinite\n      &amp;&amp; _opacity != null\n      &amp;&amp; _opacity &gt;= 0.0\n      &amp;&amp; _opacity &lt;= 1.0);\n  return true;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/debugAssertIsValid.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "debugAssertIsValid",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"painting\/FlutterLogoDecoration\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/Diagnosticable\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.add(DiagnosticsNode.message('$lightColor\/$darkColor on $textColor'));\n  properties.add(EnumProperty&lt;FlutterLogoStyle&gt;('style', style));\n  if (_inTransition)\n    properties.add(DiagnosticsNode.message('transition $_position:$_opacity'));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Tests whether the given point, on a rectangle of a given size,\nwould be considered to hit the decoration or not. For example,\nif the decoration only draws a circle, this function might\nreturn true if the point was inside the circle and false\notherwise.<\/p>\n<p>The decoration may be sensitive to the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. The\n<code>textDirection<\/code> argument should therefore be provided. If it is known that\nthe decoration is not affected by the text direction, then the argument\nmay be omitted or set to null.<\/p>\n<p>When a <a href=\"painting\/Decoration-class.html\">Decoration<\/a> is painted in a <a href=\"widgets\/Container-class.html\">Container<\/a> or <a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> (which\nis what <a href=\"widgets\/Container-class.html\">Container<\/a> uses), the <code>textDirection<\/code> parameter will be populated\nbased on the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a> (by way of the <a href=\"rendering\/RenderDecoratedBox-class.html\">RenderDecoratedBox<\/a>\nrenderer).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\n\/\/ TODO(ianh): better hit testing\nbool hitTest(Size size, Offset position, { TextDirection textDirection }) =&gt; true;<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/hitTest.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "hitTest",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two Flutter logo descriptions.<\/p>\n<p>Interpolates both the color and the style in a continuous fashion.<\/p>\n<p>If both values are null, this returns null. Otherwise, it returns a\nnon-null value. If one of the values is null, then the result is obtained\nby scaling the other value's opacity and <a href=\"painting\/FlutterLogoDecoration\/margin.html\">margin<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/FlutterLogoDecoration\/lerp.html\">Decoration.lerp<\/a>, which interpolates between arbitrary decorations.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static FlutterLogoDecoration lerp(FlutterLogoDecoration a, FlutterLogoDecoration b, double t) {\n  assert(t != null);\n  assert(a == null || a.debugAssertIsValid());\n  assert(b == null || b.debugAssertIsValid());\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null) {\n    return FlutterLogoDecoration._(\n      b.lightColor,\n      b.darkColor,\n      b.textColor,\n      b.style,\n      b.margin * t,\n      b._position,\n      b._opacity * t.clamp(0.0, 1.0),\n    );\n  }\n  if (b == null) {\n    return FlutterLogoDecoration._(\n      a.lightColor,\n      a.darkColor,\n      a.textColor,\n      a.style,\n      a.margin * t,\n      a._position,\n      a._opacity * (1.0 - t).clamp(0.0, 1.0),\n    );\n  }\n  if (t == 0.0)\n    return a;\n  if (t == 1.0)\n    return b;\n  return FlutterLogoDecoration._(\n    Color.lerp(a.lightColor, b.lightColor, t),\n    Color.lerp(a.darkColor, b.darkColor, t),\n    Color.lerp(a.textColor, b.textColor, t),\n    t &lt; 0.5 ? a.style : b.style,\n    EdgeInsets.lerp(a.margin, b.margin, t),\n    a._position + (b._position - a._position) * t,\n    (a._opacity + (b._opacity - a._opacity) * t).clamp(0.0, 1.0),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.FlutterLogoDecoration",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.FlutterLogoDecoration"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.FlutterLogoDecoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of a\ndifferent class) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/FlutterLogoDecoration\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/FlutterLogoDecoration\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>Supporting interpolating from null is recommended as the <a href=\"painting\/FlutterLogoDecoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/FlutterLogoDecoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFlutterLogoDecoration lerpFrom(Decoration a, double t) {\n  assert(debugAssertIsValid());\n  if (a == null || a is FlutterLogoDecoration) {\n    assert(a == null || a.debugAssertIsValid());\n    return FlutterLogoDecoration.lerp(a, this, t);\n  }\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.FlutterLogoDecoration",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of\na different class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/FlutterLogoDecoration\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/FlutterLogoDecoration\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>Supporting interpolating to null is recommended as the <a href=\"painting\/FlutterLogoDecoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/FlutterLogoDecoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFlutterLogoDecoration lerpTo(Decoration b, double t) {\n  assert(debugAssertIsValid());\n  if (b == null || b is FlutterLogoDecoration) {\n    assert(b == null || b.debugAssertIsValid());\n    return FlutterLogoDecoration.lerp(this, b, t);\n  }\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FlutterLogoDecoration\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.FlutterLogoDecoration",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The darker of the two colors used to paint the logo.<\/p>\n<p>See <a href=\"painting\/FlutterLogoDecoration\/lightColor.html\">lightColor<\/a> for more information about selecting the logo's colors.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color darkColor\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/darkColor.html",
                    "name": "darkColor",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/FlutterLogoDecoration\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/FlutterLogoDecoration\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/FlutterLogoDecoration\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/FlutterLogoDecoration\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/FlutterLogoDecoration\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/FlutterLogoDecoration\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode {\n  assert(debugAssertIsValid());\n  return hashValues(\n    lightColor,\n    darkColor,\n    textColor,\n    _position,\n    _opacity,\n  );\n}<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Whether this decoration is complex enough to benefit from caching its painting.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isComplex =&gt; !_inTransition;<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/isComplex.html",
                    "name": "isComplex",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The lighter of the two colors used to paint the logo.<\/p>\n<p>If possible, the default should be used. It corresponds to the 400 and 900\nvalues of <a href=\"material\/Colors\/blue-constant.html\">material.Colors.blue<\/a> from the Material library.<\/p>\n<p>If for some reason that color scheme is impractical, the same entries from\n<a href=\"material\/Colors\/amber-constant.html\">material.Colors.amber<\/a>, <a href=\"material\/Colors\/red-constant.html\">material.Colors.red<\/a>, or\n<a href=\"material\/Colors\/indigo-constant.html\">material.Colors.indigo<\/a> colors can be used. These are Flutter's secondary\ncolors.<\/p>\n<p>In extreme cases where none of those four color schemes will work,\n<a href=\"material\/Colors\/pink-constant.html\">material.Colors.pink<\/a>, <a href=\"material\/Colors\/purple-constant.html\">material.Colors.purple<\/a>, or\n<a href=\"material\/Colors\/cyan-constant.html\">material.Colors.cyan<\/a> can be used. These are Flutter's tertiary colors.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color lightColor\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/lightColor.html",
                    "name": "lightColor",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>How far to inset the logo from the edge of the container.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final EdgeInsets margin\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/margin.html",
                    "name": "margin",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Whether and where to draw the \"Flutter\" text. By default, only the logo\nitself is drawn.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final FlutterLogoStyle style\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/style.html",
                    "name": "style",
                    "isDeprecated": false,
                    "type": "painting.FlutterLogoStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The color used to paint the \"Flutter\" text on the logo, if <a href=\"painting\/FlutterLogoDecoration\/style.html\">style<\/a> is\n<a href=\"painting\/FlutterLogoStyle-class.html\">FlutterLogoStyle.horizontal<\/a> or <a href=\"painting\/FlutterLogoStyle-class.html\">FlutterLogoStyle.stacked<\/a>. The\nappropriate color is <code>const Color(0xFF616161)<\/code> (a medium gray), against a\nwhite background.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color textColor\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/FlutterLogoDecoration\/textColor.html",
                    "name": "textColor",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FlutterLogoDecoration",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An offset that's expressed as a fraction of a <a href=\"dart-ui\/Size-class.html\">Size<\/a>.<\/p>\n<p><code>FractionalOffset(1.0, 0.0)<\/code> represents the top right of the <a href=\"dart-ui\/Size-class.html\">Size<\/a>.<\/p>\n<p><code>FractionalOffset(0.0, 1.0)<\/code> represents the bottom left of the <a href=\"dart-ui\/Size-class.html\">Size<\/a>.<\/p>\n<p><code>FractionalOffset(0.5, 2.0)<\/code> represents a point half way across the <a href=\"dart-ui\/Size-class.html\">Size<\/a>,\nbelow the bottom of the rectangle by the height of the <a href=\"dart-ui\/Size-class.html\">Size<\/a>.<\/p>\n<p>The <a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> class specifies offsets in terms of a distance from\nthe top left, regardless of the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n<h2 id=\"design-discussion\">Design discussion<\/h2>\n<p><a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> and <a href=\"painting\/Alignment-class.html\">Alignment<\/a> are two different representations of the\nsame information: the location within a rectangle relative to the size of\nthe rectangle. The difference between the two classes is in the coordinate\nsystem they use to represent the location.<\/p>\n<p><a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> uses a coordinate system with an origin in the top-left\ncorner of the rectangle whereas <a href=\"painting\/Alignment-class.html\">Alignment<\/a> uses a coordinate system with an\norigin in the center of the rectangle.<\/p>\n<p>Historically, <a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> predates <a href=\"painting\/Alignment-class.html\">Alignment<\/a>. When we attempted to\nmake a version of <a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> that adapted to the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, we\nran into difficulty because placing the origin in the top-left corner\nintroduced a left-to-right bias that was hard to remove.<\/p>\n<p>By placing the origin in the center, <a href=\"painting\/Alignment-class.html\">Alignment<\/a> and <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>\nare able to use the same origin, which means we can use a linear function to\nresolve an <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a> into an <a href=\"painting\/Alignment-class.html\">Alignment<\/a> in both\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a> and <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a>.<\/p>\n<p><a href=\"painting\/Alignment-class.html\">Alignment<\/a> is better for most purposes than <a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> and should\nbe used instead of <a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a>. We continue to implement\n<a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a> to support code that predates <a href=\"painting\/Alignment-class.html\">Alignment<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/Alignment-class.html\">Alignment<\/a>, which uses a coordinate system based on the center of the\nrectangle instead of the top left corner of the rectangle.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/FractionalOffset-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.FractionalOffset",
            "shortname": "FractionalOffset",
            "extends": [
                "painting.Alignment",
                "painting.AlignmentGeometry",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "rendering.FractionalOffsetTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a fractional offset.<\/p>\n<p>The <code>dx<\/code> and <code>dy<\/code> arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const FractionalOffset(double dx, double dy)\n  : assert(dx != null),\n    assert(dy != null),\n    super(dx * 2.0 - 1.0, dy * 2.0 - 1.0);<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/FractionalOffset.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "FractionalOffset",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.FractionalOffset",
                    "params": [
                        {
                            "name": "dx",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "dy",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/FractionalOffset-class.html\">FractionalOffset<\/a>s.<\/p>\n<p>If either is null, this function interpolates from <a href=\"painting\/FractionalOffset\/center-constant.html\">FractionalOffset.center<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static FractionalOffset lerp(FractionalOffset a, FractionalOffset b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return FractionalOffset(ui.lerpDouble(0.5, b.dx, t), ui.lerpDouble(0.5, b.dy, t));\n  if (b == null)\n    return FractionalOffset(ui.lerpDouble(a.dx, 0.5, t), ui.lerpDouble(a.dy, 0.5, t));\n  return FractionalOffset(ui.lerpDouble(a.dx, b.dx, t), ui.lerpDouble(a.dy, b.dy, t));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FractionalOffset",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.FractionalOffset"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.FractionalOffset"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return 'FractionalOffset(${dx.toStringAsFixed(1)}, '\n                          '${dy.toStringAsFixed(1)})';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The center point along the bottom edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset bottomCenter = FractionalOffset(0.5, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/bottomCenter-constant.html",
                    "name": "bottomCenter",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The bottom left corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset bottomLeft = FractionalOffset(0.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/bottomLeft-constant.html",
                    "name": "bottomLeft",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The bottom right corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset bottomRight = FractionalOffset(1.0, 1.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/bottomRight-constant.html",
                    "name": "bottomRight",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The center point, both horizontally and vertically.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset center = FractionalOffset(0.5, 0.5)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/center-constant.html",
                    "name": "center",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the left edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset centerLeft = FractionalOffset(0.0, 0.5)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/centerLeft-constant.html",
                    "name": "centerLeft",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the right edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset centerRight = FractionalOffset(1.0, 0.5)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/centerRight-constant.html",
                    "name": "centerRight",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The distance fraction in the horizontal direction.<\/p>\n<p>A value of 0.0 corresponds to the leftmost edge. A value of 1.0\ncorresponds to the rightmost edge. Values are not limited to that range;\nnegative values represent positions to the left of the left edge, and\nvalues greater than 1.0 represent positions to the right of the right\nedge.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get dx =&gt; (x + 1.0) \/ 2.0;<\/code><\/pre>\n        ",
                    "href": "painting\/FractionalOffset\/dx.html",
                    "name": "dx",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The distance fraction in the vertical direction.<\/p>\n<p>A value of 0.0 corresponds to the topmost edge. A value of 1.0 corresponds\nto the bottommost edge. Values are not limited to that range; negative\nvalues represent positions above the top, and values greater than 1.0\nrepresent positions below the bottom.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get dy =&gt; (y + 1.0) \/ 2.0;<\/code><\/pre>\n        ",
                    "href": "painting\/FractionalOffset\/dy.html",
                    "name": "dy",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The center point along the top edge.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset topCenter = FractionalOffset(0.5, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/topCenter-constant.html",
                    "name": "topCenter",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The top left corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset topLeft = FractionalOffset(0.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/topLeft-constant.html",
                    "name": "topLeft",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                },
                {
                    "desc": "<p>The top right corner.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const FractionalOffset topRight = FractionalOffset(1.0, 0.0)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/FractionalOffset\/topRight-constant.html",
                    "name": "topRight",
                    "isDeprecated": false,
                    "type": "painting.FractionalOffset",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FractionalOffset",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A 2D gradient.<\/p>\n<p>This is an interface that allows <a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a>, <a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a>, and\n<a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a> classes to be used interchangeably in <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>s.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"https:\/\/api.flutter.dev\/flutter\/dart-ui\/Gradient-class.html\">Gradient<\/a>, the class in the <a href=\"dart-ui\/dart-ui-library.html\">dart:ui<\/a> library.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/Gradient-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.Gradient",
            "shortname": "Gradient",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.LinearGradient",
                "painting.RadialGradient",
                "painting.SweepGradient"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Initialize the gradient's colors and stops.<\/p>\n<p>The <code>colors<\/code> argument must not be null, and must have at least two colors\n(the length is not verified until the <a href=\"painting\/Gradient\/createShader.html\">createShader<\/a> method is called).<\/p>\n<p>If specified, the <code>stops<\/code> argument must have the same number of entries as\n<code>colors<\/code> (this is also not verified until the <a href=\"painting\/Gradient\/createShader.html\">createShader<\/a> method is\ncalled).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const Gradient({\n  @required this.colors,\n  this.stops,\n}) : assert(colors != null);<\/code><\/pre>\n    ",
                    "href": "painting\/Gradient\/Gradient.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "Gradient",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.Gradient",
                    "params": [
                        {
                            "name": "colors",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:ui.Color>"
                        },
                        {
                            "name": "stops",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:core.double>"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Shader-class.html\">Shader<\/a> for this gradient to fill the given rect.<\/p>\n<p>If the gradient's configuration is text-direction-dependent, for example\nit uses <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a> objects instead of <a href=\"painting\/Alignment-class.html\">Alignment<\/a>\nobjects, then the <code>textDirection<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Shader createShader(Rect rect, { TextDirection textDirection });<\/code><\/pre>\n    ",
                    "href": "painting\/Gradient\/createShader.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Shader",
                    "name": "createShader",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Gradient",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates between two <a href=\"painting\/Gradient-class.html\">Gradient<\/a>s.<\/p>\n<p>This defers to <code>b<\/code>'s <a href=\"painting\/Gradient\/lerpTo.html\">lerpTo<\/a> function if <code>b<\/code> is not null. If <code>b<\/code> is\nnull or if its <a href=\"painting\/Gradient\/lerpTo.html\">lerpTo<\/a> returns null, it uses <code>a<\/code>'s <a href=\"painting\/Gradient\/lerpFrom.html\">lerpFrom<\/a>\nfunction instead. If both return null, it returns <code>a<\/code> before <code>t == 0.5<\/code>\nand <code>b<\/code> after <code>t == 0.5<\/code>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Gradient lerp(Gradient a, Gradient b, double t) {\n  assert(t != null);\n  Gradient result;\n  if (b != null)\n    result = b.lerpFrom(a, t); \/\/ if a is null, this must return non-null\n  if (result == null &amp;&amp; a != null)\n    result = a.lerpTo(b, t); \/\/ if b is null, this must return non-null\n  if (result != null)\n    return result;\n  if (a == null &amp;&amp; b == null)\n    return null;\n  assert(a != null &amp;&amp; b != null);\n  return t &lt; 0.5 ? a.scale(1.0 - (t * 2.0)) : b.scale((t - 0.5) * 2.0);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Gradient\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Gradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Gradient-class.html\">Gradient<\/a> to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/Gradient\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/Gradient\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>If <code>a<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/Gradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/Gradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nGradient lerpFrom(Gradient a, double t) {\n  if (a == null)\n    return scale(t);\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Gradient\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Gradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Gradient-class.html\">Gradient<\/a>.<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/Gradient\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/Gradient\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>If <code>b<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/Gradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/Gradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nGradient lerpTo(Gradient b, double t) {\n  if (b == null)\n    return scale(1.0 - t);\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/Gradient\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Gradient",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new gradient with its properties scaled by the given factor.<\/p>\n<p>A factor of 0.0 (or less) should result in a variant of the gradient that\nis invisible; any two factors epsilon apart should be unnoticeably\ndifferent from each other at first glance. From this it follows that\nscaling a gradient with values from 1.0 to 0.0 over time should cause the\ngradient to smoothly disappear.<\/p>\n<p>Typically this is the same as interpolating from null (with <a href=\"painting\/Gradient\/lerp.html\">lerp<\/a>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Gradient scale(double factor);<\/code><\/pre>\n    ",
                    "href": "painting\/Gradient\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.Gradient",
                    "params": [
                        {
                            "name": "factor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The colors the gradient should obtain at each of the stops.<\/p>\n<p>If <a href=\"painting\/Gradient\/stops.html\">stops<\/a> is non-null, this list must have the same length as <a href=\"painting\/Gradient\/stops.html\">stops<\/a>.<\/p>\n<p>This list must have at least two colors in it (otherwise, it's not a\ngradient!).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final List&lt;Color&gt; colors\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Gradient\/colors.html",
                    "name": "colors",
                    "isDeprecated": false,
                    "type": "dart:core.List<dart:ui.Color>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Gradient",
                    "params": []
                },
                {
                    "desc": "<p>A list of values from 0.0 to 1.0 that denote fractions along the gradient.<\/p>\n<p>If non-null, this list must have the same length as <a href=\"painting\/Gradient\/colors.html\">colors<\/a>.<\/p>\n<p>If the first value is not 0.0, then a stop with position 0.0 and a color\nequal to the first color in <a href=\"painting\/Gradient\/colors.html\">colors<\/a> is implied.<\/p>\n<p>If the last value is not 1.0, then a stop with position 1.0 and a color\nequal to the last color in <a href=\"painting\/Gradient\/colors.html\">colors<\/a> is implied.<\/p>\n<p>The values in the <a href=\"painting\/Gradient\/stops.html\">stops<\/a> list must be in ascending order. If a value in\nthe <a href=\"painting\/Gradient\/stops.html\">stops<\/a> list is less than an earlier value in the list, then its value\nis assumed to equal the previous value.<\/p>\n<p>If stops is null, then a set of uniformly distributed stops is implied,\nwith the first stop at 0.0 and the last stop at 1.0.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final List&lt;double&gt; stops\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/Gradient\/stops.html",
                    "name": "stops",
                    "isDeprecated": false,
                    "type": "dart:core.List<dart:core.double>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.Gradient",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A color represented using <a href=\"painting\/HSLColor\/alpha.html\">alpha<\/a>, <a href=\"painting\/HSLColor\/hue.html\">hue<\/a>, <a href=\"painting\/HSLColor\/saturation.html\">saturation<\/a>, and <a href=\"painting\/HSLColor\/lightness.html\">lightness<\/a>.<\/p>\n<p>An <a href=\"painting\/HSLColor-class.html\">HSLColor<\/a> is represented in a parameter space that's based up human\nperception of colored light. The representation is useful for some color\ncomputations (e.g., combining colors of light), because interpolation and\npicking of colors as red, green, and blue channels doesn't always produce\nintuitive results.<\/p>\n<p>HSL is a perceptual color model, placing fully saturated colors around a\ncircle (conceptually) at a lightness of \u200b0.5, with a lightness of 0.0 being\ncompletely black, and a lightness of 1.0 being completely white. As the\nlightness increases or decreases from 0.5, the apparent saturation decreases\nproportionally (even though the <a href=\"painting\/HSLColor\/saturation.html\">saturation<\/a> parameter hasn't changed).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/HSVColor-class.html\">HSVColor<\/a>, a color that uses a color space based on human perception of\npigments (e.g. paint and printer's ink).<\/li>\n<li>\n<a href=\"https:\/\/en.wikipedia.org\/wiki\/HSL_and_HSV\">HSV and HSL<\/a> Wikipedia\narticle, which this implementation is based upon.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/HSLColor-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.HSLColor",
            "shortname": "HSLColor",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Linearly interpolate between two HSLColors.<\/p>\n<p>The colors are interpolated by interpolating the <a href=\"painting\/HSLColor\/alpha.html\">alpha<\/a>, <a href=\"painting\/HSLColor\/hue.html\">hue<\/a>,\n<a href=\"painting\/HSLColor\/saturation.html\">saturation<\/a>, and <a href=\"painting\/HSLColor\/lightness.html\">lightness<\/a> channels separately, which usually leads to\na more pleasing effect than <a href=\"painting\/HSLColor\/lerp.html\">Color.lerp<\/a> (which interpolates the red,\ngreen, and blue channels separately).<\/p>\n<p>If either color is null, this function linearly interpolates from a\ntransparent instance of the other color. This is usually preferable to\ninterpolating from <a href=\"material\/Colors\/transparent-constant.html\">Colors.transparent<\/a> (<code>const Color(0x00000000)<\/code>) since\nthat will interpolate from a transparent red and cycle through the hues to\nmatch the target color, regardless of what that color's hue is.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values between them\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid\n(and can easily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values outside of the valid range for each channel will be clamped.<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static HSLColor lerp(HSLColor a, HSLColor b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b._scaleAlpha(t);\n  if (b == null)\n    return a._scaleAlpha(1.0 - t);\n  return HSLColor.fromAHSL(\n    lerpDouble(a.alpha, b.alpha, t).clamp(0.0, 1.0),\n    lerpDouble(a.hue, b.hue, t) % 360.0,\n    lerpDouble(a.saturation, b.saturation, t).clamp(0.0, 1.0),\n    lerpDouble(a.lightness, b.lightness, t).clamp(0.0, 1.0),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.HSLColor",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.HSLColor"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.HSLColor"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns this HSL color in RGB.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Color toColor() {\n  final double chroma = (1.0 - (2.0 * lightness - 1.0).abs()) * saturation;\n  final double secondary = chroma * (1.0 - (((hue \/ 60.0) % 2.0) - 1.0).abs());\n  final double match = lightness - chroma \/ 2.0;\n\n  return _colorFromHue(alpha, hue, chroma, secondary, match);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/toColor.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "name": "toColor",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType($alpha, $hue, $saturation, $lightness)';<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                },
                {
                    "desc": "<p>Returns a copy of this color with the alpha parameter replaced with the\ngiven value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSLColor withAlpha(double alpha) {\n  return HSLColor.fromAHSL(alpha, hue, saturation, lightness);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/withAlpha.html",
                    "isDeprecated": false,
                    "type": "painting.HSLColor",
                    "name": "withAlpha",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": [
                        {
                            "name": "alpha",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>hue<\/code> parameter replaced with the\ngiven value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSLColor withHue(double hue) {\n  return HSLColor.fromAHSL(alpha, hue, saturation, lightness);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/withHue.html",
                    "isDeprecated": false,
                    "type": "painting.HSLColor",
                    "name": "withHue",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": [
                        {
                            "name": "hue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>lightness<\/code> parameter replaced with\nthe given value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSLColor withLightness(double lightness) {\n  return HSLColor.fromAHSL(alpha, hue, saturation, lightness);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/withLightness.html",
                    "isDeprecated": false,
                    "type": "painting.HSLColor",
                    "name": "withLightness",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": [
                        {
                            "name": "lightness",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>saturation<\/code> parameter replaced with\nthe given value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSLColor withSaturation(double saturation) {\n  return HSLColor.fromAHSL(alpha, hue, saturation, lightness);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSLColor\/withSaturation.html",
                    "isDeprecated": false,
                    "type": "painting.HSLColor",
                    "name": "withSaturation",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSLColor",
                    "params": [
                        {
                            "name": "saturation",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Alpha, from 0.0 to 1.0. The describes the transparency of the color.\nA value of 0.0 is fully transparent, and 1.0 is fully opaque.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double alpha\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSLColor\/alpha.html",
                    "name": "alpha",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/HSLColor\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/HSLColor\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/HSLColor\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/HSLColor\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/HSLColor\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/HSLColor\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(alpha, hue, saturation, lightness);<\/code><\/pre>\n        ",
                    "href": "painting\/HSLColor\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                },
                {
                    "desc": "<p>Hue, from 0.0 to 360.0. Describes which color of the spectrum is\nrepresented. A value of 0.0 represents red, as does 360.0. Values in\nbetween go through all the hues representable in RGB. You can think of\nthis as selecting which color filter is placed over a light.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double hue\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSLColor\/hue.html",
                    "name": "hue",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                },
                {
                    "desc": "<p>Lightness, from 0.0 to 1.0. The lightness of a color describes how bright\na color is. A value of 0.0 indicates black, and 1.0 indicates white. You\ncan think of this as the intensity of the light behind the filter. As the\nlightness approaches 0.5, the colors get brighter and appear more\nsaturated, and over 0.5, the colors start to become less saturated and\napproach white at 1.0.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double lightness\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSLColor\/lightness.html",
                    "name": "lightness",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                },
                {
                    "desc": "<p>Saturation, from 0.0 to 1.0. This describes how colorful the color is.\n0.0 implies a shade of grey (i.e. no pigment), and 1.0 implies a color as\nvibrant as that hue gets. You can think of this as the purity of the\ncolor filter over the light.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double saturation\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSLColor\/saturation.html",
                    "name": "saturation",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSLColor",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A color represented using <a href=\"painting\/HSVColor\/alpha.html\">alpha<\/a>, <a href=\"painting\/HSVColor\/hue.html\">hue<\/a>, <a href=\"painting\/HSVColor\/saturation.html\">saturation<\/a>, and <a href=\"painting\/HSVColor\/value.html\">value<\/a>.<\/p>\n<p>An <a href=\"painting\/HSVColor-class.html\">HSVColor<\/a> is represented in a parameter space that's based on human\nperception of color in pigments (e.g. paint and printer's ink). The\nrepresentation is useful for some color computations (e.g. rotating the hue\nthrough the colors), because interpolation and picking of\ncolors as red, green, and blue channels doesn't always produce intuitive\nresults.<\/p>\n<p>The HSV color space models the way that different pigments are perceived\nwhen mixed. The hue describes which pigment is used, the saturation\ndescribes which shade of the pigment, and the value resembles mixing the\npigment with different amounts of black or white pigment.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/HSLColor-class.html\">HSLColor<\/a>, a color that uses a color space based on human perception of\ncolored light.<\/li>\n<li>\n<a href=\"https:\/\/en.wikipedia.org\/wiki\/HSL_and_HSV\">HSV and HSL<\/a> Wikipedia\narticle, which this implementation is based upon.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/HSVColor-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.HSVColor",
            "shortname": "HSVColor",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Linearly interpolate between two HSVColors.<\/p>\n<p>The colors are interpolated by interpolating the <a href=\"painting\/HSVColor\/alpha.html\">alpha<\/a>, <a href=\"painting\/HSVColor\/hue.html\">hue<\/a>,\n<a href=\"painting\/HSVColor\/saturation.html\">saturation<\/a>, and <a href=\"painting\/HSVColor\/value.html\">value<\/a> channels separately, which usually leads to a\nmore pleasing effect than <a href=\"painting\/HSVColor\/lerp.html\">Color.lerp<\/a> (which interpolates the red, green,\nand blue channels separately).<\/p>\n<p>If either color is null, this function linearly interpolates from a\ntransparent instance of the other color. This is usually preferable to\ninterpolating from <a href=\"material\/Colors\/transparent-constant.html\">Colors.transparent<\/a> (<code>const Color(0x00000000)<\/code>) since\nthat will interpolate from a transparent red and cycle through the hues to\nmatch the target color, regardless of what that color's hue is.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Values outside of the valid range for each channel will be clamped.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static HSVColor lerp(HSVColor a, HSVColor b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b._scaleAlpha(t);\n  if (b == null)\n    return a._scaleAlpha(1.0 - t);\n  return HSVColor.fromAHSV(\n    lerpDouble(a.alpha, b.alpha, t).clamp(0.0, 1.0),\n    lerpDouble(a.hue, b.hue, t) % 360.0,\n    lerpDouble(a.saturation, b.saturation, t).clamp(0.0, 1.0),\n    lerpDouble(a.value, b.value, t).clamp(0.0, 1.0),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.HSVColor",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.HSVColor"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.HSVColor"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns this color in RGB.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Color toColor() {\n  final double chroma = saturation * value;\n  final double secondary = chroma * (1.0 - (((hue \/ 60.0) % 2.0) - 1.0).abs());\n  final double match = value - chroma;\n\n  return _colorFromHue(alpha, hue, chroma, secondary, match);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/toColor.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "name": "toColor",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType($alpha, $hue, $saturation, $value)';<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>alpha<\/code> parameter replaced with the\ngiven value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSVColor withAlpha(double alpha) {\n  return HSVColor.fromAHSV(alpha, hue, saturation, value);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/withAlpha.html",
                    "isDeprecated": false,
                    "type": "painting.HSVColor",
                    "name": "withAlpha",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": [
                        {
                            "name": "alpha",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>hue<\/code> parameter replaced with the\ngiven value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSVColor withHue(double hue) {\n  return HSVColor.fromAHSV(alpha, hue, saturation, value);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/withHue.html",
                    "isDeprecated": false,
                    "type": "painting.HSVColor",
                    "name": "withHue",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": [
                        {
                            "name": "hue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>saturation<\/code> parameter replaced with\nthe given value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSVColor withSaturation(double saturation) {\n  return HSVColor.fromAHSV(alpha, hue, saturation, value);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/withSaturation.html",
                    "isDeprecated": false,
                    "type": "painting.HSVColor",
                    "name": "withSaturation",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": [
                        {
                            "name": "saturation",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a copy of this color with the <code>value<\/code> parameter replaced with the\ngiven value.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">HSVColor withValue(double value) {\n  return HSVColor.fromAHSV(alpha, hue, saturation, value);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/HSVColor\/withValue.html",
                    "isDeprecated": false,
                    "type": "painting.HSVColor",
                    "name": "withValue",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.HSVColor",
                    "params": [
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Alpha, from 0.0 to 1.0. The describes the transparency of the color.\nA value of 0.0 is fully transparent, and 1.0 is fully opaque.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double alpha\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSVColor\/alpha.html",
                    "name": "alpha",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/HSVColor\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/HSVColor\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/HSVColor\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/HSVColor\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/HSVColor\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/HSVColor\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(alpha, hue, saturation, value);<\/code><\/pre>\n        ",
                    "href": "painting\/HSVColor\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                },
                {
                    "desc": "<p>Hue, from 0.0 to 360.0. Describes which color of the spectrum is\nrepresented. A value of 0.0 represents red, as does 360.0. Values in\nbetween go through all the hues representable in RGB. You can think of\nthis as selecting which pigment will be added to a color.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double hue\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSVColor\/hue.html",
                    "name": "hue",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                },
                {
                    "desc": "<p>Saturation, from 0.0 to 1.0. This describes how colorful the color is.\n0.0 implies a shade of grey (i.e. no pigment), and 1.0 implies a color as\nvibrant as that hue gets. You can think of this as the equivalent of\nhow much of a pigment is added.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double saturation\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSVColor\/saturation.html",
                    "name": "saturation",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                },
                {
                    "desc": "<p>Value, from 0.0 to 1.0. The \"value\" of a color that, in this context,\ndescribes how bright a color is. A value of 0.0 indicates black, and 1.0\nindicates full intensity color. You can think of this as the equivalent of\nremoving black from the color as value increases.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double value\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/HSVColor\/value.html",
                    "name": "value",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.HSVColor",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Class for the <a href=\"painting\/imageCache.html\">imageCache<\/a> object.<\/p>\n<p>Implements a least-recently-used cache of up to 1000 images, and up to 100\nMB. The maximum size can be adjusted using <a href=\"painting\/ImageCache\/maximumSize.html\">maximumSize<\/a> and\n<a href=\"painting\/ImageCache\/maximumSizeBytes.html\">maximumSizeBytes<\/a>. Images that are actively in use (i.e. to which the\napplication is holding references, either via <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> objects,\n<a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> objects, <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> objects, or raw <a href=\"dart-ui\/Image-class.html\">dart:ui.Image<\/a>\nobjects) may get evicted from the cache (and thus need to be refetched from\nthe network if they are referenced in the <a href=\"painting\/ImageCache\/putIfAbsent.html\">putIfAbsent<\/a> method), but the raw\nbits are kept in memory for as long as the application is using them.<\/p>\n<p>The <a href=\"painting\/ImageCache\/putIfAbsent.html\">putIfAbsent<\/a> method is the main entry-point to the cache API. It\nreturns the previously cached <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> for the given key, if\navailable; if not, it calls the given callback to obtain it first. In either\ncase, the key is moved to the \"most recently used\" position.<\/p>\n<p>Generally this class is not used directly. The <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> class and its\nsubclasses automatically handle the caching of images.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/ImageCache-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageCache",
            "shortname": "ImageCache",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "painting\/ImageCache\/ImageCache.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ImageCache",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ImageCache",
                    "params": []
                },
                {
                    "desc": "<p>Evicts all entries from the cache.<\/p>\n<p>This is useful if, for instance, the root asset bundle has been updated\nand therefore new images must be obtained.<\/p>\n<p>Images which have not finished loading yet will not be removed from the\ncache, and when they complete they will be inserted as normal.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void clear() {\n  _cache.clear();\n  _pendingImages.clear();\n  _currentSizeBytes = 0;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageCache\/clear.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "clear",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageCache",
                    "params": []
                },
                {
                    "desc": "<p>Evicts a single entry from the cache, returning true if successful.\nPending images waiting for completion are removed as well, returning true if successful.<\/p>\n<p>When a pending image is removed the listener on it is removed as well to prevent\nit from adding itself to the cache if it eventually completes.<\/p>\n<p>The <code>key<\/code> must be equal to an object used to cache an image in\n<a href=\"painting\/ImageCache\/putIfAbsent.html\">ImageCache.putIfAbsent<\/a>.<\/p>\n<p>If the key is not immediately available, as is common, consider using\n<a href=\"painting\/ImageCache\/evict.html\">ImageProvider.evict<\/a> to call this method indirectly instead.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>, for providing images to the <a href=\"widgets\/Image-class.html\">Image<\/a> widget.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool evict(Object key) {\n  final _PendingImage pendingImage = _pendingImages.remove(key);\n  if (pendingImage != null) {\n    pendingImage.removeListener();\n    return true;\n  }\n  final _CachedImage image = _cache.remove(key);\n  if (image != null) {\n    _currentSizeBytes -= image.sizeBytes;\n    return true;\n  }\n  return false;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageCache\/evict.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "evict",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageCache",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the previously cached <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> for the given key, if available;\nif not, calls the given callback to obtain it first. In either case, the\nkey is moved to the \"most recently used\" position.<\/p>\n<p>The arguments must not be null. The <code>loader<\/code> cannot return null.<\/p>\n<p>In the event that the loader throws an exception, it will be caught only if\n<code>onError<\/code> is also provided. When an exception is caught resolving an image,\nno completers are cached and <code>null<\/code> is returned instead of a new\ncompleter.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ImageStreamCompleter putIfAbsent(Object key, ImageStreamCompleter loader(), { ImageErrorListener onError }) {\n  assert(key != null);\n  assert(loader != null);\n  ImageStreamCompleter result = _pendingImages[key]?.completer;\n  \/\/ Nothing needs to be done because the image hasn't loaded yet.\n  if (result != null)\n    return result;\n  \/\/ Remove the provider from the list so that we can move it to the\n  \/\/ recently used position below.\n  final _CachedImage image = _cache.remove(key);\n  if (image != null) {\n    _cache[key] = image;\n    return image.completer;\n  }\n  try {\n    result = loader();\n  } catch (error, stackTrace) {\n    if (onError != null) {\n      onError(error, stackTrace);\n      return null;\n    } else {\n      rethrow;\n    }\n  }\n  void listener(ImageInfo info, bool syncCall) {\n    \/\/ Images that fail to load don't contribute to cache size.\n    final int imageSize = info?.image == null ? 0 : info.image.height * info.image.width * 4;\n    final _CachedImage image = _CachedImage(result, imageSize);\n    \/\/ If the image is bigger than the maximum cache size, and the cache size\n    \/\/ is not zero, then increase the cache size to the size of the image plus\n    \/\/ some change.\n    if (maximumSizeBytes &gt; 0 &amp;&amp; imageSize &gt; maximumSizeBytes) {\n      _maximumSizeBytes = imageSize + 1000;\n    }\n    _currentSizeBytes += imageSize;\n    final _PendingImage pendingImage = _pendingImages.remove(key);\n    if (pendingImage != null) {\n      pendingImage.removeListener();\n    }\n\n    _cache[key] = image;\n    _checkCacheSize();\n  }\n  if (maximumSize &gt; 0 &amp;&amp; maximumSizeBytes &gt; 0) {\n    _pendingImages[key] = _PendingImage(result, listener);\n    result.addListener(listener);\n  }\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageCache\/putIfAbsent.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "name": "putIfAbsent",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageCache",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "loader",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageStreamCompleter"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageErrorListener"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The current number of cached entries.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get currentSize =&gt; _cache.length;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageCache\/currentSize.html",
                    "name": "currentSize",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageCache",
                    "params": []
                },
                {
                    "desc": "<p>The current size of cached entries in bytes.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get currentSizeBytes =&gt; _currentSizeBytes;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageCache\/currentSizeBytes.html",
                    "name": "currentSizeBytes",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageCache",
                    "params": []
                },
                {
                    "desc": "<p>Maximum number of entries to store in the cache.<\/p>\n<p>Once this many entries have been cached, the least-recently-used entry is\nevicted when adding a new entry.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get maximumSize =&gt; _maximumSize;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageCache\/maximumSize.html",
                    "name": "maximumSize",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageCache",
                    "params": []
                },
                {
                    "desc": "<p>Maximum size of entries to store in the cache in bytes.<\/p>\n<p>Once more than this amount of bytes have been cached, the\nleast-recently-used entry is evicted until there are fewer than the\nmaximum bytes.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get maximumSizeBytes =&gt; _maximumSizeBytes;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageCache\/maximumSizeBytes.html",
                    "name": "maximumSizeBytes",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageCache",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Configuration information passed to the <a href=\"painting\/ImageProvider\/resolve.html\">ImageProvider.resolve<\/a> method to\nselect a specific image.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/createLocalImageConfiguration.html\">createLocalImageConfiguration<\/a>, which creates an <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a>\nbased on ambient configuration in a <a href=\"widgets\/Widget-class.html\">Widget<\/a> environment.<\/li>\n<li>\n<a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>, which uses <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects to determine\nwhich image to obtain.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ImageConfiguration-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageConfiguration",
            "shortname": "ImageConfiguration",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object holding the configuration information for an <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>.<\/p>\n<p>All the arguments are optional. Configuration information is merely\nadvisory and best-effort.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ImageConfiguration({\n  this.bundle,\n  this.devicePixelRatio,\n  this.locale,\n  this.textDirection,\n  this.size,\n  this.platform,\n});<\/code><\/pre>\n    ",
                    "href": "painting\/ImageConfiguration\/ImageConfiguration.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ImageConfiguration",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": [
                        {
                            "name": "bundle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "services.AssetBundle"
                        },
                        {
                            "name": "devicePixelRatio",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "locale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Locale"
                        },
                        {
                            "name": "platform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "foundation.TargetPlatform"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates an object holding the configuration information for an <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>.<\/p>\n<p>All the arguments are optional. Configuration information is merely\nadvisory and best-effort.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ImageConfiguration copyWith({\n  AssetBundle bundle,\n  double devicePixelRatio,\n  Locale locale,\n  TextDirection textDirection,\n  Size size,\n  String platform,\n}) {\n  return ImageConfiguration(\n    bundle: bundle ?? this.bundle,\n    devicePixelRatio: devicePixelRatio ?? this.devicePixelRatio,\n    locale: locale ?? this.locale,\n    textDirection: textDirection ?? this.textDirection,\n    size: size ?? this.size,\n    platform: platform ?? this.platform,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageConfiguration\/copyWith.html",
                    "isDeprecated": false,
                    "type": "painting.ImageConfiguration",
                    "name": "copyWith",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": [
                        {
                            "name": "bundle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "services.AssetBundle"
                        },
                        {
                            "name": "devicePixelRatio",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "locale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Locale"
                        },
                        {
                            "name": "platform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  final StringBuffer result = StringBuffer();\n  result.write('ImageConfiguration(');\n  bool hasArguments = false;\n  if (bundle != null) {\n    if (hasArguments)\n      result.write(', ');\n    result.write('bundle: $bundle');\n    hasArguments = true;\n  }\n  if (devicePixelRatio != null) {\n    if (hasArguments)\n      result.write(', ');\n    result.write('devicePixelRatio: ${devicePixelRatio.toStringAsFixed(1)}');\n    hasArguments = true;\n  }\n  if (locale != null) {\n    if (hasArguments)\n      result.write(', ');\n    result.write('locale: $locale');\n    hasArguments = true;\n  }\n  if (textDirection != null) {\n    if (hasArguments)\n      result.write(', ');\n    result.write('textDirection: $textDirection');\n    hasArguments = true;\n  }\n  if (size != null) {\n    if (hasArguments)\n      result.write(', ');\n    result.write('size: $size');\n    hasArguments = true;\n  }\n  if (platform != null) {\n    if (hasArguments)\n      result.write(', ');\n    result.write('platform: ${describeEnum(platform)}');\n    hasArguments = true;\n  }\n  result.write(')');\n  return result.toString();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageConfiguration\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The preferred <a href=\"services\/AssetBundle-class.html\">AssetBundle<\/a> to use if the <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> needs one and\ndoes not have one already selected.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AssetBundle bundle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/bundle.html",
                    "name": "bundle",
                    "isDeprecated": false,
                    "type": "services.AssetBundle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>The device pixel ratio where the image will be shown.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double devicePixelRatio\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/devicePixelRatio.html",
                    "name": "devicePixelRatio",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>An image configuration that provides no additional information.<\/p>\n<p>Useful when resolving an <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> without any context.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const ImageConfiguration empty = ImageConfiguration()\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/ImageConfiguration\/empty-constant.html",
                    "name": "empty",
                    "isDeprecated": false,
                    "type": "painting.ImageConfiguration",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/ImageConfiguration\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/ImageConfiguration\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/ImageConfiguration\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/ImageConfiguration\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/ImageConfiguration\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/ImageConfiguration\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(bundle, devicePixelRatio, locale, size, platform);<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>The language and region for which to select the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Locale locale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/locale.html",
                    "name": "locale",
                    "isDeprecated": false,
                    "type": "dart:ui.Locale",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>The <a href=\"foundation\/TargetPlatform-class.html\">TargetPlatform<\/a> for which assets should be used. This allows images\nto be specified in a platform-neutral fashion yet use different assets on\ndifferent platforms, to match local conventions e.g. for color matching or\nshadows.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TargetPlatform platform\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/platform.html",
                    "name": "platform",
                    "isDeprecated": false,
                    "type": "foundation.TargetPlatform",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>The size at which the image will be rendered.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Size size\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/size.html",
                    "name": "size",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                },
                {
                    "desc": "<p>The reading direction of the language for which to select the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TextDirection textDirection\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageConfiguration\/textDirection.html",
                    "name": "textDirection",
                    "isDeprecated": false,
                    "type": "dart:ui.TextDirection",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageConfiguration",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A <a href=\"dart-ui\/Image-class.html\">dart:ui.Image<\/a> object with its corresponding scale.<\/p>\n<p>ImageInfo objects are used by <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> objects to represent the\nactual data of the image once it has been obtained.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/ImageInfo-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageInfo",
            "shortname": "ImageInfo",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object for the given image and scale.<\/p>\n<p>Both the image and the scale must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ImageInfo({ @required this.image, this.scale = 1.0 })\n  : assert(image != null),\n    assert(scale != null);<\/code><\/pre>\n    ",
                    "href": "painting\/ImageInfo\/ImageInfo.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ImageInfo",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ImageInfo",
                    "params": [
                        {
                            "name": "image",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Image"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$image @ ${scale}x';<\/code><\/pre>\n    ",
                    "href": "painting\/ImageInfo\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageInfo",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/ImageInfo\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/ImageInfo\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/ImageInfo\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/ImageInfo\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/ImageInfo\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/ImageInfo\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(image, scale);<\/code><\/pre>\n        ",
                    "href": "painting\/ImageInfo\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageInfo",
                    "params": []
                },
                {
                    "desc": "<p>The raw image pixels.<\/p>\n<p>This is the object to pass to the <a href=\"dart-ui\/Canvas\/drawImage.html\">Canvas.drawImage<\/a>,\n<a href=\"dart-ui\/Canvas\/drawImageRect.html\">Canvas.drawImageRect<\/a>, or <a href=\"dart-ui\/Canvas\/drawImageNine.html\">Canvas.drawImageNine<\/a> methods when painting\nthe image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ui.Image image\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageInfo\/image.html",
                    "name": "image",
                    "isDeprecated": false,
                    "type": "dart:ui.Image",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageInfo",
                    "params": []
                },
                {
                    "desc": "<p>The linear scale factor for drawing this image at its intended size.<\/p>\n<p>The scale factor applies to the width and the height.<\/p>\n<p>For example, if this is 2.0 it means that there are four image pixels for\nevery one logical pixel, and the image's actual width and height (as given\nby the <a href=\"dart-ui\/Image\/width.html\">dart:ui.Image.width<\/a> and <a href=\"dart-ui\/Image\/height.html\">dart:ui.Image.height<\/a> properties) are double the\nheight and width that should be used when painting the image (e.g. in the\narguments given to <a href=\"dart-ui\/Canvas\/drawImage.html\">Canvas.drawImage<\/a>).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double scale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ImageInfo\/scale.html",
                    "name": "scale",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageInfo",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Identifies an image without committing to the precise final asset. This\nallows a set of images to be identified and for the precise image to later\nbe resolved based on the environment, e.g. the device pixel ratio.<\/p>\n<p>To obtain an <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> from an <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>, call <a href=\"painting\/ImageProvider\/resolve.html\">resolve<\/a>,\npassing it an <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> object.<\/p>\n<p><a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> uses the global <a href=\"painting\/imageCache.html\">imageCache<\/a> to cache images.<\/p>\n<p>The type argument <code>T<\/code> is the type of the object used to represent a resolved\nconfiguration. This is also the type used for the key in the image cache. It\nshould be immutable and implement the <code>==<\/code> operator and the <a href=\"dart-core\/Object\/hashCode.html\">hashCode<\/a>\ngetter. Subclasses should subclass a variant of <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> with an\nexplicit <code>T<\/code> type argument.<\/p>\n<p>The type argument does not have to be specified when using the type as an\nargument (where any image provider is acceptable).<\/p>\n<p>The following image formats are supported: JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe following shows the code required to write a widget that fully conforms\nto the <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> and <a href=\"widgets\/Widget-class.html\">Widget<\/a> protocols. (It is essentially a\nbare-bones version of the <a href=\"widgets\/Image-class.html\">widgets.Image<\/a> widget.)\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class MyImage extends StatefulWidget {\n  const MyImage({\n    Key key,\n    @required this.imageProvider,\n  }) : assert(imageProvider != null),\n       super(key: key);\n\n  final ImageProvider imageProvider;\n\n  @override\n  _MyImageState createState() =&gt; _MyImageState();\n}\n\nclass _MyImageState extends State&lt;MyImage&gt; {\n  ImageStream _imageStream;\n  ImageInfo _imageInfo;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    \/\/ We call _getImage here because createLocalImageConfiguration() needs to\n    \/\/ be called again if the dependencies changed, in case the changes relate\n    \/\/ to the DefaultAssetBundle, MediaQuery, etc, which that method uses.\n    _getImage();\n  }\n\n  @override\n  void didUpdateWidget(MyImage oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.imageProvider != oldWidget.imageProvider)\n      _getImage();\n  }\n\n  void _getImage() {\n    final ImageStream oldImageStream = _imageStream;\n    _imageStream = widget.imageProvider.resolve(createLocalImageConfiguration(context));\n    if (_imageStream.key != oldImageStream?.key) {\n      \/\/ If the keys are the same, then we got the same image back, and so we don't\n      \/\/ need to update the listeners. If the key changed, though, we must make sure\n      \/\/ to switch our listeners to the new image stream.\n      oldImageStream?.removeListener(_updateImage);\n      _imageStream.addListener(_updateImage);\n    }\n  }\n\n  void _updateImage(ImageInfo imageInfo, bool synchronousCall) {\n    setState(() {\n      \/\/ Trigger a build whenever the image changes.\n      _imageInfo = imageInfo;\n    });\n  }\n\n  @override\n  void dispose() {\n    _imageStream.removeListener(_updateImage);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return RawImage(\n      image: _imageInfo?.image, \/\/ this is a dart:ui Image object\n      scale: _imageInfo?.scale ?? 1.0,\n    );\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/ImageProvider-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageProvider",
            "shortname": "ImageProvider",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.AssetImage",
                "painting.ExactAssetImage",
                "painting.FileImage",
                "painting.MemoryImage",
                "painting.NetworkImage"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ImageProvider();<\/code><\/pre>\n    ",
                    "href": "painting\/ImageProvider\/ImageProvider.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ImageProvider",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ImageProvider",
                    "params": []
                },
                {
                    "desc": "<p>Evicts an entry from the image cache.<\/p>\n<p>Returns a <a href=\"dart-async\/Future-class.html\">Future<\/a> which indicates whether the value was successfully\nremoved.<\/p>\n<p>The <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> used does not need to be the same instance that was\npassed to an <a href=\"widgets\/Image-class.html\">Image<\/a> widget, but it does need to create a key which is\nequal to one.<\/p>\n<p>The <code>cache<\/code> is optional and defaults to the global image cache.<\/p>\n<p>The <code>configuration<\/code> is optional and defaults to\n<a href=\"painting\/ImageConfiguration\/empty-constant.html\">ImageConfiguration.empty<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe following sample code shows how an image loaded using the <a href=\"widgets\/Image-class.html\">Image<\/a>\nwidget can be evicted using a <a href=\"painting\/NetworkImage-class.html\">NetworkImage<\/a> with a matching URL.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class MyWidget extends StatelessWidget {\n  final String url = '...';\n\n  @override\n  Widget build(BuildContext context) {\n    return Image.network(url);\n  }\n\n  void evictImage() {\n    final NetworkImage provider = NetworkImage(url);\n    provider.evict().then&lt;void&gt;((bool success) {\n      if (success)\n        debugPrint('removed image!');\n    });\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;bool&gt; evict({ ImageCache cache, ImageConfiguration configuration = ImageConfiguration.empty }) async {\n  cache ??= imageCache;\n  final T key = await obtainKey(configuration);\n  return cache.evict(key);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageProvider\/evict.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<dart:core.bool>",
                    "name": "evict",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageProvider",
                    "params": [
                        {
                            "name": "cache",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageCache"
                        },
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts a key into an <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a>, and begins fetching the\nimage.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nImageStreamCompleter load(T key);<\/code><\/pre>\n    ",
                    "href": "painting\/ImageProvider\/load.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "name": "load",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageProvider",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<T>"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.<\/p>\n<p>The type of the key is determined by the subclass. It is a value that\nunambiguously identifies the image (<em>including its scale<\/em>) that the <a href=\"painting\/ImageProvider\/load.html\">load<\/a>\nmethod will fetch. Different <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>s given the same constructor\narguments and <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects should return keys that are\n'==' to each other (possibly by using a class for the key that itself\nimplements <code>==<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nFuture&lt;T&gt; obtainKey(ImageConfiguration configuration);<\/code><\/pre>\n    ",
                    "href": "painting\/ImageProvider\/obtainKey.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "obtainKey",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageProvider",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Resolves this image provider using the given <code>configuration<\/code>, returning\nan <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>.<\/p>\n<p>This is the public entry-point of the <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> class hierarchy.<\/p>\n<p>Subclasses should implement <a href=\"painting\/ImageProvider\/obtainKey.html\">obtainKey<\/a> and <a href=\"painting\/ImageProvider\/load.html\">load<\/a>, which are used by this\nmethod.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ImageStream resolve(ImageConfiguration configuration) {\n  assert(configuration != null);\n  final ImageStream stream = ImageStream();\n  T obtainedKey;\n  Future&lt;void&gt; handleError(dynamic exception, StackTrace stack) async {\n    await null; \/\/ wait an event turn in case a listener has been added to the image stream.\n    final _ErrorImageCompleter imageCompleter = _ErrorImageCompleter();\n    stream.setCompleter(imageCompleter);\n    imageCompleter.setError(\n      exception: exception,\n      stack: stack,\n      context: 'while resolving an image',\n      silent: true, \/\/ could be a network error or whatnot\n      informationCollector: (StringBuffer information) {\n        information.writeln('Image provider: $this');\n        information.writeln('Image configuration: $configuration');\n        if (obtainedKey != null) {\n          information.writeln('Image key: $obtainedKey');\n        }\n      },\n    );\n  }\n\n  \/\/ `obtainKey` can throw both sync and async errors.\n  \/\/ `catchError` handles cases where async errors are thrown and the try block is for sync errors.\n  \/\/\n  \/\/ `onError` callback on [ImageCache] handles the cases where `obtainKey` is a sync future and `load` throws.\n  Future&lt;T&gt; key;\n  try {\n    key = obtainKey(configuration);\n  } catch (error, stackTrace) {\n    handleError(error, stackTrace);\n    return stream;\n  }\n\n  key.then&lt;void&gt;((T key) {\n    obtainedKey = key;\n    final ImageStreamCompleter completer = PaintingBinding.instance\n        .imageCache.putIfAbsent(key, () =&gt; load(key), onError: handleError);\n    if (completer != null) {\n      stream.setCompleter(completer);\n    }\n  }).catchError(handleError);\n\n  return stream;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageProvider\/resolve.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStream",
                    "name": "resolve",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageProvider",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType()';<\/code><\/pre>\n    ",
                    "href": "painting\/ImageProvider\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageProvider",
                    "params": []
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A handle to an image resource.<\/p>\n<p>ImageStream represents a handle to a <a href=\"dart-ui\/Image-class.html\">dart:ui.Image<\/a> object and its scale\n(together represented by an <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object). The underlying image object\nmight change over time, either because the image is animating or because the\nunderlying image resource was mutated.<\/p>\n<p>ImageStream objects can also represent an image that hasn't finished\nloading.<\/p>\n<p>ImageStream objects are backed by <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> objects.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>, which has an example that includes the use of an\n<a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> in a <a href=\"widgets\/Widget-class.html\">Widget<\/a>.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ImageStream-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageStream",
            "shortname": "ImageStream",
            "extends": [
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Create an initially unbound image stream.<\/p>\n<p>Once an <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> is available, call <a href=\"painting\/ImageStream\/setCompleter.html\">setCompleter<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ImageStream();<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStream\/ImageStream.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ImageStream",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ImageStream",
                    "params": []
                },
                {
                    "desc": "<p>Adds a listener callback that is called whenever a new concrete <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a>\nobject is available. If a concrete image is already available, this object\nwill call the listener synchronously.<\/p>\n<p>If the assigned <a href=\"painting\/ImageStream\/completer.html\">completer<\/a> completes multiple images over its lifetime,\nthis listener will fire multiple times.<\/p>\n<p>The listener will be passed a flag indicating whether a synchronous call\noccurred. If the listener is added within a render object paint function,\nthen use this flag to avoid calling <a href=\"rendering\/RenderObject\/markNeedsPaint.html\">RenderObject.markNeedsPaint<\/a> during\na paint.<\/p>\n<p>An <a href=\"painting\/ImageErrorListener.html\">ImageErrorListener<\/a> can also optionally be added along with the\n<code>listener<\/code>. If an error occurred, <code>onError<\/code> will be called instead of\n<code>listener<\/code>.<\/p>\n<p>If a <code>listener<\/code> or <code>onError<\/code> handler is registered multiple times, then it\nwill be called multiple times when the image stream completes (whether\nbecause a new image is available or because an error occurs,\nrespectively). In general, registering a listener multiple times is\ndiscouraged because <a href=\"painting\/ImageStream\/removeListener.html\">removeListener<\/a> will remove the first instance that\nwas added, even if it was added with a different <code>onError<\/code> than the\nintended paired <code>addListener<\/code> call.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addListener(ImageListener listener, { ImageErrorListener onError }) {\n  if (_completer != null)\n    return _completer.addListener(listener, onError: onError);\n  _listeners ??= &lt;_ImageListenerPair&gt;[];\n  _listeners.add(_ImageListenerPair(listener, onError));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStream\/addListener.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "addListener",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStream",
                    "params": [
                        {
                            "name": "listener",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageListener"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageErrorListener"
                        }
                    ]
                },
                {
                    "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"painting\/ImageStream\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/Diagnosticable\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.add(ObjectFlagProperty&lt;ImageStreamCompleter&gt;(\n    'completer',\n    _completer,\n    ifPresent: _completer?.toStringShort(),\n    ifNull: 'unresolved',\n  ));\n  properties.add(ObjectFlagProperty&lt;List&lt;_ImageListenerPair&gt;&gt;(\n    'listeners',\n    _listeners,\n    ifPresent: '${_listeners?.length} listener${_listeners?.length == 1 ? \"\" : \"s\" }',\n    ifNull: 'no listeners',\n    level: _completer != null ? DiagnosticLevel.hidden : DiagnosticLevel.info,\n  ));\n  _completer?.debugFillProperties(properties);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStream\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStream",
                    "params": [
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Stop listening for new concrete <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> objects and errors from\nthe <code>listener<\/code>'s associated <a href=\"painting\/ImageErrorListener.html\">ImageErrorListener<\/a>.<\/p>\n<p>If <code>listener<\/code> has been added multiple times, this removes the first\ninstance of the listener, along with the <code>onError<\/code> listener that was\nregistered with that first instance. This might not be the instance that\nthe <code>addListener<\/code> corresponding to this <code>removeListener<\/code> had added.<\/p>\n<p>For example, if one widget calls <a href=\"painting\/ImageStream\/addListener.html\">addListener<\/a> with a global static\nfunction and a private error handler, and another widget calls\n<a href=\"painting\/ImageStream\/addListener.html\">addListener<\/a> with the same global static function but a different private\nerror handler, then the second widget is disposed and removes the image\nlistener (the aforementioned global static function), it will remove the\nerror handler from the first widget, not the second. If an error later\noccurs, the first widget, which is still supposedly listening, will not\nreceive any messages, while the second, which is supposedly disposed, will\nhave its callback invoked.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void removeListener(ImageListener listener) {\n  if (_completer != null)\n    return _completer.removeListener(listener);\n  assert(_listeners != null);\n  for (int i = 0; i &lt; _listeners.length; i += 1) {\n    if (_listeners[i].listener == listener) {\n      _listeners.removeAt(i);\n      break;\n    }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStream\/removeListener.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "removeListener",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStream",
                    "params": [
                        {
                            "name": "listener",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageListener"
                        }
                    ]
                },
                {
                    "desc": "<p>Assigns a particular <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> to this <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>.<\/p>\n<p>This is usually done automatically by the <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> that created the\n<a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>.<\/p>\n<p>This method can only be called once per stream. To have an <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>\nrepresent multiple images over time, assign it a completer that\ncompletes several images in succession.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void setCompleter(ImageStreamCompleter value) {\n  assert(_completer == null);\n  _completer = value;\n  if (_listeners != null) {\n    final List&lt;_ImageListenerPair&gt; initialListeners = _listeners;\n    _listeners = null;\n    for (_ImageListenerPair listenerPair in initialListeners) {\n      _completer.addListener(\n        listenerPair.listener,\n        onError: listenerPair.errorListener,\n      );\n    }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStream\/setCompleter.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "setCompleter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStream",
                    "params": [
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageStreamCompleter"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The completer that has been assigned to this image stream.<\/p>\n<p>Generally there is no need to deal with the completer directly.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ImageStreamCompleter get completer =&gt; _completer;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageStream\/completer.html",
                    "name": "completer",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageStream",
                    "params": []
                },
                {
                    "desc": "<p>Returns an object which can be used with <code>==<\/code> to determine if this\n<a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> shares the same listeners list as another <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>.<\/p>\n<p>This can be used to avoid un-registering and re-registering listeners\nafter calling <a href=\"painting\/ImageProvider\/resolve.html\">ImageProvider.resolve<\/a> on a new, but possibly equivalent,\n<a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>.<\/p>\n<p>The key may change once in the lifetime of the object. When it changes, it\nwill go from being different than other <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>'s keys to\npotentially being the same as others'. No notification is sent when this\nhappens.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Object get key =&gt; _completer != null ? _completer : this;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageStream\/key.html",
                    "name": "key",
                    "isDeprecated": false,
                    "type": "dart:core.Object",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageStream",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Base class for those that manage the loading of <a href=\"dart-ui\/Image-class.html\">dart:ui.Image<\/a> objects for\n<a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>s.<\/p>\n<p><code>ImageStreamListener<\/code> objects are rarely constructed directly. Generally, an\n<a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a> subclass will return an <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> and automatically\nconfigure it with the right <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> when possible.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/ImageStreamCompleter-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageStreamCompleter",
            "shortname": "ImageStreamCompleter",
            "extends": [
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.MultiFrameImageStreamCompleter",
                "painting.OneFrameImageStreamCompleter"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "",
                    "example": "",
                    "href": "painting\/ImageStreamCompleter\/ImageStreamCompleter.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ImageStreamCompleter",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": []
                },
                {
                    "desc": "<p>Adds a listener callback that is called whenever a new concrete <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a>\nobject is available or an error is reported. If a concrete image is\nalready available, or if an error has been already reported, this object\nwill call the listener or error listener synchronously.<\/p>\n<p>If the <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> completes multiple images over its lifetime,\nthis listener will fire multiple times.<\/p>\n<p>The listener will be passed a flag indicating whether a synchronous call\noccurred. If the listener is added within a render object paint function,\nthen use this flag to avoid calling <a href=\"rendering\/RenderObject\/markNeedsPaint.html\">RenderObject.markNeedsPaint<\/a> during\na paint.<\/p>\n<p>An <a href=\"painting\/ImageErrorListener.html\">ImageErrorListener<\/a> can also optionally be added along with the\n<code>listener<\/code>. If an error occurred, <code>onError<\/code> will be called instead of\n<code>listener<\/code>.<\/p>\n<p>If a <code>listener<\/code> or <code>onError<\/code> handler is registered multiple times, then it\nwill be called multiple times when the image stream completes (whether\nbecause a new image is available or because an error occurs,\nrespectively). In general, registering a listener multiple times is\ndiscouraged because <a href=\"painting\/ImageStreamCompleter\/removeListener.html\">removeListener<\/a> will remove the first instance that\nwas added, even if it was added with a different <code>onError<\/code> than the\nintended paired <code>addListener<\/code> call.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void addListener(ImageListener listener, { ImageErrorListener onError }) {\n  _listeners.add(_ImageListenerPair(listener, onError));\n  if (_currentImage != null) {\n    try {\n      listener(_currentImage, true);\n    } catch (exception, stack) {\n      reportError(\n        context: 'by a synchronously-called image listener',\n        exception: exception,\n        stack: stack,\n      );\n    }\n  }\n  if (_currentError != null &amp;&amp; onError != null) {\n    try {\n      onError(_currentError.exception, _currentError.stack);\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          library: 'image resource service',\n          context: 'by a synchronously-called image error listener',\n          stack: stack,\n        ),\n      );\n    }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStreamCompleter\/addListener.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "addListener",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": [
                        {
                            "name": "listener",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageListener"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageErrorListener"
                        }
                    ]
                },
                {
                    "desc": "<p>Accumulates a list of strings describing the object's state. Subclasses\nshould override this to have their information included in <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder description) {\n  super.debugFillProperties(description);\n  description.add(DiagnosticsProperty&lt;ImageInfo&gt;('current', _currentImage, ifNull: 'unresolved', showName: false));\n  description.add(ObjectFlagProperty&lt;List&lt;_ImageListenerPair&gt;&gt;(\n    'listeners',\n    _listeners,\n    ifPresent: '${_listeners?.length} listener${_listeners?.length == 1 ? \"\" : \"s\" }',\n  ));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStreamCompleter\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": [
                        {
                            "name": "description",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Stop listening for new concrete <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> objects and errors from\nits associated <a href=\"painting\/ImageErrorListener.html\">ImageErrorListener<\/a>.<\/p>\n<p>If <code>listener<\/code> has been added multiple times, this removes the first\ninstance of the listener, along with the <code>onError<\/code> listener that was\nregistered with that first instance. This might not be the instance that\nthe <code>addListener<\/code> corresponding to this <code>removeListener<\/code> had added.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void removeListener(ImageListener listener) {\n  for (int i = 0; i &lt; _listeners.length; i += 1) {\n    if (_listeners[i].listener == listener) {\n      _listeners.removeAt(i);\n      break;\n    }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStreamCompleter\/removeListener.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "removeListener",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": [
                        {
                            "name": "listener",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageListener"
                        }
                    ]
                },
                {
                    "desc": "<p>Calls all the registered error listeners to notify them of an error that\noccurred while resolving the image.<\/p>\n<p>If no error listeners are attached, a <a href=\"foundation\/FlutterError-class.html\">FlutterError<\/a> will be reported\ninstead.<\/p>\n<p>The <code>context<\/code> should be a string describing where the error was caught, in\na form that will make sense in English when following the word \"thrown\",\nas in \"thrown while obtaining the image from the network\" (for the context\n\"while obtaining the image from the network\").<\/p>\n<p>The <code>exception<\/code> is the error being reported; the <code>stack<\/code> is the\n<a href=\"dart-core\/StackTrace-class.html\">StackTrace<\/a> associated with the exception.<\/p>\n<p>The <code>informationCollector<\/code> is a callback (of type <a href=\"foundation\/InformationCollector.html\">InformationCollector<\/a>)\nthat is called when the exception is used by <a href=\"painting\/ImageStreamCompleter\/reportError.html\">FlutterError.reportError<\/a>.\nIt is used to obtain further details to include in the logs, which may be\nexpensive to collect, and thus should only be collected if the error is to\nbe logged in the first place.<\/p>\n<p>The <code>silent<\/code> argument causes the exception to not be reported to the logs\nin release builds, if passed to <a href=\"painting\/ImageStreamCompleter\/reportError.html\">FlutterError.reportError<\/a>. (It is still\nsent to error handlers.) It should be set to true if the error is one that\nis expected to be encountered in release builds, for example network\nerrors. That way, logs on end-user devices will not have spurious\nmessages, but errors during development will still be reported.<\/p>\n<p>See <a href=\"foundation\/FlutterErrorDetails-class.html\">FlutterErrorDetails<\/a> for further details on these values.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid reportError({\n  String context,\n  dynamic exception,\n  StackTrace stack,\n  InformationCollector informationCollector,\n  bool silent = false,\n}) {\n  _currentError = FlutterErrorDetails(\n    exception: exception,\n    stack: stack,\n    library: 'image resource service',\n    context: context,\n    informationCollector: informationCollector,\n    silent: silent,\n  );\n\n  final List&lt;ImageErrorListener&gt; localErrorListeners =\n    _listeners.map&lt;ImageErrorListener&gt;(\n      (_ImageListenerPair listenerPair) =&gt; listenerPair.errorListener\n    ).where(\n      (ImageErrorListener errorListener) =&gt; errorListener != null\n    ).toList();\n\n  if (localErrorListeners.isEmpty) {\n    FlutterError.reportError(_currentError);\n  } else {\n    for (ImageErrorListener errorListener in localErrorListeners) {\n      try {\n        errorListener(exception, stack);\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            context: 'when reporting an error to an image listener',\n            library: 'image resource service',\n            exception: exception,\n            stack: stack,\n          ),\n        );\n      }\n    }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStreamCompleter\/reportError.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "reportError",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": [
                        {
                            "name": "context",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "exception",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "<dynamic>"
                        },
                        {
                            "name": "informationCollector",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.InformationCollector"
                        },
                        {
                            "name": "silent",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "stack",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.StackTrace"
                        }
                    ]
                },
                {
                    "desc": "<p>Calls all the registered listeners to notify them of a new image.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nvoid setImage(ImageInfo image) {\n  _currentImage = image;\n  if (_listeners.isEmpty)\n    return;\n  final List&lt;ImageListener&gt; localListeners = _listeners.map&lt;ImageListener&gt;(\n    (_ImageListenerPair listenerPair) =&gt; listenerPair.listener\n  ).toList();\n  for (ImageListener listener in localListeners) {\n    try {\n      listener(image, false);\n    } catch (exception, stack) {\n      reportError(\n        context: 'by an image listener',\n        exception: exception,\n        stack: stack,\n      );\n    }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ImageStreamCompleter\/setImage.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "setImage",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": [
                        {
                            "name": "image",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageInfo"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Whether any listeners are currently registered.<\/p>\n<p>Clients should not depend on this value for their behavior, because having\none listener's logic change when another listener happens to start or stop\nlistening will lead to extremely hard-to-track bugs. Subclasses might use\nthis information to determine whether to do any work when there are no\nlisteners, however; for example, <a href=\"painting\/MultiFrameImageStreamCompleter-class.html\">MultiFrameImageStreamCompleter<\/a> uses it\nto determine when to iterate through frames of an animated image.<\/p>\n<p>Typically this is used by overriding <a href=\"painting\/ImageStreamCompleter\/addListener.html\">addListener<\/a>, checking if\n<a href=\"painting\/ImageStreamCompleter\/hasListeners.html\">hasListeners<\/a> is false before calling <code>super.addListener()<\/code>, and if so,\nstarting whatever work is needed to determine when to call\n<code>notifyListeners<\/code>; and similarly, by overriding <a href=\"painting\/ImageStreamCompleter\/removeListener.html\">removeListener<\/a>, checking\nif <a href=\"painting\/ImageStreamCompleter\/hasListeners.html\">hasListeners<\/a> is false after calling <code>super.removeListener()<\/code>, and if\nso, stopping that same work.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nbool get hasListeners =&gt; _listeners.isNotEmpty;<\/code><\/pre>\n        ",
                    "href": "painting\/ImageStreamCompleter\/hasListeners.html",
                    "name": "hasListeners",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ImageStreamCompleter",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A 2D linear gradient.<\/p>\n<p>This class is used by <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> to represent linear gradients. This\nabstracts out the arguments to the <a href=\"dart-ui\/Gradient\/Gradient.linear.html\">new ui.Gradient.linear<\/a> constructor from\nthe <code>dart:ui<\/code> library.<\/p>\n<p>A gradient has two anchor points, <a href=\"painting\/LinearGradient\/begin.html\">begin<\/a> and <a href=\"painting\/LinearGradient\/end.html\">end<\/a>. The <a href=\"painting\/LinearGradient\/begin.html\">begin<\/a> point\ncorresponds to 0.0, and the <a href=\"painting\/LinearGradient\/end.html\">end<\/a> point corresponds to 1.0. These points are\nexpressed in fractions, so that the same gradient can be reused with varying\nsized boxes without changing the parameters. (This contrasts with <a href=\"dart-ui\/Gradient\/Gradient.linear.html\">new\nui.Gradient.linear<\/a>, whose arguments are expressed in logical pixels.)<\/p>\n<p>The <a href=\"painting\/Gradient\/colors.html\">colors<\/a> are described by a list of <a href=\"dart-ui\/Color-class.html\">Color<\/a> objects. There must be at\nleast two colors. The <a href=\"painting\/Gradient\/stops.html\">stops<\/a> list, if specified, must have the same length\nas <a href=\"painting\/Gradient\/colors.html\">colors<\/a>. It specifies fractions of the vector from start to end, between\n0.0 and 1.0, for each color. If it is null, a uniform distribution is\nassumed.<\/p>\n<p>The region of the canvas before <a href=\"painting\/LinearGradient\/begin.html\">begin<\/a> and after <a href=\"painting\/LinearGradient\/end.html\">end<\/a> is colored according\nto <a href=\"painting\/LinearGradient\/tileMode.html\">tileMode<\/a>.<\/p>\n<p>Typically this class is used with <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which does the painting.\nTo use a <a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a> to paint on a canvas directly, see <a href=\"painting\/LinearGradient\/createShader.html\">createShader<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis sample draws a picture that looks like vertical window shades by having\na <a href=\"widgets\/Container-class.html\">Container<\/a> display a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> with a <a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a>.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    gradient: LinearGradient(\n      begin: Alignment.topLeft,\n      end: Alignment(0.8, 0.0), \/\/ 10% of the width, so there are ten blinds.\n      colors: [const Color(0xFFFFFFEE), const Color(0xFF999999)], \/\/ whitish to gray\n      tileMode: TileMode.repeated, \/\/ repeats the gradient over the canvas\n    ),\n  ),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a>, which displays a gradient in concentric circles, and\nhas an example which shows a different way to use <a href=\"painting\/Gradient-class.html\">Gradient<\/a> objects.<\/li>\n<li>\n<a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a>, which displays a gradient in a sweeping arc around a\ncenter point.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which can take a <a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a> in its\n<a href=\"painting\/BoxDecoration\/gradient.html\">BoxDecoration.gradient<\/a> property.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/LinearGradient-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.LinearGradient",
            "shortname": "LinearGradient",
            "extends": [
                "painting.Gradient",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a linear gradient.<\/p>\n<p>The <code>colors<\/code> argument must not be null. If <code>stops<\/code> is non-null, it must\nhave the same length as <code>colors<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const LinearGradient({\n  this.begin = Alignment.centerLeft,\n  this.end = Alignment.centerRight,\n  @required List&lt;Color&gt; colors,\n  List&lt;double&gt; stops,\n  this.tileMode = TileMode.clamp,\n}) : assert(begin != null),\n     assert(end != null),\n     assert(tileMode != null),\n     super(colors: colors, stops: stops);<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/LinearGradient.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "LinearGradient",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": [
                        {
                            "name": "begin",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "colors",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:ui.Color>"
                        },
                        {
                            "name": "end",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "stops",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:core.double>"
                        },
                        {
                            "name": "tileMode",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TileMode"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Shader-class.html\">Shader<\/a> for this gradient to fill the given rect.<\/p>\n<p>If the gradient's configuration is text-direction-dependent, for example\nit uses <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a> objects instead of <a href=\"painting\/Alignment-class.html\">Alignment<\/a>\nobjects, then the <code>textDirection<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShader createShader(Rect rect, { TextDirection textDirection }) {\n  return ui.Gradient.linear(\n    begin.resolve(textDirection).withinRect(rect),\n    end.resolve(textDirection).withinRect(rect),\n    colors, _impliedStops(), tileMode,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/createShader.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Shader",
                    "name": "createShader",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a>s.<\/p>\n<p>If either gradient is null, this function linearly interpolates from a\na gradient that matches the other gradient in <a href=\"painting\/LinearGradient\/begin.html\">begin<\/a>, <a href=\"painting\/LinearGradient\/end.html\">end<\/a>, <a href=\"painting\/Gradient\/stops.html\">stops<\/a> and\n<a href=\"painting\/LinearGradient\/tileMode.html\">tileMode<\/a> and with the same <a href=\"painting\/Gradient\/colors.html\">colors<\/a> but transparent (using <a href=\"painting\/LinearGradient\/scale.html\">scale<\/a>).<\/p>\n<p>If neither gradient is null, they must have the same number of <a href=\"painting\/Gradient\/colors.html\">colors<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents a position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static LinearGradient lerp(LinearGradient a, LinearGradient b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  final _ColorsAndStops interpolated = _interpolateColorsAndStops(\n      a.colors,\n      a._impliedStops(),\n      b.colors,\n      b._impliedStops(),\n      t,\n  );\n  return LinearGradient(\n    begin: AlignmentGeometry.lerp(a.begin, b.begin, t),\n    end: AlignmentGeometry.lerp(a.end, b.end, t),\n    colors: interpolated.colors,\n    stops: interpolated.stops,\n    tileMode: t &lt; 0.5 ? a.tileMode : b.tileMode, \/\/ TODO(ianh): interpolate tile mode\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.LinearGradient",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.LinearGradient"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.LinearGradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Gradient-class.html\">Gradient<\/a> to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/LinearGradient\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/LinearGradient\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>If <code>a<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/LinearGradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/LinearGradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nGradient lerpFrom(Gradient a, double t) {\n  if (a == null || (a is LinearGradient))\n    return LinearGradient.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Gradient-class.html\">Gradient<\/a>.<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/LinearGradient\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/LinearGradient\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>If <code>b<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/LinearGradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/LinearGradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nGradient lerpTo(Gradient b, double t) {\n  if (b == null || (b is LinearGradient))\n    return LinearGradient.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new <a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a> with its colors scaled by the given factor.<\/p>\n<p>Since the alpha component of the Color is what is scaled, a factor\nof 0.0 or less results in a gradient that is fully transparent.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nLinearGradient scale(double factor) {\n  return LinearGradient(\n    begin: begin,\n    end: end,\n    colors: colors.map&lt;Color&gt;((Color color) =&gt; Color.lerp(null, color, factor)).toList(),\n    stops: stops,\n    tileMode: tileMode,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.LinearGradient",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": [
                        {
                            "name": "factor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($begin, $end, $colors, $stops, $tileMode)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/LinearGradient\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.LinearGradient",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The offset at which stop 0.0 of the gradient is placed.<\/p>\n<p>If this is an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, then it is expressed as a vector from\ncoordinate (0.0, 0.0), in a coordinate space that maps the center of the\npaint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).<\/p>\n<p>For example, a begin offset of (-1.0, 0.0) is half way down the\nleft side of the box.<\/p>\n<p>It can also be an <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, where the start is the\nleft in left-to-right contexts and the right in right-to-left contexts. If\na text-direction-dependent value is provided here, then the <a href=\"painting\/LinearGradient\/createShader.html\">createShader<\/a>\nmethod will need to be given a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AlignmentGeometry begin\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/LinearGradient\/begin.html",
                    "name": "begin",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.LinearGradient",
                    "params": []
                },
                {
                    "desc": "<p>The offset at which stop 1.0 of the gradient is placed.<\/p>\n<p>If this is an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, then it is expressed as a vector from\ncoordinate (0.0, 0.0), in a coordinate space that maps the center of the\npaint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).<\/p>\n<p>For example, a begin offset of (1.0, 0.0) is half way down the\nright side of the box.<\/p>\n<p>It can also be an <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, where the start is the left in\nleft-to-right contexts and the right in right-to-left contexts. If a\ntext-direction-dependent value is provided here, then the <a href=\"painting\/LinearGradient\/createShader.html\">createShader<\/a>\nmethod will need to be given a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AlignmentGeometry end\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/LinearGradient\/end.html",
                    "name": "end",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.LinearGradient",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/LinearGradient\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/LinearGradient\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/LinearGradient\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/LinearGradient\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/LinearGradient\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/LinearGradient\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(begin, end, tileMode, hashList(colors), hashList(stops));<\/code><\/pre>\n        ",
                    "href": "painting\/LinearGradient\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.LinearGradient",
                    "params": []
                },
                {
                    "desc": "<p>How this gradient should tile the plane beyond in the region before\n<a href=\"painting\/LinearGradient\/begin.html\">begin<\/a> and after <a href=\"painting\/LinearGradient\/end.html\">end<\/a>.<\/p>\n<p>For details, see <a href=\"dart-ui\/TileMode-class.html\">TileMode<\/a>.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_clamp_linear.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_mirror_linear.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_repeated_linear.png\"><\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TileMode tileMode\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/LinearGradient\/tileMode.html",
                    "name": "tileMode",
                    "isDeprecated": false,
                    "type": "dart:ui.TileMode",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.LinearGradient",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Utility functions for working with matrices.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/MatrixUtils-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.MatrixUtils",
            "shortname": "MatrixUtils",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Create a transformation matrix which mimics the effects of tangentially\nwrapping the plane on which this transform is applied around a cylinder\nand then looking at the cylinder from a point outside the cylinder.<\/p>\n<p>The <code>radius<\/code> simulates the radius of the cylinder the plane is being\nwrapped onto. If the transformation is applied to a 0-dimensional dot\ninstead of a plane, the dot would simply translate by +\/- <code>radius<\/code> pixels\nalong the <code>orientation<\/code> <a href=\"painting\/Axis-class.html\">Axis<\/a> when rotating from 0 to +\/- 90 degrees.<\/p>\n<p>A positive radius means the object is closest at 0 <code>angle<\/code> and a negative\nradius means the object is closest at \u03c0 <code>angle<\/code> or 180 degrees.<\/p>\n<p>The <code>angle<\/code> argument is the difference in angle in radians between the\nobject and the viewing point. A positive <code>angle<\/code> on a positive <code>radius<\/code>\nmoves the object up when <code>orientation<\/code> is vertical and right when\nhorizontal.<\/p>\n<p>The transformation is always done such that a 0 <code>angle<\/code> keeps the\ntransformed object at exactly the same size as before regardless of\n<code>radius<\/code> and <code>perspective<\/code> when <code>radius<\/code> is positive.<\/p>\n<p>The <code>perspective<\/code> argument is a number between 0 and 1 where 0 means\nlooking at the object from infinitely far with an infinitely narrow field\nof view and 1 means looking at the object from infinitely close with an\ninfinitely wide field of view. Defaults to a sane but arbitrary 0.001.<\/p>\n<p>The <code>orientation<\/code> is the direction of the rotation axis.<\/p>\n<p>Because the viewing position is a point, it's never possible to see the\nouter side of the cylinder at or past +\/- \u03c0 \/ 2 or 90 degrees and it's\nalmost always possible to end up seeing the inner side of the cylinder\nor the back side of the transformed plane before \u03c0 \/ 2 when perspective &gt; 0.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Matrix4 createCylindricalProjectionTransform({\n  @required double radius,\n  @required double angle,\n  double perspective = 0.001,\n  Axis orientation = Axis.vertical,\n}) {\n  assert(radius != null);\n  assert(angle != null);\n  assert(perspective &gt;= 0 &amp;&amp; perspective &lt;= 1.0);\n  assert(orientation != null);\n\n  \/\/ Pre-multiplied matrix of a projection matrix and a view matrix.\n  \/\/\n  \/\/ Projection matrix is a simplified perspective matrix\n  \/\/ http:\/\/web.iitd.ac.in\/~hegde\/cad\/lecture\/L9_persproj.pdf\n  \/\/ in the form of\n  \/\/ [[1.0, 0.0, 0.0, 0.0],\n  \/\/  [0.0, 1.0, 0.0, 0.0],\n  \/\/  [0.0, 0.0, 1.0, 0.0],\n  \/\/  [0.0, 0.0, -perspective, 1.0]]\n  \/\/\n  \/\/ View matrix is a simplified camera view matrix.\n  \/\/ Basically re-scales to keep object at original size at angle = 0 at\n  \/\/ any radius in the form of\n  \/\/ [[1.0, 0.0, 0.0, 0.0],\n  \/\/  [0.0, 1.0, 0.0, 0.0],\n  \/\/  [0.0, 0.0, 1.0, -radius],\n  \/\/  [0.0, 0.0, 0.0, 1.0]]\n  Matrix4 result = Matrix4.identity()\n      ..setEntry(3, 2, -perspective)\n      ..setEntry(2, 3, -radius)\n      ..setEntry(3, 3, perspective * radius + 1.0);\n\n  \/\/ Model matrix by first translating the object from the origin of the world\n  \/\/ by radius in the z axis and then rotating against the world.\n  result *= (\n      orientation == Axis.horizontal\n          ? Matrix4.rotationY(angle)\n          : Matrix4.rotationX(angle)\n  ) * Matrix4.translationValues(0.0, 0.0, radius);\n\n  \/\/ Essentially perspective * view * model.\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/createCylindricalProjectionTransform.html",
                    "isDeprecated": false,
                    "type": "vector_math_64.Matrix4",
                    "name": "createCylindricalProjectionTransform",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "angle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "orientation",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Axis"
                        },
                        {
                            "name": "perspective",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "radius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the given <code>transform<\/code> matrix as a <a href=\"dart-core\/double-class.html\">double<\/a> describing a uniform\nscale, if the matrix is nothing but a symmetric 2D scale transform.<\/p>\n<p>Otherwise, returns null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static double getAsScale(Matrix4 transform) {\n  assert(transform != null);\n  final Float64List values = transform.storage;\n  \/\/ Values are stored in column-major order.\n  if (values[1] == 0.0 &amp;&amp; \/\/ col 1 (value 0 is the scale)\n      values[2] == 0.0 &amp;&amp;\n      values[3] == 0.0 &amp;&amp;\n      values[4] == 0.0 &amp;&amp; \/\/ col 2 (value 5 is the scale)\n      values[6] == 0.0 &amp;&amp;\n      values[7] == 0.0 &amp;&amp;\n      values[8] == 0.0 &amp;&amp; \/\/ col 3\n      values[9] == 0.0 &amp;&amp;\n      values[10] == 1.0 &amp;&amp;\n      values[11] == 0.0 &amp;&amp;\n      values[12] == 0.0 &amp;&amp; \/\/ col 4\n      values[13] == 0.0 &amp;&amp;\n      values[14] == 0.0 &amp;&amp;\n      values[15] == 1.0 &amp;&amp;\n      values[0] == values[5]) { \/\/ uniform scale\n    return values[0];\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/getAsScale.html",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "name": "getAsScale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "transform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the given <code>transform<\/code> matrix as an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a>, if the matrix is\nnothing but a 2D translation.<\/p>\n<p>Otherwise, returns null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Offset getAsTranslation(Matrix4 transform) {\n  assert(transform != null);\n  final Float64List values = transform.storage;\n  \/\/ Values are stored in column-major order.\n  if (values[0] == 1.0 &amp;&amp; \/\/ col 1\n      values[1] == 0.0 &amp;&amp;\n      values[2] == 0.0 &amp;&amp;\n      values[3] == 0.0 &amp;&amp;\n      values[4] == 0.0 &amp;&amp; \/\/ col 2\n      values[5] == 1.0 &amp;&amp;\n      values[6] == 0.0 &amp;&amp;\n      values[7] == 0.0 &amp;&amp;\n      values[8] == 0.0 &amp;&amp; \/\/ col 3\n      values[9] == 0.0 &amp;&amp;\n      values[10] == 1.0 &amp;&amp;\n      values[11] == 0.0 &amp;&amp;\n      values[14] == 0.0 &amp;&amp; \/\/ bottom of col 4 (values 12 and 13 are the x and y offsets)\n      values[15] == 1.0) {\n    return Offset(values[12], values[13]);\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/getAsTranslation.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "name": "getAsTranslation",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "transform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a rect that bounds the result of applying the inverse of the given\nmatrix as a perspective transform to the given rect.<\/p>\n<p>This function assumes the given rect is in the plane with z equals 0.0.\nThe transformed rect is then projected back into the plane with z equals\n0.0 before computing its bounding rect.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Rect inverseTransformRect(Matrix4 transform, Rect rect) {\n  assert(rect != null);\n  assert(transform.determinant != 0.0);\n  if (isIdentity(transform))\n    return rect;\n  transform = Matrix4.copy(transform)..invert();\n  return transformRect(transform, rect);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/inverseTransformRect.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Rect",
                    "name": "inverseTransformRect",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "transform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Whether the given matrix is the identity matrix.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool isIdentity(Matrix4 a) {\n  assert(a != null);\n  return a.storage[0] == 1.0 \/\/ col 1\n      &amp;&amp; a.storage[1] == 0.0\n      &amp;&amp; a.storage[2] == 0.0\n      &amp;&amp; a.storage[3] == 0.0\n      &amp;&amp; a.storage[4] == 0.0 \/\/ col 2\n      &amp;&amp; a.storage[5] == 1.0\n      &amp;&amp; a.storage[6] == 0.0\n      &amp;&amp; a.storage[7] == 0.0\n      &amp;&amp; a.storage[8] == 0.0 \/\/ col 3\n      &amp;&amp; a.storage[9] == 0.0\n      &amp;&amp; a.storage[10] == 1.0\n      &amp;&amp; a.storage[11] == 0.0\n      &amp;&amp; a.storage[12] == 0.0 \/\/ col 4\n      &amp;&amp; a.storage[13] == 0.0\n      &amp;&amp; a.storage[14] == 0.0\n      &amp;&amp; a.storage[15] == 1.0;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/isIdentity.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "isIdentity",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns true if the given matrices are exactly equal, and false\notherwise. Null values are assumed to be the identity matrix.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static bool matrixEquals(Matrix4 a, Matrix4 b) {\n  if (identical(a, b))\n    return true;\n  assert(a != null || b != null);\n  if (a == null)\n    return isIdentity(b);\n  if (b == null)\n    return isIdentity(a);\n  assert(a != null &amp;&amp; b != null);\n  return a.storage[0] == b.storage[0]\n      &amp;&amp; a.storage[1] == b.storage[1]\n      &amp;&amp; a.storage[2] == b.storage[2]\n      &amp;&amp; a.storage[3] == b.storage[3]\n      &amp;&amp; a.storage[4] == b.storage[4]\n      &amp;&amp; a.storage[5] == b.storage[5]\n      &amp;&amp; a.storage[6] == b.storage[6]\n      &amp;&amp; a.storage[7] == b.storage[7]\n      &amp;&amp; a.storage[8] == b.storage[8]\n      &amp;&amp; a.storage[9] == b.storage[9]\n      &amp;&amp; a.storage[10] == b.storage[10]\n      &amp;&amp; a.storage[11] == b.storage[11]\n      &amp;&amp; a.storage[12] == b.storage[12]\n      &amp;&amp; a.storage[13] == b.storage[13]\n      &amp;&amp; a.storage[14] == b.storage[14]\n      &amp;&amp; a.storage[15] == b.storage[15];\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/matrixEquals.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "matrixEquals",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Applies the given matrix as a perspective transform to the given point.<\/p>\n<p>This function assumes the given point has a z-coordinate of 0.0. The\nz-coordinate of the result is ignored.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Offset transformPoint(Matrix4 transform, Offset point) {\n  final Vector3 position3 = Vector3(point.dx, point.dy, 0.0);\n  final Vector3 transformed3 = transform.perspectiveTransform(position3);\n  return Offset(transformed3.x, transformed3.y);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/transformPoint.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "name": "transformPoint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "point",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        },
                        {
                            "name": "transform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a rect that bounds the result of applying the given matrix as a\nperspective transform to the given rect.<\/p>\n<p>This function assumes the given rect is in the plane with z equals 0.0.\nThe transformed rect is then projected back into the plane with z equals\n0.0 before computing its bounding rect.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static Rect transformRect(Matrix4 transform, Rect rect) {\n  final Offset point1 = transformPoint(transform, rect.topLeft);\n  final Offset point2 = transformPoint(transform, rect.topRight);\n  final Offset point3 = transformPoint(transform, rect.bottomLeft);\n  final Offset point4 = transformPoint(transform, rect.bottomRight);\n  return Rect.fromLTRB(\n      _min4(point1.dx, point2.dx, point3.dx, point4.dx),\n      _min4(point1.dy, point2.dy, point3.dy, point4.dy),\n      _max4(point1.dx, point2.dx, point3.dx, point4.dx),\n      _max4(point1.dy, point2.dy, point3.dy, point4.dy),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MatrixUtils\/transformRect.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Rect",
                    "name": "transformRect",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MatrixUtils",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "transform",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Decodes the given <a href=\"dart-typed_data\/Uint8List-class.html\">Uint8List<\/a> buffer as an image, associating it with the\ngiven scale.<\/p>\n<p>The provided <a href=\"painting\/MemoryImage\/bytes.html\">bytes<\/a> buffer should not be changed after it is provided\nto a <a href=\"painting\/MemoryImage-class.html\">MemoryImage<\/a>. To provide an <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a> that represents an image\nthat changes over time, consider creating a new subclass of <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>\nwhose <a href=\"painting\/MemoryImage\/load.html\">load<\/a> method returns a subclass of <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> that can\nhandle providing multiple images.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/Image\/Image.memory.html\">Image.memory<\/a> for a shorthand of an <a href=\"widgets\/Image-class.html\">Image<\/a> widget backed by <a href=\"painting\/MemoryImage-class.html\">MemoryImage<\/a>.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/MemoryImage-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.MemoryImage",
            "shortname": "MemoryImage",
            "extends": [
                "painting.MemoryImage",
                "painting.ImageProvider",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.MemoryImage"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object that decodes a <a href=\"dart-typed_data\/Uint8List-class.html\">Uint8List<\/a> buffer as an image.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const MemoryImage(this.bytes, { this.scale = 1.0 })\n  : assert(bytes != null),\n    assert(scale != null);<\/code><\/pre>\n    ",
                    "href": "painting\/MemoryImage\/MemoryImage.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "MemoryImage",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.MemoryImage",
                    "params": [
                        {
                            "name": "bytes",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:typed_data.Uint8List"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts a key into an <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a>, and begins fetching the\nimage.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nImageStreamCompleter load(MemoryImage key) {\n  return MultiFrameImageStreamCompleter(\n    codec: _loadAsync(key),\n    scale: key.scale,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MemoryImage\/load.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "name": "load",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MemoryImage",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.MemoryImage"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.<\/p>\n<p>The type of the key is determined by the subclass. It is a value that\nunambiguously identifies the image (<em>including its scale<\/em>) that the <a href=\"painting\/MemoryImage\/load.html\">load<\/a>\nmethod will fetch. Different <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>s given the same constructor\narguments and <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects should return keys that are\n'==' to each other (possibly by using a class for the key that itself\nimplements <code>==<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;MemoryImage&gt; obtainKey(ImageConfiguration configuration) {\n  return SynchronousFuture&lt;MemoryImage&gt;(this);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MemoryImage\/obtainKey.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<painting.MemoryImage>",
                    "name": "obtainKey",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MemoryImage",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(${describeIdentity(bytes)}, scale: $scale)';<\/code><\/pre>\n    ",
                    "href": "painting\/MemoryImage\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MemoryImage",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The bytes to decode into an image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Uint8List bytes\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/MemoryImage\/bytes.html",
                    "name": "bytes",
                    "isDeprecated": false,
                    "type": "dart:typed_data.Uint8List",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.MemoryImage",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/MemoryImage\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/MemoryImage\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/MemoryImage\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/MemoryImage\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/MemoryImage\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/MemoryImage\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(bytes.hashCode, scale);<\/code><\/pre>\n        ",
                    "href": "painting\/MemoryImage\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.MemoryImage",
                    "params": []
                },
                {
                    "desc": "<p>The scale to place in the <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object of the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double scale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/MemoryImage\/scale.html",
                    "name": "scale",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.MemoryImage",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Manages the decoding and scheduling of image frames.<\/p>\n<p>New frames will only be emitted while there are registered listeners to the\nstream (registered with <a href=\"painting\/MultiFrameImageStreamCompleter\/addListener.html\">addListener<\/a>).<\/p>\n<p>This class deals with 2 types of frames:<\/p>\n<ul>\n<li>image frames - image frames of an animated image.<\/li>\n<li>app frames - frames that the flutter engine is drawing to the screen to\nshow the app GUI.<\/li>\n<\/ul>\n<p>For single frame images the stream will only complete once.<\/p>\n<p>For animated images, this class eagerly decodes the next image frame,\nand notifies the listeners that a new frame is ready on the first app frame\nthat is scheduled after the image frame duration has passed.<\/p>\n<p>Scheduling new timers only from scheduled app frames, makes sure we pause\nthe animation when the app is not visible (as new app frames will not be\nscheduled).<\/p>\n<p>See the following timeline example:<\/p>\n<pre class=\"language-dart\"><code>| Time | Event                                      | Comment                   |\n|------|--------------------------------------------|---------------------------|\n| t1   | App frame scheduled (image frame A posted) |                           |\n| t2   | App frame scheduled                        |                           |\n| t3   | App frame scheduled                        |                           |\n| t4   | Image frame B decoded                      |                           |\n| t5   | App frame scheduled                        | t5 - t1 &lt; frameB_duration |\n| t6   | App frame scheduled (image frame B posted) | t6 - t1 &gt; frameB_duration |\n<\/code><\/pre>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/MultiFrameImageStreamCompleter-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.MultiFrameImageStreamCompleter",
            "shortname": "MultiFrameImageStreamCompleter",
            "extends": [
                "painting.ImageStreamCompleter",
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a image stream completer.<\/p>\n<p>Immediately starts decoding the first image frame when the codec is ready.<\/p>\n<p><code>codec<\/code> is a future for an initialized <a href=\"dart-ui\/Codec-class.html\">ui.Codec<\/a> that will be used to\ndecode the image.\n<code>scale<\/code> is the linear scale factor for drawing this frames of this image\nat their intended size.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">MultiFrameImageStreamCompleter({\n  @required Future&lt;ui.Codec&gt; codec,\n  @required double scale,\n  InformationCollector informationCollector,\n}) : assert(codec != null),\n     _informationCollector = informationCollector,\n     _scale = scale,\n     _framesEmitted = 0,\n     _timer = null {\n  codec.then&lt;void&gt;(_handleCodecReady, onError: (dynamic error, StackTrace stack) {\n    reportError(\n      context: 'resolving an image codec',\n      exception: error,\n      stack: stack,\n      informationCollector: informationCollector,\n      silent: true,\n    );\n  });\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MultiFrameImageStreamCompleter\/MultiFrameImageStreamCompleter.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "MultiFrameImageStreamCompleter",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.MultiFrameImageStreamCompleter",
                    "params": [
                        {
                            "name": "codec",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.Future<dart:ui.Codec>"
                        },
                        {
                            "name": "informationCollector",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "foundation.InformationCollector"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds a listener callback that is called whenever a new concrete <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a>\nobject is available or an error is reported. If a concrete image is\nalready available, or if an error has been already reported, this object\nwill call the listener or error listener synchronously.<\/p>\n<p>If the <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a> completes multiple images over its lifetime,\nthis listener will fire multiple times.<\/p>\n<p>The listener will be passed a flag indicating whether a synchronous call\noccurred. If the listener is added within a render object paint function,\nthen use this flag to avoid calling <a href=\"rendering\/RenderObject\/markNeedsPaint.html\">RenderObject.markNeedsPaint<\/a> during\na paint.<\/p>\n<p>An <a href=\"painting\/ImageErrorListener.html\">ImageErrorListener<\/a> can also optionally be added along with the\n<code>listener<\/code>. If an error occurred, <code>onError<\/code> will be called instead of\n<code>listener<\/code>.<\/p>\n<p>If a <code>listener<\/code> or <code>onError<\/code> handler is registered multiple times, then it\nwill be called multiple times when the image stream completes (whether\nbecause a new image is available or because an error occurs,\nrespectively). In general, registering a listener multiple times is\ndiscouraged because <a href=\"painting\/MultiFrameImageStreamCompleter\/removeListener.html\">removeListener<\/a> will remove the first instance that\nwas added, even if it was added with a different <code>onError<\/code> than the\nintended paired <code>addListener<\/code> call.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid addListener(ImageListener listener, { ImageErrorListener onError }) {\n  if (!hasListeners &amp;&amp; _codec != null)\n    _decodeNextFrameAndSchedule();\n  super.addListener(listener, onError: onError);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MultiFrameImageStreamCompleter\/addListener.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "addListener",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MultiFrameImageStreamCompleter",
                    "params": [
                        {
                            "name": "listener",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageListener"
                        },
                        {
                            "name": "onError",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageErrorListener"
                        }
                    ]
                },
                {
                    "desc": "<p>Stop listening for new concrete <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> objects and errors from\nits associated <a href=\"painting\/ImageErrorListener.html\">ImageErrorListener<\/a>.<\/p>\n<p>If <code>listener<\/code> has been added multiple times, this removes the first\ninstance of the listener, along with the <code>onError<\/code> listener that was\nregistered with that first instance. This might not be the instance that\nthe <code>addListener<\/code> corresponding to this <code>removeListener<\/code> had added.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid removeListener(ImageListener listener) {\n  super.removeListener(listener);\n  if (!hasListeners) {\n    _timer?.cancel();\n    _timer = null;\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/MultiFrameImageStreamCompleter\/removeListener.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "removeListener",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.MultiFrameImageStreamCompleter",
                    "params": [
                        {
                            "name": "listener",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageListener"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Fetches the given URL from the network, associating it with the given scale.<\/p>\n<p>The image will be cached regardless of cache headers from the server.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"widgets\/Image\/Image.network.html\">Image.network<\/a> for a shorthand of an <a href=\"widgets\/Image-class.html\">Image<\/a> widget backed by <a href=\"painting\/NetworkImage-class.html\">NetworkImage<\/a>.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/NetworkImage-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.NetworkImage",
            "shortname": "NetworkImage",
            "extends": [
                "painting.NetworkImage",
                "painting.ImageProvider",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.NetworkImage"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates an object that fetches the image at the given URL.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const NetworkImage(this.url, { this.scale = 1.0, this.headers })\n  : assert(url != null),\n    assert(scale != null);<\/code><\/pre>\n    ",
                    "href": "painting\/NetworkImage\/NetworkImage.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "NetworkImage",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.NetworkImage",
                    "params": [
                        {
                            "name": "headers",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.Map<dart:core.String<dart:core.String>>"
                        },
                        {
                            "name": "scale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "url",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts a key into an <a href=\"painting\/ImageStreamCompleter-class.html\">ImageStreamCompleter<\/a>, and begins fetching the\nimage.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nImageStreamCompleter load(NetworkImage key) {\n  return MultiFrameImageStreamCompleter(\n    codec: _loadAsync(key),\n    scale: key.scale,\n    informationCollector: (StringBuffer information) {\n      information.writeln('Image provider: $this');\n      information.write('Image key: $key');\n    },\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/NetworkImage\/load.html",
                    "isDeprecated": false,
                    "type": "painting.ImageStreamCompleter",
                    "name": "load",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.NetworkImage",
                    "params": [
                        {
                            "name": "key",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.NetworkImage"
                        }
                    ]
                },
                {
                    "desc": "<p>Converts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.<\/p>\n<p>The type of the key is determined by the subclass. It is a value that\nunambiguously identifies the image (<em>including its scale<\/em>) that the <a href=\"painting\/NetworkImage\/load.html\">load<\/a>\nmethod will fetch. Different <a href=\"painting\/ImageProvider-class.html\">ImageProvider<\/a>s given the same constructor\narguments and <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> objects should return keys that are\n'==' to each other (possibly by using a class for the key that itself\nimplements <code>==<\/code>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nFuture&lt;NetworkImage&gt; obtainKey(ImageConfiguration configuration) {\n  return SynchronousFuture&lt;NetworkImage&gt;(this);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/NetworkImage\/obtainKey.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future<painting.NetworkImage>",
                    "name": "obtainKey",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.NetworkImage",
                    "params": [
                        {
                            "name": "configuration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ImageConfiguration"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() =&gt; '$runtimeType(\"$url\", scale: $scale)';<\/code><\/pre>\n    ",
                    "href": "painting\/NetworkImage\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.NetworkImage",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/NetworkImage\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/NetworkImage\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/NetworkImage\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/NetworkImage\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/NetworkImage\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/NetworkImage\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(url, scale);<\/code><\/pre>\n        ",
                    "href": "painting\/NetworkImage\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.NetworkImage",
                    "params": []
                },
                {
                    "desc": "<p>The HTTP headers that will be used with <a href=\"dart-io\/HttpClient\/get.html\">HttpClient.get<\/a> to fetch image from network.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Map&lt;String, String&gt; headers\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/NetworkImage\/headers.html",
                    "name": "headers",
                    "isDeprecated": false,
                    "type": "dart:core.Map<dart:core.String<dart:core.String>>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.NetworkImage",
                    "params": []
                },
                {
                    "desc": "<p>The scale to place in the <a href=\"painting\/ImageInfo-class.html\">ImageInfo<\/a> object of the image.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double scale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/NetworkImage\/scale.html",
                    "name": "scale",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.NetworkImage",
                    "params": []
                },
                {
                    "desc": "<p>The URL from which the image will be fetched.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String url\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/NetworkImage\/url.html",
                    "name": "url",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.NetworkImage",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A shape with a notch in its outline.<\/p>\n<p>Typically used as the outline of a 'host' widget to make a notch that\naccommodates a 'guest' widget. e.g the <a href=\"material\/BottomAppBar-class.html\">BottomAppBar<\/a> may have a notch to\naccommodate the <a href=\"material\/FloatingActionButton-class.html\">FloatingActionButton<\/a>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>, which defines a shaped border without a dynamic notch.<\/li>\n<li>\n<a href=\"painting\/AutomaticNotchedShape-class.html\">AutomaticNotchedShape<\/a>, an adapter from <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> to <a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a>.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/NotchedShape-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.NotchedShape",
            "shortname": "NotchedShape",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.AutomaticNotchedShape",
                "painting.CircularNotchedRectangle"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const NotchedShape();<\/code><\/pre>\n    ",
                    "href": "painting\/NotchedShape\/NotchedShape.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "NotchedShape",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.NotchedShape",
                    "params": []
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outline of the shape.<\/p>\n<p>The <code>host<\/code> is the bounding rectangle of the shape.<\/p>\n<p>The <code>guest<\/code> is the bounding rectangle of the shape for which a notch will\nbe made. It is null when there is no guest.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Path getOuterPath(Rect host, Rect guest);<\/code><\/pre>\n    ",
                    "href": "painting\/NotchedShape\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.NotchedShape",
                    "params": [
                        {
                            "name": "guest",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "host",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>Manages the loading of <a href=\"dart-ui\/Image-class.html\">dart:ui.Image<\/a> objects for static <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>s (those\nwith only one frame).<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/OneFrameImageStreamCompleter-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.OneFrameImageStreamCompleter",
            "shortname": "OneFrameImageStreamCompleter",
            "extends": [
                "painting.ImageStreamCompleter",
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a manager for one-frame <a href=\"painting\/ImageStream-class.html\">ImageStream<\/a>s.<\/p>\n<p>The image resource awaits the given <a href=\"dart-async\/Future-class.html\">Future<\/a>. When the future resolves,\nit notifies the <a href=\"painting\/ImageListener.html\">ImageListener<\/a>s that have been registered with\n<a href=\"painting\/ImageStreamCompleter\/addListener.html\">addListener<\/a>.<\/p>\n<p>The <a href=\"foundation\/InformationCollector.html\">InformationCollector<\/a>, if provided, is invoked if the given <a href=\"dart-async\/Future-class.html\">Future<\/a>\nresolves with an error, and can be used to supplement the reported error\nmessage (for example, giving the image's URL).<\/p>\n<p>Errors are reported using <a href=\"painting\/ImageStreamCompleter\/reportError.html\">FlutterError.reportError<\/a> with the <code>silent<\/code>\nargument on <a href=\"foundation\/FlutterErrorDetails-class.html\">FlutterErrorDetails<\/a> set to true, meaning that by default the\nmessage is only dumped to the console in debug mode (see <a href=\"foundation\/FlutterErrorDetails\/FlutterErrorDetails.html\">new\nFlutterErrorDetails<\/a>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">OneFrameImageStreamCompleter(Future&lt;ImageInfo&gt; image, { InformationCollector informationCollector })\n    : assert(image != null) {\n  image.then&lt;void&gt;(setImage, onError: (dynamic error, StackTrace stack) {\n    reportError(\n      context: 'resolving a single-frame image stream',\n      exception: error,\n      stack: stack,\n      informationCollector: informationCollector,\n      silent: true,\n    );\n  });\n}<\/code><\/pre>\n    ",
                    "href": "painting\/OneFrameImageStreamCompleter\/OneFrameImageStreamCompleter.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "OneFrameImageStreamCompleter",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.OneFrameImageStreamCompleter",
                    "params": [
                        {
                            "name": "image",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:async.Future<painting.ImageInfo>"
                        },
                        {
                            "name": "informationCollector",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "foundation.InformationCollector"
                        }
                    ]
                }
            ],
            "props": []
        },
        {
            "desc": "<p>A 2D radial gradient.<\/p>\n<p>This class is used by <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> to represent radial gradients. This\nabstracts out the arguments to the <a href=\"dart-ui\/Gradient\/Gradient.radial.html\">new ui.Gradient.radial<\/a> constructor from\nthe <code>dart:ui<\/code> library.<\/p>\n<p>A normal radial gradient has a <a href=\"painting\/RadialGradient\/center.html\">center<\/a> and a <a href=\"painting\/RadialGradient\/radius.html\">radius<\/a>. The <a href=\"painting\/RadialGradient\/center.html\">center<\/a> point\ncorresponds to 0.0, and the ring at <a href=\"painting\/RadialGradient\/radius.html\">radius<\/a> from the center corresponds\nto 1.0. These lengths are expressed in fractions, so that the same gradient\ncan be reused with varying sized boxes without changing the parameters.\n(This contrasts with <a href=\"dart-ui\/Gradient\/Gradient.radial.html\">new ui.Gradient.radial<\/a>, whose arguments are expressed\nin logical pixels.)<\/p>\n<p>It is also possible to create a two-point (or focal pointed) radial gradient\n(which is sometimes referred to as a two point conic gradient, but is not the\nsame as a CSS conic gradient which corresponds to a <a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a>). A <a href=\"painting\/RadialGradient\/focal.html\">focal<\/a>\npoint and <a href=\"painting\/RadialGradient\/focalRadius.html\">focalRadius<\/a> can be specified similarly to <a href=\"painting\/RadialGradient\/center.html\">center<\/a> and <a href=\"painting\/RadialGradient\/radius.html\">radius<\/a>,\nwhich will make the rendered gradient appear to be pointed or directed in the\ndirection of the <a href=\"painting\/RadialGradient\/focal.html\">focal<\/a> point. This is only important if <a href=\"painting\/RadialGradient\/focal.html\">focal<\/a> and <a href=\"painting\/RadialGradient\/center.html\">center<\/a>\nare not equal or <a href=\"painting\/RadialGradient\/focalRadius.html\">focalRadius<\/a> &gt; 0.0 (as this case is visually identical to a\nnormal radial gradient).  One important case to avoid is having <a href=\"painting\/RadialGradient\/focal.html\">focal<\/a> and\n<a href=\"painting\/RadialGradient\/center.html\">center<\/a> both resolve to <a href=\"dart-ui\/Offset\/zero-constant.html\">Offset.zero<\/a> when <a href=\"painting\/RadialGradient\/focalRadius.html\">focalRadius<\/a> &gt; 0.0. In such a case,\na valid shader cannot be created by the framework.<\/p>\n<p>The <a href=\"painting\/Gradient\/colors.html\">colors<\/a> are described by a list of <a href=\"dart-ui\/Color-class.html\">Color<\/a> objects. There must be at\nleast two colors. The <a href=\"painting\/Gradient\/stops.html\">stops<\/a> list, if specified, must have the same length\nas <a href=\"painting\/Gradient\/colors.html\">colors<\/a>. It specifies fractions of the radius between 0.0 and 1.0,\ngiving concentric rings for each color stop. If it is null, a uniform\ndistribution is assumed.<\/p>\n<p>The region of the canvas beyond <a href=\"painting\/RadialGradient\/radius.html\">radius<\/a> from the <a href=\"painting\/RadialGradient\/center.html\">center<\/a> is colored\naccording to <a href=\"painting\/RadialGradient\/tileMode.html\">tileMode<\/a>.<\/p>\n<p>Typically this class is used with <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which does the painting.\nTo use a <a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a> to paint on a canvas directly, see <a href=\"painting\/RadialGradient\/createShader.html\">createShader<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis function draws a gradient that looks like a sun in a blue sky.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">void paintSky(Canvas canvas, Rect rect) {\n  var gradient = RadialGradient(\n    center: const Alignment(0.7, -0.6), \/\/ near the top right\n    radius: 0.2,\n    colors: [\n      const Color(0xFFFFFF00), \/\/ yellow sun\n      const Color(0xFF0099FF), \/\/ blue sky\n    ],\n    stops: [0.4, 1.0],\n  );\n  \/\/ rect is the area we are painting over\n  var paint = Paint()\n    ..shader = gradient.createShader(rect);\n  canvas.drawRect(rect, paint);\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a>, which displays a gradient in parallel lines, and has an\nexample which shows a different way to use <a href=\"painting\/Gradient-class.html\">Gradient<\/a> objects.<\/li>\n<li>\n<a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a>, which displays a gradient in a sweeping arc around a\ncenter point.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which can take a <a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a> in its\n<a href=\"painting\/BoxDecoration\/gradient.html\">BoxDecoration.gradient<\/a> property.<\/li>\n<li>\n<a href=\"rendering\/CustomPainter-class.html\">CustomPainter<\/a>, which shows how to use the above sample code in a custom\npainter.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/RadialGradient-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.RadialGradient",
            "shortname": "RadialGradient",
            "extends": [
                "painting.Gradient",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a radial gradient.<\/p>\n<p>The <code>colors<\/code> argument must not be null. If <code>stops<\/code> is non-null, it must\nhave the same length as <code>colors<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const RadialGradient({\n  this.center = Alignment.center,\n  this.radius = 0.5,\n  @required List&lt;Color&gt; colors,\n  List&lt;double&gt; stops,\n  this.tileMode = TileMode.clamp,\n  this.focal,\n  this.focalRadius = 0.0,\n}) : assert(center != null),\n     assert(radius != null),\n     assert(tileMode != null),\n     assert(focalRadius != null),\n     super(colors: colors, stops: stops);<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/RadialGradient.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "RadialGradient",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": [
                        {
                            "name": "center",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "colors",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:ui.Color>"
                        },
                        {
                            "name": "focal",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "focalRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "radius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "stops",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:core.double>"
                        },
                        {
                            "name": "tileMode",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TileMode"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Shader-class.html\">Shader<\/a> for this gradient to fill the given rect.<\/p>\n<p>If the gradient's configuration is text-direction-dependent, for example\nit uses <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a> objects instead of <a href=\"painting\/Alignment-class.html\">Alignment<\/a>\nobjects, then the <code>textDirection<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShader createShader(Rect rect, { TextDirection textDirection }) {\n  return ui.Gradient.radial(\n    center.resolve(textDirection).withinRect(rect),\n    radius * rect.shortestSide,\n    colors, _impliedStops(), tileMode,\n    null, \/\/ transform\n    focal == null  ? null : focal.resolve(textDirection).withinRect(rect),\n    focalRadius * rect.shortestSide,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/createShader.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Shader",
                    "name": "createShader",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a>s.<\/p>\n<p>If either gradient is null, this function linearly interpolates from a\na gradient that matches the other gradient in <a href=\"painting\/RadialGradient\/center.html\">center<\/a>, <a href=\"painting\/RadialGradient\/radius.html\">radius<\/a>, <a href=\"painting\/Gradient\/stops.html\">stops<\/a> and\n<a href=\"painting\/RadialGradient\/tileMode.html\">tileMode<\/a> and with the same <a href=\"painting\/Gradient\/colors.html\">colors<\/a> but transparent (using <a href=\"painting\/RadialGradient\/scale.html\">scale<\/a>).<\/p>\n<p>If neither gradient is null, they must have the same number of <a href=\"painting\/Gradient\/colors.html\">colors<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents a position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static RadialGradient lerp(RadialGradient a, RadialGradient b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  final _ColorsAndStops interpolated = _interpolateColorsAndStops(\n      a.colors,\n      a._impliedStops(),\n      b.colors,\n      b._impliedStops(),\n      t,\n  );\n  return RadialGradient(\n    center: AlignmentGeometry.lerp(a.center, b.center, t),\n    radius: math.max(0.0, ui.lerpDouble(a.radius, b.radius, t)),\n    colors: interpolated.colors,\n    stops: interpolated.stops,\n    tileMode: t &lt; 0.5 ? a.tileMode : b.tileMode, \/\/ TODO(ianh): interpolate tile mode\n    focal: AlignmentGeometry.lerp(a.focal, b.focal, t),\n    focalRadius: math.max(0.0, ui.lerpDouble(a.focalRadius, b.focalRadius, t)),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.RadialGradient",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.RadialGradient"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.RadialGradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Gradient-class.html\">Gradient<\/a> to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/RadialGradient\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/RadialGradient\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>If <code>a<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/RadialGradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/RadialGradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nGradient lerpFrom(Gradient a, double t) {\n  if (a == null || (a is RadialGradient))\n    return RadialGradient.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Gradient-class.html\">Gradient<\/a>.<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/RadialGradient\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/RadialGradient\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>If <code>b<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/RadialGradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/RadialGradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nGradient lerpTo(Gradient b, double t) {\n  if (b == null || (b is RadialGradient))\n    return RadialGradient.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new <a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a> with its colors scaled by the given factor.<\/p>\n<p>Since the alpha component of the Color is what is scaled, a factor\nof 0.0 or less results in a gradient that is fully transparent.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nRadialGradient scale(double factor) {\n  return RadialGradient(\n    center: center,\n    radius: radius,\n    colors: colors.map&lt;Color&gt;((Color color) =&gt; Color.lerp(null, color, factor)).toList(),\n    stops: stops,\n    tileMode: tileMode,\n    focal: focal,\n    focalRadius: focalRadius,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.RadialGradient",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": [
                        {
                            "name": "factor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($center, $radius, $colors, $stops, $tileMode, $focal, $focalRadius)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RadialGradient\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The center of the gradient, as an offset into the (-1.0, -1.0) x (1.0, 1.0)\nsquare describing the gradient which will be mapped onto the paint box.<\/p>\n<p>For example, an alignment of (0.0, 0.0) will place the radial\ngradient in the center of the box.<\/p>\n<p>If this is an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, then it is expressed as a vector from\ncoordinate (0.0, 0.0), in a coordinate space that maps the center of the\npaint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).<\/p>\n<p>It can also be an <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, where the start is the left in\nleft-to-right contexts and the right in right-to-left contexts. If a\ntext-direction-dependent value is provided here, then the <a href=\"painting\/RadialGradient\/createShader.html\">createShader<\/a>\nmethod will need to be given a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AlignmentGeometry center\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RadialGradient\/center.html",
                    "name": "center",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                },
                {
                    "desc": "<p>The focal point of the gradient.  If specified, the gradient will appear\nto be focused along the vector from <a href=\"painting\/RadialGradient\/center.html\">center<\/a> to focal.<\/p>\n<p>See <a href=\"painting\/RadialGradient\/center.html\">center<\/a> for a description of how the coordinates are mapped.<\/p>\n<p>If this value is specified and <a href=\"painting\/RadialGradient\/focalRadius.html\">focalRadius<\/a> &gt; 0.0, care should be taken\nto ensure that either this value or <a href=\"painting\/RadialGradient\/center.html\">center<\/a> will not both resolve to\n<a href=\"dart-ui\/Offset\/zero-constant.html\">Offset.zero<\/a>, which would fail to create a valid gradient.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AlignmentGeometry focal\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RadialGradient\/focal.html",
                    "name": "focal",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                },
                {
                    "desc": "<p>The radius of the focal point of gradient, as a fraction of the shortest\nside of the paint box.<\/p>\n<p>For example, if a radial gradient is painted on a box that is\n100.0 pixels wide and 200.0 pixels tall, then a radius of 1.0\nwill place the 1.0 stop at 100.0 pixels from the <code>focus<\/code>.<\/p>\n<p>If this value is specified and is greater than 0.0, either <a href=\"painting\/RadialGradient\/focal.html\">focal<\/a> or\n<a href=\"painting\/RadialGradient\/center.html\">center<\/a> must not resolve to <a href=\"dart-ui\/Offset\/zero-constant.html\">Offset.zero<\/a>, which would fail to create\na valid gradient.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double focalRadius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RadialGradient\/focalRadius.html",
                    "name": "focalRadius",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/RadialGradient\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/RadialGradient\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/RadialGradient\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/RadialGradient\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/RadialGradient\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/RadialGradient\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(center, radius, tileMode, hashList(colors), hashList(stops), focal, focalRadius);<\/code><\/pre>\n        ",
                    "href": "painting\/RadialGradient\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                },
                {
                    "desc": "<p>The radius of the gradient, as a fraction of the shortest side\nof the paint box.<\/p>\n<p>For example, if a radial gradient is painted on a box that is\n100.0 pixels wide and 200.0 pixels tall, then a radius of 1.0\nwill place the 1.0 stop at 100.0 pixels from the <a href=\"painting\/RadialGradient\/center.html\">center<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double radius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RadialGradient\/radius.html",
                    "name": "radius",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                },
                {
                    "desc": "<p>How this gradient should tile the plane beyond the outer ring at <a href=\"painting\/RadialGradient\/radius.html\">radius<\/a>\npixels from the <a href=\"painting\/RadialGradient\/center.html\">center<\/a>.<\/p>\n<p>For details, see <a href=\"dart-ui\/TileMode-class.html\">TileMode<\/a>.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_clamp_radial.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_mirror_radial.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_repeated_radial.png\"><\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_clamp_radialWithFocal.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_mirror_radialWithFocal.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_repeated_radialWithFocal.png\"><\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TileMode tileMode\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RadialGradient\/tileMode.html",
                    "name": "tileMode",
                    "isDeprecated": false,
                    "type": "dart:ui.TileMode",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RadialGradient",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A rectangular border with rounded corners.<\/p>\n<p>Typically used with <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> to draw a box with a rounded\nrectangle.<\/p>\n<p>This shape can interpolate to and from <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe each side of the box.<\/li>\n<li>\n<a href=\"painting\/Border-class.html\">Border<\/a>, which, when used with <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, can also\ndescribe a rounded rectangle.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/RoundedRectangleBorder-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.RoundedRectangleBorder",
            "shortname": "RoundedRectangleBorder",
            "extends": [
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a rounded rectangle border.<\/p>\n<p>The arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const RoundedRectangleBorder({\n  this.side = BorderSide.none,\n  this.borderRadius = BorderRadius.zero,\n}) : assert(side != null),\n     assert(borderRadius != null);<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/RoundedRectangleBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "RoundedRectangleBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "borderRadius",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderRadiusGeometry"
                        },
                        {
                            "name": "side",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/RoundedRectangleBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/RoundedRectangleBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/RoundedRectangleBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getInnerPath(Rect rect, { TextDirection textDirection }) {\n  return Path()\n    ..addRRect(borderRadius.resolve(textDirection).toRRect(rect).deflate(side.width));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/RoundedRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/RoundedRectangleBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/RoundedRectangleBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect rect, { TextDirection textDirection }) {\n  return Path()\n    ..addRRect(borderRadius.resolve(textDirection).toRRect(rect));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/RoundedRectangleBorder\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/RoundedRectangleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  assert(t != null);\n  if (a is RoundedRectangleBorder) {\n    return RoundedRectangleBorder(\n      side: BorderSide.lerp(a.side, side, t),\n      borderRadius: BorderRadiusGeometry.lerp(a.borderRadius, borderRadius, t),\n    );\n  }\n  if (a is CircleBorder) {\n    return _RoundedRectangleToCircleBorder(\n      side: BorderSide.lerp(a.side, side, t),\n      borderRadius: borderRadius,\n      circleness: 1.0 - t,\n    );\n  }\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/RoundedRectangleBorder\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/RoundedRectangleBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  assert(t != null);\n  if (b is RoundedRectangleBorder) {\n    return RoundedRectangleBorder(\n      side: BorderSide.lerp(side, b.side, t),\n      borderRadius: BorderRadiusGeometry.lerp(borderRadius, b.borderRadius, t),\n    );\n  }\n  if (b is CircleBorder) {\n    return _RoundedRectangleToCircleBorder(\n      side: BorderSide.lerp(side, b.side, t),\n      borderRadius: borderRadius,\n      circleness: t,\n    );\n  }\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(Canvas canvas, Rect rect, { TextDirection textDirection }) {\n  switch (side.style) {\n    case BorderStyle.none:\n      break;\n    case BorderStyle.solid:\n      final double width = side.width;\n      if (width == 0.0) {\n        canvas.drawRRect(borderRadius.resolve(textDirection).toRRect(rect), side.toPaint());\n      } else {\n        final RRect outer = borderRadius.resolve(textDirection).toRRect(rect);\n        final RRect inner = outer.deflate(width);\n        final Paint paint = Paint()\n          ..color = side.color;\n        canvas.drawDRRect(outer, inner, paint);\n      }\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/RoundedRectangleBorder\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder scale(double t) {\n  return RoundedRectangleBorder(\n    side: side.scale(t),\n    borderRadius: borderRadius * t,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($side, $borderRadius)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/RoundedRectangleBorder\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The radii for each corner.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderRadiusGeometry borderRadius\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RoundedRectangleBorder\/borderRadius.html",
                    "name": "borderRadius",
                    "isDeprecated": false,
                    "type": "painting.BorderRadiusGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/RoundedRectangleBorder\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/RoundedRectangleBorder\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsets.all(side.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/RoundedRectangleBorder\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/RoundedRectangleBorder\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/RoundedRectangleBorder\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/RoundedRectangleBorder\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/RoundedRectangleBorder\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/RoundedRectangleBorder\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/RoundedRectangleBorder\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(side, borderRadius);<\/code><\/pre>\n        ",
                    "href": "painting\/RoundedRectangleBorder\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": []
                },
                {
                    "desc": "<p>The style of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide side\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/RoundedRectangleBorder\/side.html",
                    "name": "side",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.RoundedRectangleBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Interface for drawing an image to warm up Skia shader compilations.<\/p>\n<p>When Skia first sees a certain type of draw operation on the GPU, it needs\nto compile the corresponding shader. The compilation can be slow (20ms-\n200ms). Having that time as startup latency is often better than having\njank in the middle of an animation.<\/p>\n<p>Therefore, we use this during the <a href=\"painting\/PaintingBinding\/initInstances.html\">PaintingBinding.initInstances<\/a> call to\nmove common shader compilations from animation time to startup time. By\ndefault, a <a href=\"painting\/DefaultShaderWarmUp-class.html\">DefaultShaderWarmUp<\/a> is used. If needed, app developers can\ncreate a custom <a href=\"painting\/ShaderWarmUp-class.html\">ShaderWarmUp<\/a> subclass and hand it to\n<a href=\"painting\/PaintingBinding\/shaderWarmUp.html\">PaintingBinding.shaderWarmUp<\/a> (so it replaces <a href=\"painting\/DefaultShaderWarmUp-class.html\">DefaultShaderWarmUp<\/a>)\nbefore <a href=\"painting\/PaintingBinding\/initInstances.html\">PaintingBinding.initInstances<\/a> is called. Usually, that can be\ndone before calling <a href=\"widgets\/runApp.html\">runApp<\/a>.<\/p>\n<p>To determine whether a draw operation is useful for warming up shaders,\ncheck whether it improves the slowest GPU frame. Also, tracing with\n<code>flutter run --profile --trace-skia<\/code> may reveal whether there is shader-\ncompilation-related jank. If there is such jank, some long\n<code>GrGLProgramBuilder::finalize<\/code> calls would appear in the middle of an\nanimation. Their parent calls, which look like <code>XyzOp<\/code> (e.g., <code>FillRecOp<\/code>,\n<code>CircularRRectOp<\/code>) would suggest Xyz draw operations are causing the\nshaders to be compiled. A useful shader warm-up draw operation would\neliminate such long compilation calls in the animation. To double-check\nthe warm-up, trace with <code>flutter run --profile --trace-skia --start-\npaused<\/code>. The <code>GrGLProgramBuilder<\/code> with the associated <code>XyzOp<\/code> should\nappear during startup rather than in the middle of a later animation.<\/p>\n<p>This warm-up needs to be run on each individual device because the shader\ncompilation depends on the specific GPU hardware and driver a device has. It\ncan't be pre-computed during the Flutter engine compilation as the engine is\ndevice-agnostic.<\/p>\n<p>If no warm-up is desired (e.g., when the startup latency is crucial), set\n<a href=\"painting\/PaintingBinding\/shaderWarmUp.html\">PaintingBinding.shaderWarmUp<\/a> either to a custom ShaderWarmUp with an empty\n<a href=\"painting\/ShaderWarmUp\/warmUpOnCanvas.html\">warmUpOnCanvas<\/a> or null.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/PaintingBinding\/shaderWarmUp.html\">PaintingBinding.shaderWarmUp<\/a>, the actual instance of <a href=\"painting\/ShaderWarmUp-class.html\">ShaderWarmUp<\/a>\nthat's used to warm up the shaders.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ShaderWarmUp-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ShaderWarmUp",
            "shortname": "ShaderWarmUp",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "painting.DefaultShaderWarmUp"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Allow const constructors for subclasses.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ShaderWarmUp();<\/code><\/pre>\n    ",
                    "href": "painting\/ShaderWarmUp\/ShaderWarmUp.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ShaderWarmUp",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ShaderWarmUp",
                    "params": []
                },
                {
                    "desc": "<p>Construct an offscreen image of <a href=\"painting\/ShaderWarmUp\/size.html\">size<\/a>, and execute <a href=\"painting\/ShaderWarmUp\/warmUpOnCanvas.html\">warmUpOnCanvas<\/a> on a\ncanvas associated with that image.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Future&lt;void&gt; execute() async {\n  final ui.PictureRecorder recorder = ui.PictureRecorder();\n  final ui.Canvas canvas = ui.Canvas(recorder);\n\n  await warmUpOnCanvas(canvas);\n\n  final ui.Picture picture = recorder.endRecording();\n  final TimelineTask shaderWarmUpTask = TimelineTask();\n  shaderWarmUpTask.start('Warm-up shader');\n  picture.toImage(size.width.ceil(), size.height.ceil()).then((ui.Image image) {\n    shaderWarmUpTask.finish();\n  });\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShaderWarmUp\/execute.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "execute",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShaderWarmUp",
                    "params": []
                },
                {
                    "desc": "<p>Trigger draw operations on a given canvas to warm up GPU shader\ncompilation cache.<\/p>\n<p>To decide which draw operations to be added to your custom warm up\nprocess, try capture an skp using <code>flutter screenshot --observatory-\nport=&lt;port&gt; --type=skia<\/code> and analyze it with <a href=\"https:\/\/debugger.skia.org\">https:\/\/debugger.skia.org<\/a>.\nAlternatively, one may run the app with <code>flutter run --trace-skia<\/code> and\nthen examine the GPU thread in the observatory timeline to see which\nSkia draw operations are commonly used, and which shader compilations\nare causing janks.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nFuture&lt;void&gt; warmUpOnCanvas(ui.Canvas canvas);<\/code><\/pre>\n    ",
                    "href": "painting\/ShaderWarmUp\/warmUpOnCanvas.html",
                    "isDeprecated": false,
                    "type": "dart:async.Future",
                    "name": "warmUpOnCanvas",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShaderWarmUp",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The size of the warm up image.<\/p>\n<p>The exact size shouldn't matter much as long as it's not too far away from\nthe target device's screen. 1024x1024 is a good choice as it is within an\norder of magnitude of most devices.<\/p>\n<p>A custom shader warm up can override this based on targeted devices.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">ui.Size get size =&gt; const ui.Size(1024.0, 1024.0);<\/code><\/pre>\n        ",
                    "href": "painting\/ShaderWarmUp\/size.html",
                    "name": "size",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShaderWarmUp",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Base class for shape outlines.<\/p>\n<p>This class handles how to add multiple borders together. Subclasses define\nvarious shapes, like circles (<a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), rounded rectangles\n(<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>), continuous rectangles\n(<a href=\"painting\/ContinuousRectangleBorder-class.html\">ContinuousRectangleBorder<\/a>), or beveled rectangles\n(<a href=\"painting\/BeveledRectangleBorder-class.html\">BeveledRectangleBorder<\/a>).<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a>, which can be used with <a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> to show a shape.<\/li>\n<li>\n<a href=\"material\/Material-class.html\">Material<\/a> (and many other widgets in the Material library), which takes\na <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> to define its shape.<\/li>\n<li>\n<a href=\"painting\/NotchedShape-class.html\">NotchedShape<\/a>, which describes a shape with a hole in it.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ShapeBorder-class.html",
            "isAbstract": true,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ShapeBorder",
            "shortname": "ShapeBorder",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "material.OutlineInputBorder",
                "material.ShapeBorderTween",
                "material.UnderlineInputBorder",
                "painting.BeveledRectangleBorder",
                "painting.Border",
                "painting.BorderDirectional",
                "painting.CircleBorder",
                "painting.ContinuousRectangleBorder",
                "painting.RoundedRectangleBorder",
                "painting.StadiumBorder"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Abstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ShapeBorder();<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/ShapeBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ShapeBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": []
                },
                {
                    "desc": "<p>Attempts to create a new object that represents the amalgamation of <code>this<\/code>\nborder and the <code>other<\/code> border.<\/p>\n<p>If the type of the other border isn't known, or the given instance cannot\nbe reasonably added to this instance, then this should return null.<\/p>\n<p>This method is used by the <a href=\"painting\/ShapeBorder\/operator_plus.html\">operator +<\/a> implementation.<\/p>\n<p>The <code>reversed<\/code> argument is true if this object was the right operand of\nthe <code>+<\/code> operator, and false if it was the left operand.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nShapeBorder add(ShapeBorder other, { bool reversed = false }) =&gt; null;<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/add.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "add",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "reversed",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/ShapeBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/ShapeBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ShapeBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Path getInnerPath(Rect rect, { TextDirection textDirection });<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/ShapeBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/ShapeBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ShapeBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Path getOuterPath(Rect rect, { TextDirection textDirection });<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates between two <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>s.<\/p>\n<p>This defers to <code>b<\/code>'s <a href=\"painting\/ShapeBorder\/lerpTo.html\">lerpTo<\/a> function if <code>b<\/code> is not null. If <code>b<\/code> is\nnull or if its <a href=\"painting\/ShapeBorder\/lerpTo.html\">lerpTo<\/a> returns null, it uses <code>a<\/code>'s <a href=\"painting\/ShapeBorder\/lerpFrom.html\">lerpFrom<\/a>\nfunction instead. If both return null, it returns <code>a<\/code> before <code>t=0.5<\/code>\nand <code>b<\/code> after <code>t=0.5<\/code>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static ShapeBorder lerp(ShapeBorder a, ShapeBorder b, double t) {\n  assert(t != null);\n  ShapeBorder result;\n  if (b != null)\n    result = b.lerpFrom(a, t);\n  if (result == null &amp;&amp; a != null)\n    result = a.lerpTo(b, t);\n  return result ?? (t &lt; 0.5 ? a : b);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/ShapeBorder\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/ShapeBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  if (a == null)\n    return scale(t);\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/ShapeBorder\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/ShapeBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@protected\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  if (b == null)\n    return scale(1.0 - t);\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void paint(Canvas canvas, Rect rect, { TextDirection textDirection });<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/ShapeBorder\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ShapeBorder scale(double t);<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType()';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeBorder\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/ShapeBorder\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/ShapeBorder\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">EdgeInsetsGeometry get dimensions;<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeBorder\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable description of how to paint an arbitrary shape.<\/p>\n<p>The <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> class provides a way to draw a <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>,\noptionally filling it with a color or a gradient, optionally painting an\nimage into it, and optionally casting a shadow.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe following example uses the <a href=\"widgets\/Container-class.html\">Container<\/a> widget from the widgets layer to\ndraw a white rectangle with a 24-pixel multicolor outline, with the text\n\"RGB\" inside it:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Container(\n  decoration: ShapeDecoration(\n    color: Colors.white,\n    shape: Border.all(\n      color: Colors.red,\n      width: 8.0,\n    ) + Border.all(\n      color: Colors.green,\n      width: 8.0,\n    ) + Border.all(\n      color: Colors.blue,\n      width: 8.0,\n    ),\n  ),\n  child: const Text('RGB', textAlign: TextAlign.center),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> and <a href=\"widgets\/Container-class.html\">Container<\/a>, widgets that can be configured with\n<a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> objects.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, a similar <a href=\"painting\/Decoration-class.html\">Decoration<\/a> that is optimized for rectangles\nspecifically.<\/li>\n<li>\n<a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>, the base class for the objects that are used in the\n<a href=\"painting\/ShapeDecoration\/shape.html\">shape<\/a> property.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/ShapeDecoration-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ShapeDecoration",
            "shortname": "ShapeDecoration",
            "extends": [
                "painting.Decoration",
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a shape decoration.<\/p>\n<ul>\n<li>If <code>color<\/code> is null, this decoration does not paint a background color.<\/li>\n<li>If <code>gradient<\/code> is null, this decoration does not paint gradients.<\/li>\n<li>If <code>image<\/code> is null, this decoration does not paint a background image.<\/li>\n<li>If <code>shadows<\/code> is null, this decoration does not paint a shadow.<\/li>\n<\/ul>\n<p>The <code>color<\/code> and <code>gradient<\/code> properties are mutually exclusive, one (or\nboth) of them must be null.<\/p>\n<p>The <code>shape<\/code> must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const ShapeDecoration({\n  this.color,\n  this.image,\n  this.gradient,\n  this.shadows,\n  @required this.shape,\n}) : assert(!(color != null &amp;&amp; gradient != null)),\n     assert(shape != null);<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/ShapeDecoration.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "ShapeDecoration",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "gradient",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "image",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.DecorationImage"
                        },
                        {
                            "name": "shadows",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<painting.BoxShadow>"
                        },
                        {
                            "name": "shape",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.ShapeBorder"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> that will paint this decoration.<\/p>\n<p>The <code>onChanged<\/code> argument configures <a href=\"painting\/BoxPainter\/onChanged.html\">BoxPainter.onChanged<\/a>. It can be\nomitted if there is no chance that the painter will change (for example,\nif it is a <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> with definitely no <a href=\"painting\/DecorationImage-class.html\">DecorationImage<\/a>).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\n_ShapeDecorationPainter createBoxPainter([ VoidCallback onChanged ]) {\n  assert(onChanged != null || image == null);\n  return _ShapeDecorationPainter(this, onChanged);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/createBoxPainter.html",
                    "isDeprecated": false,
                    "type": "<_ShapeDecorationPainter>",
                    "name": "createBoxPainter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "onChanged",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.VoidCallback"
                        }
                    ]
                },
                {
                    "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"painting\/ShapeDecoration\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/Diagnosticable\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.whitespace;\n  properties.add(DiagnosticsProperty&lt;Color&gt;('color', color, defaultValue: null));\n  properties.add(DiagnosticsProperty&lt;Gradient&gt;('gradient', gradient, defaultValue: null));\n  properties.add(DiagnosticsProperty&lt;DecorationImage&gt;('image', image, defaultValue: null));\n  properties.add(IterableProperty&lt;BoxShadow&gt;('shadows', shadows, defaultValue: null, style: DiagnosticsTreeStyle.whitespace));\n  properties.add(DiagnosticsProperty&lt;ShapeBorder&gt;('shape', shape));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Tests whether the given point, on a rectangle of a given size,\nwould be considered to hit the decoration or not. For example,\nif the decoration only draws a circle, this function might\nreturn true if the point was inside the circle and false\notherwise.<\/p>\n<p>The decoration may be sensitive to the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. The\n<code>textDirection<\/code> argument should therefore be provided. If it is known that\nthe decoration is not affected by the text direction, then the argument\nmay be omitted or set to null.<\/p>\n<p>When a <a href=\"painting\/Decoration-class.html\">Decoration<\/a> is painted in a <a href=\"widgets\/Container-class.html\">Container<\/a> or <a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> (which\nis what <a href=\"widgets\/Container-class.html\">Container<\/a> uses), the <code>textDirection<\/code> parameter will be populated\nbased on the ambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a> (by way of the <a href=\"rendering\/RenderDecoratedBox-class.html\">RenderDecoratedBox<\/a>\nrenderer).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool hitTest(Size size, Offset position, { TextDirection textDirection }) {\n  return shape.getOuterPath(Offset.zero &amp; size, textDirection: textDirection).contains(position);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/hitTest.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "hitTest",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        },
                        {
                            "name": "size",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Size"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two shapes.<\/p>\n<p>Interpolates each parameter of the decoration separately.<\/p>\n<p>If both values are null, this returns null. Otherwise, it returns a\nnon-null value, with null arguments treated like a <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> whose\nfields are all null (including the <a href=\"painting\/ShapeDecoration\/shape.html\">shape<\/a>, which cannot normally be\nnull).<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/ShapeDecoration\/lerp.html\">Decoration.lerp<\/a>, which can interpolate between any two types of\n<a href=\"painting\/Decoration-class.html\">Decoration<\/a>s, not just <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a>s.<\/li>\n<li>\n<a href=\"painting\/ShapeDecoration\/lerpFrom.html\">lerpFrom<\/a> and <a href=\"painting\/ShapeDecoration\/lerpTo.html\">lerpTo<\/a>, which are used to implement <a href=\"painting\/ShapeDecoration\/lerp.html\">Decoration.lerp<\/a>\nand which use <a href=\"painting\/ShapeDecoration\/lerp.html\">ShapeDecoration.lerp<\/a> when interpolating two\n<a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a>s or a <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> to or from null.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static ShapeDecoration lerp(ShapeDecoration a, ShapeDecoration b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a != null &amp;&amp; b != null) {\n    if (t == 0.0)\n      return a;\n    if (t == 1.0)\n      return b;\n  }\n  return ShapeDecoration(\n    color: Color.lerp(a?.color, b?.color, t),\n    gradient: Gradient.lerp(a?.gradient, b?.gradient, t),\n    image: t &lt; 0.5 ? a.image : b.image, \/\/ TODO(ianh): cross-fade the image\n    shadows: BoxShadow.lerpList(a?.shadows, b?.shadows, t),\n    shape: ShapeBorder.lerp(a?.shape, b?.shape, t),\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeDecoration",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeDecoration"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeDecoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of a\ndifferent class) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeDecoration\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/ShapeDecoration\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>Supporting interpolating from null is recommended as the <a href=\"painting\/ShapeDecoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeDecoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeDecoration lerpFrom(Decoration a, double t) {\n  if (a is BoxDecoration) {\n    return ShapeDecoration.lerp(ShapeDecoration.fromBoxDecoration(a), this, t);\n  } else if (a == null || a is ShapeDecoration) {\n    return ShapeDecoration.lerp(a, this, t);\n  }\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeDecoration",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Decoration-class.html\">Decoration<\/a> (which may be of\na different class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/ShapeDecoration\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeDecoration\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>Supporting interpolating to null is recommended as the <a href=\"painting\/ShapeDecoration\/lerp.html\">Decoration.lerp<\/a>\nmethod uses this as a fallback when two classes can't interpolate between\neach other.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeDecoration\/lerp.html\">Decoration.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeDecoration lerpTo(Decoration b, double t) {\n  if (b is BoxDecoration) {\n    return ShapeDecoration.lerp(this, ShapeDecoration.fromBoxDecoration(b), t);\n  } else if (b == null || b is ShapeDecoration) {\n    return ShapeDecoration.lerp(this, b, t);\n  }\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/ShapeDecoration\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeDecoration",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Decoration"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>The color to fill in the background of the shape.<\/p>\n<p>The color is under the <a href=\"painting\/ShapeDecoration\/image.html\">image<\/a>.<\/p>\n<p>If a <a href=\"painting\/ShapeDecoration\/gradient.html\">gradient<\/a> is specified, <a href=\"painting\/ShapeDecoration\/color.html\">color<\/a> must be null.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color color\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/color.html",
                    "name": "color",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>A gradient to use when filling the shape.<\/p>\n<p>The gradient is under the <a href=\"painting\/ShapeDecoration\/image.html\">image<\/a>.<\/p>\n<p>If a <a href=\"painting\/ShapeDecoration\/color.html\">color<\/a> is specified, <a href=\"painting\/ShapeDecoration\/gradient.html\">gradient<\/a> must be null.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Gradient gradient\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/gradient.html",
                    "name": "gradient",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/ShapeDecoration\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/ShapeDecoration\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/ShapeDecoration\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/ShapeDecoration\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/ShapeDecoration\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/ShapeDecoration\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode {\n  return hashValues(\n    color,\n    gradient,\n    image,\n    shape,\n    shadows,\n  );\n}<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>An image to paint inside the shape (clipped to its outline).<\/p>\n<p>The image is drawn over the <a href=\"painting\/ShapeDecoration\/color.html\">color<\/a> or <a href=\"painting\/ShapeDecoration\/gradient.html\">gradient<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final DecorationImage image\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/image.html",
                    "name": "image",
                    "isDeprecated": false,
                    "type": "painting.DecorationImage",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>Whether this decoration is complex enough to benefit from caching its painting.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nbool get isComplex =&gt; shadows != null;<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/isComplex.html",
                    "name": "isComplex",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The inset space occupied by the <a href=\"painting\/ShapeDecoration\/shape.html\">shape<\/a>'s border.<\/p>\n<p>This value may be misleading. See the discussion at <a href=\"painting\/ShapeBorder\/dimensions.html\">ShapeBorder.dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsets get padding =&gt; shape.dimensions;<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/padding.html",
                    "name": "padding",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsets",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>A list of shadows cast by this shape behind the shape.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final List&lt;BoxShadow&gt; shadows\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/shadows.html",
                    "name": "shadows",
                    "isDeprecated": false,
                    "type": "dart:core.List<painting.BoxShadow>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                },
                {
                    "desc": "<p>The shape to fill the <a href=\"painting\/ShapeDecoration\/color.html\">color<\/a>, <a href=\"painting\/ShapeDecoration\/gradient.html\">gradient<\/a>, and <a href=\"painting\/ShapeDecoration\/image.html\">image<\/a> into and to cast as\nthe <a href=\"painting\/ShapeDecoration\/shadows.html\">shadows<\/a>.<\/p>\n<p>Shapes can be stacked (using the <code>+<\/code> operator). The color, gradient, and\nimage are drawn into the inner-most shape specified.<\/p>\n<p>The <a href=\"painting\/ShapeDecoration\/shape.html\">shape<\/a> property specifies the outline (border) of the decoration. The\nshape must not be null.<\/p>\n<h2 id=\"directionality-dependent-shapes\">Directionality-dependent shapes<\/h2>\n<p>Some <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses are sensitive to the <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>. The\ndirection that is provided to the border (e.g. for its <a href=\"painting\/ShapeBorder\/paint.html\">ShapeBorder.paint<\/a>\nmethod) is the one specified in the <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a>\n(<a href=\"painting\/ImageConfiguration\/textDirection.html\">ImageConfiguration.textDirection<\/a>) provided to the <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> (via its\n[BoxPainter.paint method). The <a href=\"painting\/BoxPainter-class.html\">BoxPainter<\/a> is obtained when\n<a href=\"painting\/ShapeDecoration\/createBoxPainter.html\">createBoxPainter<\/a> is called.<\/p>\n<p>When a <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> is used with a <a href=\"widgets\/Container-class.html\">Container<\/a> widget or a\n<a href=\"widgets\/DecoratedBox-class.html\">DecoratedBox<\/a> widget (which is what <a href=\"widgets\/Container-class.html\">Container<\/a> uses), the\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a> specified in the <a href=\"painting\/ImageConfiguration-class.html\">ImageConfiguration<\/a> is obtained from the\nambient <a href=\"widgets\/Directionality-class.html\">Directionality<\/a>, using <a href=\"widgets\/createLocalImageConfiguration.html\">createLocalImageConfiguration<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final ShapeBorder shape\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/ShapeDecoration\/shape.html",
                    "name": "shape",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.ShapeDecoration",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A border that fits a stadium-shaped border (a box with semicircles on the ends)\nwithin the rectangle of the widget it is applied to.<\/p>\n<p>Typically used with <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a> to draw a stadium border.<\/p>\n<p>If the rectangle is taller than it is wide, then the semicircles will be on the\ntop and bottom, and on the left and right otherwise.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/BorderSide-class.html\">BorderSide<\/a>, which is used to describe the border of the stadium.<\/li><\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/StadiumBorder-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.StadiumBorder",
            "shortname": "StadiumBorder",
            "extends": [
                "painting.ShapeBorder",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Create a stadium border.<\/p>\n<p>The <code>side<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const StadiumBorder({this.side = BorderSide.none}) : assert(side != null);<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/StadiumBorder.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StadiumBorder",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "side",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.BorderSide"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the inner edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/StadiumBorder\/getOuterPath.html\">getOuterPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/StadiumBorder\/getOuterPath.html\">getOuterPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/StadiumBorder\/getOuterPath.html\">getOuterPath<\/a>, which creates the path for the outer edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getInnerPath(Rect rect, { TextDirection textDirection }) {\n  final Radius radius = Radius.circular(rect.shortestSide \/ 2.0);\n  return Path()\n    ..addRRect(RRect.fromRectAndRadius(rect, radius).deflate(side.width));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/getInnerPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getInnerPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Create a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the outer edge of the border.<\/p>\n<p>This path must not cross the path given by <a href=\"painting\/StadiumBorder\/getInnerPath.html\">getInnerPath<\/a> for the same\n<a href=\"dart-ui\/Rect-class.html\">Rect<\/a>.<\/p>\n<p>To obtain a <a href=\"dart-ui\/Path-class.html\">Path<\/a> that describes the area of the border itself, set the\n<a href=\"dart-ui\/Path\/fillType.html\">Path.fillType<\/a> of the returned object to <a href=\"dart-ui\/PathFillType-class.html\">PathFillType.evenOdd<\/a>, and add\nto this object the path returned from <a href=\"painting\/StadiumBorder\/getInnerPath.html\">getInnerPath<\/a> (using\n<a href=\"dart-ui\/Path\/addPath.html\">Path.addPath<\/a>).<\/p>\n<p>The <code>textDirection<\/code> argument must be provided non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/StadiumBorder\/getInnerPath.html\">getInnerPath<\/a>, which creates the path for the inner edge.<\/li>\n<li>\n<a href=\"dart-ui\/Path\/contains.html\">Path.contains<\/a>, which can tell if an <a href=\"dart-ui\/Offset-class.html\">Offset<\/a> is within a <a href=\"dart-ui\/Path-class.html\">Path<\/a>.<\/li>\n<\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nPath getOuterPath(Rect rect, { TextDirection textDirection }) {\n  final Radius radius = Radius.circular(rect.shortestSide \/ 2.0);\n  return Path()\n    ..addRRect(RRect.fromRectAndRadius(rect, radius));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/getOuterPath.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Path",
                    "name": "getOuterPath",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of another\nclass) to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/StadiumBorder\/lerpTo.html\">lerpTo<\/a>\nmethod instead. If <code>a<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>a<\/code> being null by\ndeferring to <a href=\"painting\/StadiumBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpFrom(ShapeBorder a, double t) {\n  assert(t != null);\n  if (a is StadiumBorder)\n    return StadiumBorder(side: BorderSide.lerp(a.side, side, t));\n  if (a is CircleBorder) {\n    return _StadiumToCircleBorder(\n      side: BorderSide.lerp(a.side, side, t),\n      circleness: 1.0 - t,\n    );\n  }\n  if (a is RoundedRectangleBorder) {\n    return _StadiumToRoundedRectangleBorder(\n      side: BorderSide.lerp(a.side, side, t),\n      borderRadius: a.borderRadius,\n      rectness: 1.0 - t,\n    );\n  }\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> (possibly of\nanother class).<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/StadiumBorder\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/ShapeBorder\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead. If <code>b<\/code> is null, this must not return null.<\/p>\n<p>The base class implementation handles the case of <code>b<\/code> being null by\ndeferring to <a href=\"painting\/StadiumBorder\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/ShapeBorder\/lerp.html\">ShapeBorder.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder lerpTo(ShapeBorder b, double t) {\n  assert(t != null);\n  if (b is StadiumBorder)\n    return StadiumBorder(side: BorderSide.lerp(side, b.side, t));\n  if (b is CircleBorder) {\n    return _StadiumToCircleBorder(\n      side: BorderSide.lerp(side, b.side, t),\n      circleness: t,\n    );\n  }\n  if (b is RoundedRectangleBorder) {\n    return _StadiumToRoundedRectangleBorder(\n      side: BorderSide.lerp(side, b.side, t),\n      borderRadius: b.borderRadius,\n      rectness: t,\n    );\n  }\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.ShapeBorder"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the border within the given <a href=\"dart-ui\/Rect-class.html\">Rect<\/a> on the given <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>The <code>textDirection<\/code> argument must be provided and non-null if the border\nhas a text direction dependency (for example if it is expressed in terms\nof \"start\" and \"end\" instead of \"left\" and \"right\"). It may be null if\nthe border will not need the text direction to paint itself.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid paint(Canvas canvas, Rect rect, { TextDirection textDirection }) {\n  switch (side.style) {\n    case BorderStyle.none:\n      break;\n    case BorderStyle.solid:\n      final Radius radius = Radius.circular(rect.shortestSide \/ 2.0);\n      canvas.drawRRect(\n        RRect.fromRectAndRadius(rect, radius).deflate(side.width \/ 2.0),\n        side.toPaint(),\n      );\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this border, scaled by the factor <code>t<\/code>.<\/p>\n<p>Typically this means scaling the width of the border's side, but it can\nalso include scaling other artifacts of the border, e.g. the border radius\nof a <a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents the multiplicand, or the position on the\ntimeline for an interpolation from nothing to <code>this<\/code>, with 0.0 meaning\nthat the object returned should be the nil variant of this object, 1.0\nmeaning that no change should be applied, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), and other values meaning that the object should be\nmultiplied by <code>t<\/code>. Negative values are allowed but may be meaningless\n(they correspond to extrapolating the interpolation from this object to\nnothing, and going beyond nothing)<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/StadiumBorder\/scale.html\">BorderSide.scale<\/a>, which most <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses defer to for\nthe actual computation.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShapeBorder scale(double t) =&gt; StadiumBorder(side: side.scale(t));<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.ShapeBorder",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": [
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($side)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StadiumBorder\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The widths of the sides of this border represented as an <a href=\"painting\/EdgeInsets-class.html\">EdgeInsets<\/a>.<\/p>\n<p>Specifically, this is the amount by which a rectangle should be inset so\nas to avoid painting over any important part of the border. It is the\namount by which additional borders will be inset before they are drawn.<\/p>\n<p>This can be used, for example, with a <a href=\"widgets\/Padding-class.html\">Padding<\/a> widget to inset a box by\nthe size of these borders.<\/p>\n<p>Shapes that have a fixed ratio regardless of the area on which they are\npainted, or that change their rendering based on the size they are given\nwhen painting (for instance <a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>), will not return valid\n<a href=\"painting\/StadiumBorder\/dimensions.html\">dimensions<\/a> information because they cannot know their eventual size when\ncomputing their <a href=\"painting\/StadiumBorder\/dimensions.html\">dimensions<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nEdgeInsetsGeometry get dimensions {\n  return EdgeInsets.all(side.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/StadiumBorder\/dimensions.html",
                    "name": "dimensions",
                    "isDeprecated": false,
                    "type": "painting.EdgeInsetsGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/StadiumBorder\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/StadiumBorder\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/StadiumBorder\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/StadiumBorder\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/StadiumBorder\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/StadiumBorder\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; side.hashCode;<\/code><\/pre>\n        ",
                    "href": "painting\/StadiumBorder\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": []
                },
                {
                    "desc": "<p>The style of this border.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final BorderSide side\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StadiumBorder\/side.html",
                    "name": "side",
                    "isDeprecated": false,
                    "type": "painting.BorderSide",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StadiumBorder",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Defines the strut, which sets the minimum height a line can be\nrelative to the baseline. Strut applies to all lines in the paragraph.<\/p>\n<p>Strut is a feature that allows minimum line heights to be set. The effect is as\nif a zero width space was included at the beginning of each line in the\nparagraph. This imaginary space is 'shaped' according the properties defined\nin this class. Flutter's strut is based on <a href=\"https:\/\/en.wikipedia.org\/wiki\/Strut_(typesetting)\">typesetting strut<\/a>\nand CSS's <a href=\"https:\/\/www.w3.org\/TR\/CSS2\/visudet.html#line-height\">line-height<\/a>.<\/p>\n<p>No lines may be shorter than the strut. The ascent and descent of the strut\nare calculated, and any laid out text that has a shorter ascent or descent than\nthe strut's ascent or descent will take the ascent and descent of the strut.\nText with ascents or descents larger than the strut's ascent or descent will lay\nout as normal and extend past the strut.<\/p>\n<p>Strut is defined independently from any text content or <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>s.<\/p>\n<p>The vertical components of strut are as follows:<\/p>\n<ul>\n<li>\n<code>leading * fontSize \/ 2<\/code> or half the font leading if <code>leading<\/code> is undefined (half leading)<\/li>\n<li><code>ascent * height<\/code><\/li>\n<li><code>descent * height<\/code><\/li>\n<li>\n<code>leading * fontSize \/ 2<\/code> or half the font leading if <code>leading<\/code> is undefined (half leading)<\/li>\n<\/ul>\n<p>The sum of these four values is the total height of the line.<\/p>\n<p>The <code>ascent + descent<\/code> is equivalent to the <a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a>. Ascent is the font's\nspacing above the baseline without leading and descent is the spacing below the\nbaseline without leading. Leading is split evenly between the top and bottom.\nThe values for <code>ascent<\/code> and <code>descent<\/code> are provided by the font named by\n<a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a>. If no <a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a> or <a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> is provided, then the\nplatform's default family will be used.<\/p>\n<p>Each line's spacing above the baseline will be at least as tall as the half\nleading plus ascent. Each line's spacing below the baseline will be at least as\ntall as the half leading plus descent.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"https:\/\/api.flutter.dev\/flutter\/dart-ui\/StrutStyle-class.html\">StrutStyle<\/a>, the class in the <a href=\"dart-ui\/dart-ui-library.html\">dart:ui<\/a> library.<\/li><\/ul>\n<h3 id=\"fields-and-their-default-values\">Fields and their default values.<\/h3>\n<p>Omitted or null properties will take the default values specified below:<\/p>\n<ul>\n<li>\n<p><a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a>: the name of the font to use when calculating the strut\n(e.g., Roboto). No glyphs from the font will be drawn and the font will\nbe used purely for metrics.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>: an ordered list of font family names that will be searched for when\nthe font in <a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a> cannot be found. When all specified font families have been\nexhausted an no match was found, the default platform font will be used.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a>: the size of the ascent plus descent in logical pixels. This\nis also used as the basis of the custom leading calculation. This value\ncannot be negative.\nDefault is 14 logical pixels.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/height.html\">height<\/a>: the multiple of <a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a> to multiply the ascent and descent by.\nThe <a href=\"painting\/StrutStyle\/height.html\">height<\/a> will impact the spacing above and below the baseline differently\ndepending on the ratios between the font's ascent and descent. This property is\nseparate from the leading multiplier, which is controlled through <a href=\"painting\/StrutStyle\/leading.html\">leading<\/a>.\nDefault is 1.0.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/leading.html\">leading<\/a>: the custom leading to apply to the strut as a multiple of <a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a>.\nLeading is additional spacing between lines. Half of the leading is added\nto the top and the other half to the bottom of the line height. This differs\nfrom <a href=\"painting\/StrutStyle\/height.html\">height<\/a> since the spacing is equally distributed above and below the\nbaseline.\nDefault is <code>null<\/code>, which will use the font-specified leading.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/fontWeight.html\">fontWeight<\/a>: the typeface thickness to use when calculating the strut (e.g., bold).\nDefault is <a href=\"dart-ui\/FontWeight\/w400-constant.html\">FontWeight.w400<\/a>.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/fontStyle.html\">fontStyle<\/a>: the typeface variant to use when calculating the strut (e.g., italic).\nDefault is <a href=\"dart-ui\/FontStyle-class.html\">FontStyle.normal<\/a>.<\/p>\n<\/li>\n<li>\n<p><a href=\"painting\/StrutStyle\/forceStrutHeight.html\">forceStrutHeight<\/a>: when true, all lines will be laid out with the height of the\nstrut. All line and run-specific metrics will be ignored\/overridden and only strut\nmetrics will be used instead. This property guarantees uniform line spacing, however\ntext in adjacent lines may overlap. This property should be enabled with caution as\nit bypasses a large portion of the vertical layout system.\nThe default value is false.<\/p>\n<\/li>\n<\/ul>\n<h3 id=\"examples\">Examples<\/h3>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nIn this simple case, the text will be rendered at font size 10, however, the vertical\nheight of each line will be the strut height (Roboto in font size 30 * 1.5) as the text\nitself is shorter than the strut.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const Text(\n  'Hello, world!\\nSecond line!',\n  style: TextStyle(\n    fontSize: 10,\n    fontFamily: 'Raleway',\n  ),\n  strutStyle: StrutStyle(\n    fontFamily: 'Roboto',\n    fontSize: 30,\n    height: 1.5,\n  ),\n),<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nHere, strut is used to absorb the additional line height in the second line.\nThe strut <a href=\"painting\/StrutStyle\/height.html\">height<\/a> was defined as 1.5 (the default font size is 14), which\ncaused all lines to be laid out taller than without strut. This extra space\nwas able to accommodate the larger font size of <code>Second line!<\/code> without\ncausing the line height to change for the second line only. All lines in\nthis example are thus the same height (<code>14 * 1.5<\/code>).\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const Text.rich(\n  TextSpan(\n    text: 'First line!\\n',\n    style: TextStyle(\n      fontSize: 14,\n      fontFamily: 'Roboto'\n    ),\n    children: &lt;TextSpan&gt;[\n      TextSpan(\n        text: 'Second line!\\n',\n        style: TextStyle(\n          fontSize: 16,\n          fontFamily: 'Roboto',\n        ),\n      ),\n      TextSpan(\n        text: 'Third line!\\n',\n        style: TextStyle(\n          fontSize: 14,\n          fontFamily: 'Roboto',\n        ),\n      ),\n    ],\n  ),\n  strutStyle: StrutStyle(\n    fontFamily: 'Roboto',\n    height: 1.5,\n  ),\n),<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nHere, strut is used to enable strange and overlapping text to achieve unique\neffects. The <code>M<\/code>s in lines 2 and 3 are able to extend above their lines and\nfill empty space in lines above. The <a href=\"painting\/StrutStyle\/forceStrutHeight.html\">forceStrutHeight<\/a> is enabled and functions\nas a 'grid' for the glyphs to draw on.\n<p><img alt=\"The result of the example below.\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/strut_force_example.png\"><\/p>\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const Text.rich(\n  TextSpan(\n    text: '---------         ---------\\n',\n    style: TextStyle(\n      fontSize: 14,\n      fontFamily: 'Roboto',\n    ),\n    children: &lt;TextSpan&gt;[\n      TextSpan(\n        text: '^^^M^^^\\n',\n        style: TextStyle(\n          fontSize: 30,\n          fontFamily: 'Roboto',\n        ),\n      ),\n      TextSpan(\n        text: 'M------M\\n',\n        style: TextStyle(\n          fontSize: 30,\n          fontFamily: 'Roboto',\n        ),\n      ),\n    ],\n  ),\n  strutStyle: StrutStyle(\n    fontFamily: 'Roboto',\n    fontSize: 14,\n    height: 1,\n    forceStrutHeight: true,\n  ),\n),<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example uses forceStrutHeight to create a 'drop cap' for the 'T' in 'The'.\nBy locking the line heights to the metrics of the 14pt serif font, we are able\nto lay out a large 37pt 'T' on the second line to take up space on both the first\nand second lines.\n<p><img alt=\"The result of the example below.\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/strut_force_example_2.png\"><\/p>\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text.rich(\n  TextSpan(\n    text: '      \u2009he candle flickered\\n',\n    style: TextStyle(\n      fontSize: 14,\n      fontFamily: 'Serif'\n    ),\n    children: &lt;TextSpan&gt;[\n      TextSpan(\n        text: 'T',\n        style: TextStyle(\n          fontSize: 37,\n          fontFamily: 'Serif'\n        ),\n      ),\n      TextSpan(\n        text: 'in the moonlight as\\n',\n        style: TextStyle(\n          fontSize: 14,\n          fontFamily: 'Serif'\n        ),\n      ),\n      TextSpan(\n        text: 'Dash the bird fluttered\\n',\n        style: TextStyle(\n          fontSize: 14,\n          fontFamily: 'Serif'\n        ),\n      ),\n      TextSpan(\n        text: 'off into the distance.',\n        style: TextStyle(\n          fontSize: 14,\n          fontFamily: 'Serif'\n        ),\n      ),\n    ],\n  ),\n  strutStyle: StrutStyle(\n    fontFamily: 'Serif',\n    fontSize: 14,\n    forceStrutHeight: true,\n  ),\n),<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/StrutStyle-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.StrutStyle",
            "shortname": "StrutStyle",
            "extends": [
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a strut style.<\/p>\n<p>The <code>package<\/code> argument must be non-null if the font family is defined in a\npackage. It is combined with the <code>fontFamily<\/code> argument to set the\n<code>fontFamily<\/code> property.<\/p>\n<p>If provided, fontSize must be positive and non-zero, leading must be zero or positive.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const StrutStyle({\n  String fontFamily,\n  List&lt;String&gt; fontFamilyFallback,\n  this.fontSize,\n  this.height,\n  this.leading,\n  this.fontWeight,\n  this.fontStyle,\n  this.forceStrutHeight,\n  this.debugLabel,\n  String package,\n}) : fontFamily = package == null ? fontFamily : 'packages\/$package\/$fontFamily',\n     _fontFamilyFallback = fontFamilyFallback,\n     _package = package,\n     assert(fontSize == null || fontSize &gt; 0),\n     assert(leading == null || leading &gt;= 0),\n     assert(package == null || (package != null &amp;&amp; (fontFamily != null || fontFamilyFallback != null)));<\/code><\/pre>\n    ",
                    "href": "painting\/StrutStyle\/StrutStyle.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "StrutStyle",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.StrutStyle",
                    "params": [
                        {
                            "name": "debugLabel",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontFamily",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontFamilyFallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:core.String>"
                        },
                        {
                            "name": "fontSize",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.FontStyle"
                        },
                        {
                            "name": "fontWeight",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.FontWeight"
                        },
                        {
                            "name": "forceStrutHeight",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "height",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "leading",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "package",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Describe the difference between this style and another, in terms of how\nmuch damage it will make to the rendering.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/StrutStyle\/compareTo.html\">TextSpan.compareTo<\/a>, which does the same thing for entire <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>s.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RenderComparison compareTo(StrutStyle other) {\n  if (identical(this, other))\n    return RenderComparison.identical;\n  if (fontFamily != other.fontFamily ||\n      fontSize != other.fontSize ||\n      fontWeight != other.fontWeight ||\n      fontStyle != other.fontStyle ||\n      height != other.height ||\n      leading != other.leading ||\n      forceStrutHeight != other.forceStrutHeight ||\n      !listEquals(fontFamilyFallback, other.fontFamilyFallback))\n    return RenderComparison.layout;\n  return RenderComparison.identical;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StrutStyle\/compareTo.html",
                    "isDeprecated": false,
                    "type": "painting.RenderComparison",
                    "name": "compareTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StrutStyle",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.StrutStyle"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds all properties prefixing property names with the optional <code>prefix<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties, { String prefix = '' }) {\n  super.debugFillProperties(properties);\n  if (debugLabel != null)\n    properties.add(MessageProperty('${prefix}debugLabel', debugLabel));\n  final List&lt;DiagnosticsNode&gt; styles = &lt;DiagnosticsNode&gt;[];\n  styles.add(StringProperty('${prefix}family', fontFamily, defaultValue: null, quoted: false));\n  styles.add(IterableProperty&lt;String&gt;('${prefix}familyFallback', fontFamilyFallback, defaultValue: null));\n  styles.add(DoubleProperty('${prefix}size', fontSize, defaultValue: null));\n  String weightDescription;\n  if (fontWeight != null) {\n    weightDescription = 'w${fontWeight.index + 1}00';\n  }\n  \/\/ TODO(jacobr): switch this to use enumProperty which will either cause the\n  \/\/ weight description to change to w600 from 600 or require existing\n  \/\/ enumProperty to handle this special case.\n  styles.add(DiagnosticsProperty&lt;FontWeight&gt;(\n    '${prefix}weight',\n    fontWeight,\n    description: weightDescription,\n    defaultValue: null,\n  ));\n  styles.add(EnumProperty&lt;FontStyle&gt;('${prefix}style', fontStyle, defaultValue: null));\n  styles.add(DoubleProperty('${prefix}height', height, unit: 'x', defaultValue: null));\n  styles.add(FlagProperty('${prefix}forceStrutHeight', value: forceStrutHeight, defaultValue: null));\n\n  final bool styleSpecified = styles.any((DiagnosticsNode n) =&gt; !n.isFiltered(DiagnosticLevel.info));\n  styles.forEach(properties.add);\n\n  if (!styleSpecified)\n    properties.add(FlagProperty('forceStrutHeight', value: forceStrutHeight, ifTrue: '$prefix&lt;strut height forced&gt;', ifFalse: '$prefix&lt;strut height normal&gt;'));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StrutStyle\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StrutStyle",
                    "params": [
                        {
                            "name": "prefix",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new strut style that inherits its null values from corresponding\nproperties in the <code>other<\/code> <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>.<\/p>\n<p>The \"missing\" properties of the this strut style are <em>filled<\/em> by the properties\nof the provided <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>. This is possible because <a href=\"painting\/StrutStyle-class.html\">StrutStyle<\/a> shares many of\nthe same basic properties as <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>.<\/p>\n<p>If the given text style is null, returns this strut style.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">StrutStyle inheritFromTextStyle(TextStyle other) {\n  if (other == null)\n    return this;\n\n  return StrutStyle(\n    fontFamily: fontFamily ?? other.fontFamily,\n    fontFamilyFallback: fontFamilyFallback ?? other.fontFamilyFallback,\n    fontSize: fontSize ?? other.fontSize,\n    height: height ?? other.height,\n    leading: leading, \/\/ No equivalent property in TextStyle yet.\n    fontWeight: fontWeight ?? other.fontWeight,\n    fontStyle: fontStyle ?? other.fontStyle,\n    forceStrutHeight: forceStrutHeight, \/\/ StrutStyle-unique property.\n    debugLabel: debugLabel ?? other.debugLabel,\n    \/\/ Package is embedded within the getters for fontFamilyFallback.\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/StrutStyle\/inheritFromTextStyle.html",
                    "isDeprecated": false,
                    "type": "painting.StrutStyle",
                    "name": "inheritFromTextStyle",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StrutStyle",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextStyle"
                        }
                    ]
                },
                {
                    "desc": "<p>A brief description of this object, usually just the <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and the\n<a href=\"painting\/StrutStyle\/hashCode.html\">hashCode<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>, for a detailed description of the object.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toStringShort() =&gt; '$runtimeType';<\/code><\/pre>\n    ",
                    "href": "painting\/StrutStyle\/toStringShort.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toStringShort",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>A human-readable description of this strut style.<\/p>\n<p>This property is maintained only in debug builds.<\/p>\n<p>This property is not considered when comparing strut styles using <code>==<\/code> or\n<a href=\"painting\/StrutStyle\/compareTo.html\">compareTo<\/a>, and it does not affect <a href=\"painting\/StrutStyle\/hashCode.html\">hashCode<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String debugLabel\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/debugLabel.html",
                    "name": "debugLabel",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>A <a href=\"painting\/StrutStyle-class.html\">StrutStyle<\/a> that will have no impact on the text layout.<\/p>\n<p>Equivalent to having no strut at all. All lines will be laid out according to\nthe properties defined in <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static const StrutStyle disabled = StrutStyle(\n  height: 0.0,\n  leading: 0.0,\n)\n\n<\/code><\/pre>\n    ",
                    "href": "painting\/StrutStyle\/disabled-constant.html",
                    "name": "disabled",
                    "isDeprecated": false,
                    "type": "painting.StrutStyle",
                    "dtype": "constant",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The name of the font to use when calculating the strut (e.g., Roboto). If\nthe font is defined in a package, this will be prefixed with\n'packages\/package_name\/' (e.g. 'packages\/cool_fonts\/Roboto'). The\nprefixing is done by the constructor when the <code>package<\/code> argument is\nprovided.<\/p>\n<p>The value provided in <a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a> will act as the preferred\/first font\nfamily that will be searched for, followed in order by the font families\nin <a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>. If all font families are exhausted and no match\nwas found, the default platform font family will be used instead. Unlike\n<a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">TextStyle.fontFamilyFallback<\/a>, the font does not need to contain the\ndesired glyphs to match.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String fontFamily\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/fontFamily.html",
                    "name": "fontFamily",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The ordered list of font families to fall back on when a higher priority\nfont family cannot be found.<\/p>\n<p>The value provided in <a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a> will act as the preferred\/first font\nfamily that will be searched for, followed in order by the font families\nin <a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>. If all font families are exhausted and no match\nwas found, the default platform font family will be used instead. Unlike\n<a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">TextStyle.fontFamilyFallback<\/a>, the font does not need to contain the\ndesired glyphs to match.<\/p>\n<p>When <a href=\"painting\/StrutStyle\/fontFamily.html\">fontFamily<\/a> is null or not provided, the first value in <a href=\"painting\/StrutStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>\nacts as the preferred\/first font family. When neither is provided, then\nthe default platform font will be used. Providing and empty list or null\nfor this property is the same as omitting it.<\/p>\n<p>If the font is defined in a package, each font family in the list will be\nprefixed with 'packages\/package_name\/' (e.g. 'packages\/cool_fonts\/Roboto').\nThe package name should be provided by the <code>package<\/code> argument in the\nconstructor.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">List&lt;String&gt; get fontFamilyFallback {\n  if (_package != null &amp;&amp; _fontFamilyFallback != null)\n    return _fontFamilyFallback.map((String family) =&gt; 'packages\/$_package\/$family').toList();\n  return _fontFamilyFallback;\n}<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/fontFamilyFallback.html",
                    "name": "fontFamilyFallback",
                    "isDeprecated": false,
                    "type": "dart:core.List<dart:core.String>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The size of text (in logical pixels) to use when obtaining metrics from the font.<\/p>\n<p>The <a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a> is used to get the base set of metrics that are then used to calculated\nthe metrics of strut. The height and leading are expressed as a multiple of\n<a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a>.<\/p>\n<p>The default fontSize is 14 logical pixels.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double fontSize\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/fontSize.html",
                    "name": "fontSize",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The typeface variant to use when calculating the strut (e.g., italics).<\/p>\n<p>The default fontStyle is <a href=\"dart-ui\/FontStyle-class.html\">FontStyle.normal<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final FontStyle fontStyle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/fontStyle.html",
                    "name": "fontStyle",
                    "isDeprecated": false,
                    "type": "dart:ui.FontStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The typeface thickness to use when calculating the strut (e.g., bold).<\/p>\n<p>The default fontWeight is <a href=\"dart-ui\/FontWeight\/w400-constant.html\">FontWeight.w400<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final FontWeight fontWeight\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/fontWeight.html",
                    "name": "fontWeight",
                    "isDeprecated": false,
                    "type": "dart:ui.FontWeight",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>Whether the strut height should be forced.<\/p>\n<p>When true, all lines will be laid out with the height of the\nstrut. All line and run-specific metrics will be ignored\/overridden and only strut\nmetrics will be used instead. This property guarantees uniform line spacing, however\ntext in adjacent lines may overlap.<\/p>\n<p>This property should be enabled with caution as\nit bypasses a large portion of the vertical layout system.<\/p>\n<p>This is equivalent to setting <a href=\"painting\/StrutStyle\/height.html\">TextStyle.height<\/a> to zero for all <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>s\nin the paragraph. Since the height of each line is calculated as a max of the\nmetrics of each run of text, zero height <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>s cause the minimums\ndefined by strut to always manifest, resulting in all lines having the height\nof the strut.<\/p>\n<p>The default is false.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final bool forceStrutHeight\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/forceStrutHeight.html",
                    "name": "forceStrutHeight",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/StrutStyle\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/StrutStyle\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/StrutStyle\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/StrutStyle\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/StrutStyle\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/StrutStyle\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode {\n  return hashValues(\n    fontFamily,\n    fontSize,\n    fontWeight,\n    fontStyle,\n    height,\n    leading,\n    forceStrutHeight,\n  );\n}<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The multiple of <a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a> to multiply the ascent and descent by where <code>ascent + descent = fontSize<\/code>.<\/p>\n<p>Ascent is the spacing above the baseline and descent is the spacing below the baseline.<\/p>\n<p>The <a href=\"painting\/StrutStyle\/height.html\">height<\/a> will impact the spacing above and below the baseline differently\ndepending on the ratios between the font's ascent and descent. This property is\nseparate from the leading multiplier, which is controlled through <a href=\"painting\/StrutStyle\/leading.html\">leading<\/a>.<\/p>\n<p>The default height is 1.0.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double height\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/height.html",
                    "name": "height",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                },
                {
                    "desc": "<p>The custom leading to apply to the strut as a multiple of <a href=\"painting\/StrutStyle\/fontSize.html\">fontSize<\/a>.<\/p>\n<p>Leading is additional spacing between lines. Half of the leading is added\nto the top and the other half to the bottom of the line. This differs\nfrom <a href=\"painting\/StrutStyle\/height.html\">height<\/a> since the spacing is equally distributed above and below the\nbaseline.<\/p>\n<p>The default leading is null, which will use the font-specified leading.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double leading\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/StrutStyle\/leading.html",
                    "name": "leading",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.StrutStyle",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A 2D sweep gradient.<\/p>\n<p>This class is used by <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> to represent sweep gradients. This\nabstracts out the arguments to the <a href=\"dart-ui\/Gradient\/Gradient.sweep.html\">new ui.Gradient.sweep<\/a> constructor from\nthe <code>dart:ui<\/code> library.<\/p>\n<p>A gradient has a <a href=\"painting\/SweepGradient\/center.html\">center<\/a>, a <a href=\"painting\/SweepGradient\/startAngle.html\">startAngle<\/a>, and an <a href=\"painting\/SweepGradient\/endAngle.html\">endAngle<\/a>. The <a href=\"painting\/SweepGradient\/startAngle.html\">startAngle<\/a>\ncorresponds to 0.0, and the <a href=\"painting\/SweepGradient\/endAngle.html\">endAngle<\/a> corresponds to 1.0. These angles are\nexpressed in radians.<\/p>\n<p>The <a href=\"painting\/Gradient\/colors.html\">colors<\/a> are described by a list of <a href=\"dart-ui\/Color-class.html\">Color<\/a> objects. There must be at\nleast two colors. The <a href=\"painting\/Gradient\/stops.html\">stops<\/a> list, if specified, must have the same length\nas <a href=\"painting\/Gradient\/colors.html\">colors<\/a>. It specifies fractions of the vector from start to end, between\n0.0 and 1.0, for each color. If it is null, a uniform distribution is\nassumed.<\/p>\n<p>The region of the canvas before <a href=\"painting\/SweepGradient\/startAngle.html\">startAngle<\/a> and after <a href=\"painting\/SweepGradient\/endAngle.html\">endAngle<\/a> is colored\naccording to <a href=\"painting\/SweepGradient\/tileMode.html\">tileMode<\/a>.<\/p>\n<p>Typically this class is used with <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which does the painting.\nTo use a <a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a> to paint on a canvas directly, see <a href=\"painting\/SweepGradient\/createShader.html\">createShader<\/a>.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis sample draws a different color in each quadrant.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Container(\n  decoration: BoxDecoration(\n    gradient: SweepGradient(\n      center: FractionalOffset.center,\n      startAngle: 0.0,\n      endAngle: math.pi * 2,\n      colors: const &lt;Color&gt;[\n        Color(0xFF4285F4), \/\/ blue\n        Color(0xFF34A853), \/\/ green\n        Color(0xFFFBBC05), \/\/ yellow\n        Color(0xFFEA4335), \/\/ red\n        Color(0xFF4285F4), \/\/ blue again to seamlessly transition to the start\n      ],\n      stops: const &lt;double&gt;[0.0, 0.25, 0.5, 0.75, 1.0],\n     ),\n  ),\n )<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/LinearGradient-class.html\">LinearGradient<\/a>, which displays a gradient in parallel lines, and has an\nexample which shows a different way to use <a href=\"painting\/Gradient-class.html\">Gradient<\/a> objects.<\/li>\n<li>\n<a href=\"painting\/RadialGradient-class.html\">RadialGradient<\/a>, which displays a gradient in concentric circles, and\nhas an example which shows a different way to use <a href=\"painting\/Gradient-class.html\">Gradient<\/a> objects.<\/li>\n<li>\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>, which can take a <a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a> in its\n<a href=\"painting\/BoxDecoration\/gradient.html\">BoxDecoration.gradient<\/a> property.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/SweepGradient-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.SweepGradient",
            "shortname": "SweepGradient",
            "extends": [
                "painting.Gradient",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a sweep gradient.<\/p>\n<p>The <code>colors<\/code> argument must not be null. If <code>stops<\/code> is non-null, it must\nhave the same length as <code>colors<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const SweepGradient({\n  this.center = Alignment.center,\n  this.startAngle = 0.0,\n  this.endAngle = math.pi * 2,\n  @required List&lt;Color&gt; colors,\n  List&lt;double&gt; stops,\n  this.tileMode = TileMode.clamp,\n}) : assert(center != null),\n     assert(startAngle != null),\n     assert(endAngle != null),\n     assert(tileMode != null),\n     super(colors: colors, stops: stops);<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/SweepGradient.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "SweepGradient",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": [
                        {
                            "name": "center",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.AlignmentGeometry"
                        },
                        {
                            "name": "colors",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:ui.Color>"
                        },
                        {
                            "name": "endAngle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "startAngle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "stops",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:core.double>"
                        },
                        {
                            "name": "tileMode",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TileMode"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a <a href=\"dart-ui\/Shader-class.html\">Shader<\/a> for this gradient to fill the given rect.<\/p>\n<p>If the gradient's configuration is text-direction-dependent, for example\nit uses <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a> objects instead of <a href=\"painting\/Alignment-class.html\">Alignment<\/a>\nobjects, then the <code>textDirection<\/code> argument must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nShader createShader(Rect rect, { TextDirection textDirection }) {\n  return ui.Gradient.sweep(\n    center.resolve(textDirection).withinRect(rect),\n    colors, _impliedStops(), tileMode,\n    startAngle,\n    endAngle,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/createShader.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Shader",
                    "name": "createShader",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": [
                        {
                            "name": "rect",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolate between two <a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a>s.<\/p>\n<p>If either gradient is null, then the non-null gradient is returned with\nits color scaled in the same way as the <a href=\"painting\/SweepGradient\/scale.html\">scale<\/a> function.<\/p>\n<p>If neither gradient is null, they must have the same number of <a href=\"painting\/Gradient\/colors.html\">colors<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents a position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static SweepGradient lerp(SweepGradient a, SweepGradient b, double t) {\n  assert(t != null);\n  if (a == null &amp;&amp; b == null)\n    return null;\n  if (a == null)\n    return b.scale(t);\n  if (b == null)\n    return a.scale(1.0 - t);\n  final _ColorsAndStops interpolated = _interpolateColorsAndStops(\n      a.colors,\n      a._impliedStops(),\n      b.colors,\n      b._impliedStops(),\n      t,\n  );\n  return SweepGradient(\n    center: AlignmentGeometry.lerp(a.center, b.center, t),\n    startAngle: math.max(0.0, ui.lerpDouble(a.startAngle, b.startAngle, t)),\n    endAngle: math.max(0.0, ui.lerpDouble(a.endAngle, b.endAngle, t)),\n    colors: interpolated.colors,\n    stops: interpolated.stops,\n    tileMode: t &lt; 0.5 ? a.tileMode : b.tileMode, \/\/ TODO(ianh): interpolate tile mode\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.SweepGradient",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.SweepGradient"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.SweepGradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from another <a href=\"painting\/Gradient-class.html\">Gradient<\/a> to <code>this<\/code>.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>a<\/code>. In that case, <a href=\"painting\/SweepGradient\/lerp.html\">lerp<\/a> will try <code>a<\/code>'s <a href=\"painting\/SweepGradient\/lerpTo.html\">lerpTo<\/a>\nmethod instead.<\/p>\n<p>If <code>a<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/SweepGradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>this<\/code> (or something equivalent to <code>this<\/code>), and values in\nbetween meaning that the interpolation is at the relevant point on the\ntimeline between <code>a<\/code> and <code>this<\/code>. The interpolation can be extrapolated\nbeyond 0.0 and 1.0, so negative values and values greater than 1.0 are\nvalid (and can easily be generated by curves such as\n<a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/SweepGradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nGradient lerpFrom(Gradient a, double t) {\n  if (a == null || (a is SweepGradient))\n    return SweepGradient.lerp(a, this, t);\n  return super.lerpFrom(a, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/lerpFrom.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpFrom",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Linearly interpolates from <code>this<\/code> to another <a href=\"painting\/Gradient-class.html\">Gradient<\/a>.<\/p>\n<p>This is called if <code>b<\/code>'s <a href=\"painting\/SweepGradient\/lerpTo.html\">lerpTo<\/a> did not know how to handle this class.<\/p>\n<p>When implementing this method in subclasses, return null if this class\ncannot interpolate from <code>b<\/code>. In that case, <a href=\"painting\/SweepGradient\/lerp.html\">lerp<\/a> will apply a default\nbehavior instead.<\/p>\n<p>If <code>b<\/code> is null, this must not return null. The base class implements this\nby deferring to <a href=\"painting\/SweepGradient\/scale.html\">scale<\/a>.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>this<\/code> (or something\nequivalent to <code>this<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>this<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0\nand 1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>Instead of calling this directly, use <a href=\"painting\/SweepGradient\/lerp.html\">Gradient.lerp<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nGradient lerpTo(Gradient b, double t) {\n  if (b == null || (b is SweepGradient))\n    return SweepGradient.lerp(this, b, t);\n  return super.lerpTo(b, t);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/lerpTo.html",
                    "isDeprecated": false,
                    "type": "painting.Gradient",
                    "name": "lerpTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": [
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.Gradient"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new <a href=\"painting\/SweepGradient-class.html\">SweepGradient<\/a> with its colors scaled by the given factor.<\/p>\n<p>Since the alpha component of the Color is what is scaled, a factor\nof 0.0 or less results in a gradient that is fully transparent.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nSweepGradient scale(double factor) {\n  return SweepGradient(\n    center: center,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    colors: colors.map&lt;Color&gt;((Color color) =&gt; Color.lerp(null, color, factor)).toList(),\n    stops: stops,\n    tileMode: tileMode,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/scale.html",
                    "isDeprecated": false,
                    "type": "painting.SweepGradient",
                    "name": "scale",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": [
                        {
                            "name": "factor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of this object.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toString() {\n  return '$runtimeType($center, $startAngle, $endAngle, $colors, $stops, $tileMode)';\n}<\/code><\/pre>\n    ",
                    "href": "painting\/SweepGradient\/toString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.SweepGradient",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The center of the gradient, as an offset into the (-1.0, -1.0) x (1.0, 1.0)\nsquare describing the gradient which will be mapped onto the paint box.<\/p>\n<p>For example, an alignment of (0.0, 0.0) will place the sweep\ngradient in the center of the box.<\/p>\n<p>If this is an <a href=\"painting\/Alignment-class.html\">Alignment<\/a>, then it is expressed as a vector from\ncoordinate (0.0, 0.0), in a coordinate space that maps the center of the\npaint box at (0.0, 0.0) and the bottom right at (1.0, 1.0).<\/p>\n<p>It can also be an <a href=\"painting\/AlignmentDirectional-class.html\">AlignmentDirectional<\/a>, where the start is the left in\nleft-to-right contexts and the right in right-to-left contexts. If a\ntext-direction-dependent value is provided here, then the <a href=\"painting\/SweepGradient\/createShader.html\">createShader<\/a>\nmethod will need to be given a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final AlignmentGeometry center\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/SweepGradient\/center.html",
                    "name": "center",
                    "isDeprecated": false,
                    "type": "painting.AlignmentGeometry",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.SweepGradient",
                    "params": []
                },
                {
                    "desc": "<p>The angle in radians at which stop 1.0 of the gradient is placed.<\/p>\n<p>Defaults to math.pi * 2.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double endAngle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/SweepGradient\/endAngle.html",
                    "name": "endAngle",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.SweepGradient",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/SweepGradient\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/SweepGradient\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/SweepGradient\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/SweepGradient\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/SweepGradient\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/SweepGradient\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(center, startAngle, endAngle, tileMode, hashList(colors), hashList(stops));<\/code><\/pre>\n        ",
                    "href": "painting\/SweepGradient\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.SweepGradient",
                    "params": []
                },
                {
                    "desc": "<p>The angle in radians at which stop 0.0 of the gradient is placed.<\/p>\n<p>Defaults to 0.0.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double startAngle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/SweepGradient\/startAngle.html",
                    "name": "startAngle",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.SweepGradient",
                    "params": []
                },
                {
                    "desc": "<p>How this gradient should tile the plane beyond in the region before\n<a href=\"painting\/SweepGradient\/startAngle.html\">startAngle<\/a> and after <a href=\"painting\/SweepGradient\/endAngle.html\">endAngle<\/a>.<\/p>\n<p>For details, see <a href=\"dart-ui\/TileMode-class.html\">TileMode<\/a>.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_clamp_sweep.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_mirror_sweep.png\"><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/dart-ui\/tile_mode_repeated_sweep.png\"><\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TileMode tileMode\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/SweepGradient\/tileMode.html",
                    "name": "tileMode",
                    "isDeprecated": false,
                    "type": "dart:ui.TileMode",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.SweepGradient",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An object that paints a <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> tree into a <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/p>\n<p>To use a <a href=\"painting\/TextPainter-class.html\">TextPainter<\/a>, follow these steps:<\/p>\n<ol>\n<li>\n<p>Create a <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> tree and pass it to the <a href=\"painting\/TextPainter-class.html\">TextPainter<\/a>\nconstructor.<\/p>\n<\/li>\n<li>\n<p>Call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> to prepare the paragraph.<\/p>\n<\/li>\n<li>\n<p>Call <a href=\"painting\/TextPainter\/paint.html\">paint<\/a> as often as desired to paint the paragraph.<\/p>\n<\/li>\n<\/ol>\n<p>If the width of the area into which the text is being painted\nchanges, return to step 2. If the text to be painted changes,\nreturn to step 1.<\/p>\n<p>The default text style is white. To change the color of the text,\npass a <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> object to the <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> in <code>text<\/code>.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/TextPainter-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.TextPainter",
            "shortname": "TextPainter",
            "extends": [],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a text painter that paints the given text.<\/p>\n<p>The <code>text<\/code> and <code>textDirection<\/code> arguments are optional but <code>text<\/code> and\n<code>textDirection<\/code> must be non-null before calling <a href=\"painting\/TextPainter\/layout.html\">layout<\/a>.<\/p>\n<p>The <code>textAlign<\/code> property must not be null.<\/p>\n<p>The <code>maxLines<\/code> property, if non-null, must be greater than zero.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextPainter({\n  TextSpan text,\n  TextAlign textAlign = TextAlign.start,\n  TextDirection textDirection,\n  double textScaleFactor = 1.0,\n  int maxLines,\n  String ellipsis,\n  Locale locale,\n  StrutStyle strutStyle,\n}) : assert(text == null || text.debugAssertIsValid()),\n     assert(textAlign != null),\n     assert(textScaleFactor != null),\n     assert(maxLines == null || maxLines &gt; 0),\n     _text = text,\n     _textAlign = textAlign,\n     _textDirection = textDirection,\n     _textScaleFactor = textScaleFactor,\n     _maxLines = maxLines,\n     _ellipsis = ellipsis,\n     _locale = locale,\n     _strutStyle = strutStyle;<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/TextPainter.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TextPainter",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "ellipsis",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "locale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Locale"
                        },
                        {
                            "name": "maxLines",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.int"
                        },
                        {
                            "name": "strutStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.StrutStyle"
                        },
                        {
                            "name": "text",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.TextSpan"
                        },
                        {
                            "name": "textAlign",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TextAlign"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TextDirection"
                        },
                        {
                            "name": "textScaleFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the distance from the top of the text to the first baseline of the\ngiven type.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">double computeDistanceToActualBaseline(TextBaseline baseline) {\n  assert(!_needsLayout);\n  assert(baseline != null);\n  switch (baseline) {\n    case TextBaseline.alphabetic:\n      return _paragraph.alphabeticBaseline;\n    case TextBaseline.ideographic:\n      return _paragraph.ideographicBaseline;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/computeDistanceToActualBaseline.html",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "name": "computeDistanceToActualBaseline",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "baseline",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextBaseline"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a list of rects that bound the given selection.<\/p>\n<p>A given selection might have more than one rect if this text painter\ncontains bidirectional text because logically contiguous text might not be\nvisually contiguous.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">List&lt;TextBox&gt; getBoxesForSelection(TextSelection selection) {\n  assert(!_needsLayout);\n  return _paragraph.getBoxesForRange(selection.start, selection.end);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/getBoxesForSelection.html",
                    "isDeprecated": false,
                    "type": "dart:core.List<dart:ui.TextBox>",
                    "name": "getBoxesForSelection",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "selection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "services.TextSelection"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the closest offset after <code>offset<\/code> at which the input cursor can be\npositioned.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">int getOffsetAfter(int offset) {\n  final int nextCodeUnit = _text.codeUnitAt(offset);\n  if (nextCodeUnit == null)\n    return null;\n  \/\/ TODO(goderbauer): doesn't handle extended grapheme clusters with more than one Unicode scalar value (https:\/\/github.com\/flutter\/flutter\/issues\/13404).\n  return _isUtf16Surrogate(nextCodeUnit) ? offset + 2 : offset + 1;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/getOffsetAfter.html",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "name": "getOffsetAfter",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "offset",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the closest offset before <code>offset<\/code> at which the input cursor can\nbe positioned.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">int getOffsetBefore(int offset) {\n  final int prevCodeUnit = _text.codeUnitAt(offset - 1);\n  if (prevCodeUnit == null)\n    return null;\n  \/\/ TODO(goderbauer): doesn't handle extended grapheme clusters with more than one Unicode scalar value (https:\/\/github.com\/flutter\/flutter\/issues\/13404).\n  return _isUtf16Surrogate(prevCodeUnit) ? offset - 2 : offset - 1;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/getOffsetBefore.html",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "name": "getOffsetBefore",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "offset",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the offset at which to paint the caret.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">Offset getOffsetForCaret(TextPosition position, Rect caretPrototype) {\n  assert(!_needsLayout);\n  final int offset = position.offset;\n  assert(position.affinity != null);\n  switch (position.affinity) {\n    case TextAffinity.upstream:\n      return _getOffsetFromUpstream(offset, caretPrototype)\n          ?? _getOffsetFromDownstream(offset, caretPrototype)\n          ?? _emptyOffset;\n    case TextAffinity.downstream:\n      return _getOffsetFromDownstream(offset, caretPrototype)\n          ?? _getOffsetFromUpstream(offset, caretPrototype)\n          ?? _emptyOffset;\n  }\n  return null;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/getOffsetForCaret.html",
                    "isDeprecated": false,
                    "type": "dart:ui.Offset",
                    "name": "getOffsetForCaret",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "caretPrototype",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Rect"
                        },
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextPosition"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the position within the text for the given pixel offset.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextPosition getPositionForOffset(Offset offset) {\n  assert(!_needsLayout);\n  return _paragraph.getPositionForOffset(offset);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/getPositionForOffset.html",
                    "isDeprecated": false,
                    "type": "dart:ui.TextPosition",
                    "name": "getPositionForOffset",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "offset",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the text range of the word at the given offset. Characters not\npart of a word, such as spaces, symbols, and punctuation, have word breaks\non both sides. In such cases, this method will return a text range that\ncontains the given text position.<\/p>\n<p>Word boundaries are defined more precisely in Unicode Standard Annex #29\n<a href=\"http:\/\/www.unicode.org\/reports\/tr29\/#Word_Boundaries\">www.unicode.org\/reports\/tr29\/#Word_Boundaries<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextRange getWordBoundary(TextPosition position) {\n  assert(!_needsLayout);\n  final List&lt;int&gt; indices = _paragraph.getWordBoundary(position.offset);\n  return TextRange(start: indices[0], end: indices[1]);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/getWordBoundary.html",
                    "isDeprecated": false,
                    "type": "services.TextRange",
                    "name": "getWordBoundary",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextPosition"
                        }
                    ]
                },
                {
                    "desc": "<p>Computes the visual position of the glyphs for painting the text.<\/p>\n<p>The text will layout with a width that's as close to its max intrinsic\nwidth as possible while still being greater than or equal to <code>minWidth<\/code> and\nless than or equal to <code>maxWidth<\/code>.<\/p>\n<p>The <a href=\"painting\/TextPainter\/text.html\">text<\/a> and <a href=\"painting\/TextPainter\/textDirection.html\">textDirection<\/a> properties must be non-null before this is\ncalled.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void layout({ double minWidth = 0.0, double maxWidth = double.infinity }) {\n  assert(text != null, 'TextPainter.text must be set to a non-null value before using the TextPainter.');\n  assert(textDirection != null, 'TextPainter.textDirection must be set to a non-null value before using the TextPainter.');\n  if (!_needsLayout &amp;&amp; minWidth == _lastMinWidth &amp;&amp; maxWidth == _lastMaxWidth)\n    return;\n  _needsLayout = false;\n  if (_paragraph == null) {\n    final ui.ParagraphBuilder builder = ui.ParagraphBuilder(_createParagraphStyle());\n    _text.build(builder, textScaleFactor: textScaleFactor);\n    _paragraph = builder.build();\n  }\n  _lastMinWidth = minWidth;\n  _lastMaxWidth = maxWidth;\n  _paragraph.layout(ui.ParagraphConstraints(width: maxWidth));\n  if (minWidth != maxWidth) {\n    final double newWidth = maxIntrinsicWidth.clamp(minWidth, maxWidth);\n    if (newWidth != width)\n      _paragraph.layout(ui.ParagraphConstraints(width: newWidth));\n  }\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/layout.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "layout",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "maxWidth",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "minWidth",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Paints the text onto the given canvas at the given offset.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n<p>If you cannot see the text being painted, check that your text color does\nnot conflict with the background on which you are drawing. The default\ntext color is white (to contrast with the default black background color),\nso if you are writing an application with a white background, the text\nwill not be visible by default.<\/p>\n<p>To set the text style, specify a <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> when creating the <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>\nthat you pass to the <a href=\"painting\/TextPainter-class.html\">TextPainter<\/a> constructor or to the <a href=\"painting\/TextPainter\/text.html\">text<\/a> property.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void paint(Canvas canvas, Offset offset) {\n  assert(() {\n    if (_needsLayout) {\n      throw FlutterError(\n        'TextPainter.paint called when text geometry was not yet calculated.\\n'\n        'Please call layout() before paint() to position the text before painting it.'\n      );\n    }\n    return true;\n  }());\n  canvas.drawParagraph(_paragraph, offset);\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextPainter\/paint.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "paint",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextPainter",
                    "params": [
                        {
                            "name": "canvas",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Canvas"
                        },
                        {
                            "name": "offset",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Offset"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Whether any text was truncated or ellipsized.<\/p>\n<p>If <a href=\"painting\/TextPainter\/maxLines.html\">maxLines<\/a> is not null, this is true if there were more lines to be\ndrawn than the given <a href=\"painting\/TextPainter\/maxLines.html\">maxLines<\/a>, and thus at least one line was omitted in\nthe output; otherwise it is false.<\/p>\n<p>If <a href=\"painting\/TextPainter\/maxLines.html\">maxLines<\/a> is null, this is true if <a href=\"painting\/TextPainter\/ellipsis.html\">ellipsis<\/a> is not the empty string\nand there was a line that overflowed the <code>maxWidth<\/code> argument passed to\n<a href=\"painting\/TextPainter\/layout.html\">layout<\/a>; otherwise it is false.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">bool get didExceedMaxLines {\n  assert(!_needsLayout);\n  return _paragraph.didExceedMaxLines;\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/didExceedMaxLines.html",
                    "name": "didExceedMaxLines",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The string used to ellipsize overflowing text. Setting this to a non-empty\nstring will cause this string to be substituted for the remaining text\nif the text can not fit within the specified maximum width.<\/p>\n<p>Specifically, the ellipsis is applied to the last line before the line\ntruncated by <a href=\"painting\/TextPainter\/maxLines.html\">maxLines<\/a>, if <a href=\"painting\/TextPainter\/maxLines.html\">maxLines<\/a> is non-null and that line overflows\nthe width constraint, or to the first line that is wider than the width\nconstraint, if <a href=\"painting\/TextPainter\/maxLines.html\">maxLines<\/a> is null. The width constraint is the <code>maxWidth<\/code>\npassed to <a href=\"painting\/TextPainter\/layout.html\">layout<\/a>.<\/p>\n<p>After this is set, you must call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> before the next call to <a href=\"painting\/TextPainter\/paint.html\">paint<\/a>.<\/p>\n<p>The higher layers of the system, such as the <a href=\"widgets\/Text-class.html\">Text<\/a> widget, represent\noverflow effects using the <a href=\"rendering\/TextOverflow-class.html\">TextOverflow<\/a> enum. The\n<a href=\"painting\/TextPainter\/ellipsis.html\">TextOverflow.ellipsis<\/a> value corresponds to setting this property to\nU+2026 HORIZONTAL ELLIPSIS (\u2026).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">String get ellipsis =&gt; _ellipsis;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/ellipsis.html",
                    "name": "ellipsis",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The vertical space required to paint this text.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get height {\n  assert(!_needsLayout);\n  return _applyFloatingPointHack(_paragraph.height);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/height.html",
                    "name": "height",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The locale used to select region-specific glyphs.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Locale get locale =&gt; _locale;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/locale.html",
                    "name": "locale",
                    "isDeprecated": false,
                    "type": "dart:ui.Locale",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The width at which increasing the width of the text no longer decreases the height.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get maxIntrinsicWidth {\n  assert(!_needsLayout);\n  return _applyFloatingPointHack(_paragraph.maxIntrinsicWidth);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/maxIntrinsicWidth.html",
                    "name": "maxIntrinsicWidth",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>An optional maximum number of lines for the text to span, wrapping if\nnecessary.<\/p>\n<p>If the text exceeds the given number of lines, it is truncated such that\nsubsequent lines are dropped.<\/p>\n<p>After this is set, you must call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> before the next call to <a href=\"painting\/TextPainter\/paint.html\">paint<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">int get maxLines =&gt; _maxLines;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/maxLines.html",
                    "name": "maxLines",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The width at which decreasing the width of the text would prevent it from\npainting itself completely within its bounds.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get minIntrinsicWidth {\n  assert(!_needsLayout);\n  return _applyFloatingPointHack(_paragraph.minIntrinsicWidth);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/minIntrinsicWidth.html",
                    "name": "minIntrinsicWidth",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The height of a space in <a href=\"painting\/TextPainter\/text.html\">text<\/a> in logical pixels.<\/p>\n<p>Not every line of text in <a href=\"painting\/TextPainter\/text.html\">text<\/a> will have this height, but this height\nis \"typical\" for text in <a href=\"painting\/TextPainter\/text.html\">text<\/a> and useful for sizing other objects\nrelative a typical line of text.<\/p>\n<p>Obtaining this value does not require calling <a href=\"painting\/TextPainter\/layout.html\">layout<\/a>.<\/p>\n<p>The style of the <a href=\"painting\/TextPainter\/text.html\">text<\/a> property is used to determine the font settings\nthat contribute to the <a href=\"painting\/TextPainter\/preferredLineHeight.html\">preferredLineHeight<\/a>. If <a href=\"painting\/TextPainter\/text.html\">text<\/a> is null or if it\nspecifies no styles, the default <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> values are used (a 10 pixel\nsans-serif font).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get preferredLineHeight {\n  if (_layoutTemplate == null) {\n    final ui.ParagraphBuilder builder = ui.ParagraphBuilder(\n      _createParagraphStyle(TextDirection.rtl),\n    ); \/\/ direction doesn't matter, text is just a space\n    if (text?.style != null)\n      builder.pushStyle(text.style.getTextStyle(textScaleFactor: textScaleFactor));\n    builder.addText(' ');\n    _layoutTemplate = builder.build()\n      ..layout(const ui.ParagraphConstraints(width: double.infinity));\n  }\n  return _layoutTemplate.height;\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/preferredLineHeight.html",
                    "name": "preferredLineHeight",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The amount of space required to paint this text.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">Size get size {\n  assert(!_needsLayout);\n  return Size(width, height);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/size.html",
                    "name": "size",
                    "isDeprecated": false,
                    "type": "dart:ui.Size",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The strut style to use. Strut style defines the strut, which sets minimum\nvertical layout metrics.<\/p>\n<p>Omitting or providing null will disable strut.<\/p>\n<p>Omitting or providing null for any properties of <a href=\"painting\/StrutStyle-class.html\">StrutStyle<\/a> will result in\ndefault values being used. It is highly recommended to at least specify a\n<code>fontSize<\/code>.<\/p>\n<p>See <a href=\"painting\/StrutStyle-class.html\">StrutStyle<\/a> for details.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">StrutStyle get strutStyle =&gt; _strutStyle;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/strutStyle.html",
                    "name": "strutStyle",
                    "isDeprecated": false,
                    "type": "painting.StrutStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The (potentially styled) text to paint.<\/p>\n<p>After this is set, you must call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> before the next call to <a href=\"painting\/TextPainter\/paint.html\">paint<\/a>.<\/p>\n<p>This and <a href=\"painting\/TextPainter\/textDirection.html\">textDirection<\/a> must be non-null before you call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">TextSpan get text =&gt; _text;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/text.html",
                    "name": "text",
                    "isDeprecated": false,
                    "type": "painting.TextSpan",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>How the text should be aligned horizontally.<\/p>\n<p>After this is set, you must call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> before the next call to <a href=\"painting\/TextPainter\/paint.html\">paint<\/a>.<\/p>\n<p>The <a href=\"painting\/TextPainter\/textAlign.html\">textAlign<\/a> property must not be null. It defaults to <a href=\"dart-ui\/TextAlign-class.html\">TextAlign.start<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">TextAlign get textAlign =&gt; _textAlign;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/textAlign.html",
                    "name": "textAlign",
                    "isDeprecated": false,
                    "type": "dart:ui.TextAlign",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The default directionality of the text.<\/p>\n<p>This controls how the <a href=\"dart-ui\/TextAlign-class.html\">TextAlign.start<\/a>, <a href=\"dart-ui\/TextAlign-class.html\">TextAlign.end<\/a>, and\n<a href=\"dart-ui\/TextAlign-class.html\">TextAlign.justify<\/a> values of <a href=\"painting\/TextPainter\/textAlign.html\">textAlign<\/a> are resolved.<\/p>\n<p>This is also used to disambiguate how to render bidirectional text. For\nexample, if the <a href=\"painting\/TextPainter\/text.html\">text<\/a> is an English phrase followed by a Hebrew phrase,\nin a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.ltr<\/a> context the English phrase will be on the left\nand the Hebrew phrase to its right, while in a <a href=\"dart-ui\/TextDirection-class.html\">TextDirection.rtl<\/a>\ncontext, the English phrase will be on the right and the Hebrew phrase on\nits left.<\/p>\n<p>After this is set, you must call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> before the next call to <a href=\"painting\/TextPainter\/paint.html\">paint<\/a>.<\/p>\n<p>This and <a href=\"painting\/TextPainter\/text.html\">text<\/a> must be non-null before you call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">TextDirection get textDirection =&gt; _textDirection;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/textDirection.html",
                    "name": "textDirection",
                    "isDeprecated": false,
                    "type": "dart:ui.TextDirection",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The number of font pixels for each logical pixel.<\/p>\n<p>For example, if the text scale factor is 1.5, text will be 50% larger than\nthe specified font size.<\/p>\n<p>After this is set, you must call <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> before the next call to <a href=\"painting\/TextPainter\/paint.html\">paint<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get textScaleFactor =&gt; _textScaleFactor;<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/textScaleFactor.html",
                    "name": "textScaleFactor",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                },
                {
                    "desc": "<p>The horizontal space required to paint this text.<\/p>\n<p>Valid only after <a href=\"painting\/TextPainter\/layout.html\">layout<\/a> has been called.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">double get width {\n  assert(!_needsLayout);\n  return _applyFloatingPointHack(_paragraph.width);\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextPainter\/width.html",
                    "name": "width",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextPainter",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable span of text.<\/p>\n<p>A <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> object can be styled using its <a href=\"painting\/TextSpan\/style.html\">style<\/a> property.\nThe style will be applied to the <a href=\"painting\/TextSpan\/text.html\">text<\/a> and the <a href=\"painting\/TextSpan\/children.html\">children<\/a>.<\/p>\n<p>A <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> object can just have plain text, or it can have\nchildren <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> objects with their own styles that (possibly\nonly partially) override the <a href=\"painting\/TextSpan\/style.html\">style<\/a> of this object. If a\n<a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> has both <a href=\"painting\/TextSpan\/text.html\">text<\/a> and <a href=\"painting\/TextSpan\/children.html\">children<\/a>, then the <a href=\"painting\/TextSpan\/text.html\">text<\/a> is\ntreated as if it was an unstyled <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> at the start of the\n<a href=\"painting\/TextSpan\/children.html\">children<\/a> list.<\/p>\n<p>To paint a <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> on a <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>, use a <a href=\"painting\/TextPainter-class.html\">TextPainter<\/a>. To display a text\nspan in a widget, use a <a href=\"widgets\/RichText-class.html\">RichText<\/a>. For text with a single style, consider\nusing the <a href=\"widgets\/Text-class.html\">Text<\/a> widget.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe text \"Hello world!\", in black:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">TextSpan(\n  text: 'Hello world!',\n  style: TextStyle(color: Colors.black),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p><em>There is some more detailed sample code in the documentation for the\n<a href=\"painting\/TextSpan\/recognizer.html\">recognizer<\/a> property.<\/em><\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/Text-class.html\">Text<\/a>, a widget for showing uniformly-styled text.<\/li>\n<li>\n<a href=\"widgets\/RichText-class.html\">RichText<\/a>, a widget for finer control of text rendering.<\/li>\n<li>\n<a href=\"painting\/TextPainter-class.html\">TextPainter<\/a>, a class for painting <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> objects on a <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/TextSpan-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.TextSpan",
            "shortname": "TextSpan",
            "extends": [
                "foundation.DiagnosticableTree",
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> with the given values.<\/p>\n<p>For the object to be useful, at least one of <code>text<\/code> or\n<code>children<\/code> should be set.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const TextSpan({\n  this.style,\n  this.text,\n  this.children,\n  this.recognizer,\n});<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/TextSpan.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TextSpan",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "children",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<painting.TextSpan>"
                        },
                        {
                            "name": "recognizer",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "gestures.GestureRecognizer"
                        },
                        {
                            "name": "style",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "painting.TextStyle"
                        },
                        {
                            "name": "text",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        }
                    ]
                },
                {
                    "desc": "<p>Apply the <a href=\"painting\/TextSpan\/style.html\">style<\/a>, <a href=\"painting\/TextSpan\/text.html\">text<\/a>, and <a href=\"painting\/TextSpan\/children.html\">children<\/a> of this object to the\ngiven <a href=\"dart-ui\/ParagraphBuilder-class.html\">ParagraphBuilder<\/a>, from which a <a href=\"dart-ui\/Paragraph-class.html\">Paragraph<\/a> can be obtained.\n<a href=\"dart-ui\/Paragraph-class.html\">Paragraph<\/a> objects can be drawn on <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a> objects.<\/p>\n<p>Rather than using this directly, it's simpler to use the\n<a href=\"painting\/TextPainter-class.html\">TextPainter<\/a> class to paint <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> objects onto <a href=\"dart-ui\/Canvas-class.html\">Canvas<\/a>\nobjects.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">void build(ui.ParagraphBuilder builder, { double textScaleFactor = 1.0 }) {\n  assert(debugAssertIsValid());\n  final bool hasStyle = style != null;\n  if (hasStyle)\n    builder.pushStyle(style.getTextStyle(textScaleFactor: textScaleFactor));\n  if (text != null)\n    builder.addText(text);\n  if (children != null) {\n    for (TextSpan child in children) {\n      assert(child != null);\n      child.build(builder, textScaleFactor: textScaleFactor);\n    }\n  }\n  if (hasStyle)\n    builder.pop();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/build.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "build",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "builder",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.ParagraphBuilder"
                        },
                        {
                            "name": "textScaleFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the UTF-16 code unit at the given index in the flattened string.<\/p>\n<p>Returns null if the index is out of bounds.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">int codeUnitAt(int index) {\n  if (index &lt; 0)\n    return null;\n  int offset = 0;\n  int result;\n  visitTextSpan((TextSpan span) {\n    if (index - offset &lt; span.text.length) {\n      result = span.text.codeUnitAt(index - offset);\n      return false;\n    }\n    offset += span.text.length;\n    return true;\n  });\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/codeUnitAt.html",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "name": "codeUnitAt",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "index",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        }
                    ]
                },
                {
                    "desc": "<p>Describe the difference between this text span and another, in terms of\nhow much damage it will make to the rendering. The comparison is deep.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/TextSpan\/compareTo.html\">TextStyle.compareTo<\/a>, which does the same thing for <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>s.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RenderComparison compareTo(TextSpan other) {\n  if (identical(this, other))\n    return RenderComparison.identical;\n  if (other.text != text ||\n      children?.length != other.children?.length ||\n      (style == null) != (other.style == null))\n    return RenderComparison.layout;\n  RenderComparison result = recognizer == other.recognizer ? RenderComparison.identical : RenderComparison.metadata;\n  if (style != null) {\n    final RenderComparison candidate = style.compareTo(other.style);\n    if (candidate.index &gt; result.index)\n      result = candidate;\n    if (result == RenderComparison.layout)\n      return result;\n  }\n  if (children != null) {\n    for (int index = 0; index &lt; children.length; index += 1) {\n      final RenderComparison candidate = children[index].compareTo(other.children[index]);\n      if (candidate.index &gt; result.index)\n        result = candidate;\n      if (result == RenderComparison.layout)\n        return result;\n    }\n  }\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/compareTo.html",
                    "isDeprecated": false,
                    "type": "painting.RenderComparison",
                    "name": "compareTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextSpan"
                        }
                    ]
                },
                {
                    "desc": "<p>In checked mode, throws an exception if the object is not in a\nvalid configuration. Otherwise, returns true.<\/p>\n<p>This is intended to be used as follows:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">assert(myTextSpan.debugAssertIsValid());\n<\/code><\/pre>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool debugAssertIsValid() {\n  assert(() {\n    if (!visitTextSpan((TextSpan span) {\n      if (span.children != null) {\n        for (TextSpan child in span.children) {\n          if (child == null)\n            return false;\n        }\n      }\n      return true;\n    })) {\n      throw FlutterError(\n        'TextSpan contains a null child.\\n'\n        'A TextSpan object with a non-null child list should not have any nulls in its child list.\\n'\n        'The full text in question was:\\n'\n        '${toStringDeep(prefixLineOne: '  ')}'\n      );\n    }\n    return true;\n  }());\n  return true;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/debugAssertIsValid.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "debugAssertIsValid",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>Returns a list of <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> objects describing this node's\nchildren.<\/p>\n<p>Children that are offstage should be added with <code>style<\/code> set to\n<a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle.offstage<\/a> to indicate that they are offstage.<\/p>\n<p>The list must not contain any null entries. If there are explicit null\nchildren to report, consider <a href=\"foundation\/DiagnosticsNode\/DiagnosticsNode.message.html\">new DiagnosticsNode.message<\/a> or\n<a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty&lt;Object&gt;<\/a> as possible <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> objects to\nprovide.<\/p>\n<p>Used by <a href=\"foundation\/DiagnosticableTree\/toStringDeep.html\">toStringDeep<\/a>, <a href=\"foundation\/DiagnosticableTree\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/DiagnosticableTree\/toStringShallow.html\">toStringShallow<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/TextSpan\/debugDescribeChildren.html\">RenderTable.debugDescribeChildren<\/a>, which provides high quality custom\ndescriptions for its child nodes.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nList&lt;DiagnosticsNode&gt; debugDescribeChildren() {\n  if (children == null)\n    return const &lt;DiagnosticsNode&gt;[];\n  return children.map&lt;DiagnosticsNode&gt;((TextSpan child) {\n    if (child != null) {\n      return child.toDiagnosticsNode();\n    } else {\n      return DiagnosticsNode.message('&lt;null child&gt;');\n    }\n  }).toList();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/debugDescribeChildren.html",
                    "isDeprecated": false,
                    "type": "dart:core.List<foundation.DiagnosticsNode>",
                    "name": "debugDescribeChildren",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>Add additional properties associated with the node.<\/p>\n<p>Use the most specific <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> existing subclass to describe\neach property instead of the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> base class. There are\nonly a small number of <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses each covering a\ncommon use case. Consider what values a property is relevant for users\ndebugging as users debugging large trees are overloaded with information.\nCommon named parameters in <a href=\"foundation\/DiagnosticsNode-class.html\">DiagnosticsNode<\/a> subclasses help filter when\nand how properties are displayed.<\/p>\n<p><code>defaultValue<\/code>, <code>showName<\/code>, <code>showSeparator<\/code>, and <code>level<\/code> keep string\nrepresentations of diagnostics terse and hide properties when they are not\nvery useful.<\/p>\n<ul>\n<li>Use <code>defaultValue<\/code> any time the default value of a property is\nuninteresting. For example, specify a default value of null any time\na property being null does not indicate an error.<\/li>\n<li>Avoid specifying the <code>level<\/code> parameter unless the result you want\ncannot be achieved by using the <code>defaultValue<\/code> parameter or using\nthe <a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a> class to conditionally display the property\nas a flag.<\/li>\n<li>Specify <code>showName<\/code> and <code>showSeparator<\/code> in rare cases where the string\noutput would look clumsy if they were not set.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;Object&gt;('child(3, 4)', null, ifNull: 'is null', showSeparator: false).toString()\n<\/code><\/pre>Shows using <code>showSeparator<\/code> to get output <code>child(3, 4) is null<\/code> which\nis more polished than <code>child(3, 4): is null<\/code>.\n<pre class=\"language-dart\"><code class=\"language-dart\">DiagnosticsProperty&lt;IconData&gt;('icon', icon, ifNull: '&lt;empty&gt;', showName: false)).toString()\n<\/code><\/pre>Shows using <code>showName<\/code> to omit the property name as in this context the\nproperty name does not add useful information.<\/li>\n<\/ul>\n<p><code>ifNull<\/code>, <code>ifEmpty<\/code>, <code>unit<\/code>, and <code>tooltip<\/code> make property\ndescriptions clearer. The examples in the code sample below illustrate\ngood uses of all of these parameters.<\/p>\n<h2 id=\"diagnosticsproperty-subclasses-for-primitive-types\">DiagnosticsProperty subclasses for primitive types<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/StringProperty-class.html\">StringProperty<\/a>, which supports automatically enclosing a <a href=\"dart-core\/String-class.html\">String<\/a>\nvalue in quotes.<\/li>\n<li>\n<a href=\"foundation\/DoubleProperty-class.html\">DoubleProperty<\/a>, which supports specifying a unit of measurement for\na <a href=\"dart-core\/double-class.html\">double<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/PercentProperty-class.html\">PercentProperty<\/a>, which clamps a <a href=\"dart-core\/double-class.html\">double<\/a> to between 0 and 1 and\nformats it as a percentage.<\/li>\n<li>\n<a href=\"foundation\/IntProperty-class.html\">IntProperty<\/a>, which supports specifying a unit of measurement for an\n<a href=\"dart-core\/int-class.html\">int<\/a> value.<\/li>\n<li>\n<a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a>, which formats a <a href=\"dart-core\/bool-class.html\">bool<\/a> value as one or more flags.\nDepending on the use case it is better to format a bool as\n<code>DiagnosticsProperty&lt;bool&gt;<\/code> instead of using <a href=\"foundation\/FlagProperty-class.html\">FlagProperty<\/a> as the\noutput is more verbose but unambiguous.<\/li>\n<\/ul>\n<h2 id=\"other-important-diagnosticsproperty-variants\">Other important <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> variants<\/h2>\n<ul>\n<li>\n<a href=\"foundation\/EnumProperty-class.html\">EnumProperty<\/a>, which provides terse descriptions of enum values\nworking around limitations of the <code>toString<\/code> implementation for Dart\nenum types.<\/li>\n<li>\n<a href=\"foundation\/IterableProperty-class.html\">IterableProperty<\/a>, which handles iterable values with display\ncustomizable depending on the <a href=\"foundation\/DiagnosticsTreeStyle-class.html\">DiagnosticsTreeStyle<\/a> used.<\/li>\n<li>\n<a href=\"foundation\/ObjectFlagProperty-class.html\">ObjectFlagProperty<\/a>, which provides terse descriptions of whether a\nproperty value is present or not. For example, whether an <code>onClick<\/code>\ncallback is specified or an animation is in progress.<\/li>\n<\/ul>\n<p>If none of these subclasses apply, use the <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nconstructor or in rare cases create your own <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\nsubclass as in the case for <a href=\"painting\/TransformProperty-class.html\">TransformProperty<\/a> which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a>\nthat represent transforms. Generally any property value with a good\n<code>toString<\/code> method implementation works fine using <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a>\ndirectly.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows best practices for implementing <a href=\"painting\/TextSpan\/debugFillProperties.html\">debugFillProperties<\/a>\nillustrating use of all common <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> subclasses and all\ncommon <a href=\"foundation\/DiagnosticsProperty-class.html\">DiagnosticsProperty<\/a> parameters.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class ExampleObject extends ExampleSuperclass {\n\n  \/\/ ...various members and properties...\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    \/\/ Always add properties from the base class first.\n    super.debugFillProperties(properties);\n\n    \/\/ Omit the property name 'message' when displaying this String property\n    \/\/ as it would just add visual noise.\n    properties.add(StringProperty('message', message, showName: false));\n\n    properties.add(DoubleProperty('stepWidth', stepWidth));\n\n    \/\/ A scale of 1.0 does nothing so should be hidden.\n    properties.add(DoubleProperty('scale', scale, defaultValue: 1.0));\n\n    \/\/ If the hitTestExtent matches the paintExtent, it is just set to its\n    \/\/ default value so is not relevant.\n    properties.add(DoubleProperty('hitTestExtent', hitTestExtent, defaultValue: paintExtent));\n\n    \/\/ maxWidth of double.infinity indicates the width is unconstrained and\n    \/\/ so maxWidth has no impact.,\n    properties.add(DoubleProperty('maxWidth', maxWidth, defaultValue: double.infinity));\n\n    \/\/ Progress is a value between 0 and 1 or null. Showing it as a\n    \/\/ percentage makes the meaning clear enough that the name can be\n    \/\/ hidden.\n    properties.add(PercentProperty(\n      'progress',\n      progress,\n      showName: false,\n      ifNull: '&lt;indeterminate&gt;',\n    ));\n\n    \/\/ Most text fields have maxLines set to 1.\n    properties.add(IntProperty('maxLines', maxLines, defaultValue: 1));\n\n    \/\/ Specify the unit as otherwise it would be unclear that time is in\n    \/\/ milliseconds.\n    properties.add(IntProperty('duration', duration.inMilliseconds, unit: 'ms'));\n\n    \/\/ Tooltip is used instead of unit for this case as a unit should be a\n    \/\/ terse description appropriate to display directly after a number\n    \/\/ without a space.\n    properties.add(DoubleProperty(\n      'device pixel ratio',\n      ui.window.devicePixelRatio,\n      tooltip: 'physical pixels per logical pixel',\n    ));\n\n    \/\/ Displaying the depth value would be distracting. Instead only display\n    \/\/ if the depth value is missing.\n    properties.add(ObjectFlagProperty&lt;int&gt;('depth', depth, ifNull: 'no depth'));\n\n    \/\/ bool flag that is only shown when the value is true.\n    properties.add(FlagProperty('using primary controller', value: primary));\n\n    properties.add(FlagProperty(\n      'isCurrent',\n      value: isCurrent,\n      ifTrue: 'active',\n      ifFalse: 'inactive',\n      showName: false,\n    ));\n\n    properties.add(DiagnosticsProperty&lt;bool&gt;('keepAlive', keepAlive));\n\n    \/\/ FlagProperty could have also been used in this case.\n    \/\/ This option results in the text \"obscureText: true\" instead\n    \/\/ of \"obscureText\" which is a bit more verbose but a bit clearer.\n    properties.add(DiagnosticsProperty&lt;bool&gt;('obscureText', obscureText, defaultValue: false));\n\n    properties.add(EnumProperty&lt;TextAlign&gt;('textAlign', textAlign, defaultValue: null));\n    properties.add(EnumProperty&lt;ImageRepeat&gt;('repeat', repeat, defaultValue: ImageRepeat.noRepeat));\n\n    \/\/ Warn users when the widget is missing but do not show the value.\n    properties.add(ObjectFlagProperty&lt;Widget&gt;('widget', widget, ifNull: 'no widget'));\n\n    properties.add(IterableProperty&lt;BoxShadow&gt;(\n      'boxShadow',\n      boxShadow,\n      defaultValue: null,\n      style: style,\n    ));\n\n    \/\/ Getting the value of size throws an exception unless hasSize is true.\n    properties.add(DiagnosticsProperty&lt;Size&gt;.lazy(\n      'size',\n      () =&gt; size,\n      description: '${ hasSize ? size : \"MISSING\" }',\n    ));\n\n    \/\/ If the `toString` method for the property value does not provide a\n    \/\/ good terse description, write a DiagnosticsProperty subclass as in\n    \/\/ the case of TransformProperty which displays a nice debugging view\n    \/\/ of a Matrix4 that represents a transform.\n    properties.add(TransformProperty('transform', transform));\n\n    \/\/ If the value class has a good `toString` method, use\n    \/\/ DiagnosticsProperty&lt;YourValueType&gt;. Specifying the value type ensures\n    \/\/ that debugging tools always know the type of the field and so can\n    \/\/ provide the right UI affordances. For example, in this case even\n    \/\/ if color is null, a debugging tool still knows the value is a Color\n    \/\/ and can display relevant color related UI.\n    properties.add(DiagnosticsProperty&lt;Color&gt;('color', color));\n\n    \/\/ Use a custom description to generate a more terse summary than the\n    \/\/ `toString` method on the map class.\n    properties.add(DiagnosticsProperty&lt;Map&lt;Listenable, VoidCallback&gt;&gt;(\n      'handles',\n      handles,\n      description: handles != null ?\n      '${handles.length} active client${ handles.length == 1 ? \"\" : \"s\" }' :\n      null,\n      ifNull: 'no notifications ever received',\n      showName: false,\n    ));\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>Used by <a href=\"foundation\/DiagnosticableTree\/toDiagnosticsNode.html\">toDiagnosticsNode<\/a> and <a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n  super.debugFillProperties(properties);\n  properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.whitespace;\n  \/\/ Properties on style are added as if they were properties directly on\n  \/\/ this TextSpan.\n  if (style != null)\n    style.debugFillProperties(properties);\n\n  properties.add(DiagnosticsProperty&lt;GestureRecognizer&gt;(\n    'recognizer', recognizer,\n    description: recognizer?.runtimeType?.toString(),\n    defaultValue: null,\n  ));\n\n  properties.add(StringProperty('text', text, showName: false, defaultValue: null));\n  if (style == null &amp;&amp; text == null &amp;&amp; children == null)\n    properties.add(DiagnosticsNode.message('(empty)'));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns the text span that contains the given position in the text.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextSpan getSpanForPosition(TextPosition position) {\n  assert(debugAssertIsValid());\n  final TextAffinity affinity = position.affinity;\n  final int targetOffset = position.offset;\n  int offset = 0;\n  TextSpan result;\n  visitTextSpan((TextSpan span) {\n    assert(result == null);\n    final int endOffset = offset + span.text.length;\n    if (targetOffset == offset &amp;&amp; affinity == TextAffinity.downstream ||\n        targetOffset &gt; offset &amp;&amp; targetOffset &lt; endOffset ||\n        targetOffset == endOffset &amp;&amp; affinity == TextAffinity.upstream) {\n      result = span;\n      return false;\n    }\n    offset = endOffset;\n    return true;\n  });\n  return result;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/getSpanForPosition.html",
                    "isDeprecated": false,
                    "type": "painting.TextSpan",
                    "name": "getSpanForPosition",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "position",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextPosition"
                        }
                    ]
                },
                {
                    "desc": "<p>Flattens the <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> tree into a single string.<\/p>\n<p>Styles are not honored in this process.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">String toPlainText() {\n  assert(debugAssertIsValid());\n  final StringBuffer buffer = StringBuffer();\n  visitTextSpan((TextSpan span) {\n    buffer.write(span.text);\n    return true;\n  });\n  return buffer.toString();\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/toPlainText.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toPlainText",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>A brief description of this object, usually just the <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and the\n<a href=\"painting\/TextSpan\/hashCode.html\">hashCode<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>, for a detailed description of the object.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toStringShort() =&gt; '$runtimeType';<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/toStringShort.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toStringShort",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>Walks this text span and its descendants in pre-order and calls <code>visitor<\/code>\nfor each span that has text.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">bool visitTextSpan(bool visitor(TextSpan span)) {\n  if (text != null) {\n    if (!visitor(this))\n      return false;\n  }\n  if (children != null) {\n    for (TextSpan child in children) {\n      if (!child.visitTextSpan(visitor))\n        return false;\n    }\n  }\n  return true;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextSpan\/visitTextSpan.html",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "name": "visitTextSpan",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextSpan",
                    "params": [
                        {
                            "name": "span",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextSpan"
                        }
                    ]
                }
            ],
            "props": [
                {
                    "desc": "<p>Additional spans to include as children.<\/p>\n<p>If both <a href=\"painting\/TextSpan\/text.html\">text<\/a> and <a href=\"painting\/TextSpan\/children.html\">children<\/a> are non-null, the text will precede the\nchildren.<\/p>\n<p>Modifying the list after the <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> has been created is not\nsupported and may have unexpected results.<\/p>\n<p>The list must not contain any nulls.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final List&lt;TextSpan&gt; children\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextSpan\/children.html",
                    "name": "children",
                    "isDeprecated": false,
                    "type": "dart:core.List<painting.TextSpan>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/TextSpan\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/TextSpan\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/TextSpan\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/TextSpan\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/TextSpan\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/TextSpan\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode =&gt; hashValues(style, text, recognizer, hashList(children));<\/code><\/pre>\n        ",
                    "href": "painting\/TextSpan\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>A gesture recognizer that will receive events that hit this text span.<\/p>\n<p><a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> itself does not implement hit testing or event dispatch. The\nobject that manages the <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> painting is also responsible for\ndispatching events. In the rendering library, that is the\n<a href=\"rendering\/RenderParagraph-class.html\">RenderParagraph<\/a> object, which corresponds to the <a href=\"widgets\/RichText-class.html\">RichText<\/a> widget in\nthe widgets layer; these objects do not bubble events in <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>s, so a\n<a href=\"painting\/TextSpan\/recognizer.html\">recognizer<\/a> is only effective for events that directly hit the <a href=\"painting\/TextSpan\/text.html\">text<\/a> of\nthat <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>, not any of its <a href=\"painting\/TextSpan\/children.html\">children<\/a>.<\/p>\n<p><a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> also does not manage the lifetime of the gesture recognizer.\nThe code that owns the <a href=\"gestures\/GestureRecognizer-class.html\">GestureRecognizer<\/a> object must call\n<a href=\"gestures\/GestureRecognizer\/dispose.html\">GestureRecognizer.dispose<\/a> when the <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> object is no longer used.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThis example shows how to manage the lifetime of a gesture recognizer\nprovided to a <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> object. It defines a <code>BuzzingText<\/code> widget which\nuses the <a href=\"services\/HapticFeedback-class.html\">HapticFeedback<\/a> class to vibrate the device when the user\nlong-presses the \"find the\" span, which is underlined in wavy green. The\nhit-testing is handled by the <a href=\"widgets\/RichText-class.html\">RichText<\/a> widget.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">class BuzzingText extends StatefulWidget {\n  @override\n  _BuzzingTextState createState() =&gt; _BuzzingTextState();\n}\n\nclass _BuzzingTextState extends State&lt;BuzzingText&gt; {\n  LongPressGestureRecognizer _longPressRecognizer;\n\n  @override\n  void initState() {\n    super.initState();\n    _longPressRecognizer = LongPressGestureRecognizer()\n      ..onLongPress = _handlePress;\n  }\n\n  @override\n  void dispose() {\n    _longPressRecognizer.dispose();\n    super.dispose();\n  }\n\n  void _handlePress() {\n    HapticFeedback.vibrate();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return RichText(\n      text: TextSpan(\n        text: 'Can you ',\n        style: TextStyle(color: Colors.black),\n        children: &lt;TextSpan&gt;[\n          TextSpan(\n            text: 'find the',\n            style: TextStyle(\n              color: Colors.green,\n              decoration: TextDecoration.underline,\n              decorationStyle: TextDecorationStyle.wavy,\n            ),\n            recognizer: _longPressRecognizer,\n          ),\n          TextSpan(\n            text: ' secret?',\n          ),\n        ],\n      ),\n    );\n  }\n}<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final GestureRecognizer recognizer\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextSpan\/recognizer.html",
                    "name": "recognizer",
                    "isDeprecated": false,
                    "type": "gestures.GestureRecognizer",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>The style to apply to the <a href=\"painting\/TextSpan\/text.html\">text<\/a> and the <a href=\"painting\/TextSpan\/children.html\">children<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TextStyle style\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextSpan\/style.html",
                    "name": "style",
                    "isDeprecated": false,
                    "type": "painting.TextStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                },
                {
                    "desc": "<p>The text contained in the span.<\/p>\n<p>If both <a href=\"painting\/TextSpan\/text.html\">text<\/a> and <a href=\"painting\/TextSpan\/children.html\">children<\/a> are non-null, the text will precede the\nchildren.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String text\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextSpan\/text.html",
                    "name": "text",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextSpan",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>An immutable style in which paint text.<\/p>\n<h3 id=\"bold\">Bold<\/h3>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nHere, a single line of text in a <a href=\"widgets\/Text-class.html\">Text<\/a> widget is given a specific style\noverride. The style is mixed with the ambient <a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a> by the\n<a href=\"widgets\/Text-class.html\">Text<\/a> widget.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text(\n  'No, we need bold strokes. We need this plan.',\n  style: TextStyle(fontWeight: FontWeight.bold),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<h3 id=\"italics\">Italics<\/h3>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nAs in the previous example, the <a href=\"widgets\/Text-class.html\">Text<\/a> widget is given a specific style\noverride which is implicitly mixed with the ambient <a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a>.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text(\n  'Welcome to the present, we\\'re running a real nation.',\n  style: TextStyle(fontStyle: FontStyle.italic),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<h3 id=\"opacity-and-color\">Opacity and Color<\/h3>\n<p>Each line here is progressively more opaque. The base color is\n<a href=\"material\/Colors\/black-constant.html\">material.Colors.black<\/a>, and <a href=\"dart-ui\/Color\/withOpacity.html\">Color.withOpacity<\/a> is used to create a\nderivative color with the desired opacity. The root <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> for this\n<a href=\"widgets\/RichText-class.html\">RichText<\/a> widget is explicitly given the ambient <a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a>, since\n<a href=\"widgets\/RichText-class.html\">RichText<\/a> does not do that automatically. The inner <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> objects are\nimplicitly mixed with the parent <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>'s <a href=\"painting\/TextSpan\/style.html\">TextSpan.style<\/a>.<\/p>\n<p>If <a href=\"painting\/TextStyle\/color.html\">color<\/a> is specified, <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> must be null and vice versa. <a href=\"painting\/TextStyle\/color.html\">color<\/a> is\ntreated as a shorthand for <code>Paint()..color = color<\/code>.<\/p>\n<p>If <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> is specified, <a href=\"painting\/TextStyle\/background.html\">background<\/a> must be null and vice versa.\nThe <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> is treated as a shorthand for\n<code>background: Paint()..color = backgroundColor<\/code>.<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">RichText(\n  text: TextSpan(\n    style: DefaultTextStyle.of(context).style,\n    children: &lt;TextSpan&gt;[\n      TextSpan(\n        text: 'You don\\'t have the votes.\\n',\n        style: TextStyle(color: Colors.black.withOpacity(0.6)),\n      ),\n      TextSpan(\n        text: 'You don\\'t have the votes!\\n',\n        style: TextStyle(color: Colors.black.withOpacity(0.8)),\n      ),\n      TextSpan(\n        text: 'You\\'re gonna need congressional approval and you don\\'t have the votes!\\n',\n        style: TextStyle(color: Colors.black.withOpacity(1.0)),\n      ),\n    ],\n  ),\n)\n<\/code><\/pre>\n<h3 id=\"size\">Size<\/h3>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nIn this example, the ambient <a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a> is explicitly manipulated to\nobtain a <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> that doubles the default font size.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text(\n  'These are wise words, enterprising men quote \\'em.',\n  style: DefaultTextStyle.of(context).style.apply(fontSizeFactor: 2.0),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<h3 id=\"line-height\">Line height<\/h3>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nThe <a href=\"painting\/TextStyle\/height.html\">height<\/a> property can be used to change the line height. Here, the line\nheight is set to 5 times the font size, so that the text is very spaced out.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text(\n  'Don\\'t act surprised, you guys, cuz I wrote \\'em!',\n  style: TextStyle(height: 5.0),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<h3 id=\"wavy-red-underline-with-black-text\">Wavy red underline with black text<\/h3>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nStyles can be combined. In this example, the misspelt word is drawn in black\ntext and underlined with a wavy red line to indicate a spelling error. (The\nremainder is styled according to the Flutter default text styles, not the\nambient <a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a>, since no explicit style is given and <a href=\"widgets\/RichText-class.html\">RichText<\/a>\ndoes not automatically use the ambient <a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a>.)\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">RichText(\n  text: TextSpan(\n    text: 'Don\\'t tax the South ',\n    children: &lt;TextSpan&gt;[\n      TextSpan(\n        text: 'cuz',\n        style: TextStyle(\n          color: Colors.black,\n          decoration: TextDecoration.underline,\n          decorationColor: Colors.red,\n          decorationStyle: TextDecorationStyle.wavy,\n        ),\n      ),\n      TextSpan(\n        text: ' we got it made in the shade',\n      ),\n    ],\n  ),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<h3 id=\"custom-fonts\">Custom Fonts<\/h3>\n<p>Custom fonts can be declared in the <code>pubspec.yaml<\/code> file as shown below:<\/p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">flutter:\n  fonts:\n    - family: Raleway\n      fonts:\n        - asset: fonts\/Raleway-Regular.ttf\n        - asset: fonts\/Raleway-Medium.ttf\n          weight: 500\n        - asset: assets\/fonts\/Raleway-SemiBold.ttf\n          weight: 600\n     - family: Schyler\n       fonts:\n         - asset: fonts\/Schyler-Regular.ttf\n         - asset: fonts\/Schyler-Italic.ttf\n           style: italic\n<\/code><\/pre>\n<p>The <code>family<\/code> property determines the name of the font, which you can use in\nthe <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a> argument. The <code>asset<\/code> property is a path to the font file,\nrelative to the <code>pubspec.yaml<\/code> file. The <code>weight<\/code> property specifies the\nweight of the glyph outlines in the file as an integer multiple of 100\nbetween 100 and 900. This corresponds to the <a href=\"dart-ui\/FontWeight-class.html\">FontWeight<\/a> class and can be\nused in the <a href=\"painting\/TextStyle\/fontWeight.html\">fontWeight<\/a> argument. The <code>style<\/code> property specifies whether the\noutlines in the file are <code>italic<\/code> or <code>normal<\/code>. These values correspond to\nthe <a href=\"dart-ui\/FontStyle-class.html\">FontStyle<\/a> class and can be used in the <a href=\"painting\/TextStyle\/fontStyle.html\">fontStyle<\/a> argument.<\/p>\n<p>To select a custom font, create <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> using the <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a>\nargument as shown in the example below:<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const TextStyle(fontFamily: 'Raleway')<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>To use a font family defined in a package, the <code>package<\/code> argument must be\nprovided. For instance, suppose the font declaration above is in the\n<code>pubspec.yaml<\/code> of a package named <code>my_package<\/code> which the app depends on.\nThen creating the TextStyle is done as follows:<\/p>\n<pre class=\"language-dart\"><code class=\"language-dart\">const TextStyle(fontFamily: 'Raleway', package: 'my_package')\n<\/code><\/pre>\n<p>If the package internally uses the font it defines, it should still specify\nthe <code>package<\/code> argument when creating the text style as in the example above.<\/p>\n<p>A package can also provide font files without declaring a font in its\n<code>pubspec.yaml<\/code>. These files should then be in the <code>lib\/<\/code> folder of the\npackage. The font files will not automatically be bundled in the app, instead\nthe app can use these selectively when declaring a font. Suppose a package\nnamed <code>my_package<\/code> has:<\/p>\n<pre class=\"language-dart\"><code>lib\/fonts\/Raleway-Medium.ttf\n<\/code><\/pre>\n<p>Then the app can declare a font like in the example below:<\/p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">flutter:\n  fonts:\n    - family: Raleway\n      fonts:\n        - asset: assets\/fonts\/Raleway-Regular.ttf\n        - asset: packages\/my_package\/fonts\/Raleway-Medium.ttf\n          weight: 500\n<\/code><\/pre>\n<p>The <code>lib\/<\/code> is implied, so it should not be included in the asset path.<\/p>\n<p>In this case, since the app locally defines the font, the TextStyle is\ncreated without the <code>package<\/code> argument:<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const TextStyle(fontFamily: 'Raleway')<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<h3 id=\"custom-font-fallback\">Custom Font Fallback<\/h3>\n<p>A custom <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> list can be provided. The list should be an\nordered list of strings of font family names in the order they will be attempted.<\/p>\n<p>The fonts in <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> will be used only if the requested glyph is\nnot present in the <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a>.<\/p>\n<p>The fallback order is:<\/p>\n<ul>\n<li><a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a><\/li>\n<li>\n<a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> in order of first to last.<\/li>\n<\/ul>\n<p>The glyph used will always be the first matching version in fallback order.<\/p>\n<p>The <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> property is commonly used to specify different font\nfamilies for multilingual text spans as well as separate fonts for glyphs such\nas emojis.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nIn the following example, any glyphs not present in the font <code>Raleway<\/code> will be attempted\nto be resolved with <code>Noto Sans CJK SC<\/code>, and then with <code>Noto Color Emoji<\/code>:\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">const TextStyle(\n  fontFamily: 'Raleway',\n  fontFamilyFallback: &lt;String&gt;[\n    'Noto Sans CJK SC',\n    'Noto Color Emoji',\n  ],\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>If all custom fallback font families are exhausted and no match was found\nor no custom fallback was provided, the platform font fallback will be used.<\/p>\n<h3 id=\"inconsistent-platform-fonts\">Inconsistent platform fonts<\/h3>\n<p>Since Flutter's font discovery for default fonts depends on the fonts present\non the device, it is not safe to assume all default fonts will be available or\nconsistent across devices.<\/p>\n<p>A known example of this is that Samsung devices ship with a CJK font that has\nsmaller line spacing than the Android default. This results in Samsung devices\ndisplaying more tightly spaced text than on other Android devices when no\ncustom font is specified.<\/p>\n<p>To avoid this, a custom font should be specified if absolute font consistency\nis required for your application.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"widgets\/Text-class.html\">Text<\/a>, the widget for showing text in a single style.<\/li>\n<li>\n<a href=\"widgets\/DefaultTextStyle-class.html\">DefaultTextStyle<\/a>, the widget that specifies the default text styles for\n<a href=\"widgets\/Text-class.html\">Text<\/a> widgets, configured using a <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a>.<\/li>\n<li>\n<a href=\"widgets\/RichText-class.html\">RichText<\/a>, the widget for showing a paragraph of mix-style text.<\/li>\n<li>\n<a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>, the class that wraps a <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> for the purposes of\npassing it to a <a href=\"widgets\/RichText-class.html\">RichText<\/a>.<\/li>\n<li>\n<a href=\"https:\/\/api.flutter.dev\/flutter\/dart-ui\/TextStyle-class.html\">TextStyle<\/a>, the class in the <a href=\"dart-ui\/dart-ui-library.html\">dart:ui<\/a> library.<\/li>\n<\/ul>",
            "dtype": "class",
            "example": "",
            "href": "painting\/TextStyle-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.TextStyle",
            "shortname": "TextStyle",
            "extends": [
                "foundation.Diagnosticable",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [
                "widgets.TextStyleTween"
            ],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Creates a text style.<\/p>\n<p>The <code>package<\/code> argument must be non-null if the font family is defined in a\npackage. It is combined with the <code>fontFamily<\/code> argument to set the\n<code>fontFamily<\/code> property.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">const TextStyle({\n  this.inherit = true,\n  this.color,\n  this.backgroundColor,\n  this.fontSize,\n  this.fontWeight,\n  this.fontStyle,\n  this.letterSpacing,\n  this.wordSpacing,\n  this.textBaseline,\n  this.height,\n  this.locale,\n  this.foreground,\n  this.background,\n  this.shadows,\n  this.decoration,\n  this.decorationColor,\n  this.decorationStyle,\n  this.decorationThickness,\n  this.debugLabel,\n  String fontFamily,\n  List&lt;String&gt; fontFamilyFallback,\n  String package,\n}) : fontFamily = package == null ? fontFamily : 'packages\/$package\/$fontFamily',\n     _fontFamilyFallback = fontFamilyFallback,\n     _package = package,\n     assert(inherit != null),\n     assert(color == null || foreground == null, _kColorForegroundWarning),\n     assert(backgroundColor == null || background == null, _kColorBackgroundWarning);<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/TextStyle.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TextStyle",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "background",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Paint"
                        },
                        {
                            "name": "backgroundColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "debugLabel",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "decoration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TextDecoration"
                        },
                        {
                            "name": "decorationColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "decorationStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TextDecorationStyle"
                        },
                        {
                            "name": "decorationThickness",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontFamily",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontFamilyFallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:core.String>"
                        },
                        {
                            "name": "fontSize",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.FontStyle"
                        },
                        {
                            "name": "fontWeight",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.FontWeight"
                        },
                        {
                            "name": "foreground",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Paint"
                        },
                        {
                            "name": "height",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "inherit",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "letterSpacing",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "locale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.Locale"
                        },
                        {
                            "name": "package",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "shadows",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.List<dart:ui.Shadow>"
                        },
                        {
                            "name": "textBaseline",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:ui.TextBaseline"
                        },
                        {
                            "name": "wordSpacing",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this text style replacing or altering the specified\nproperties.<\/p>\n<p>The non-numeric properties <code>color<\/code>, <code>fontFamily<\/code>, <code>decoration<\/code>,\n<code>decorationColor<\/code> and <code>decorationStyle<\/code> are replaced with the new values.<\/p>\n<p><a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> will be given preference over <code>color<\/code> if it is not null and\n<a href=\"painting\/TextStyle\/background.html\">background<\/a> will be given preference over <code>backgroundColor<\/code> if it is not\nnull.<\/p>\n<p>The numeric properties are multiplied by the given factors and then\nincremented by the given deltas.<\/p>\n<p>For example, <code>style.apply(fontSizeFactor: 2.0, fontSizeDelta: 1.0)<\/code> would\nreturn a <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> whose <a href=\"painting\/TextStyle\/fontSize.html\">fontSize<\/a> is <code>style.fontSize * 2.0 + 1.0<\/code>.<\/p>\n<p>For the <a href=\"painting\/TextStyle\/fontWeight.html\">fontWeight<\/a>, the delta is applied to the <a href=\"dart-ui\/FontWeight-class.html\">FontWeight<\/a> enum index\nvalues, so that for instance <code>style.apply(fontWeightDelta: -2)<\/code> when\napplied to a <code>style<\/code> whose <a href=\"painting\/TextStyle\/fontWeight.html\">fontWeight<\/a> is <a href=\"dart-ui\/FontWeight\/w500-constant.html\">FontWeight.w500<\/a> will return a\n<a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> with a <a href=\"dart-ui\/FontWeight\/w300-constant.html\">FontWeight.w300<\/a>.<\/p>\n<p>The numeric arguments must not be null.<\/p>\n<p>If the underlying values are null, then the corresponding factors and\/or\ndeltas must not be specified.<\/p>\n<p>If <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> is specified on this object, then applying <code>color<\/code> here\nwill have no effect and if <a href=\"painting\/TextStyle\/background.html\">background<\/a> is specified on this object, then\napplying <code>backgroundColor<\/code> here will have no effect either.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextStyle apply({\n  Color color,\n  Color backgroundColor,\n  TextDecoration decoration,\n  Color decorationColor,\n  TextDecorationStyle decorationStyle,\n  double decorationThicknessFactor = 1.0,\n  double decorationThicknessDelta = 0.0,\n  String fontFamily,\n  List&lt;String&gt; fontFamilyFallback,\n  double fontSizeFactor = 1.0,\n  double fontSizeDelta = 0.0,\n  int fontWeightDelta = 0,\n  double letterSpacingFactor = 1.0,\n  double letterSpacingDelta = 0.0,\n  double wordSpacingFactor = 1.0,\n  double wordSpacingDelta = 0.0,\n  double heightFactor = 1.0,\n  double heightDelta = 0.0,\n}) {\n  assert(fontSizeFactor != null);\n  assert(fontSizeDelta != null);\n  assert(fontSize != null || (fontSizeFactor == 1.0 &amp;&amp; fontSizeDelta == 0.0));\n  assert(fontWeightDelta != null);\n  assert(fontWeight != null || fontWeightDelta == 0.0);\n  assert(letterSpacingFactor != null);\n  assert(letterSpacingDelta != null);\n  assert(letterSpacing != null || (letterSpacingFactor == 1.0 &amp;&amp; letterSpacingDelta == 0.0));\n  assert(wordSpacingFactor != null);\n  assert(wordSpacingDelta != null);\n  assert(wordSpacing != null || (wordSpacingFactor == 1.0 &amp;&amp; wordSpacingDelta == 0.0));\n  assert(heightFactor != null);\n  assert(heightDelta != null);\n  assert(heightFactor != null || (heightFactor == 1.0 &amp;&amp; heightDelta == 0.0));\n  assert(decorationThicknessFactor != null);\n  assert(decorationThicknessDelta != null);\n  assert(decorationThickness != null || (decorationThicknessFactor == 1.0 &amp;&amp; decorationThicknessDelta == 0.0));\n\n  String modifiedDebugLabel;\n  assert(() {\n    if (debugLabel != null)\n      modifiedDebugLabel = '($debugLabel).apply';\n    return true;\n  }());\n\n  return TextStyle(\n    inherit: inherit,\n    color: foreground == null ? color ?? this.color : null,\n    backgroundColor: background == null ? backgroundColor ?? this.backgroundColor : null,\n    fontFamily: fontFamily ?? this.fontFamily,\n    fontFamilyFallback: fontFamilyFallback ?? this.fontFamilyFallback,\n    fontSize: fontSize == null ? null : fontSize * fontSizeFactor + fontSizeDelta,\n    fontWeight: fontWeight == null ? null : FontWeight.values[(fontWeight.index + fontWeightDelta).clamp(0, FontWeight.values.length - 1)],\n    fontStyle: fontStyle,\n    letterSpacing: letterSpacing == null ? null : letterSpacing * letterSpacingFactor + letterSpacingDelta,\n    wordSpacing: wordSpacing == null ? null : wordSpacing * wordSpacingFactor + wordSpacingDelta,\n    textBaseline: textBaseline,\n    height: height == null ? null : height * heightFactor + heightDelta,\n    locale: locale,\n    foreground: foreground,\n    background: background,\n    shadows: shadows,\n    decoration: decoration ?? this.decoration,\n    decorationColor: decorationColor ?? this.decorationColor,\n    decorationStyle: decorationStyle ?? this.decorationStyle,\n    decorationThickness: decorationThickness == null ? null : decorationThickness * decorationThicknessFactor + decorationThicknessDelta,\n    debugLabel: modifiedDebugLabel,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/apply.html",
                    "isDeprecated": false,
                    "type": "painting.TextStyle",
                    "name": "apply",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "backgroundColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "decoration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDecoration"
                        },
                        {
                            "name": "decorationColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "decorationStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDecorationStyle"
                        },
                        {
                            "name": "decorationThicknessDelta",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "decorationThicknessFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontFamily",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontFamilyFallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.List<dart:core.String>"
                        },
                        {
                            "name": "fontSizeDelta",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontSizeFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontWeightDelta",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        },
                        {
                            "name": "heightDelta",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "heightFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "letterSpacingDelta",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "letterSpacingFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "wordSpacingDelta",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "wordSpacingFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Describe the difference between this style and another, in terms of how\nmuch damage it will make to the rendering.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/TextStyle\/compareTo.html\">TextSpan.compareTo<\/a>, which does the same thing for entire <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>s.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">RenderComparison compareTo(TextStyle other) {\n  if (identical(this, other))\n    return RenderComparison.identical;\n  if (inherit != other.inherit ||\n      fontFamily != other.fontFamily ||\n      fontSize != other.fontSize ||\n      fontWeight != other.fontWeight ||\n      fontStyle != other.fontStyle ||\n      letterSpacing != other.letterSpacing ||\n      wordSpacing != other.wordSpacing ||\n      textBaseline != other.textBaseline ||\n      height != other.height ||\n      locale != other.locale ||\n      foreground != other.foreground ||\n      background != other.background ||\n      !listEquals(shadows, other.shadows) ||\n      !listEquals(fontFamilyFallback, other.fontFamilyFallback))\n    return RenderComparison.layout;\n  if (color != other.color ||\n      backgroundColor != other.backgroundColor ||\n      decoration != other.decoration ||\n      decorationColor != other.decorationColor ||\n      decorationStyle != other.decorationStyle ||\n      decorationThickness != other.decorationThickness)\n    return RenderComparison.paint;\n  return RenderComparison.identical;\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/compareTo.html",
                    "isDeprecated": false,
                    "type": "painting.RenderComparison",
                    "name": "compareTo",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextStyle"
                        }
                    ]
                },
                {
                    "desc": "<p>Creates a copy of this text style but with the given fields replaced with\nthe new values.<\/p>\n<p>One of <code>color<\/code> or <code>foreground<\/code> must be null, and if this has <code>foreground<\/code>\nspecified it will be given preference over any color parameter.<\/p>\n<p>One of <code>backgroundColor<\/code> or <code>background<\/code> must be null, and if this has\n<code>background<\/code> specified it will be given preference over any\nbackgroundColor parameter.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextStyle copyWith({\n  bool inherit,\n  Color color,\n  Color backgroundColor,\n  String fontFamily,\n  List&lt;String&gt; fontFamilyFallback,\n  double fontSize,\n  FontWeight fontWeight,\n  FontStyle fontStyle,\n  double letterSpacing,\n  double wordSpacing,\n  TextBaseline textBaseline,\n  double height,\n  Locale locale,\n  Paint foreground,\n  Paint background,\n  List&lt;ui.Shadow&gt; shadows,\n  TextDecoration decoration,\n  Color decorationColor,\n  TextDecorationStyle decorationStyle,\n  double decorationThickness,\n  String debugLabel,\n}) {\n  assert(color == null || foreground == null, _kColorForegroundWarning);\n  assert(backgroundColor == null || background == null, _kColorBackgroundWarning);\n  String newDebugLabel;\n  assert(() {\n    if (this.debugLabel != null)\n      newDebugLabel = debugLabel ?? '(${this.debugLabel}).copyWith';\n    return true;\n  }());\n  return TextStyle(\n    inherit: inherit ?? this.inherit,\n    color: this.foreground == null &amp;&amp; foreground == null ? color ?? this.color : null,\n    backgroundColor: this.background == null &amp;&amp; background == null ? backgroundColor ?? this.backgroundColor : null,\n    fontFamily: fontFamily ?? this.fontFamily,\n    fontFamilyFallback: fontFamilyFallback ?? this.fontFamilyFallback,\n    fontSize: fontSize ?? this.fontSize,\n    fontWeight: fontWeight ?? this.fontWeight,\n    fontStyle: fontStyle ?? this.fontStyle,\n    letterSpacing: letterSpacing ?? this.letterSpacing,\n    wordSpacing: wordSpacing ?? this.wordSpacing,\n    textBaseline: textBaseline ?? this.textBaseline,\n    height: height ?? this.height,\n    locale: locale ?? this.locale,\n    foreground: foreground ?? this.foreground,\n    background: background ?? this.background,\n    shadows: shadows ?? this.shadows,\n    decoration: decoration ?? this.decoration,\n    decorationColor: decorationColor ?? this.decorationColor,\n    decorationStyle: decorationStyle ?? this.decorationStyle,\n    decorationThickness: decorationThickness ?? this.decorationThickness,\n    debugLabel: newDebugLabel,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/copyWith.html",
                    "isDeprecated": false,
                    "type": "painting.TextStyle",
                    "name": "copyWith",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "background",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Paint"
                        },
                        {
                            "name": "backgroundColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "color",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "debugLabel",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "decoration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDecoration"
                        },
                        {
                            "name": "decorationColor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Color"
                        },
                        {
                            "name": "decorationStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDecorationStyle"
                        },
                        {
                            "name": "decorationThickness",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontFamily",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontFamilyFallback",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.List<dart:core.String>"
                        },
                        {
                            "name": "fontSize",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.FontStyle"
                        },
                        {
                            "name": "fontWeight",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.FontWeight"
                        },
                        {
                            "name": "foreground",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Paint"
                        },
                        {
                            "name": "height",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "inherit",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "letterSpacing",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "locale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Locale"
                        },
                        {
                            "name": "shadows",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.List<dart:ui.Shadow>"
                        },
                        {
                            "name": "textBaseline",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextBaseline"
                        },
                        {
                            "name": "wordSpacing",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Adds all properties prefixing property names with the optional <code>prefix<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties, { String prefix = '' }) {\n  super.debugFillProperties(properties);\n  if (debugLabel != null)\n    properties.add(MessageProperty('${prefix}debugLabel', debugLabel));\n  final List&lt;DiagnosticsNode&gt; styles = &lt;DiagnosticsNode&gt;[];\n  styles.add(DiagnosticsProperty&lt;Color&gt;('${prefix}color', color, defaultValue: null));\n  styles.add(DiagnosticsProperty&lt;Color&gt;('${prefix}backgroundColor', backgroundColor, defaultValue: null));\n  styles.add(StringProperty('${prefix}family', fontFamily, defaultValue: null, quoted: false));\n  styles.add(IterableProperty&lt;String&gt;('${prefix}familyFallback', fontFamilyFallback, defaultValue: null));\n  styles.add(DoubleProperty('${prefix}size', fontSize, defaultValue: null));\n  String weightDescription;\n  if (fontWeight != null) {\n    weightDescription = '${fontWeight.index + 1}00';\n  }\n  \/\/ TODO(jacobr): switch this to use enumProperty which will either cause the\n  \/\/ weight description to change to w600 from 600 or require existing\n  \/\/ enumProperty to handle this special case.\n  styles.add(DiagnosticsProperty&lt;FontWeight&gt;(\n    '${prefix}weight',\n    fontWeight,\n    description: weightDescription,\n    defaultValue: null,\n  ));\n  styles.add(EnumProperty&lt;FontStyle&gt;('${prefix}style', fontStyle, defaultValue: null));\n  styles.add(DoubleProperty('${prefix}letterSpacing', letterSpacing, defaultValue: null));\n  styles.add(DoubleProperty('${prefix}wordSpacing', wordSpacing, defaultValue: null));\n  styles.add(EnumProperty&lt;TextBaseline&gt;('${prefix}baseline', textBaseline, defaultValue: null));\n  styles.add(DoubleProperty('${prefix}height', height, unit: 'x', defaultValue: null));\n  styles.add(DiagnosticsProperty&lt;Locale&gt;('${prefix}locale', locale, defaultValue: null));\n  styles.add(DiagnosticsProperty&lt;Paint&gt;('${prefix}foreground', foreground, defaultValue: null));\n  styles.add(DiagnosticsProperty&lt;Paint&gt;('${prefix}background', background, defaultValue: null));\n  if (decoration != null || decorationColor != null || decorationStyle != null || decorationThickness != null) {\n    final List&lt;String&gt; decorationDescription = &lt;String&gt;[];\n    if (decorationStyle != null)\n      decorationDescription.add(describeEnum(decorationStyle));\n\n    \/\/ Hide decorationColor from the default text view as it is shown in the\n    \/\/ terse decoration summary as well.\n    styles.add(DiagnosticsProperty&lt;Color&gt;('${prefix}decorationColor', decorationColor, defaultValue: null, level: DiagnosticLevel.fine));\n\n    if (decorationColor != null)\n      decorationDescription.add('$decorationColor');\n\n    \/\/ Intentionally collide with the property 'decoration' added below.\n    \/\/ Tools that show hidden properties could choose the first property\n    \/\/ matching the name to disambiguate.\n    styles.add(DiagnosticsProperty&lt;TextDecoration&gt;('${prefix}decoration', decoration, defaultValue: null, level: DiagnosticLevel.hidden));\n    if (decoration != null)\n      decorationDescription.add('$decoration');\n    assert(decorationDescription.isNotEmpty);\n    styles.add(MessageProperty('${prefix}decoration', decorationDescription.join(' ')));\n    styles.add(DoubleProperty('${prefix}decorationThickness', decorationThickness, unit: 'x', defaultValue: null));\n  }\n\n  final bool styleSpecified = styles.any((DiagnosticsNode n) =&gt; !n.isFiltered(DiagnosticLevel.info));\n  properties.add(DiagnosticsProperty&lt;bool&gt;('${prefix}inherit', inherit, level: (!styleSpecified &amp;&amp; inherit) ? DiagnosticLevel.fine : DiagnosticLevel.info));\n  styles.forEach(properties.add);\n\n  if (!styleSpecified)\n    properties.add(FlagProperty('inherit', value: inherit, ifTrue: '$prefix&lt;all styles inherited&gt;', ifFalse: '$prefix&lt;no style specified&gt;'));\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/debugFillProperties.html",
                    "isDeprecated": false,
                    "type": "<void>",
                    "name": "debugFillProperties",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "prefix",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "properties",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.DiagnosticPropertiesBuilder"
                        }
                    ]
                },
                {
                    "desc": "<p>The style information for paragraphs, encoded for use by <code>dart:ui<\/code>.<\/p>\n<p>The <code>textScaleFactor<\/code> argument must not be null. If omitted, it defaults\nto 1.0. The other arguments may be null. The <code>maxLines<\/code> argument, if\nspecified and non-null, must be greater than zero.<\/p>\n<p>If the font size on this style isn't set, it will default to 14 logical\npixels.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ui.ParagraphStyle getParagraphStyle({\n  TextAlign textAlign,\n  TextDirection textDirection,\n  double textScaleFactor = 1.0,\n  String ellipsis,\n  int maxLines,\n  Locale locale,\n  String fontFamily,\n  double fontSize,\n  FontWeight fontWeight,\n  FontStyle fontStyle,\n  double height,\n  StrutStyle strutStyle,\n}) {\n  assert(textScaleFactor != null);\n  assert(maxLines == null || maxLines &gt; 0);\n  return ui.ParagraphStyle(\n    textAlign: textAlign,\n    textDirection: textDirection,\n    \/\/ Here, we stablish the contents of this TextStyle as the paragraph's default font\n    \/\/ unless an override is passed in.\n    fontWeight: fontWeight ?? this.fontWeight,\n    fontStyle: fontStyle ?? this.fontStyle,\n    fontFamily: fontFamily ?? this.fontFamily,\n    fontSize: (fontSize ?? this.fontSize ?? _defaultFontSize) * textScaleFactor,\n    height: height ?? this.height,\n    strutStyle: strutStyle == null ? null : ui.StrutStyle(\n      fontFamily: strutStyle.fontFamily,\n      fontFamilyFallback: strutStyle.fontFamilyFallback,\n      fontSize: strutStyle.fontSize,\n      height: strutStyle.height,\n      leading: strutStyle.leading,\n      fontWeight: strutStyle.fontWeight,\n      fontStyle: strutStyle.fontStyle,\n      forceStrutHeight: strutStyle.forceStrutHeight,\n    ),\n    maxLines: maxLines,\n    ellipsis: ellipsis,\n    locale: locale,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/getParagraphStyle.html",
                    "isDeprecated": false,
                    "type": "dart:ui.ParagraphStyle",
                    "name": "getParagraphStyle",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "ellipsis",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontFamily",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "fontSize",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "fontStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.FontStyle"
                        },
                        {
                            "name": "fontWeight",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.FontWeight"
                        },
                        {
                            "name": "height",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        },
                        {
                            "name": "locale",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.Locale"
                        },
                        {
                            "name": "maxLines",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.int"
                        },
                        {
                            "name": "strutStyle",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.StrutStyle"
                        },
                        {
                            "name": "textAlign",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextAlign"
                        },
                        {
                            "name": "textDirection",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:ui.TextDirection"
                        },
                        {
                            "name": "textScaleFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>The style information for text runs, encoded for use by <code>dart:ui<\/code>.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">ui.TextStyle getTextStyle({ double textScaleFactor = 1.0 }) {\n  return ui.TextStyle(\n    color: color,\n    decoration: decoration,\n    decorationColor: decorationColor,\n    decorationStyle: decorationStyle,\n    decorationThickness: decorationThickness,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle,\n    textBaseline: textBaseline,\n    fontFamily: fontFamily,\n    fontFamilyFallback: fontFamilyFallback,\n    fontSize: fontSize == null ? null : fontSize * textScaleFactor,\n    letterSpacing: letterSpacing,\n    wordSpacing: wordSpacing,\n    height: height,\n    locale: locale,\n    foreground: foreground,\n    background: background ?? (backgroundColor != null\n      ? (Paint()..color = backgroundColor)\n      : null\n    ),\n    shadows: shadows,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/getTextStyle.html",
                    "isDeprecated": false,
                    "type": "dart:ui.TextStyle",
                    "name": "getTextStyle",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "textScaleFactor",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Interpolate between two text styles.<\/p>\n<p>This will not work well if the styles don't set the same fields.<\/p>\n<p>The <code>t<\/code> argument represents position on the timeline, with 0.0 meaning\nthat the interpolation has not started, returning <code>a<\/code> (or something\nequivalent to <code>a<\/code>), 1.0 meaning that the interpolation has finished,\nreturning <code>b<\/code> (or something equivalent to <code>b<\/code>), and values in between\nmeaning that the interpolation is at the relevant point on the timeline\nbetween <code>a<\/code> and <code>b<\/code>. The interpolation can be extrapolated beyond 0.0 and\n1.0, so negative values and values greater than 1.0 are valid (and can\neasily be generated by curves such as <a href=\"animation\/Curves\/elasticInOut-constant.html\">Curves.elasticInOut<\/a>).<\/p>\n<p>Values for <code>t<\/code> are usually obtained from an <a href=\"animation\/Animation-class.html\">Animation&lt;double&gt;<\/a>, such as\nan <a href=\"animation\/AnimationController-class.html\">AnimationController<\/a>.<\/p>\n<p>If <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> is specified on either of <code>a<\/code> or <code>b<\/code>, both will be treated\nas if they have a <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> paint (creating a new <a href=\"dart-ui\/Paint-class.html\">Paint<\/a> if necessary\nbased on the <a href=\"painting\/TextStyle\/color.html\">color<\/a> property).<\/p>\n<p>If <a href=\"painting\/TextStyle\/background.html\">background<\/a> is specified on either of <code>a<\/code> or <code>b<\/code>, both will be treated\nas if they have a <a href=\"painting\/TextStyle\/background.html\">background<\/a> paint (creating a new <a href=\"dart-ui\/Paint-class.html\">Paint<\/a> if necessary\nbased on the <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> property).<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">static TextStyle lerp(TextStyle a, TextStyle b, double t) {\n  assert(t != null);\n  assert(a == null || b == null || a.inherit == b.inherit);\n  if (a == null &amp;&amp; b == null) {\n    return null;\n  }\n\n  String lerpDebugLabel;\n  assert(() {\n    lerpDebugLabel = 'lerp(${a?.debugLabel ?? _kDefaultDebugLabel} \u23af${t.toStringAsFixed(1)}\u2192 ${b?.debugLabel ?? _kDefaultDebugLabel})';\n    return true;\n  }());\n\n  if (a == null) {\n    return TextStyle(\n      inherit: b.inherit,\n      color: Color.lerp(null, b.color, t),\n      backgroundColor: Color.lerp(null, b.backgroundColor, t),\n      fontFamily: t &lt; 0.5 ? null : b.fontFamily,\n      fontFamilyFallback: t &lt; 0.5 ? null : b.fontFamilyFallback,\n      fontSize: t &lt; 0.5 ? null : b.fontSize,\n      fontWeight: FontWeight.lerp(null, b.fontWeight, t),\n      fontStyle: t &lt; 0.5 ? null : b.fontStyle,\n      letterSpacing: t &lt; 0.5 ? null : b.letterSpacing,\n      wordSpacing: t &lt; 0.5 ? null : b.wordSpacing,\n      textBaseline: t &lt; 0.5 ? null : b.textBaseline,\n      height: t &lt; 0.5 ? null : b.height,\n      locale: t &lt; 0.5 ? null : b.locale,\n      foreground: t &lt; 0.5 ? null : b.foreground,\n      background: t &lt; 0.5 ? null : b.background,\n      decoration: t &lt; 0.5 ? null : b.decoration,\n      shadows: t &lt; 0.5 ? null : b.shadows,\n      decorationColor: Color.lerp(null, b.decorationColor, t),\n      decorationStyle: t &lt; 0.5 ? null : b.decorationStyle,\n      decorationThickness: t &lt; 0.5 ? null : b.decorationThickness,\n      debugLabel: lerpDebugLabel,\n    );\n  }\n\n  if (b == null) {\n    return TextStyle(\n      inherit: a.inherit,\n      color: Color.lerp(a.color, null, t),\n      backgroundColor: Color.lerp(null, a.backgroundColor, t),\n      fontFamily: t &lt; 0.5 ? a.fontFamily : null,\n      fontFamilyFallback: t &lt; 0.5 ? a.fontFamilyFallback : null,\n      fontSize: t &lt; 0.5 ? a.fontSize : null,\n      fontWeight: FontWeight.lerp(a.fontWeight, null, t),\n      fontStyle: t &lt; 0.5 ? a.fontStyle : null,\n      letterSpacing: t &lt; 0.5 ? a.letterSpacing : null,\n      wordSpacing: t &lt; 0.5 ? a.wordSpacing : null,\n      textBaseline: t &lt; 0.5 ? a.textBaseline : null,\n      height: t &lt; 0.5 ? a.height : null,\n      locale: t &lt; 0.5 ? a.locale : null,\n      foreground: t &lt; 0.5 ? a.foreground : null,\n      background: t &lt; 0.5 ? a.background : null,\n      shadows: t &lt; 0.5 ? a.shadows : null,\n      decoration: t &lt; 0.5 ? a.decoration : null,\n      decorationColor: Color.lerp(a.decorationColor, null, t),\n      decorationStyle: t &lt; 0.5 ? a.decorationStyle : null,\n      decorationThickness: t &lt; 0.5 ? a.decorationThickness : null,\n      debugLabel: lerpDebugLabel,\n    );\n  }\n\n  return TextStyle(\n    inherit: b.inherit,\n    color: a.foreground == null &amp;&amp; b.foreground == null ? Color.lerp(a.color, b.color, t) : null,\n    backgroundColor: a.background == null &amp;&amp; b.background == null ? Color.lerp(a.backgroundColor, b.backgroundColor, t) : null,\n    fontFamily: t &lt; 0.5 ? a.fontFamily : b.fontFamily,\n    fontFamilyFallback: t &lt; 0.5 ? a.fontFamilyFallback : b.fontFamilyFallback,\n    fontSize: ui.lerpDouble(a.fontSize ?? b.fontSize, b.fontSize ?? a.fontSize, t),\n    fontWeight: FontWeight.lerp(a.fontWeight, b.fontWeight, t),\n    fontStyle: t &lt; 0.5 ? a.fontStyle : b.fontStyle,\n    letterSpacing: ui.lerpDouble(a.letterSpacing ?? b.letterSpacing, b.letterSpacing ?? a.letterSpacing, t),\n    wordSpacing: ui.lerpDouble(a.wordSpacing ?? b.wordSpacing, b.wordSpacing ?? a.wordSpacing, t),\n    textBaseline: t &lt; 0.5 ? a.textBaseline : b.textBaseline,\n    height: ui.lerpDouble(a.height ?? b.height, b.height ?? a.height, t),\n    locale: t &lt; 0.5 ? a.locale : b.locale,\n    foreground: (a.foreground != null || b.foreground != null)\n      ? t &lt; 0.5\n        ? a.foreground ?? (Paint()..color = a.color)\n        : b.foreground ?? (Paint()..color = b.color)\n      : null,\n    background: (a.background != null || b.background != null)\n      ? t &lt; 0.5\n        ? a.background ?? (Paint()..color = a.backgroundColor)\n        : b.background ?? (Paint()..color = b.backgroundColor)\n      : null,\n    shadows: t &lt; 0.5 ? a.shadows : b.shadows,\n    decoration: t &lt; 0.5 ? a.decoration : b.decoration,\n    decorationColor: Color.lerp(a.decorationColor, b.decorationColor, t),\n    decorationStyle: t &lt; 0.5 ? a.decorationStyle : b.decorationStyle,\n    decorationThickness: ui.lerpDouble(a.decorationThickness ?? b.decorationThickness, b.decorationThickness ?? a.decorationThickness, t),\n    debugLabel: lerpDebugLabel,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/lerp.html",
                    "isDeprecated": false,
                    "type": "painting.TextStyle",
                    "name": "lerp",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "a",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextStyle"
                        },
                        {
                            "name": "b",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextStyle"
                        },
                        {
                            "name": "t",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "dart:core.double"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a new text style that is a combination of this style and the given\n<code>other<\/code> style.<\/p>\n<p>If the given <code>other<\/code> text style has its <a href=\"painting\/TextStyle\/inherit.html\">TextStyle.inherit<\/a> set to true,\nits null properties are replaced with the non-null properties of this text\nstyle. The <code>other<\/code> style <em>inherits<\/em> the properties of this style. Another\nway to think of it is that the \"missing\" properties of the <code>other<\/code> style\nare <em>filled<\/em> by the properties of this style.<\/p>\n<p>If the given <code>other<\/code> text style has its <a href=\"painting\/TextStyle\/inherit.html\">TextStyle.inherit<\/a> set to false,\nreturns the given <code>other<\/code> style unchanged. The <code>other<\/code> style does not\ninherit properties of this style.<\/p>\n<p>If the given text style is null, returns this text style.<\/p>\n<p>One of <a href=\"painting\/TextStyle\/color.html\">color<\/a> or <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> must be null, and if this or <code>other<\/code> has\n<a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> specified it will be given preference over any color parameter.<\/p>\n<p>Similarly, One of <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> or <a href=\"painting\/TextStyle\/background.html\">background<\/a> must be null, and if\nthis or <code>other<\/code> has <a href=\"painting\/TextStyle\/background.html\">background<\/a> specified it will be given preference\nover any backgroundColor parameter.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TextStyle merge(TextStyle other) {\n  if (other == null)\n    return this;\n  if (!other.inherit)\n    return other;\n\n  String mergedDebugLabel;\n  assert(() {\n    if (other.debugLabel != null || debugLabel != null)\n      mergedDebugLabel = '(${debugLabel ?? _kDefaultDebugLabel}).merge(${other.debugLabel ?? _kDefaultDebugLabel})';\n    return true;\n  }());\n\n  return copyWith(\n    color: other.color,\n    backgroundColor: other.backgroundColor,\n    fontFamily: other.fontFamily,\n    fontFamilyFallback: other.fontFamilyFallback,\n    fontSize: other.fontSize,\n    fontWeight: other.fontWeight,\n    fontStyle: other.fontStyle,\n    letterSpacing: other.letterSpacing,\n    wordSpacing: other.wordSpacing,\n    textBaseline: other.textBaseline,\n    height: other.height,\n    locale: other.locale,\n    foreground: other.foreground,\n    background: other.background,\n    shadows: other.shadows,\n    decoration: other.decoration,\n    decorationColor: other.decorationColor,\n    decorationStyle: other.decorationStyle,\n    decorationThickness: other.decorationThickness,\n    debugLabel: mergedDebugLabel,\n  );\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/merge.html",
                    "isDeprecated": false,
                    "type": "painting.TextStyle",
                    "name": "merge",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": [
                        {
                            "name": "other",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "painting.TextStyle"
                        }
                    ]
                },
                {
                    "desc": "<p>A brief description of this object, usually just the <a href=\"dart-core\/Object\/runtimeType.html\">runtimeType<\/a> and the\n<a href=\"painting\/TextStyle\/hashCode.html\">hashCode<\/a>.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"foundation\/Diagnosticable\/toString.html\">toString<\/a>, for a detailed description of the object.<\/li><\/ul>",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString toStringShort() =&gt; '$runtimeType';<\/code><\/pre>\n    ",
                    "href": "painting\/TextStyle\/toStringShort.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "toStringShort",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                }
            ],
            "props": [
                {
                    "desc": "<p>The paint drawn as a background for the text.<\/p>\n<p>The value should ideally be cached and reused each time if multiple text\nstyles are created with the same paint settings. Otherwise, each time it\nwill appear like the style changed, which will result in unnecessary\nupdates all the way through the framework.<\/p>\n<p>If <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> is specified, this value must be null. The\n<a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> property is shorthand for\n<code>background: Paint()..color = backgroundColor<\/code>.<\/p>\n<p>In <a href=\"painting\/TextStyle\/merge.html\">merge<\/a>, <a href=\"painting\/TextStyle\/apply.html\">apply<\/a>, and <a href=\"painting\/TextStyle\/lerp.html\">lerp<\/a>, conflicts between <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> and\n<a href=\"painting\/TextStyle\/background.html\">background<\/a> specification are resolved in <a href=\"painting\/TextStyle\/background.html\">background<\/a>'s favor - i.e. if\n<a href=\"painting\/TextStyle\/background.html\">background<\/a> is specified in one place, it will dominate <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a>\nin another.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Paint background\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/background.html",
                    "name": "background",
                    "isDeprecated": false,
                    "type": "dart:ui.Paint",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The color to use as the background for the text.<\/p>\n<p>If <a href=\"painting\/TextStyle\/background.html\">background<\/a> is specified, this value must be null. The\n<a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> property is shorthand for\n<code>background: Paint()..color = backgroundColor<\/code>.<\/p>\n<p>In <a href=\"painting\/TextStyle\/merge.html\">merge<\/a>, <a href=\"painting\/TextStyle\/apply.html\">apply<\/a>, and <a href=\"painting\/TextStyle\/lerp.html\">lerp<\/a>, conflicts between <a href=\"painting\/TextStyle\/backgroundColor.html\">backgroundColor<\/a> and <a href=\"painting\/TextStyle\/background.html\">background<\/a>\nspecification are resolved in <a href=\"painting\/TextStyle\/background.html\">background<\/a>'s favor - i.e. if <a href=\"painting\/TextStyle\/background.html\">background<\/a> is\nspecified in one place, it will dominate <a href=\"painting\/TextStyle\/color.html\">color<\/a> in another.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color backgroundColor\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/backgroundColor.html",
                    "name": "backgroundColor",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The color to use when painting the text.<\/p>\n<p>If <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> is specified, this value must be null. The <a href=\"painting\/TextStyle\/color.html\">color<\/a> property\nis shorthand for <code>Paint()..color = color<\/code>.<\/p>\n<p>In <a href=\"painting\/TextStyle\/merge.html\">merge<\/a>, <a href=\"painting\/TextStyle\/apply.html\">apply<\/a>, and <a href=\"painting\/TextStyle\/lerp.html\">lerp<\/a>, conflicts between <a href=\"painting\/TextStyle\/color.html\">color<\/a> and <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a>\nspecification are resolved in <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a>'s favor - i.e. if <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> is\nspecified in one place, it will dominate <a href=\"painting\/TextStyle\/color.html\">color<\/a> in another.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color color\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/color.html",
                    "name": "color",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>A human-readable description of this text style.<\/p>\n<p>This property is maintained only in debug builds.<\/p>\n<p>When merging (<a href=\"painting\/TextStyle\/merge.html\">merge<\/a>), copying (<a href=\"painting\/TextStyle\/copyWith.html\">copyWith<\/a>), modifying using <a href=\"painting\/TextStyle\/apply.html\">apply<\/a>, or\ninterpolating (<a href=\"painting\/TextStyle\/lerp.html\">lerp<\/a>), the label of the resulting style is marked with\nthe debug labels of the original styles. This helps figuring out where a\nparticular text style came from.<\/p>\n<p>This property is not considered when comparing text styles using <code>==<\/code> or\n<a href=\"painting\/TextStyle\/compareTo.html\">compareTo<\/a>, and it does not affect <a href=\"painting\/TextStyle\/hashCode.html\">hashCode<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String debugLabel\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/debugLabel.html",
                    "name": "debugLabel",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The decorations to paint near the text (e.g., an underline).<\/p>\n<p>Multiple decorations can be applied using <a href=\"dart-ui\/TextDecoration\/TextDecoration.combine.html\">TextDecoration.combine<\/a>.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TextDecoration decoration\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/decoration.html",
                    "name": "decoration",
                    "isDeprecated": false,
                    "type": "dart:ui.TextDecoration",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The color in which to paint the text decorations.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Color decorationColor\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/decorationColor.html",
                    "name": "decorationColor",
                    "isDeprecated": false,
                    "type": "dart:ui.Color",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The style in which to paint the text decorations (e.g., dashed).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TextDecorationStyle decorationStyle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/decorationStyle.html",
                    "name": "decorationStyle",
                    "isDeprecated": false,
                    "type": "dart:ui.TextDecorationStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The thickness of the decoration stroke as a muliplier of the thickness\ndefined by the font.<\/p>\n<p>The font provides a base stroke width for <a href=\"painting\/TextStyle\/decoration.html\">decoration<\/a>s which scales off\nof the <a href=\"painting\/TextStyle\/fontSize.html\">fontSize<\/a>. This property may be used to achieve a thinner or\nthicker decoration stroke, without changing the <a href=\"painting\/TextStyle\/fontSize.html\">fontSize<\/a>. For example,\na <a href=\"painting\/TextStyle\/decorationThickness.html\">decorationThickness<\/a> of 2.0 will draw a decoration twice as thick as\nthe font defined decoration thickness.<\/p>\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nTo achieve a bolded strike-through, we can apply a thicker stroke for the\ndecoration.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text(\n  'This has a very BOLD strike through!',\n  style: TextStyle(\n    decoration: TextDecoration.lineThrough,\n    decorationThickness: 2.85,\n  ),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>\n<\/p>\n<div class=\"snippet-buttons\">\n  <button id=\"shortSnippetButton\" selected>Sample<\/button>\n<\/div>\n<div class=\"snippet-container\">\n  <div class=\"snippet\">\n<div class=\"snippet-description\">\nWe can apply a very thin and subtle wavy underline (perhaps, when words\nare misspelled) by using a <a href=\"painting\/TextStyle\/decorationThickness.html\">decorationThickness<\/a> &lt; 1.0.\n<\/div>\n    <div class=\"copyable-container\">\n      <button class=\"copy-button-overlay copy-button\" title=\"Copy to clipboard\" onclick=\"copyTextToClipboard(findSiblingWithId(this, 'sample-code'));\">\n        <i class=\"material-icons copy-image\">assignment<\/i>\n      <\/button>\n      <pre class=\"language-dart\" id=\"sample-code\"><code class=\"language-dart\">Text(\n  'oopsIforgottousespaces!',\n  style: TextStyle(\n    decoration: TextDecoration.underline,\n    decorationStyle: TextDecorationStyle.wavy,\n    decorationColor: Colors.red,\n    decorationThickness: 0.5,\n  ),\n)<\/code><\/pre>\n    <\/div>\n  <\/div>\n<\/div>\n\n<p>The default <a href=\"painting\/TextStyle\/decorationThickness.html\">decorationThickness<\/a> is 1.0, which will use the font's base\nstroke thickness\/width.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double decorationThickness\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/decorationThickness.html",
                    "name": "decorationThickness",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The name of the font to use when painting the text (e.g., Roboto). If the\nfont is defined in a package, this will be prefixed with\n'packages\/package_name\/' (e.g. 'packages\/cool_fonts\/Roboto'). The\nprefixing is done by the constructor when the <code>package<\/code> argument is\nprovided.<\/p>\n<p>The value provided in <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a> will act as the preferred\/first font\nfamily that glyphs are looked for in, followed in order by the font families\nin <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>. When <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a> is null or not provided, the\nfirst value in <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> acts as the preferred\/first font\nfamily. When neither is provided, then the default platform font will\nbe used.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final String fontFamily\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/fontFamily.html",
                    "name": "fontFamily",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The ordered list of font families to fall back on when a glyph cannot be\nfound in a higher priority font family.<\/p>\n<p>The value provided in <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a> will act as the preferred\/first font\nfamily that glyphs are looked for in, followed in order by the font families\nin <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>. If all font families are exhausted and no match\nwas found, the default platform font family will be used instead.<\/p>\n<p>When <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a> is null or not provided, the first value in <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a>\nacts as the preferred\/first font family. When neither is provided, then\nthe default platform font will be used. Providing and empty list or null\nfor this property is the same as omitting it.<\/p>\n<p>For example, if a glyph is not found in <a href=\"painting\/TextStyle\/fontFamily.html\">fontFamily<\/a>, then each font family\nin <a href=\"painting\/TextStyle\/fontFamilyFallback.html\">fontFamilyFallback<\/a> will be searched in order until it is found. If it\nis not found, then a box will be drawn in its place.<\/p>\n<p>If the font is defined in a package, each font family in the list will be\nprefixed with 'packages\/package_name\/' (e.g. 'packages\/cool_fonts\/Roboto').\nThe package name should be provided by the <code>package<\/code> argument in the\nconstructor.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">List&lt;String&gt; get fontFamilyFallback =&gt; _package != null &amp;&amp; _fontFamilyFallback != null ? _fontFamilyFallback.map((String str) =&gt; 'packages\/$_package\/$str').toList() : _fontFamilyFallback;<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/fontFamilyFallback.html",
                    "name": "fontFamilyFallback",
                    "isDeprecated": false,
                    "type": "dart:core.List<dart:core.String>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The size of glyphs (in logical pixels) to use when painting the text.<\/p>\n<p>During painting, the <a href=\"painting\/TextStyle\/fontSize.html\">fontSize<\/a> is multiplied by the current\n<code>textScaleFactor<\/code> to let users make it easier to read text by increasing\nits size.<\/p>\n<p><a href=\"painting\/TextStyle\/getParagraphStyle.html\">getParagraphStyle<\/a> will default to 14 logical pixels if the font size\nisn't specified here.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double fontSize\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/fontSize.html",
                    "name": "fontSize",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The typeface variant to use when drawing the letters (e.g., italics).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final FontStyle fontStyle\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/fontStyle.html",
                    "name": "fontStyle",
                    "isDeprecated": false,
                    "type": "dart:ui.FontStyle",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The typeface thickness to use when painting the text (e.g., bold).<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final FontWeight fontWeight\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/fontWeight.html",
                    "name": "fontWeight",
                    "isDeprecated": false,
                    "type": "dart:ui.FontWeight",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The paint drawn as a foreground for the text.<\/p>\n<p>The value should ideally be cached and reused each time if multiple text\nstyles are created with the same paint settings. Otherwise, each time it\nwill appear like the style changed, which will result in unnecessary\nupdates all the way through the framework.<\/p>\n<p>If <a href=\"painting\/TextStyle\/color.html\">color<\/a> is specified, this value must be null. The <a href=\"painting\/TextStyle\/color.html\">color<\/a> property\nis shorthand for <code>Paint()..color = color<\/code>.<\/p>\n<p>In <a href=\"painting\/TextStyle\/merge.html\">merge<\/a>, <a href=\"painting\/TextStyle\/apply.html\">apply<\/a>, and <a href=\"painting\/TextStyle\/lerp.html\">lerp<\/a>, conflicts between <a href=\"painting\/TextStyle\/color.html\">color<\/a> and <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a>\nspecification are resolved in <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a>'s favor - i.e. if <a href=\"painting\/TextStyle\/foreground.html\">foreground<\/a> is\nspecified in one place, it will dominate <a href=\"painting\/TextStyle\/color.html\">color<\/a> in another.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Paint foreground\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/foreground.html",
                    "name": "foreground",
                    "isDeprecated": false,
                    "type": "dart:ui.Paint",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The hash code for this object.<\/p>\n<p>A hash code is a single integer which represents the state of the object\nthat affects <a href=\"painting\/TextStyle\/operator_equals.html\">operator ==<\/a> comparisons.<\/p>\n<p>All objects have hash codes.\nThe default hash code represents only the identity of the object,\nthe same way as the default <a href=\"painting\/TextStyle\/operator_equals.html\">operator ==<\/a> implementation only considers objects\nequal if they are identical (see <a href=\"dart-core\/identityHashCode.html\">identityHashCode<\/a>).<\/p>\n<p>If <a href=\"painting\/TextStyle\/operator_equals.html\">operator ==<\/a> is overridden to use the object state instead,\nthe hash code must also be changed to represent that state.<\/p>\n<p>Hash codes must be the same for objects that are equal to each other\naccording to <a href=\"painting\/TextStyle\/operator_equals.html\">operator ==<\/a>.\nThe hash code of an object should only change if the object changes\nin a way that affects equality.\nThere are no further requirements for the hash codes.\nThey need not be consistent between executions of the same program\nand there are no distribution guarantees.<\/p>\n<p>Objects that are not equal are allowed to have the same hash code,\nit is even technically allowed that all instances have the same hash code,\nbut if clashes happen too often, it may reduce the efficiency of hash-based\ndata structures like <a href=\"dart-collection\/HashSet-class.html\">HashSet<\/a> or <a href=\"dart-collection\/HashMap-class.html\">HashMap<\/a>.<\/p>\n<p>If a subclass overrides <a href=\"painting\/TextStyle\/hashCode.html\">hashCode<\/a>, it should override the\n<a href=\"painting\/TextStyle\/operator_equals.html\">operator ==<\/a> operator as well to maintain consistency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">@override\nint get hashCode {\n  return hashValues(\n    inherit,\n    color,\n    backgroundColor,\n    fontFamily,\n    fontFamilyFallback,\n    fontSize,\n    fontWeight,\n    fontStyle,\n    letterSpacing,\n    wordSpacing,\n    textBaseline,\n    height,\n    locale,\n    foreground,\n    background,\n    decoration,\n    decorationColor,\n    decorationStyle,\n    shadows,\n  );\n}<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/hashCode.html",
                    "name": "hashCode",
                    "isDeprecated": false,
                    "type": "dart:core.int",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The height of this text span, as a multiple of the font size.<\/p>\n<p>If applied to the root <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>, this value sets the line height, which\nis the minimum distance between subsequent text baselines, as multiple of\nthe font size.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double height\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/height.html",
                    "name": "height",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>Whether null values are replaced with their value in an ancestor text\nstyle (e.g., in a <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a> tree).<\/p>\n<p>If this is false, properties that don't have explicit values will revert\nto the defaults: white in color, a font size of 10 pixels, in a sans-serif\nfont face.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final bool inherit\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/inherit.html",
                    "name": "inherit",
                    "isDeprecated": false,
                    "type": "dart:core.bool",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The amount of space (in logical pixels) to add between each letter.\nA negative value can be used to bring the letters closer.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double letterSpacing\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/letterSpacing.html",
                    "name": "letterSpacing",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The locale used to select region-specific glyphs.<\/p>\n<p>This property is rarely set. Typically the locale used to select\nregion-specific glyphs is defined by the text widget's <a href=\"widgets\/BuildContext-class.html\">BuildContext<\/a>\nusing <code>Localizations.localeOf(context)<\/code>. For example <a href=\"widgets\/RichText-class.html\">RichText<\/a> defines\nits locale this way. However, a rich text widget's <a href=\"painting\/TextSpan-class.html\">TextSpan<\/a>s could\nspecify text styles with different explicit locales in order to select\ndifferent region-specific glyphs for each text span.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final Locale locale\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/locale.html",
                    "name": "locale",
                    "isDeprecated": false,
                    "type": "dart:ui.Locale",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>A list of <a href=\"dart-ui\/Shadow-class.html\">Shadow<\/a>s that will be painted underneath the text.<\/p>\n<p>Multiple shadows are supported to replicate lighting from multiple light\nsources.<\/p>\n<p>Shadows must be in the same order for <a href=\"painting\/TextStyle-class.html\">TextStyle<\/a> to be considered as\nequivalent as order produces differing transparency.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final List&lt;ui.Shadow&gt; shadows\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/shadows.html",
                    "name": "shadows",
                    "isDeprecated": false,
                    "type": "dart:core.List<dart:ui.Shadow>",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The common baseline that should be aligned between this text span and its\nparent text span, or, for the root text spans, with the line box.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final TextBaseline textBaseline\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/textBaseline.html",
                    "name": "textBaseline",
                    "isDeprecated": false,
                    "type": "dart:ui.TextBaseline",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                },
                {
                    "desc": "<p>The amount of space (in logical pixels) to add at each sequence of\nwhite-space (i.e. between each word). A negative value can be used to\nbring the words closer.<\/p>\n        ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n          <pre class=\"language-dart\"><code class=\"language-dart\">final double wordSpacing\n\n<\/code><\/pre>\n        ",
                    "href": "painting\/TextStyle\/wordSpacing.html",
                    "name": "wordSpacing",
                    "isDeprecated": false,
                    "type": "dart:core.double",
                    "dtype": "property",
                    "isStatic": false,
                    "isConstant": false,
                    "memberOf": "painting.TextStyle",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Property which handles <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a> that represent transforms.<\/p>\n    ",
            "dtype": "class",
            "example": "",
            "href": "painting\/TransformProperty-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.TransformProperty",
            "shortname": "TransformProperty",
            "extends": [
                "vector_math_64.Matrix4",
                "foundation.DiagnosticsProperty",
                "foundation.DiagnosticsNode",
                "dart:core.Object"
            ],
            "is_enum": false,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [
                {
                    "desc": "<p>Create a diagnostics property for <a href=\"vector_math_64\/Matrix4-class.html\">Matrix4<\/a> objects.<\/p>\n<p>The <code>showName<\/code> and <code>level<\/code> arguments must not be null.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">TransformProperty(\n  String name,\n  Matrix4 value, {\n  bool showName = true,\n  Object defaultValue = kNoDefaultValue,\n  DiagnosticLevel level = DiagnosticLevel.info,\n}) : assert(showName != null),\n     assert(level != null),\n     super(\n       name,\n       value,\n       showName: showName,\n       defaultValue: defaultValue,\n       level: level,\n     );<\/code><\/pre>\n    ",
                    "href": "painting\/TransformProperty\/TransformProperty.html",
                    "isDeprecated": false,
                    "type": "",
                    "name": "TransformProperty",
                    "dtype": "constructor",
                    "isConstructor": true,
                    "static": false,
                    "memberOf": "painting.TransformProperty",
                    "params": [
                        {
                            "name": "defaultValue",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.Object"
                        },
                        {
                            "name": "level",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "foundation.DiagnosticLevel"
                        },
                        {
                            "name": "name",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.String"
                        },
                        {
                            "name": "showName",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "dart:core.bool"
                        },
                        {
                            "name": "value",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": true,
                            "type": "vector_math_64.Matrix4"
                        }
                    ]
                },
                {
                    "desc": "<p>Returns a string representation of the property value.<\/p>\n<p>Subclasses should override this method instead of <a href=\"foundation\/DiagnosticsProperty\/toDescription.html\">toDescription<\/a> to\ncustomize how property values are converted to strings.<\/p>\n<p>Overriding this method ensures that behavior controlling how property\nvalues are decorated to generate a nice <a href=\"foundation\/DiagnosticsProperty\/toDescription.html\">toDescription<\/a> are consistent\nacross all implementations. Debugging tools may also choose to use\n<a href=\"painting\/TransformProperty\/valueToString.html\">valueToString<\/a> directly instead of <a href=\"foundation\/DiagnosticsProperty\/toDescription.html\">toDescription<\/a>.<\/p>\n<p><code>parentConfiguration<\/code> specifies how the parent is rendered as text art.\nFor example, if the parent places all properties on one line, the value\nof the property should be displayed without line breaks if possible.<\/p>\n    ",
                    "example": "<h2><span>Implementation<\/span><\/h2>\n      <pre class=\"language-dart\"><code class=\"language-dart\">@override\nString valueToString({ TextTreeConfiguration parentConfiguration }) {\n  if (parentConfiguration != null &amp;&amp; !parentConfiguration.lineBreakProperties) {\n    \/\/ Format the value on a single line to be compatible with the parent's\n    \/\/ style.\n    final List&lt;Vector4&gt; rows = &lt;Vector4&gt;[\n      value.getRow(0),\n      value.getRow(1),\n      value.getRow(2),\n      value.getRow(3),\n    ];\n    return '[${rows.join(\"; \")}]';\n  }\n  return debugDescribeTransform(value).join('\\n');\n}<\/code><\/pre>\n    ",
                    "href": "painting\/TransformProperty\/valueToString.html",
                    "isDeprecated": false,
                    "type": "dart:core.String",
                    "name": "valueToString",
                    "dtype": "method",
                    "isConstructor": false,
                    "static": false,
                    "memberOf": "painting.TransformProperty",
                    "params": [
                        {
                            "name": "parentConfiguration",
                            "desc": "",
                            "example": "",
                            "href": "",
                            "isDeprecated": false,
                            "isOptional": false,
                            "type": "foundation.TextTreeConfiguration"
                        }
                    ]
                }
            ],
            "props": []
        }
    ],
    "mixin": [
        {
            "desc": "<p>Binding for the painting library.<\/p>\n<p>Hooks into the cache eviction logic to clear the image cache.<\/p>\n<p>Requires the <a href=\"services\/ServicesBinding-mixin.html\">ServicesBinding<\/a> to be mixed in earlier.<\/p>\n    ",
            "dtype": "mixin",
            "example": "",
            "href": "painting\/PaintingBinding-mixin.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.PaintingBinding",
            "shortname": "PaintingBinding",
            "extends": [],
            "is_enum": false,
            "is_mixin": true,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": []
        }
    ],
    "enum": [
        {
            "desc": "<p>The two cardinal directions in two dimensions.<\/p>\n<p>The axis is always relative to the current coordinate space. This means, for\nexample, that a <a href=\"painting\/Axis-class.html\">horizontal<\/a> axis might actually be diagonally from top\nright to bottom left, due to some local <a href=\"widgets\/Transform-class.html\">Transform<\/a> applied to the scene.<\/p>\n<p>See also:<\/p>\n<ul>\n<li>\n<a href=\"painting\/AxisDirection-class.html\">AxisDirection<\/a>, which is a directional version of this enum (with values\nlight left and right, rather than just horizontal).<\/li>\n<li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which disambiguates between left-to-right horizontal\ncontent and right-to-left horizontal content.<\/li>\n<\/ul>",
            "dtype": "enum",
            "example": "",
            "href": "painting\/Axis-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.Axis",
            "shortname": "Axis",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>Left and right.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which disambiguates between left-to-right horizontal\ncontent and right-to-left horizontal content.<\/li><\/ul>\n<div>\n            <span class=\"signature\"><code>const Axis(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "horizontal",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Axis",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">Axis<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Axis",
                    "params": []
                },
                {
                    "desc": "\n          <p>Up and down.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const Axis(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "vertical",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.Axis",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A direction along either the horizontal or vertical <a href=\"painting\/Axis-class.html\">Axis<\/a>.<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/AxisDirection-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.AxisDirection",
            "shortname": "AxisDirection",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>Zero is at the top and positive values are below it: \u21ca<\/p>\n<p>Alphabetical content with a <a href=\"rendering\/GrowthDirection-class.html\">GrowthDirection.forward<\/a> would have the A at\nthe top and the Z at the bottom. This is the ordinary reading order for a\nvertical list.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const AxisDirection(2)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "down",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AxisDirection",
                    "params": []
                },
                {
                    "desc": "\n          <p>Zero is to the right and positive values are to the left of it: \u21c7<\/p>\n<p>Alphabetical content with a <a href=\"rendering\/GrowthDirection-class.html\">GrowthDirection.forward<\/a> would have the A at\nthe right and the Z at the left. This is the ordinary reading order for a\nhorizontal set of tabs in a Hebrew application, for example.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const AxisDirection(3)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "left",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AxisDirection",
                    "params": []
                },
                {
                    "desc": "\n          <p>Zero is on the left and positive values are to the right of it: \u21c9<\/p>\n<p>Alphabetical content with a <a href=\"rendering\/GrowthDirection-class.html\">GrowthDirection.forward<\/a> would have the A on\nthe left and the Z on the right. This is the ordinary reading order for a\nhorizontal set of tabs in an English application, for example.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const AxisDirection(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "right",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AxisDirection",
                    "params": []
                },
                {
                    "desc": "\n          <p>Zero is at the bottom and positive values are above it: \u21c8<\/p>\n<p>Alphabetical content with a <a href=\"rendering\/GrowthDirection-class.html\">GrowthDirection.forward<\/a> would have the A at\nthe bottom and the Z at the top. This is an unusual configuration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const AxisDirection(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "up",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AxisDirection",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">AxisDirection<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.AxisDirection",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>The style of line to draw for a <a href=\"painting\/BorderSide-class.html\">BorderSide<\/a> in a <a href=\"painting\/Border-class.html\">Border<\/a>.<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/BorderStyle-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BorderStyle",
            "shortname": "BorderStyle",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>Skip the border.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BorderStyle(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "none",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BorderStyle",
                    "params": []
                },
                {
                    "desc": "\n          <p>Draw the border as a solid line.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BorderStyle(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "solid",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BorderStyle",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">BorderStyle<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BorderStyle",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>How a box should be inscribed into another box.<\/p>\n<p>See also <a href=\"painting\/applyBoxFit.html\">applyBoxFit<\/a>, which applies the sizing semantics of these values\n(though not the alignment semantics).<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/BoxFit-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BoxFit",
            "shortname": "BoxFit",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>As large as possible while still containing the source entirely within the\ntarget box.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_contain.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "contain",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>As small as possible while still covering the entire target box.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_cover.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(2)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "cover",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>Fill the target box by distorting the source's aspect ratio.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_fill.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "fill",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>Make sure the full height of the source is shown, regardless of\nwhether this means the source overflows the target box horizontally.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_fitHeight.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(4)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "fitHeight",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>Make sure the full width of the source is shown, regardless of\nwhether this means the source overflows the target box vertically.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_fitWidth.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(3)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "fitWidth",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>Align the source within the target box (by default, centering) and discard\nany portions of the source that lie outside the box.<\/p>\n<p>The source image is not resized.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_none.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(5)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "none",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>Align the source within the target box (by default, centering) and, if\nnecessary, scale the source down to ensure that the source fits within the\nbox.<\/p>\n<p>This is the same as <code>contain<\/code> if that would shrink the image, otherwise it\nis the same as <code>none<\/code>.<\/p>\n<p><img alt=\"\" src=\"https:\/\/flutter.github.io\/assets-for-api-docs\/assets\/painting\/box_fit_scaleDown.png\"><\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const BoxFit(6)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "scaleDown",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">BoxFit<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxFit",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>The shape to use when rendering a <a href=\"painting\/Border-class.html\">Border<\/a> or <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a>.<\/p>\n<p>Consider using <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a> subclasses directly (with <a href=\"painting\/ShapeDecoration-class.html\">ShapeDecoration<\/a>),\ninstead of using <a href=\"painting\/BoxShape-class.html\">BoxShape<\/a> and <a href=\"painting\/Border-class.html\">Border<\/a>, if the shapes will need to be\ninterpolated or animated. The <a href=\"painting\/Border-class.html\">Border<\/a> class cannot interpolate between\ndifferent shapes.<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/BoxShape-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.BoxShape",
            "shortname": "BoxShape",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>A circle centered in the middle of the box into which the <a href=\"painting\/Border-class.html\">Border<\/a> or\n<a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> is painted. The diameter of the circle is the shortest\ndimension of the box, either the width or the height, such that the circle\ntouches the edges of the box.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/CircleBorder-class.html\">CircleBorder<\/a>, the equivalent <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>.<\/li><\/ul>\n<div>\n            <span class=\"signature\"><code>const BoxShape(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "circle",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxShape",
                    "params": []
                },
                {
                    "desc": "\n          <p>An axis-aligned, 2D rectangle. May have rounded corners (described by a\n<a href=\"painting\/BorderRadius-class.html\">BorderRadius<\/a>). The edges of the rectangle will match the edges of the box\ninto which the <a href=\"painting\/Border-class.html\">Border<\/a> or <a href=\"painting\/BoxDecoration-class.html\">BoxDecoration<\/a> is painted.<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"painting\/RoundedRectangleBorder-class.html\">RoundedRectangleBorder<\/a>, the equivalent <a href=\"painting\/ShapeBorder-class.html\">ShapeBorder<\/a>.<\/li><\/ul>\n<div>\n            <span class=\"signature\"><code>const BoxShape(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "rectangle",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxShape",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">BoxShape<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.BoxShape",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>Possible ways to draw Flutter's logo.<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/FlutterLogoStyle-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.FlutterLogoStyle",
            "shortname": "FlutterLogoStyle",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>Show Flutter's logo on the left, and the \"Flutter\" label to its right.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const FlutterLogoStyle(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "horizontal",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FlutterLogoStyle",
                    "params": []
                },
                {
                    "desc": "\n          <p>Show only Flutter's logo, not the \"Flutter\" label.<\/p>\n<p>This is the default behavior for <a href=\"painting\/FlutterLogoDecoration-class.html\">FlutterLogoDecoration<\/a> objects.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const FlutterLogoStyle(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "markOnly",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FlutterLogoStyle",
                    "params": []
                },
                {
                    "desc": "\n          <p>Show Flutter's logo above the \"Flutter\" label.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const FlutterLogoStyle(2)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "stacked",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FlutterLogoStyle",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">FlutterLogoStyle<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.FlutterLogoStyle",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>How to paint any portions of a box not covered by an image.<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/ImageRepeat-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.ImageRepeat",
            "shortname": "ImageRepeat",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>Leave uncovered portions of the box transparent.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const ImageRepeat(3)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "noRepeat",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.ImageRepeat",
                    "params": []
                },
                {
                    "desc": "\n          <p>Repeat the image in both the x and y directions until the box is filled.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const ImageRepeat(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "repeat",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.ImageRepeat",
                    "params": []
                },
                {
                    "desc": "\n          <p>Repeat the image in the x direction until the box is filled horizontally.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const ImageRepeat(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "repeatX",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.ImageRepeat",
                    "params": []
                },
                {
                    "desc": "\n          <p>Repeat the image in the y direction until the box is filled vertically.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const ImageRepeat(2)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "repeatY",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.ImageRepeat",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">ImageRepeat<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.ImageRepeat",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>The description of the difference between two objects, in the context of how\nit will affect the rendering.<\/p>\n<p>Used by <a href=\"painting\/TextSpan\/compareTo.html\">TextSpan.compareTo<\/a> and <a href=\"painting\/TextStyle\/compareTo.html\">TextStyle.compareTo<\/a>.<\/p>\n<p>The values in this enum are ordered such that they are in increasing order\nof cost. A value with index N implies all the values with index less than N.\nFor example, <a href=\"painting\/RenderComparison-class.html\">layout<\/a> (index 3) implies <a href=\"painting\/RenderComparison-class.html\">paint<\/a> (2).<\/p>\n    ",
            "dtype": "enum",
            "example": "",
            "href": "painting\/RenderComparison-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.RenderComparison",
            "shortname": "RenderComparison",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>The two objects are identical (meaning deeply equal, not necessarily\n<a href=\"painting\/RenderComparison-class.html\">dart:core.identical<\/a>).<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const RenderComparison(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "identical",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.RenderComparison",
                    "params": []
                },
                {
                    "desc": "\n          <p>The two objects are different in ways that affect layout (and therefore paint).<\/p>\n<p>For example, the size is changed.<\/p>\n<p>This is the most drastic level of change possible.<\/p>\n<p><a href=\"rendering\/RenderObject\/markNeedsLayout.html\">RenderObject.markNeedsLayout<\/a> would be necessary to handle this kind of\nchange in a render object.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const RenderComparison(3)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "layout",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.RenderComparison",
                    "params": []
                },
                {
                    "desc": "\n          <p>The two objects are identical for the purpose of layout, but may be different\nin other ways.<\/p>\n<p>For example, maybe some event handlers changed.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const RenderComparison(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "metadata",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.RenderComparison",
                    "params": []
                },
                {
                    "desc": "\n          <p>The two objects are different but only in ways that affect paint, not layout.<\/p>\n<p>For example, only the color is changed.<\/p>\n<p><a href=\"rendering\/RenderObject\/markNeedsPaint.html\">RenderObject.markNeedsPaint<\/a> would be necessary to handle this kind of\nchange in a render object.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const RenderComparison(2)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "paint",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.RenderComparison",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">RenderComparison<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.RenderComparison",
                    "params": []
                }
            ]
        },
        {
            "desc": "<p>A direction in which boxes flow vertically.<\/p>\n<p>This is used by the flex algorithm (e.g. <a href=\"widgets\/Column-class.html\">Column<\/a>) to decide in which\ndirection to draw boxes.<\/p>\n<p>This is also used to disambiguate <code>start<\/code> and <code>end<\/code> values (e.g.\n<a href=\"rendering\/MainAxisAlignment-class.html\">MainAxisAlignment.start<\/a> or <a href=\"rendering\/CrossAxisAlignment-class.html\">CrossAxisAlignment.end<\/a>).<\/p>\n<p>See also:<\/p>\n<ul><li>\n<a href=\"dart-ui\/TextDirection-class.html\">TextDirection<\/a>, which controls the same thing but horizontally.<\/li><\/ul>",
            "dtype": "enum",
            "example": "",
            "href": "painting\/VerticalDirection-class.html",
            "isAbstract": false,
            "isConstant": false,
            "isDeprecated": false,
            "memberOf": "painting",
            "name": "painting.VerticalDirection",
            "shortname": "VerticalDirection",
            "extends": [],
            "is_enum": true,
            "is_mixin": false,
            "realImplementors": [],
            "events": [],
            "methods": [],
            "props": [
                {
                    "desc": "\n          <p>Boxes should start at the top and be stacked vertically towards the bottom.<\/p>\n<p>The \"start\" is at the top, the \"end\" is at the bottom.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const VerticalDirection(1)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "down",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.VerticalDirection",
                    "params": []
                },
                {
                    "desc": "\n          <p>Boxes should start at the bottom and be stacked vertically towards the top.<\/p>\n<p>The \"start\" is at the bottom, the \"end\" is at the top.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const VerticalDirection(0)<\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "up",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.VerticalDirection",
                    "params": []
                },
                {
                    "desc": "\n          <p>A constant List of the values in this enum, in order of their declaration.<\/p>\n                  \n  <div>\n            <span class=\"signature\"><code>const List&lt;<wbr><span class=\"type-parameter\">VerticalDirection<\/span>&gt;<\/wbr><\/code><\/span>\n          <\/div>\n        ",
                    "example": "",
                    "href": "",
                    "name": "values",
                    "isDeprecated": false,
                    "type": "",
                    "dtype": "enum-value",
                    "isStatic": true,
                    "isConstant": true,
                    "memberOf": "painting.VerticalDirection",
                    "params": []
                }
            ]
        }
    ],
    "typedef": []
}